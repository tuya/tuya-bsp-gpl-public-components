diff --git a/Makefile b/Makefile
old mode 100644
new mode 100755
index 18889fb..286eacf
--- a/Makefile
+++ b/Makefile
@@ -152,6 +152,7 @@ sub-make: FORCE
 	$(Q)$(MAKE) -C $(KBUILD_OUTPUT) KBUILD_SRC=$(CURDIR) \
 	-f $(CURDIR)/Makefile $(filter-out _all sub-make,$(MAKECMDGOALS))
 
+
 # Leave processing to above invocation of make
 skip-makefile := 1
 endif # ifneq ($(KBUILD_OUTPUT),)
@@ -254,8 +255,11 @@ SUBARCH := $(shell uname -m | sed -e s/i.86/x86/ -e s/x86_64/x86/ \
 # "make" in the configured kernel build directory always uses that.
 # Default value for CROSS_COMPILE is not to prefix executables
 # Note: Some architectures assign CROSS_COMPILE in their arch/*/Makefile
-ARCH		?= $(SUBARCH)
-CROSS_COMPILE	?= $(CONFIG_CROSS_COMPILE:"%"=%)
+# ARCH		?= $(SUBARCH)
+# CROSS_COMPILE	?= $(CONFIG_CROSS_COMPILE:"%"=%)
+
+ARCH		?= arm
+CROSS_COMPILE	?= arm-anykav500-linux-uclibcgnueabi-
 
 # Architecture as present in compile.h
 UTS_MACHINE 	:= $(ARCH)
diff --git a/README.md b/README.md
old mode 100644
new mode 100755
index a1ff664..efa7e39
--- a/README.md
+++ b/README.md
@@ -1,3 +1,3 @@
-# linux4.4.192_tarball
+# linux4.4.192
 
 This is linux4.4.192 tarball of www.kernel.org for making patch every PDK release for anycloudv500 project
\ No newline at end of file
diff --git a/arch/arm/Kconfig b/arch/arm/Kconfig
old mode 100644
new mode 100755
index 737c8b0..d489ad0
--- a/arch/arm/Kconfig
+++ b/arch/arm/Kconfig
@@ -317,6 +317,36 @@ choice
 	default ARCH_VERSATILE if !MMU
 	default ARCH_MULTIPLATFORM if MMU
 
+config ARCH_AK39
+	bool "ANYKA AK39XX"
+	select CPU_ARM926T
+	select GENERIC_GPIO
+	select ARCH_REQUIRE_GPIOLIB
+	select CLKDEV_LOOKUP
+	select COMMON_CLK
+	select USE_OF
+	select CLKSRC_OF
+	select CLKSRC_MMIO
+	select GENERIC_CLOCKEVENTS
+	select PINCTRL
+	help
+	  Support for Anyka AK39xx series Chips platform.
+
+config ARCH_AK
+	bool "ANYKA ANYCLOUDV500"
+	select CPU_ARM926T
+	select GENERIC_GPIO
+	select ARCH_REQUIRE_GPIOLIB
+	select CLKDEV_LOOKUP
+	select COMMON_CLK
+	select USE_OF
+	select CLKSRC_OF
+	select CLKSRC_MMIO
+	select GENERIC_CLOCKEVENTS
+	select PINCTRL
+	help
+	  Support for Anyka series Chips platform.
+
 config ARCH_MULTIPLATFORM
 	bool "Allow multiple platforms to be selected"
 	depends on MMU
@@ -808,6 +838,10 @@ config ARCH_VIRT
 # Kconfigs may be included either alphabetically (according to the
 # plat- suffix) or along side the corresponding mach-* source.
 #
+#source "arch/arm/mach-ak39/Kconfig"
+
+source "arch/arm/mach-anycloudv500/Kconfig"
+
 source "arch/arm/mach-mvebu/Kconfig"
 
 source "arch/arm/mach-alpine/Kconfig"
diff --git a/arch/arm/Makefile b/arch/arm/Makefile
old mode 100644
new mode 100755
index 2c2b28e..c353105
--- a/arch/arm/Makefile
+++ b/arch/arm/Makefile
@@ -222,6 +222,8 @@ machine-$(CONFIG_ARCH_W90X900)		+= w90x900
 machine-$(CONFIG_ARCH_ZX)		+= zx
 machine-$(CONFIG_ARCH_ZYNQ)		+= zynq
 machine-$(CONFIG_PLAT_SPEAR)		+= spear
+machine-$(CONFIG_ARCH_AK39)		:= ak39
+machine-$(CONFIG_ARCH_AK)		:= anycloudv500
 
 # Platform directory name.  This list is sorted alphanumerically
 # by CONFIG_* macro name.
diff --git a/arch/arm/boot/dts/Makefile b/arch/arm/boot/dts/Makefile
old mode 100644
new mode 100755
index 30bbc37..61bc4d3
--- a/arch/arm/boot/dts/Makefile
+++ b/arch/arm/boot/dts/Makefile
@@ -1,5 +1,17 @@
 ifeq ($(CONFIG_OF),y)
 
+dtb-$(CONFIG_ARCH_AK39) += ak3916ev300.dtb
+dtb-$(CONFIG_ARCH_AK) += c500_cbd_ak3760d_dsi_v1.0.0.dtb
+dtb-$(CONFIG_ARCH_AK) += c500_cbd_ak3760d_dsi_v1.0.0_spinand.dtb
+dtb-$(CONFIG_ARCH_AK) += c500_cbd_ak3760d_rgb_v1.0.0.dtb
+dtb-$(CONFIG_ARCH_AK) += c500_cbd_ak3760d_rgb_v1.0.0_spinand.dtb
+dtb-$(CONFIG_ARCH_AK) += c500_cbd_ak3761d_dsi_v1.0.0.dtb
+dtb-$(CONFIG_ARCH_AK) += c500_cbd_ak3761d_dsi_v1.0.0_spinand.dtb
+dtb-$(CONFIG_ARCH_AK) += c500_cbd_ak3761d_rgb_v1.0.0.dtb
+dtb-$(CONFIG_ARCH_AK) += c500_cbd_ak3761d_rgb_v1.0.0_spinand.dtb
+dtb-$(CONFIG_ARCH_AK) += sh3d_cbd_ak3790d_v1.0.0.dtb
+dtb-$(CONFIG_ARCH_AK) += c500_cbd_ak3918ev500_v1.0.0.dtb
+dtb-$(CONFIG_ARCH_AK) += c500_cbd_ak3918ev500_v1.0.0_spinand.dtb
 dtb-$(CONFIG_ARCH_ALPINE) += \
 	alpine-db.dtb
 dtb-$(CONFIG_MACH_ASM9260) += \
diff --git a/arch/arm/boot/dts/ak3916ev300.dts b/arch/arm/boot/dts/ak3916ev300.dts
new file mode 100755
index 0000000..fa1f09f
--- /dev/null
+++ b/arch/arm/boot/dts/ak3916ev300.dts
@@ -0,0 +1,652 @@
+﻿/*
+ * AK3916EV300 SoC
+ *
+ * Copyright (C) 2018 Anyka(Guangzhou) Microelectronics Technology Co., Ltd.
+ *
+ * Author: Feilong Dong <dong_feilong@anyka.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+/dts-v1/;
+
+/ {
+    model = "anyka,ak3916ev300";
+    compatible = "anyka,ak3916ev300","anyka,ak3918ev300","anyka,ak3919ev300";
+    #address-cells = <1>;
+    #size-cells = <1>;
+
+    interrupt-parent = <&intc>;
+
+    chosen {
+        //bootargs = "console=ttySAK0,115200";
+        
+    };
+   
+	aliases {
+		intc = &intc;
+		watchdog = &watchdog;
+		pwm0 = &pwm0;
+		pwm1 = &pwm1;
+		pwm2 = &pwm2;
+		gpio = &gpio;
+		uart0 = &uart0;
+		uart1 = &uart1;
+		spi0 = &spi0;
+		spi1 = &spi1;
+		mmc0 = &mmc0;
+		mmc1 = &mmc1;
+		i2c0 = &i2c0;
+		i2c1 = &i2c1;
+		motor0 = &motor0;
+		motor1 = &motor1;
+		usb = &usb;
+		leds = &leds;
+		keys = &keys;
+		ethernet = &ethernet;
+	};
+
+	cpus {
+	    #address-cells = <1>;
+	    #size-cells = <0>;
+	    
+	    cpu@0 {
+	        compatible = "arm, arm926ej-s";
+	        device_type = "cpu";
+	        reg = <0>;
+	        d-cache-line-size = <32>;  // 32 bytes
+	        i-cache-line-size = <32>;  // 32 bytes
+	        d-cache-size = <0x8000>;
+	        i-cache-size = <0x8000>;
+	        timebase-frequency = <0>;
+	        bus-frequency = <0>;
+	        clock-frequency = <0>;
+	    };
+	};
+	
+	memory {
+	    device_type = "memory";
+	    reg = <0x80000000 0x04000000>;
+	};
+	
+    reserved-memory {
+        #address-cells = <1>;
+        #size-cells = <1>;
+        ranges;
+
+        vi_reserved: vi_reserved@82200000 {
+            compatible = "shared-dma-pool";
+            linux,cma-default;
+            reusable;
+            size = <0x1e00000>;
+            reg = <0x82200000 0x1e00000>;
+            status = "okay";
+        };
+    };
+    
+    ion {
+        compatible = "anyka,ak39-ion-reserve";
+        memory-region = <&vi_reserved>;
+        #address-cells = <1>;
+        #size-cells = <1>;
+        heaps-nr = <1>;
+        ranges;
+
+        cma_reserved_heap: cma_reserved_heap {
+            compatible = "anyka,cma-reserve";
+            ion-id = <0>;
+            base-address = <0x82200000>;
+            size = <0x1e00000>;
+            align = <0x4>;
+            status = "okay";
+        };     
+    };
+
+    chip-id {
+        compatible = "anyka,ak3916ev3000-id";  
+    };
+    
+    intc: interrupt-controller {
+        compatible = "anyka,ak3916ev300-ic";
+        interrupt-controller;
+        #interrupt-cells = <2>;
+        bank_irqs = <20 11>;
+    };
+   
+    system_intc: system-control-ic {
+        compatible = "anyka,ak3916ev300-system-ic";
+        interrupt-controller;
+	    interrupts = <3 0>;
+    };
+    
+    rtc: rtc {
+        compatible = "anyka,ak3916ev300-rtc";
+        status = "okay";
+    };
+		
+    crc: crc {
+        compatible = "anyka,ak3916ev300-crc";
+        status = "disable";
+    };
+    
+    usbi2sctrl: usb-i2s-controller {
+        compatible = "anyka,ak3916ev300-usb-i2s";
+        status = "disable";
+    };
+		
+    timer{
+        compatible = "anyka,ak39-system-timer";
+        interrupts = <6 1>,
+                     <5 1>,
+                     <4 1>,
+                     <3 1>,
+                     <2 1>;
+        clock-frequency = <12000000>;
+    };
+
+    watchdog: watchdog {
+		compatible = "anyka,ak3916ev300-wdt";
+		status = "okay";
+		};
+
+	soc: soc {
+		compatible = "simple-bus";
+		#address-cells = <1>;
+		#size-cells = <1>;
+		ranges;
+        
+        isp: isp@20000000 {
+            compatible = "anyka,ak3916ev300-isp";
+            reg = <0x20000000 0xffff>;
+            interrupts = <1 0>;
+            status = "disable";
+        };
+        
+        pre-processor@20010000 {
+            compatible = "anyka,ak3916ev300-pre-processsor";
+            reg = <0x20010000 0xffff>;
+            status = "disable";
+        };
+        
+        vencoder: video-encoder@20020000 {
+            compatible = "anyka,ak39-uio-vencoder";
+            uio_name = "video-encoder";
+            version = "0.1.0";
+            reg = <0x20020000 0x10000>;
+            interrupts = <2 0>;
+            clocks = <&gclk_asic 18>;
+            status = "okay";
+        };
+
+		mmc0: mmc0@20100000 {
+            compatible = "anyka,ak3916ev300-mmc0";
+            reg = <0x20100000 0x7fff>;
+            interrupts = <4 0>;
+			clocks = <&gclk_asic 0>;
+			bus-width = <0x1>;
+			max-frequency = <60000000>;
+			
+			akmci_detect_mode_gpio;
+			akmci_xfer_l2dma;
+			
+			cap-sd-highspeed;
+            pinctrl-names = "default";
+	        pinctrl-0 = <&sdhost_pins &sddetect_pins>;
+	        cd-gpios = <&gpio 46 1>;
+	        
+            status = "okay";
+        };
+        
+        mmc1: mmc1@20108000 {
+            compatible = "anyka,ak3916ev300-mmc1";
+            reg = <0x20108000 0x7fff>;
+            interrupts = <5 0>;
+			clocks = <&gclk_asic 1>;
+			bus-width = <0x4>;
+			max-frequency = <60000000>;
+			
+			non-removable;
+			akmci_xfer_l2dma;
+			
+			cap-sdio-irq;
+            pinctrl-names = "default";
+	        pinctrl-0 = <&sdio_pins>;     
+            status = "okay";
+        };
+      
+        dac: dac@20110000 {
+            compatible = "anyka,ak3916ev300-dac";
+            reg = <0x08000000 0xffff>,
+			      <0x20110000 0x7fff>;
+            interrupts = <7 0>;
+            pinctrl-names = "default";
+	          pinctrl-0 = <&speak_pins>;
+	          speak-gpios = <&gpio 44 1>;     
+            status = "okay";
+        };
+        
+        adc: adc@20118000 {
+            compatible = "anyka,ak3916ev300-adc";
+            reg = <0x20118000 0x7fff>;
+            interrupts = <6 0>;
+            status = "okay";
+        };
+        
+        spi0: spi0@20120000 {
+            compatible = "anyka,ak3916ev300-spi0";
+            reg = <0x20120000 0x7fff>;
+            interrupts = <8 0>;
+            clocks = <&gclk_asic 4>;
+            pinctrl-names = "default";
+	          pinctrl-0 = <&spiflash_pins>;
+
+            #address-cells = <1>;
+			#size-cells = <0>;
+            status = "okay";
+            
+            spi-flash@0 {
+			        compatible = "anyka,ak-spiflash";
+			        reg = <0>; /* Chip select 0 */
+			        spi-max-frequency = <20000000>;
+		        };
+        };
+        
+        spi1: spi1@20128000 {
+            compatible = "anyka,ak3916ev300-spi1";
+            reg = <0x20128000 0x7fff>;
+            interrupts = <9 0>;
+            status = "disable";
+        };
+        
+        uart0: uart0@20130000 {
+            compatible = "anyka,ak3916ev300-uart0";
+            reg = <0x20130000 0x7fff>;
+            interrupts = <10 0>;
+            pinctrl-names = "default";
+	          pinctrl-0 = <&uart0_pins>;
+            status = "okay";
+        };
+        
+        uart1: uart1@20138000 {
+            compatible = "anyka,ak3916ev300-uart1";
+            reg = <0x20138000 0x7fff>;
+            interrupts = <11 0>;
+            status = "disable";
+        };
+        	
+		    motor0: motor0 {
+			      compatible = "anyka,ak3916ev300-motor0";
+			      status = "okay";
+		    };
+	      
+		    motor1: motor1 {
+			      compatible = "anyka,ak3916ev300-motor1";
+			      status = "okay";
+		    };
+		    
+		    pwm0: pwm0 {
+		        compatible = "anyka,ak3916ev300-pwm0";
+		        pinctrl-names = "default";
+	          pinctrl-0 = <&pwm0_pins>;
+		        status = "okay";
+	      };
+	  
+	  	  pwm1: pwm1 {
+		        compatible = "anyka,ak3916ev300-pwm1";
+		        pinctrl-names = "default";
+	          pinctrl-0 = <&pwm1_pins>;
+		        status = "okay";
+	      };
+	  	
+	  	  pwm2: pwm2 {
+		        compatible = "anyka,ak3916ev300-pwm2";
+		        pinctrl-names = "default";
+	          pinctrl-0 = <&pwm2_pins>;
+		        status = "okay";
+	      };
+        
+        l2buffer: l2-buffer@20140000 {
+            compatible = "anyka,ak3916ev300-l2-dma";
+            reg = <0x20140000 0xffff>;
+            interrupts = <12 0>;
+            status = "disable";
+        };
+        
+        i2c0: i2c0@20150000 {
+            compatible = "anyka,ak3916ev300-i2c0";
+            reg = <0x20150000 0xffff>;
+            interrupts = <13 0>;
+            pinctrl-names = "default";
+	          pinctrl-0 = <&i2c0_pins>;
+            clocks = <&gclk_asic 9>;
+            clock-frequency = <300000>;
+            sda-delay = <100>;
+            status = "okay";
+            
+            sensor {
+                compatible = "anyka,ak3916ev300-sensor";
+                //anyka,clock-parent = <&clk_sclk0>;
+                //anyka,clock-ctrlbit = <18>;
+                status = "disable";
+            };
+            
+        };
+        
+        irda: irda@20160000 {
+            compatible = "anyka,ak3916ev300-irda";
+            reg = <0x20160000 0xffff>;
+            interrupts = <14 0>;
+            status = "disable";
+        };
+        
+        gpio: gpio@20170000 {
+            compatible = "anyka,ak3916ev300-gpio";
+            reg = <0x20170000 0xffff>;
+            
+            interrupt-controller;
+            #interrupt-cells = <2>;
+            interrupts = <15 0>;
+            clocks = <&gclk_asic 12>;
+            
+            gpio-controller;
+            #gpio-cells = <2>;
+            status = "okay";
+            
+            /* anyka,function sharepin cfg index (index > 0) */
+            /* anyka,pull enable/disable PDPU, 1 enable PD/PU, 0 disable PD/PU */
+         	spiflash_pins: spiflash_pins {
+        		anyka,pins = <25 26 34 35 36 79>; /* 4 LINE mode*/
+        		anyka,function = <40>;
+        		anyka,pull = <1>;
+        	};
+        	
+        	speak_pins: speak_pins {
+        		anyka,pins = <44>; 
+        		anyka,pull = <1>;
+        	};
+
+        	uart0_pins: uart0_pins {
+        		anyka,pins = <1 2>;
+        		anyka,function = <1>;
+        		anyka,pull = <1>;
+        	};
+
+			    phy_reset_pins: phy_reset_pins {		
+				    anyka,pins = <81>;		
+				    anyka,pull = <1>;
+			    };
+
+        	ethernet_pins_rmii: ethernet_pins_rmii {
+        		anyka,pins = <10 11 13 14 15 19 20 23 24 47>;
+        		anyka,function = <48>;
+        		anyka,pull = <0>;
+        	};
+
+			    ethernet_pins_mii: ethernet_pins_mii {
+        		anyka,pins = <10 11 13 14 15 19 20 23 24 47>;
+        		anyka,function = <47>;
+        		anyka,pull = <0>;
+        	};
+
+        	i2c0_pins: i2c0 {
+        		anyka,pins = <27 28>;
+        		anyka,function = <49>;
+        		anyka,pull = <1>;
+        	};
+
+        	cis0_pins: cis0_pins {
+        		anyka,pins = <6 7 8 9 64 65 66 67 68 69 70 71 72 73 74 75>;
+        		anyka,function = <26>;
+        		anyka,pull = <0>;
+        	};
+
+        	sdhost_pins: sdhost_pins {
+        		anyka,pins = <31 32 33>;
+        		anyka,function = <32>;
+        		anyka,pull = <1>;
+        	};
+
+        	sddetect_pins: sddetect_pins {
+        	    anyka,pins = <46>;
+        	    anyka,pull = <1>;
+        	};
+			
+        	sdio_pins: sdio_pins {
+        		anyka,pins = <41 42 19 20 23 24>;
+        		anyka,function = <38>;
+        		anyka,pull = <1 1 0 0 0 0>;
+        	};
+
+        	pwm0_pins: pwm0_pins {
+        		anyka,pins = <50>;
+        		anyka,function = <11>;
+        		anyka,pull = <0>;
+        	};
+        	
+        	pwm1_pins: pwm1_pins {
+        		anyka,pins = <51>;
+        		anyka,function = <15>;
+        		anyka,pull = <0>;
+        	};
+        	
+        	pwm2_pins: pwm2_pins {
+        		anyka,pins = <57>;
+        		anyka,function = <18>;
+        		anyka,pull = <0>;
+        	};
+        	
+        	led_pins: led_pins {
+        		anyka,pins = <80 85>;
+        		anyka,pull = <0>;
+        	};
+        	
+        };
+        
+        encrypt: encrypt@20180000 {
+            compatible = "anyka,ak3916ev300-encrypt";
+            reg = <0x20180000 0xffff>;
+            interrupts = <17 0>;
+            status = "disable";       
+        };
+        
+        i2c1: i2c1@20190000 {
+            compatible = "anyka,ak3916ev300-i2c1";
+            reg = <0x20190000 0xffff>;
+            interrupts = <20 0>;
+            clocks = <&gclk_asic 16>;
+            clock-frequency = <300000>;
+            sda-delay = <100>;
+            status = "okay";
+        };
+        
+        usb: usb@20200000 {
+            compatible = "anyka,ak3916ev300-usb";
+            reg = <0x20200000 0xffff>;
+            interrupts = <18 0
+                          19 0>;
+            clocks = <&gclk_asic 14>;
+            status = "okay";
+        };
+        
+        ethernet: ethernet@20300000 {
+            compatible = "anyka,ak3916ev300-ethernet";
+            reg = <0x20300000 0x1fff>;
+            interrupts = <16 0>;
+            pinctrl-names = "default";
+	          pinctrl-0 = <&ethernet_pins_rmii &phy_reset_pins>;
+			      reset-gpios = <&gpio 81 1>;
+			      clocks-name = "ethernet", "50M";
+			      clocks = <&gclk_asic 12>, <&clk_peri 5>;
+            status = "okay";
+        };
+        
+        mipi: mipi@20400000 {
+            compatible = "anyka,ak3916ev300-mipi";
+            reg = <0x20400000 0xffff>;
+            status = "disable";
+        };
+        
+        dramctrl:dram-controller@21000000 {
+            compatible = "anyka,ak3916ev300-dram-controller";
+            reg = <0x21000000 0xffffff>;
+            interrupts = <0 0>;
+            //clocks = <&clk_cpu>;
+            status = "disable";
+        };
+	};
+	
+	  leds: leds {
+		    compatible = "anyka,ak3916ev300-leds";
+		    pinctrl-names = "default";
+	      pinctrl-0 = <&led_pins>;
+	      led-gpios = <&gpio 80 1
+	                   &gpio 85 1>;
+
+	      status = "okay";
+	  };
+	
+	  keys: keys {
+	     compatible = "anyka,ak3916ev300-adckeys";
+	     status = "okay";
+	  };
+
+	
+
+    clocks {
+        osc24M: osc24M {
+            compatible = "fixed-clock";
+            #clock-cells = <0>;
+            clock-output-names = "osc24M";
+            clock-frequency = <12000000>;
+        };
+
+        osc32K {
+            compatible = "fixed-clock";
+            #clock-cells = <0>;
+            clock-output-names = "osc32K";
+            clock-frequency = <32768>;
+        };
+
+        /* this clocks are configed in boot setting, can't be configed in kernel */
+        /* this node is only for get cpu and mem clk in kernel */
+        cpu_pll {
+            compatible = "anyka,ak39-fixed-clk";
+            #clock-cells = <1>;
+            clock-id = <0>, <1>, <2>, <3>;
+        	clock-output-names = "cpu", "ahb", "mem", "dphy";
+            clocks = <&osc24M>;
+        };
+
+        asic_pll: asic_pll {
+            compatible = "anyka,ak39-fixed-clk";
+            #clock-cells = <0>;
+            clock-div-od = <1>;
+            clock-div-n = <3>;
+            clock-id = <4>;
+        	clock-frequency = <480000000>;
+        	clock-output-names = "asic_pll";
+            clocks = <&osc24M>;
+        };
+
+        gclk_asic:gclk_asic {
+        	compatible = "anyka,ak39-gate-clk";
+        	#clock-cells = <1>;
+        	clock-frequency = <120000000>;
+            clock-ctrlbit = <1>, <2>, <3>,
+                            <4>, <5>, <6>,
+                            <7>, <8>, <9>,
+                            <10>, <11>, <12>,
+                            <13>, <14>, <15>,
+                            <16>, <17>, <19>,
+                            <20> ,<21>,<22>,
+                            <23>;
+            clock-output-names = "mmc0", "mmc1", "adc1",
+                                 "dac", "spi0", "spi1",
+                                 "uart0", "uart1", "l2buffer",
+                                 "i2c0", "irda", "gpio",
+                                 "ethernet", "encrypt", "usb-otg",
+                                 "mipi", "i2c1", "isp",
+                                 "video encoder","video decoder","lcd controller",
+                                 "gui";
+            clocks = <&asic_pll>;
+        };
+
+        clk_asic: clk_asic {
+        	compatible = "anyka,ak39-factor-clk";
+        	#clock-cells = <1>;
+        	clock-id = <0>, <1>, <2>, <3>;
+        	clock-output-names = "adchs", "dachs", "i2s_adc1", "i2s_dac";
+        	clocks = <&asic_pll>;
+        };
+
+    	i2s_mclk {
+    	    compatible = "anyka,ak39-mux-clk";
+    	    #clock-cells = <0>;
+    	    clock-id = <0>;
+    	    clock-output-names = "i2s";
+    	    clocks = <&clk_asic 2>, <&clk_asic 3>;
+    	};
+
+    	/*config this clock in uboot*/
+    	peri_pll: peri_pll {
+            compatible = "anyka,ak39-fixed-clk";
+            #clock-cells = <0>;
+            clock-div-od = <1>;
+            clock-div-n = <2>;
+        	clock-id = <5>;
+        	clock-frequency = <600000000>;
+        	clock-output-names = "peri_pll";
+            clocks = <&osc24M>;
+        };
+
+        clk_peri: clk_peri {
+        	compatible = "anyka,ak39-factor-clk";
+        	#clock-cells = <1>;
+        	clock-id = <4>, <5>, <6>, <7>, <8>, <9>;
+        	clock-output-names = "sclk0", "sclk1", "sel_opclk", "12M", "25M", "50M";
+        	clocks = <&peri_pll>;
+        };
+        
+        clk_mac: clk_mac {
+            compatible = "anyka,ak39-mux-clk";
+            #clock-cells = <0>;
+            clock-id = <1>;
+    	    clock-output-names = "mac";
+    	    clocks = <&clk_peri 4>, <&clk_peri 5>;
+        };
+        
+        clk_opclk: clk_opclk {
+        	compatible = "anyka,ak39-mux-clk";
+        	#clock-cells = <0>;
+        	clock-id = <2>;
+        	clock-output-names = "opclk";
+        	clocks = <&clk_peri 2>, <&clk_mac>;
+        	//need to change here if use Xtal 50M clk
+        };
+
+        clk_oclk {
+        	compatible = "anyka,ak39-mux-clk";
+        	#clock-cells = <0>;
+        	clock-id = <3>;
+        	clock-output-names = "oclk";
+        	clocks = <&clk_opclk>, <&clk_mac>;
+        	//need to change here if use Xtal 50M clk
+        };
+
+        clk_adc0 {
+        	compatible = "anyka,ak39-factor-clk";
+        	#clock-cells = <1>;
+        	clock-id = <10>;
+        	clock-output-names = "adc0";
+        	clocks = <&osc24M>;
+        };
+    };
+};
diff --git a/arch/arm/boot/dts/anyka_ev500.dtsi b/arch/arm/boot/dts/anyka_ev500.dtsi
new file mode 100755
index 0000000..69aa9c8
--- /dev/null
+++ b/arch/arm/boot/dts/anyka_ev500.dtsi
@@ -0,0 +1,103 @@
+/*
+ * AK37D 128M memory chip dts
+ *
+ * Copyright (C) 2018 Anyka(Guangzhou) Microelectronics Technology Co., Ltd.
+ *
+ * Author: Feilong Dong <dong_feilong@anyka.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include "anyka_ev500_common.dtsi"
+
+/ {
+    model = "anyka,ak3790d";
+    compatible = "anyka,ak3760d","anyka,ak3918ev500","anyka,ak3750d";
+
+	chosen {
+		/* No padding required - the uboot can do that. */
+		bootargs = "console=ttySAK0,115200n8 root=/dev/mtdblock6 rootfstype=squashfs init=/sbin/init mem=64M memsize=64M";
+	};
+
+	cpus {
+	    #address-cells = <1>;
+	    #size-cells = <0>;
+
+	    cpu@0 {
+	        compatible = "arm, arm926ej-s";
+	        device_type = "cpu";
+	        reg = <0>;
+	        d-cache-line-size = <32>;  // 32 bytes
+	        i-cache-line-size = <32>;  // 32 bytes
+	        d-cache-size = <0x8000>;
+	        i-cache-size = <0x8000>;
+	        timebase-frequency = <0>;
+	        bus-frequency = <0>;
+	        clock-frequency = <0>;
+	    };
+	};
+
+    memory {
+	    device_type = "memory";
+	    reg = <0x80000000 0x04000000>;
+	};
+
+    reserved-memory {
+        #address-cells = <1>;
+        #size-cells = <1>;
+        ranges;
+
+        cma_reserved: cma_reserved@83400000 {
+            compatible = "shared-dma-pool";
+            linux,cma-default;
+            reusable;
+            size = <0x800000>;
+            reg = <0x83400000 0x800000>;
+            status = "okay";
+        };
+
+        dma_reserved: dma_reserved@81400000 {
+            /*compatible = "shared-dma-pool";*/
+            /*linux,cma-default;*/
+            /*reusable;*/
+            size = <0x2000000>;
+            reg = <0x81400000 0x2000000>;
+            status = "okay";
+        };
+    };
+
+    ion {
+        compatible = "anyka,ak3790d-ion-reserve";
+        memory-region = <&cma_reserved>, <&dma_reserved>;
+        #address-cells = <1>;
+        #size-cells = <1>;
+        heaps-nr = <2>;
+        ranges;
+
+        cma_reserved_heap: cma_reserved_heap {
+            compatible = "anyka,cma-reserve";
+            ion-id = <0>;
+            base-address = <0x83400000>;
+            size = <0x800000>;
+            align = <0x4>;
+            status = "okay";
+        };
+
+       dma_reserved_heap: dma_reserved_heap {
+            compatible = "anyka,dma-reserve";
+            ion-id = <1>;
+            base-address = <0x81400000>;
+            size = <0x2000000>;
+            align = <0x4>;
+            status = "okay";
+        };
+    };
+};
diff --git a/arch/arm/boot/dts/anyka_ev500_common.dtsi b/arch/arm/boot/dts/anyka_ev500_common.dtsi
new file mode 100755
index 0000000..96d5766
--- /dev/null
+++ b/arch/arm/boot/dts/anyka_ev500_common.dtsi
@@ -0,0 +1,616 @@
+﻿/*
+ * AK37XXD & AK3918EV500 SoC
+ *
+ * Copyright (C) 2018 Anyka(Guangzhou) Microelectronics Technology Co., Ltd.
+ *
+ * Author: Feilong Dong <dong_feilong@anyka.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+/ {
+    #address-cells = <1>;
+    #size-cells = <1>;
+
+    interrupt-parent = <&intc>;
+
+	aliases {
+		intc = &intc;
+		watchdog = &watchdog;
+		rtc = &rtc;
+		pwm0 = &pwm0;
+		pwm1 = &pwm1;
+		pwm2 = &pwm2;
+		pwm3 = &pwm3;
+		pwm4 = &pwm4;
+		gpio = &gpio;
+		uart0 = &uart0;
+		uart1 = &uart1;
+		uart2 = &uart2;
+		uart3 = &uart3;
+		spi0 = &spi0;
+		spi1 = &spi1;
+		mmc0 = &mmc0;
+		mmc1 = &mmc1;
+		mmc2 = &mmc2;
+		i2c0 = &i2c0;
+		i2c1 = &i2c1;
+		i2c2 = &i2c2;
+		motor0 = &motor0;
+		motor1 = &motor1;
+		mipicsi0 = &mipicsi0;
+		mipicsi1 = &mipicsi1;
+		usb = &usb;
+		leds = &leds;
+		adkeys = &adkeys;
+		gpiokeys = &gpiokeys;		
+		ethernet = &ethernet;
+	};
+
+    intc: interrupt-controller {
+        compatible = "anyka,ak3790d-ic";
+        interrupt-controller;
+        #interrupt-cells = <2>;
+		bank_irqs = <31 20>;
+    };
+
+    system_intc: system-control-ic {
+        compatible = "anyka,ak3790d-system-ic";
+        interrupt-controller;
+	    interrupts = <3 0>;
+    };
+
+    rtc: rtc {
+        compatible = "anyka,ak3790d-rtc";
+        status = "disable";
+    };
+
+    crc: crc {
+        compatible = "anyka,ak3790d-crc";
+        status = "disable";
+    };
+
+    timer{
+        compatible = "anyka,ak3790d-system-timer";
+        interrupts = <6 1>,
+                     <5 1>,
+                     <4 1>,
+                     <3 1>,
+                     <2 1>,
+                     <20 1>,
+                     <19 1>;
+        clock-frequency = <12000000>;
+        status = "okay";
+    };
+
+    watchdog: watchdog {
+        compatible = "anyka,ak3790d-wdt";
+        status = "disable";
+    };
+
+	soc: soc {
+		compatible = "simple-bus";
+		#address-cells = <1>;
+		#size-cells = <1>;
+		ranges;
+
+        isp: isp@20000000 {
+            compatible = "anyka,ak3790d-isp";
+            reg = <0x20000000 0x7fff>;
+            interrupts = <1 0>;
+            status = "disable";
+        };
+
+        pre-processor@20008000 {
+            compatible = "anyka,ak3790d-pre-processsor";
+            reg = <0x20008000 0x7fff>;
+            status = "disable";
+        };
+
+        lcdc: lcdc@20010000 {
+            compatible = "anyka,ak3790d-lcd-ctrl";
+            reg = <0x20010000 0x7fff>, /* lcd ctrl */
+                  <0x20500000 0xffff>; /* dsi ctrl */
+            interrupts = <25 0>;
+            clocks = <&gclk_asic 20>, <&gclk_asic 24>;
+            clock-names = "lcdc", "mipi_dsi";
+		    status = "disable";
+        };
+
+		gui: gui@20040000 {
+			compatible = "anyka,ak3790d-gui-controller";
+			reg = <0x20040000 0x10000>;
+			interrupts = <24 0>;
+			clocks = <&gclk_asic 21>;
+			status = "disable";
+		};
+
+        vencoder: video-encoder@20020000 {
+            compatible = "anyka,ak3790d-uio-vencoder";
+            reg = <0x20020000 0x10000>;
+            interrupts = <2 0>;
+            clocks = <&gclk_asic 18>;
+            status = "disable";
+        };
+
+        vdecoder: video-decoder@20030000 {
+            compatible = "anyka,ak3790d-uio-vdecoder";
+            reg = <0x20030000 0x10000>;
+            interrupts = <23 0>;
+            clocks = <&gclk_asic 19>;
+            status = "disable";
+        };
+
+		mmc0: mmc0@20100000 {
+            compatible = "anyka,ak3790d-mmc0";
+            reg = <0x20100000 0x7fff>;
+            interrupts = <4 0>,<28 0>;
+			clocks = <&gclk_asic 0>;
+            status = "disable";
+        };
+
+        mmc1: mmc1@20108000 {
+            compatible = "anyka,ak3790d-mmc1";
+            reg = <0x20108000 0x7fff>;
+            interrupts = <5 0>, <28 0>;
+			clocks = <&gclk_asic 1>;
+            status = "disable";
+        };
+
+        mmc2: mmc2@201B0000 {
+            compatible = "anyka,ak3790d-mmc2";
+            reg = <0x201B0000 0x7fff>;
+            interrupts = <27 0>,<28 0>;
+			clocks = <&gclk_asic 25>;
+            status = "disable";
+        };
+
+        adc: adc@20118000 {
+            compatible = "anyka,ak3790d-adc";
+            reg = <0x20118000 0x7fff>;
+            interrupts = <6 0>;
+            clocks = <&gclk_asic 2>;
+            status = "disable";
+        };
+
+        dac: dac@20110000 {
+            compatible = "anyka,ak3790d-dac";
+            reg = <0x08000000 0xffff>,
+			      <0x20110000 0x7fff>;
+            interrupts = <7 0>;
+            clocks = <&gclk_asic 3>,
+            <&clk_sdadc_sddac 0>,
+            <&clk_sdadc_sddac 1>,
+            <&clk_asic 0>,	//adc hs clk
+            <&clk_asic 1>;	//dac hs clk
+            clock-names = "gate_dac",
+           "clk_sdadc",
+           "clk_sddac",
+           "adchs",
+           "dachs";
+           status = "disable";
+        };
+        
+        saradc: saradc@08000000 {
+            compatible = "anyka,ak3790d-sar-adc";
+            reg = <0x08000000 0x100>;
+            interrupts = <1 1>;
+
+	    clocks = <&clk_adc0 0>;
+
+
+            status = "disable";
+        };
+        
+        spi0: spi0@20120000 {
+            compatible = "anyka,ak3790d-spi0";
+            reg = <0x20120000 0x7fff>;
+            interrupts = <8 0>;
+            clocks = <&gclk_asic 4>, <&clk_asic 2>;
+            clock-names = "spi0", "spi0_bus";
+
+            #address-cells = <1>;
+            #size-cells = <0>;
+            status = "disable";
+
+			spif0:spi-flash@0 {
+			    compatible = "anyka,ak-spiflash";
+				reg = <0>; /* Chip select 0 */
+				spi-max-frequency = <80000000>;
+				status = "disable";
+				#address-cells = <1>;
+            	#size-cells = <0>;
+			};
+
+			spif1:spi-flash@1 {
+			   compatible = "anyka,ak-spinand";
+			   reg = <1>; /* Chip select 1 */
+			   spi-max-frequency = <80000000>;
+			   ///status = "okay";
+			   status = "disable";
+			};
+        };
+
+        spi1: spi1@20128000 {
+            compatible = "anyka,ak3790d-spi1";
+            reg = <0x20128000 0x7fff>;
+            interrupts = <9 0>;
+            clocks = <&gclk_asic 5>;
+
+            #address-cells = <1>;
+            #size-cells = <0>;
+            status = "disable";
+        };
+
+        uart0: uart0@20130000 {
+            compatible = "anyka,ak3790d-uart0";
+            reg = <0x20130000 0x7fff>;
+            interrupts = <10 0>;
+            fifosize = <64>;
+            clocks = <&gclk_asic 7>;
+            status = "disable";
+        };
+
+        uart1: uart1@20138000 {
+            compatible = "anyka,ak3790d-uart1";
+            reg = <0x20138000 0x7fff>;
+            interrupts = <11 0>;
+            fifosize = <64>;
+            clocks = <&gclk_asic 8>;
+            status = "disable";
+        };
+
+        uart2: uart2@201A0000 {
+            compatible = "anyka,ak3790d-uart2";
+            reg = <0x201A0000 0x7fff>;
+            interrupts = <21 0>;
+            fifosize = <64>;
+            clocks = <&gclk_asic 22>;
+            status = "disable";
+        };
+
+        uart3: uart3@201A8000 {
+            compatible = "anyka,ak3790d-uart3";
+            reg = <0x201A8000 0x7fff>;
+            interrupts = <22 0>;
+            fifosize = <64>;
+            clocks = <&gclk_asic 23>;
+            status = "disable";
+        };
+        
+        
+        l2buffer: l2-buffer@20140000 {
+            compatible = "anyka,ak3790d-l2-dma";
+            reg = <0x20140000 0xffff>;
+            interrupts = <12 0>;
+            status = "disable";
+        };
+
+        i2c0: i2c0@20150000 {
+            compatible = "anyka,ak3790d-i2c0";
+            reg = <0x20150000 0xffff>;
+            interrupts = <13 0>;
+            clocks = <&gclk_asic 9>;
+
+            status = "disable";
+        };
+
+        irda: irda@20160000 {
+            compatible = "anyka,ak3790d-irda";
+            reg = <0x20160000 0xffff>;
+            interrupts = <14 0>;
+            status = "disable";
+        };
+
+        gpio: gpio@20170000 {
+            compatible = "anyka,ak3790d-gpio";
+            reg = <0x20170000 0xffff>,
+            <0x20400000 0x1000>,	/* mipi0 */
+            <0x20480000 0x1000>;	/* mipi1 */
+
+            interrupt-controller;
+            #interrupt-cells = <2>;
+            interrupts = <15 0>;
+            clocks = <&gclk_asic 12>;
+
+            gpio-controller;
+            #gpio-cells = <2>;
+            status = "okay";
+        };
+
+        encrypt: encrypt@20180000 {
+            compatible = "anyka,ak3790d-encrypt";
+            reg = <0x20180000 0xffff>;
+            interrupts = <17 0>;
+            status = "disable";       
+        };
+
+        i2c1: i2c1@20190000 {
+            compatible = "anyka,ak3790d-i2c1";
+            reg = <0x20190000 0xffff>;
+            interrupts = <20 0>;
+            clocks = <&gclk_asic 16>;
+
+            status = "disable";
+        };
+        
+       i2c2: i2c2@201c0000 {
+            compatible = "anyka,ak3790d-i2c2";
+            reg = <0x201c0000 0xffff>;
+            interrupts = <29 0>;
+            clocks = <&gclk_asic 26>;
+
+            #address-cells = <1>;
+	        #size-cells = <0>;
+            status = "disable";
+        };
+
+        i2c3: i2c3@201D0000 {
+            compatible = "anyka,ak3790d-i2c3";
+            reg = <0x201d0000 0xffff>;
+            interrupts = <30 0>;
+            clocks = <&gclk_asic 27>;
+ 
+            #address-cells = <1>;
+            #size-cells = <0>;
+            status = "disable";
+        };
+
+        usb: usb@20200000 {
+            compatible = "anyka,ak3790d-usb";
+            reg = <0x20200000 0xffff>;
+            interrupts = <18 0
+                          19 0>;
+            clocks = <&gclk_asic 14>;
+            status = "disable";
+        };
+
+        ethernet: ethernet@20300000 {
+            compatible = "anyka,ak3790d-ethernet";
+            reg = <0x20300000 0x1fff>;
+            interrupts = <16 0>;
+            clock-names = "ethernet", "50M";
+            clocks = <&gclk_asic 12>, <&clk_peri 5>;
+            status = "disable";
+        };
+
+        mipicsi0: mipicsi0@20400000 {
+            compatible = "anyka,ak3790d-mipi-csi0";
+            reg = <0x20400000 0x7ffff>;
+            status = "disable";
+        };
+
+        mipicsi1: mipicsi1@20480000 {
+            compatible = "anyka,ak3790d-mipi-csi1";
+            reg = <20480000 0x7ffff>;
+            status = "disable";
+        };
+
+        dramctrl:dram-controller@21000000 {
+            compatible = "anyka,ak3790d-dram-controller";
+            reg = <0x21000000 0xffffff>;
+            status = "disable";
+        };
+
+        vi0: vi0@20000000 {
+            compatible = "anyka,ak3790d-vi";
+            reg = <0x20000000 0x1fff>,	/*isp*/
+                  <0x20400000 0xfff>,	/*mipicsi0*/
+                  <0x20480000 0xfff>;	/*mipicsi1*/
+            interrupts = <1 0>;
+            clocks = <&gclk_asic 17>, <&gclk_asic 15>, <&clk_peri 0>;
+            clock-names = "isp_clk", "mipi_csi_clk", "csi_sclk";
+            clock-frequency_isp_clk = <24000000>;
+			/*
+				interface: 0-dvp, 1-mipi1lane, 2-mipi2lane
+			*/
+			interface = <0>;
+
+		    status = "disable";
+        };
+	};
+
+	ircut: ircut {
+		compatible = "anyka,ak3790d-ircut";
+		status = "disable";
+	};
+
+	photosensitive: photosensitive {
+		compatible = "anyka,ak3790d-photosensitive";
+		status = "disable";
+	};
+
+	leds: leds {
+		compatible = "anyka,ak3790d-leds";
+		status = "disable";
+	};
+
+	adkeys: adkeys {
+		compatible = "anyka,ak3790d-adckeys";
+		status = "disable";
+	};
+
+	gpiokeys: gpiokeys {
+		compatible = "anyka,ak3790d-gpiokeys";
+		status = "okay";
+	};	
+	
+	motor0: motor0 {
+		compatible = "anyka,ak3790d-motor0";
+		status = "disable";
+	};
+
+	motor1: motor1 {
+		compatible = "anyka,ak3790d-motor1";
+		status = "disable";
+	};
+
+	pwm0: pwm0 {
+		compatible = "anyka,ak3790d-pwm0";
+		status = "disable";
+	};
+
+	pwm1: pwm1 {
+		compatible = "anyka,ak3790d-pwm1";
+		status = "disable";
+	};
+
+	pwm2: pwm2 {
+		compatible = "anyka,ak3790d-pwm2";
+		status = "disable";
+	};
+
+	pwm3: pwm3 {
+		compatible = "anyka,ak3790d-pwm3";
+		status = "disable";
+	};
+
+  pwm4: pwm4 {
+		compatible = "anyka,ak3790d-pwm4";
+		status = "disable";
+	};
+
+    clocks {
+        osc24M: osc24M {
+            compatible = "fixed-clock";
+            #clock-cells = <0>;
+            clock-output-names = "osc24M";
+            clock-frequency = <24000000>;
+        };
+
+        osc32K {
+            compatible = "fixed-clock";
+            #clock-cells = <0>;
+            clock-output-names = "osc32K";
+            clock-frequency = <32768>;
+        };
+
+        /* this clocks are configed in boot setting, can't be configed in kernel */
+        /* this node is only for get cpu and mem clk in kernel */
+        cpu_pll {
+            compatible = "anyka,ak3790d-fixed-clk";
+            #clock-cells = <1>;
+            clock-id = <0>, <1>, <2>;
+        	clock-output-names = "jclk", "hclk", "dphy";
+            clocks = <&osc24M>;
+        };
+
+        asic_pll: asic_pll {
+            compatible = "anyka,ak3790d-fixed-clk";
+            #clock-cells = <0>;
+            clock-div-od = <1>;
+            clock-div-n = <3>;
+            clock-id = <3>;
+        	clock-frequency = <480000000>;
+        	clock-output-names = "asic_pll";
+            clocks = <&osc24M>;
+        };
+
+        gclk_asic:gclk_asic {
+        	compatible = "anyka,ak3790d-gate-clk";
+        	#clock-cells = <1>;
+            clock-ctrlbit = <1>, <2>, <3>,
+                            <4>, <5>, <6>,
+                            <7>, <8>, <9>,
+                            <10>, <11>, <12>,
+                            <13>, <14>, <15>,
+                            <16>, <17>, <19>,
+                            <20>, <21>, <22>,
+                            <23>, <32>, <33>,
+                            <34>, <35>, <36>,
+                            <37>;
+            clock-output-names = "mmc0", "mmc1", "adc1",
+                                 "dac", "spi0", "spi1",
+                                 "uart0", "uart1", "l2buffer",
+                                 "i2c0", "irda", "gpio",
+                                 "ethernet", "encrypt", "usb-otg",
+                                 "mipi_csi", "i2c1", "isp",
+                                 "vencoder","vdecoder","lcdc",
+                                 "gui", "uart2", "uart3", 
+                                 "mipi_dsi", "mmc2", "i2c2",
+                                 "i2c3";
+            clocks = <&asic_pll>;
+        };
+
+        clk_asic: clk_asic {
+        	compatible = "anyka,ak3790d-factor-clk";
+        	#clock-cells = <1>;
+        	clock-id = <0>, <1>, <2>;
+        	clock-output-names = "adchs", "dachs", "spi0_bus";
+        	clocks = <&asic_pll>;
+        };
+
+    	/*config this clock in uboot*/
+    	peri_pll: peri_pll {
+            compatible = "anyka,ak3790d-fixed-clk";
+            #clock-cells = <0>;
+            clock-div-od = <1>;
+            clock-div-n = <2>;
+        	clock-id = <4>;
+        	clock-frequency = <600000000>;
+        	clock-output-names = "peri_pll";
+            clocks = <&osc24M>;
+        };
+
+        clk_peri: clk_peri {
+        	compatible = "anyka,ak3790d-factor-clk";
+        	#clock-cells = <1>;
+        	clock-id = <3>, <4>, <5>, <6>, <7>, <8>;
+        	clock-output-names = "sclk0", "sclk1", "csi_pclk", "dsi_pclk", "opclk", "usb_phy";
+        	clocks = <&peri_pll>;
+        };
+        clk_sdadc_sddac: clk_sdadc_sddac{
+            compatible = "anyka,ak3790d-factor-clk";
+            #clock-cells = <1>;
+            clock-id = <9>, <10>;
+            clock-output-names = "clk_sdadc", "clk_sddac";
+            clocks = <&pll4_audio_pll>;
+        };
+
+        clk_adc0: clk_adc0 {
+        	compatible = "anyka,ak3790d-factor-clk";
+        	#clock-cells = <1>;
+        	clock-id = <11>;
+        	clock-output-names = "adc0";
+        	clocks = <&osc24M>;
+        };
+
+        pll4_audio_pll: pll4_audio_pll {
+            compatible = "anyka,ak3790d-fixed-clk";
+            #clock-cells = <0>;
+            clock-id = <12>;
+            clock-output-names = "pll4_audio_pll";
+            clocks = <&osc24M>;
+		};
+
+       uv_det_pd:uv_det_pd {
+            compatible = "anyka,ak3790d-uv_det_pd";
+            /*
+            under_voltage_detection
+
+            enable:
+            0: disable under voltage detection
+            1: enable under voltage detection
+
+            threshold:
+            0: reset when VDDIO drops below 2.48V,
+                and the reset will be deasserted when VDDIO reaches 2.68V
+            1: reset when VDDIO drops below 2.65V,
+                and the reset will be deasserted when VDDIO reaches 2.86V
+            2: reset when VDDIO drops below 2.72V,
+                and the reset will be deasserted when VDDIO reaches 2.93V
+            */
+            enable = <1>;
+            threshold = <2>;
+            status = "okay";
+        };
+    };
+};
diff --git a/arch/arm/boot/dts/anyka_ev500_lcd.dtsi b/arch/arm/boot/dts/anyka_ev500_lcd.dtsi
new file mode 100755
index 0000000..127b602
--- /dev/null
+++ b/arch/arm/boot/dts/anyka_ev500_lcd.dtsi
@@ -0,0 +1,737 @@
+/*
+ * AK37D LCD panel dts
+ *
+ * Copyright (C) 2018 Anyka(Guangzhou) Microelectronics Technology Co., Ltd.
+ *
+ * Author: Feilong Dong <dong_feilong@anyka.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+&lcdc {
+    lcd-alarm-empty = <128>;
+    lcd-alarm-full = <510>;
+    lcd-dma-mode = <1>;
+    //lcd-dummy-seq = <0>; //for 8bit rgb panel set
+    //lcd-rgb-seq-sel = <0>;
+    //lcd-rgb-odd-seq = <0>;
+    //lcd-rgb-even-seq = <0>;
+    lcd-rgb-tpg-sel = <1>;
+    lcd-vpage-en = <0>; //don't support vpage function in driver
+    lcd-blank-sel = <0>;
+    lcd-pos-blank-level = <0>;
+    lcd-neg-blank-level = <0>;
+    lcd-rgb-bg-color = <0x00000000>;
+    lcd-vh-delay-en = <0>;
+    lcd-vh-delay-cycle = <0>;
+    lcd-v-unit = <0>;
+    lcd-alert-line = <30>;
+    status = "disable";
+    
+    sat070cp50: lcd-panel@0 { //for RGB panel setting
+        compatible = "sat,sat070cp50";
+        panel-if = <0>; //0 for RGB, 1 for MIPI, 2 for MPU
+        panel-rgb-seq = <1>; //0 for BGR, 1 for RGB
+        panel-width = <1024>;
+        panel-height = <600>;
+        panel-pclk-div = <10>; //pixel clock = Peri_pll/(pclk_div+1)
+        panel-thpw = <60>;
+        panel-thb = <100>;
+        panel-thf = <120>;
+        panel-tvpw = <2>;
+        panel-tvb = <21>;
+        panel-tvf = <12>;
+        panel-pclk-pol = <0>; //0:pos, 1:neg
+        panel-hsync-pol = <1>;
+        panel-vsync-pol = <1>;
+        panel-vogate-pol = <0>;
+        panel-bus-width = <3>; //0:8bits,1:16bits,2:18bits,3:24bits
+        panel-sync-mode = <1>; 
+
+        status = "disable";
+    };
+
+    adt07016BR50: lcd-panel@1 { //for AJB RGB panel setting
+        compatible = "sat,sat070cp50";
+        panel-if = <0>; //0 for RGB, 1 for MIPI, 2 for MPU
+        panel-rgb-seq = <1>; //0 for BGR, 1 for RGB
+        panel-width = <1024>;
+        panel-height = <600>;
+        panel-pclk-div = <10>; //pixel clock = Peri_pll/(pclk_div+1)
+        panel-thpw = <60>;
+        panel-thb = <100>;
+        panel-thf = <120>;
+        panel-tvpw = <2>;
+        panel-tvb = <21>;
+        panel-tvf = <12>;
+        panel-pclk-pol = <0>; //0:pos, 1:neg
+        panel-hsync-pol = <1>;
+        panel-vsync-pol = <1>;
+        panel-vogate-pol = <0>;
+        panel-bus-width = <3>; //0:8bits,1:16bits,2:18bits,3:24bits
+        panel-sync-mode = <1>; 
+
+        status = "disable";
+    };
+    
+    
+    sat101cp40: lcd-panel@2 { //for JD9365 MIPI panel setting
+        compatible = "sat,sat101cp40";
+        panel-if = <1>; //0 for RGB, 1 for MIPI, 2 for MPU
+        panel-rgb-seq = <1>; //0 for BGR, 1 for RGB
+        panel-width = <800>;
+        panel-height = <1280>;
+        panel-pclk-div = <8>; //pixel clock = Peri_pll/(pclk_div+1)
+        panel-dsi-num-lane = <3>; //0-3: 1lane-4lane
+        //0-3: data0-data3, 4: clk
+        panel-dsi-txd0 = <0>;
+        panel-dsi-txd1 = <1>;
+        panel-dsi-txd2 = <4>;
+        panel-dsi-txd3 = <2>;
+        panel-dsi-txd4 = <3>;
+        panel-dsi-noncontinuous-clk = <0>; //0:continuous,1:noncontinuous
+        panel-dsi-t-pre = <1>; //t-pre, >=1
+        panel-dsi-t-post = <1>; //t-post=tlpx+t-prepare+t-zero+t-pre, >=1
+        panel-dsi-tx-gap = <1>; //ths-exit
+        panel-dsi-autoinsert-eotp = <0>; //0:not insert,1:auto-insert
+        panel-dsi-htx-to-count = <0xFFFFFF>; //high speed TX timeout count
+        panel-dsi-lrx-to-count = <0xFFFFFF>; //Low power RX timeout count
+        panel-dsi-bta-to-count = <0xFFFFFF>; //Bus turn around timeout count
+        panel-dsi-t-wakeup = <0xc8>; //DPHY T-wakeup time
+        panel-dsi-pix-fifo-send-level = <512>; //buffer send level <= 512
+        //0-2:16-bit config 1-3; 3-4:18-bit config 1-2; 5:24-bit
+        panel-dsi-if-color-coding = <0x05>;
+        //0:16-bit;1:18-bit;2:18-bit loosely packed;3:24-bit
+        panel-dsi-pix-format = <0x03>;
+        panel-dsi-vsync-pol = <0>; //0:active low; 1:active high
+        panel-dsi-hsync-pol = <0>; //0:active low; 1:active high
+        //0:Non-burst mode with sync pulses;
+        //1:Noe-burst mode with sync events;
+        //2:Burst mode; 3:reserved
+        panel-dsi-video-mode = <2>;
+        panel-dsi-hfp = <40>; //H front porch blanking packet payload size in bytes
+        panel-dsi-hbp = <20>; //H back porch blanking packet payload size in bytes
+        panel-dsi-hsa = <20>; //H sync width blanking packet payload size in bytes
+        panel-dsi-mult-pkts-en = <0>; //0: single packet;1: two packets
+        panel-dsi-vbp = <8>; //V back porch lines
+        panel-dsi-vfp = <8>; //V front porch lines
+        panel-dsi-vsa = <4>;
+        //0:blanking packets send during BLLP;1:LP mode used for BLLP
+        panel-dsi-bllp-mode = <1>;
+        panel-dsi-use-null-pkt-bllp = <0>; //0:blanking packet; 1:Null packet
+        panel-dsi-vc = <0x00>; //Virtual channel
+        panel-dsi-cmd-type = <0x0>; //0:send in LP mode, 1:send in HS mode
+        panel-dsi-clk = <600>;
+        //add special config list here
+        panel-init-list =  //delay, type, data, parameters, end symbol
+                          < 0x00 0x15 0xE0 0x00 0xFFF
+                            0x00 0x15 0xE1 0x93 0xFFF
+                            0x00 0x15 0xE2 0x65 0xFFF
+                            0x00 0x15 0xE3 0xF8 0xFFF
+                            0x00 0x15 0x80 0x03 0xFFF
+                            0x00 0x15 0xE0 0x01 0xFFF
+                            0x00 0x15 0x00 0x00 0xFFF
+                            0x00 0x15 0x01 0x65 0xFFF
+                            0x00 0x15 0x17 0x00 0xFFF
+                            0x00 0x15 0x18 0xAF 0xFFF
+                            0x00 0x15 0x19 0x01 0xFFF
+                            0x00 0x15 0x1A 0x00 0xFFF
+                            0x00 0x15 0x1B 0xAF 0xFFF
+                            0x00 0x15 0x1C 0x01 0xFFF
+                            0x00 0x15 0x1F 0x3E 0xFFF
+                            0x00 0x15 0x20 0x28 0xFFF
+                            0x00 0x15 0x21 0x28 0xFFF
+                            0x00 0x15 0x22 0x7E 0xFFF
+                            0x00 0x15 0x35 0x2A 0xFFF
+                            0x00 0x15 0x37 0x09 0xFFF
+                            0x00 0x15 0x38 0x04 0xFFF
+                            0x00 0x15 0x39 0x00 0xFFF
+                            0x00 0x15 0x3A 0x01 0xFFF
+                            0x00 0x15 0x3C 0x76 0xFFF
+                            0x00 0x15 0x3D 0xFF 0xFFF
+                            0x00 0x15 0x3E 0xFF 0xFFF
+                            0x00 0x15 0x3F 0x7F 0xFFF
+                            0x00 0x15 0x40 0x06 0xFFF
+                            0x00 0x15 0x41 0xA0 0xFFF
+                            0x00 0x15 0x42 0x81 0xFFF
+                            0x00 0x15 0x43 0x14 0xFFF
+                            0x00 0x15 0x44 0x0A 0xFFF
+                            0x00 0x15 0x45 0x12 0xFFF
+                            0x00 0x15 0x55 0x01 0xFFF
+                            0x00 0x15 0x56 0x01 0xFFF
+                            0x00 0x15 0x57 0x6E 0xFFF
+                            0x00 0x15 0x58 0x07 0xFFF
+                            0x00 0x15 0x59 0x07 0xFFF
+                            0x00 0x15 0x5A 0x29 0xFFF
+                            0x00 0x15 0x5B 0x24 0xFFF
+                            0x00 0x15 0x5D 0x7C 0xFFF
+                            0x00 0x15 0x5E 0x65 0xFFF
+                            0x00 0x15 0x5F 0x57 0xFFF
+                            0x00 0x15 0x60 0x4A 0xFFF
+                            0x00 0x15 0x61 0x46 0xFFF
+                            0x00 0x15 0x62 0x36 0xFFF
+                            0x00 0x15 0x63 0x3A 0xFFF
+                            0x00 0x15 0x64 0x23 0xFFF
+                            0x00 0x15 0x65 0x3A 0xFFF
+                            0x00 0x15 0x66 0x38 0xFFF
+                            0x00 0x15 0x67 0x38 0xFFF
+                            0x00 0x15 0x68 0x55 0xFFF
+                            0x00 0x15 0x69 0x43 0xFFF
+                            0x00 0x15 0x6A 0x4A 0xFFF
+                            0x00 0x15 0x6B 0x3B 0xFFF
+                            0x00 0x15 0x6C 0x36 0xFFF
+                            0x00 0x15 0x6D 0x28 0xFFF
+                            0x00 0x15 0x6E 0x15 0xFFF
+                            0x00 0x15 0x6F 0x00 0xFFF
+                            0x00 0x15 0x70 0x7C 0xFFF
+                            0x00 0x15 0x71 0x66 0xFFF
+                            0x00 0x15 0x72 0x57 0xFFF
+                            0x00 0x15 0x73 0x4A 0xFFF
+                            0x00 0x15 0x74 0x46 0xFFF
+                            0x00 0x15 0x75 0x36 0xFFF
+                            0x00 0x15 0x76 0x3A 0xFFF
+                            0x00 0x15 0x77 0x23 0xFFF
+                            0x00 0x15 0x78 0x3A 0xFFF
+                            0x00 0x15 0x79 0x38 0xFFF
+                            0x00 0x15 0x7A 0x38 0xFFF
+                            0x00 0x15 0x7B 0x55 0xFFF
+                            0x00 0x15 0x7C 0x43 0xFFF
+                            0x00 0x15 0x7D 0x4A 0xFFF
+                            0x00 0x15 0x7E 0x3B 0xFFF
+                            0x00 0x15 0x7F 0x36 0xFFF
+                            0x00 0x15 0x80 0x28 0xFFF
+                            0x00 0x15 0x81 0x15 0xFFF
+                            0x00 0x15 0x82 0x00 0xFFF
+                            0x00 0x15 0xE0 0x02 0xFFF
+                            0x00 0x15 0x00 0x1E 0xFFF
+                            0x00 0x15 0x01 0x1E 0xFFF
+                            0x00 0x15 0x02 0x41 0xFFF
+                            0x00 0x15 0x03 0x41 0xFFF
+                            0x00 0x15 0x04 0x43 0xFFF
+                            0x00 0x15 0x05 0x43 0xFFF
+                            0x00 0x15 0x06 0x1F 0xFFF
+                            0x00 0x15 0x07 0x1F 0xFFF
+                            0x00 0x15 0x08 0x1F 0xFFF
+                            0x00 0x15 0x09 0x1F 0xFFF
+                            0x00 0x15 0x0A 0x1E 0xFFF
+                            0x00 0x15 0x0B 0x1E 0xFFF
+                            0x00 0x15 0x0C 0x1F 0xFFF
+                            0x00 0x15 0x0D 0x47 0xFFF
+                            0x00 0x15 0x0E 0x47 0xFFF
+                            0x00 0x15 0x0F 0x45 0xFFF
+                            0x00 0x15 0x10 0x45 0xFFF
+                            0x00 0x15 0x11 0x4B 0xFFF
+                            0x00 0x15 0x12 0x4B 0xFFF
+                            0x00 0x15 0x13 0x49 0xFFF
+                            0x00 0x15 0x14 0x49 0xFFF
+                            0x00 0x15 0x15 0x1F 0xFFF
+                            0x00 0x15 0x16 0x1E 0xFFF
+                            0x00 0x15 0x17 0x1E 0xFFF
+                            0x00 0x15 0x18 0x40 0xFFF
+                            0x00 0x15 0x19 0x40 0xFFF
+                            0x00 0x15 0x1A 0x42 0xFFF
+                            0x00 0x15 0x1B 0x42 0xFFF
+                            0x00 0x15 0x1C 0x1F 0xFFF
+                            0x00 0x15 0x1D 0x1F 0xFFF
+                            0x00 0x15 0x1E 0x1F 0xFFF
+                            0x00 0x15 0x1F 0x1F 0xFFF
+                            0x00 0x15 0x20 0x1E 0xFFF
+                            0x00 0x15 0x21 0x1E 0xFFF
+                            0x00 0x15 0x22 0x1f 0xFFF
+                            0x00 0x15 0x23 0x46 0xFFF
+                            0x00 0x15 0x24 0x46 0xFFF
+                            0x00 0x15 0x25 0x44 0xFFF
+                            0x00 0x15 0x26 0x44 0xFFF
+                            0x00 0x15 0x27 0x4A 0xFFF
+                            0x00 0x15 0x28 0x4A 0xFFF
+                            0x00 0x15 0x29 0x48 0xFFF
+                            0x00 0x15 0x2A 0x48 0xFFF
+                            0x00 0x15 0x2B 0x1F 0xFFF
+                            0x00 0x15 0x2C 0x11 0xFFF
+                            0x00 0x15 0x2D 0x0F 0xFFF
+                            0x00 0x15 0x2E 0x0D 0xFFF
+                            0x00 0x15 0x2F 0x0B 0xFFF
+                            0x00 0x15 0x30 0x09 0xFFF
+                            0x00 0x15 0x31 0x07 0xFFF
+                            0x00 0x15 0x32 0x05 0xFFF
+                            0x00 0x15 0x33 0x18 0xFFF
+                            0x00 0x15 0x34 0x17 0xFFF
+                            0x00 0x15 0x35 0x1F 0xFFF
+                            0x00 0x15 0x36 0x01 0xFFF
+                            0x00 0x15 0x37 0x1F 0xFFF
+                            0x00 0x15 0x38 0x1F 0xFFF
+                            0x00 0x15 0x39 0x1F 0xFFF
+                            0x00 0x15 0x3A 0x1F 0xFFF
+                            0x00 0x15 0x3B 0x1F 0xFFF
+                            0x00 0x15 0x3C 0x1F 0xFFF
+                            0x00 0x15 0x3D 0x1F 0xFFF
+                            0x00 0x15 0x3E 0x1F 0xFFF
+                            0x00 0x15 0x3F 0x13 0xFFF
+                            0x00 0x15 0x40 0x1F 0xFFF
+                            0x00 0x15 0x41 0x1F 0xFFF
+                            0x00 0x15 0x42 0x10 0xFFF
+                            0x00 0x15 0x43 0x0E 0xFFF
+                            0x00 0x15 0x44 0x0C 0xFFF
+                            0x00 0x15 0x45 0x0A 0xFFF
+                            0x00 0x15 0x46 0x08 0xFFF
+                            0x00 0x15 0x47 0x06 0xFFF
+                            0x00 0x15 0x48 0x04 0xFFF
+                            0x00 0x15 0x49 0x18 0xFFF
+                            0x00 0x15 0x4A 0x17 0xFFF
+                            0x00 0x15 0x4B 0x1F 0xFFF
+                            0x00 0x15 0x4C 0x00 0xFFF
+                            0x00 0x15 0x4D 0x1F 0xFFF
+                            0x00 0x15 0x4E 0x1F 0xFFF
+                            0x00 0x15 0x4F 0x1F 0xFFF
+                            0x00 0x15 0x50 0x1F 0xFFF
+                            0x00 0x15 0x51 0x1F 0xFFF
+                            0x00 0x15 0x52 0x1F 0xFFF
+                            0x00 0x15 0x53 0x1F 0xFFF
+                            0x00 0x15 0x54 0x1F 0xFFF
+                            0x00 0x15 0x55 0x12 0xFFF
+                            0x00 0x15 0x56 0x1F 0xFFF
+                            0x00 0x15 0x57 0x1F 0xFFF
+                            0x00 0x15 0x58 0x10 0xFFF
+                            0x00 0x15 0x59 0x00 0xFFF
+                            0x00 0x15 0x5A 0x00 0xFFF
+                            0x00 0x15 0x5B 0x30 0xFFF
+                            0x00 0x15 0x5C 0x03 0xFFF
+                            0x00 0x15 0x5D 0x30 0xFFF
+                            0x00 0x15 0x5E 0x01 0xFFF
+                            0x00 0x15 0x5F 0x02 0xFFF
+                            0x00 0x15 0x60 0x30 0xFFF
+                            0x00 0x15 0x61 0x01 0xFFF
+                            0x00 0x15 0x62 0x02 0xFFF
+                            0x00 0x15 0x63 0x14 0xFFF
+                            0x00 0x15 0x64 0x6A 0xFFF
+                            0x00 0x15 0x65 0x05 0xFFF
+                            0x00 0x15 0x66 0x12 0xFFF
+                            0x00 0x15 0x67 0x73 0xFFF
+                            0x00 0x15 0x68 0x05 0xFFF
+                            0x00 0x15 0x69 0x14 0xFFF
+                            0x00 0x15 0x6A 0x6A 0xFFF
+                            0x00 0x15 0x6B 0x09 0xFFF
+                            0x00 0x15 0x6C 0x00 0xFFF
+                            0x00 0x15 0x6D 0x04 0xFFF
+                            0x00 0x15 0x6E 0x02 0xFFF
+                            0x00 0x15 0x6F 0x40 0xFFF
+                            0x00 0x15 0x70 0x00 0xFFF
+                            0x00 0x15 0x71 0x00 0xFFF
+                            0x00 0x15 0x72 0x06 0xFFF
+                            0x00 0x15 0x73 0x7B 0xFFF
+                            0x00 0x15 0x74 0x00 0xFFF
+                            0x00 0x15 0x75 0x07 0xFFF
+                            0x00 0x15 0x76 0x00 0xFFF
+                            0x00 0x15 0x77 0x5D 0xFFF
+                            0x00 0x15 0x78 0x17 0xFFF
+                            0x00 0x15 0x79 0x1F 0xFFF
+                            0x00 0x15 0x7A 0x00 0xFFF
+                            0x00 0x15 0x7B 0x00 0xFFF
+                            0x00 0x15 0x7C 0x00 0xFFF
+                            0x00 0x15 0x7D 0x03 0xFFF
+                            0x00 0x15 0x7E 0x7B 0xFFF
+                            0x00 0x15 0xE0 0x04 0xFFF
+                            0x00 0x15 0x2B 0x2B 0xFFF
+                            0x00 0x15 0x2E 0x44 0xFFF
+                            0x00 0x15 0x09 0x11 0xFFF
+                            0x00 0x15 0x2D 0x03 0xFFF
+                            0x00 0x15 0x0E 0x48 0xFFF
+                            0x00 0x15 0xE0 0x00 0xFFF
+                            0x00 0x15 0xE6 0x02 0xFFF
+                            0xC8 0x15 0xE7 0x02 0xFFF
+                            0x78 0x05 0x11 0x00 0xFFF
+                            0x64 0x05 0x29 0x00 0xFFF
+                            0x00 0x15 0x35 0x00 0xFFF>;
+
+        status = "disable";
+    };
+    
+    sat101at40: lcd-panel@3 { //for JD9364 MIPI panel setting
+        compatible = "sat,sat101cp40";
+        panel-if = <1>; //0 for RGB, 1 for MIPI, 2 for MPU
+        panel-rgb-seq = <1>; //0 for BGR, 1 for RGB
+        panel-width = <800>;
+        panel-height = <1280>;
+        panel-pclk-div = <8>; //pixel clock = Peri_pll/(pclk_div+1)
+        panel-dsi-num-lane = <3>; //0-3: 1lane-4lane
+        //0-3: data0-data3, 4: clk
+        panel-dsi-txd0 = <2>;
+        panel-dsi-txd1 = <1>;
+        panel-dsi-txd2 = <4>;
+        panel-dsi-txd3 = <0>;
+        panel-dsi-txd4 = <3>;
+        panel-dsi-noncontinuous-clk = <0>; //0:continuous,1:noncontinuous
+        panel-dsi-t-pre = <1>; //t-pre, >=1
+        panel-dsi-t-post = <1>; //t-post=tlpx+t-prepare+t-zero+t-pre, >=1
+        panel-dsi-tx-gap = <1>; //ths-exit
+        panel-dsi-autoinsert-eotp = <0>; //0:not insert,1:auto-insert
+        panel-dsi-htx-to-count = <0xFFFFFF>; //high speed TX timeout count
+        panel-dsi-lrx-to-count = <0xFFFFFF>; //Low power RX timeout count
+        panel-dsi-bta-to-count = <0xFFFFFF>; //Bus turn around timeout count
+        panel-dsi-t-wakeup = <0xc8>; //DPHY T-wakeup time
+        panel-dsi-pix-fifo-send-level = <512>; //buffer send level <= 512
+        //0-2:16-bit config 1-3; 3-4:18-bit config 1-2; 5:24-bit
+        panel-dsi-if-color-coding = <0x05>;
+        //0:16-bit;1:18-bit;2:18-bit loosely packed;3:24-bit
+        panel-dsi-pix-format = <0x03>;
+        panel-dsi-vsync-pol = <0>; //0:active low; 1:active high
+        panel-dsi-hsync-pol = <0>; //0:active low; 1:active high
+        //0:Non-burst mode with sync pulses;
+        //1:Noe-burst mode with sync events;
+        //2:Burst mode; 3:reserved
+        panel-dsi-video-mode = <2>;
+        panel-dsi-hfp = <32>; //H front porch blanking packet payload size in bytes
+        panel-dsi-hbp = <8>; //H back porch blanking packet payload size in bytes
+        panel-dsi-hsa = <8>; //H sync width blanking packet payload size in bytes
+        panel-dsi-mult-pkts-en = <0>; //0: single packet;1: two packets
+        panel-dsi-vbp = <8>; //V back porch lines
+        panel-dsi-vfp = <30>; //V front porch lines
+        panel-dsi-vsa = <4>;
+        //0:blanking packets send during BLLP;1:LP mode used for BLLP
+        panel-dsi-bllp-mode = <1>;
+        panel-dsi-use-null-pkt-bllp = <0>; //0:blanking packet; 1:Null packet
+        panel-dsi-vc = <0x00>; //Virtual channel
+        panel-dsi-cmd-type = <0x0>; //0:send in LP mode, 1:send in HS mode
+        panel-dsi-clk = <600>;
+        //add special config list here
+        panel-init-list = <0x00 0x23 0xE0 0x00 0xFFF
+                            0x00 0x23 0xE1 0x93 0xFFF
+                            0x00 0x23 0xE2 0x65 0xFFF
+                            0x00 0x23 0xE3 0xF8 0xFFF
+                            0x00 0x23 0x70 0x10 0xFFF
+                            0x00 0x23 0x71 0x13 0xFFF
+                            0x00 0x23 0x72 0x06 0xFFF
+                            0x00 0x23 0x80 0x03 0xFFF
+                            0x00 0x23 0xE0 0x04 0xFFF
+                            0x00 0x23 0x2D 0x03 0xFFF
+                            0x00 0x23 0xE0 0x01 0xFFF
+                            0x00 0x23 0x00 0x00 0xFFF
+                            0x00 0x23 0x01 0xB3 0xFFF
+                            0x00 0x23 0x17 0x00 0xFFF
+                            0x00 0x23 0x18 0xD8 0xFFF
+                            0x00 0x23 0x19 0x05 0xFFF
+                            0x00 0x23 0x1A 0x00 0xFFF
+                            0x00 0x23 0x1B 0xD8 0xFFF
+                            0x00 0x23 0x1C 0x05 0xFFF
+                            0x00 0x23 0x1F 0x7E 0xFFF
+                            0x00 0x23 0x20 0x28 0xFFF
+                            0x00 0x23 0x21 0x28 0xFFF
+                            0x00 0x23 0x22 0x0E 0xFFF
+                            0x00 0x23 0x24 0xF8 0xFFF
+                            0x00 0x23 0x26 0xF3 0xFFF
+                            0x00 0x23 0x27 0x44 0xFFF
+                            0x00 0x23 0x37 0x59 0xFFF
+                            0x00 0x23 0x38 0x05 0xFFF
+                            0x00 0x23 0x39 0x0C 0xFFF
+                            0x00 0x23 0x3A 0x18 0xFFF
+                            0x00 0x23 0x3C 0x78 0xFFF
+                            0x00 0x23 0x3E 0x78 0xFFF
+                            0x00 0x23 0x40 0x06 0xFFF
+                            0x00 0x23 0x41 0xA0 0xFFF
+                            0x00 0x23 0x55 0x01 0xFFF
+                            0x00 0x23 0x56 0x01 0xFFF
+                            0x00 0x23 0x57 0xA8 0xFFF
+                            0x00 0x23 0x58 0x0A 0xFFF
+                            0x00 0x23 0x59 0x2A 0xFFF
+                            0x00 0x23 0x5A 0x3C 0xFFF
+                            0x00 0x23 0x5B 0x14 0xFFF
+                            0x00 0x23 0x5D 0x70 0xFFF
+                            0x00 0x23 0x5E 0x53 0xFFF
+                            0x00 0x23 0x5F 0x42 0xFFF
+                            0x00 0x23 0x60 0x35 0xFFF
+                            0x00 0x23 0x61 0x32 0xFFF
+                            0x00 0x23 0x62 0x23 0xFFF
+                            0x00 0x23 0x63 0x28 0xFFF
+                            0x00 0x23 0x64 0x13 0xFFF
+                            0x00 0x23 0x65 0x2D 0xFFF
+                            0x00 0x23 0x66 0x2D 0xFFF
+                            0x00 0x23 0x67 0x2D 0xFFF
+                            0x00 0x23 0x68 0x4B 0xFFF
+                            0x00 0x23 0x69 0x39 0xFFF
+                            0x00 0x23 0x6A 0x40 0xFFF
+                            0x00 0x23 0x6B 0x2F 0xFFF
+                            0x00 0x23 0x6C 0x26 0xFFF
+                            0x00 0x23 0x6D 0x1E 0xFFF
+                            0x00 0x23 0x6E 0x07 0xFFF
+                            0x00 0x23 0x6F 0x02 0xFFF
+                            0x00 0x23 0x70 0x70 0xFFF
+                            0x00 0x23 0x71 0x53 0xFFF
+                            0x00 0x23 0x72 0x42 0xFFF
+                            0x00 0x23 0x73 0x35 0xFFF
+                            0x00 0x23 0x74 0x32 0xFFF
+                            0x00 0x23 0x75 0x23 0xFFF
+                            0x00 0x23 0x76 0x28 0xFFF
+                            0x00 0x23 0x77 0x13 0xFFF
+                            0x00 0x23 0x78 0x2D 0xFFF
+                            0x00 0x23 0x79 0x2D 0xFFF
+                            0x00 0x23 0x7A 0x2D 0xFFF
+                            0x00 0x23 0x7B 0x4B 0xFFF
+                            0x00 0x23 0x7C 0x39 0xFFF
+                            0x00 0x23 0x7D 0x40 0xFFF
+                            0x00 0x23 0x7E 0x2F 0xFFF
+                            0x00 0x23 0x7F 0x26 0xFFF
+                            0x00 0x23 0x80 0x1E 0xFFF
+                            0x00 0x23 0x81 0x07 0xFFF
+                            0x00 0x23 0x82 0x02 0xFFF
+                            0x00 0x23 0xE0 0x02 0xFFF
+                            0x00 0x23 0x00 0x53 0xFFF
+                            0x00 0x23 0x01 0x5F 0xFFF
+                            0x00 0x23 0x02 0x5F 0xFFF
+                            0x00 0x23 0x03 0x5F 0xFFF
+                            0x00 0x23 0x04 0x5F 0xFFF
+                            0x00 0x23 0x05 0x51 0xFFF
+                            0x00 0x23 0x06 0x58 0xFFF
+                            0x00 0x23 0x07 0x57 0xFFF
+                            0x00 0x23 0x08 0x4F 0xFFF
+                            0x00 0x23 0x09 0x5F 0xFFF
+                            0x00 0x23 0x0A 0x4D 0xFFF
+                            0x00 0x23 0x0B 0x4B 0xFFF
+                            0x00 0x23 0x0C 0x5F 0xFFF
+                            0x00 0x23 0x0D 0x49 0xFFF
+                            0x00 0x23 0x0E 0x47 0xFFF
+                            0x00 0x23 0x0F 0x45 0xFFF
+                            0x00 0x23 0x10 0x41 0xFFF
+                            0x00 0x23 0x11 0x5F 0xFFF
+                            0x00 0x23 0x12 0x5F 0xFFF
+                            0x00 0x23 0x13 0x5F 0xFFF
+                            0x00 0x23 0x14 0x5F 0xFFF
+                            0x00 0x23 0x15 0x5F 0xFFF
+                            0x00 0x23 0x16 0x52 0xFFF
+                            0x00 0x23 0x17 0x5F 0xFFF
+                            0x00 0x23 0x18 0x5F 0xFFF
+                            0x00 0x23 0x19 0x5F 0xFFF
+                            0x00 0x23 0x1A 0x5F 0xFFF
+                            0x00 0x23 0x1B 0x50 0xFFF
+                            0x00 0x23 0x1C 0x58 0xFFF
+                            0x00 0x23 0x1D 0x57 0xFFF
+                            0x00 0x23 0x1E 0x4E 0xFFF
+                            0x00 0x23 0x1F 0x5F 0xFFF
+                            0x00 0x23 0x20 0x4C 0xFFF
+                            0x00 0x23 0x21 0x4A 0xFFF
+                            0x00 0x23 0x22 0x5F 0xFFF
+                            0x00 0x23 0x23 0x48 0xFFF
+                            0x00 0x23 0x24 0x46 0xFFF
+                            0x00 0x23 0x25 0x44 0xFFF
+                            0x00 0x23 0x26 0x40 0xFFF
+                            0x00 0x23 0x27 0x5F 0xFFF
+                            0x00 0x23 0x28 0x5F 0xFFF
+                            0x00 0x23 0x29 0x5F 0xFFF
+                            0x00 0x23 0x2A 0x5F 0xFFF
+                            0x00 0x23 0x2B 0x5F 0xFFF
+                            0x00 0x23 0x2C 0x52 0xFFF
+                            0x00 0x23 0x2D 0x5F 0xFFF
+                            0x00 0x23 0x2E 0x5F 0xFFF
+                            0x00 0x23 0x2F 0x5F 0xFFF
+                            0x00 0x23 0x30 0x5F 0xFFF
+                            0x00 0x23 0x31 0x40 0xFFF
+                            0x00 0x23 0x32 0x58 0xFFF
+                            0x00 0x23 0x33 0x57 0xFFF
+                            0x00 0x23 0x34 0x44 0xFFF
+                            0x00 0x23 0x35 0x5F 0xFFF
+                            0x00 0x23 0x36 0x46 0xFFF
+                            0x00 0x23 0x37 0x48 0xFFF
+                            0x00 0x23 0x38 0x5F 0xFFF
+                            0x00 0x23 0x39 0x4A 0xFFF
+                            0x00 0x23 0x3A 0x4C 0xFFF
+                            0x00 0x23 0x3B 0x4E 0xFFF
+                            0x00 0x23 0x3C 0x50 0xFFF
+                            0x00 0x23 0x3D 0x5F 0xFFF
+                            0x00 0x23 0x3E 0x5F 0xFFF
+                            0x00 0x23 0x3F 0x5F 0xFFF
+                            0x00 0x23 0x40 0x5F 0xFFF
+                            0x00 0x23 0x41 0x5F 0xFFF
+                            0x00 0x23 0x42 0x53 0xFFF
+                            0x00 0x23 0x43 0x5F 0xFFF
+                            0x00 0x23 0x44 0x5F 0xFFF
+                            0x00 0x23 0x45 0x5F 0xFFF
+                            0x00 0x23 0x46 0x5F 0xFFF
+                            0x00 0x23 0x47 0x41 0xFFF
+                            0x00 0x23 0x48 0x58 0xFFF
+                            0x00 0x23 0x49 0x57 0xFFF
+                            0x00 0x23 0x4A 0x45 0xFFF
+                            0x00 0x23 0x4B 0x5F 0xFFF
+                            0x00 0x23 0x4C 0x47 0xFFF
+                            0x00 0x23 0x4D 0x49 0xFFF
+                            0x00 0x23 0x4E 0x5F 0xFFF
+                            0x00 0x23 0x4F 0x4B 0xFFF
+                            0x00 0x23 0x50 0x4D 0xFFF
+                            0x00 0x23 0x51 0x4F 0xFFF
+                            0x00 0x23 0x52 0x51 0xFFF
+                            0x00 0x23 0x53 0x5F 0xFFF
+                            0x00 0x23 0x54 0x5F 0xFFF
+                            0x00 0x23 0x55 0x5F 0xFFF
+                            0x00 0x23 0x56 0x5F 0xFFF
+                            0x00 0x23 0x57 0x5F 0xFFF
+                            0x00 0x23 0x58 0x10 0xFFF
+                            0x00 0x23 0x59 0x00 0xFFF
+                            0x00 0x23 0x5A 0x00 0xFFF
+                            0x00 0x23 0x5B 0x10 0xFFF
+                            0x00 0x23 0x5C 0x05 0xFFF
+                            0x00 0x23 0x5D 0x30 0xFFF
+                            0x00 0x23 0x5E 0x00 0xFFF
+                            0x00 0x23 0x5F 0x00 0xFFF
+                            0x00 0x23 0x60 0x30 0xFFF
+                            0x00 0x23 0x61 0x02 0xFFF
+                            0x00 0x23 0x62 0x00 0xFFF
+                            0x00 0x23 0x63 0x03 0xFFF
+                            0x00 0x23 0x64 0x7B 0xFFF
+                            0x00 0x23 0x65 0x75 0xFFF
+                            0x00 0x23 0x66 0x0B 0xFFF
+                            0x00 0x23 0x67 0xB3 0xFFF
+                            0x00 0x23 0x68 0x07 0xFFF
+                            0x00 0x23 0x69 0x06 0xFFF
+                            0x00 0x23 0x6A 0x7B 0xFFF
+                            0x00 0x23 0x6B 0x04 0xFFF
+                            0x00 0x23 0x6C 0x00 0xFFF
+                            0x00 0x23 0x6D 0x04 0xFFF
+                            0x00 0x23 0x6E 0x04 0xFFF
+                            0x00 0x23 0x6F 0x88 0xFFF
+                            0x00 0x23 0x70 0x00 0xFFF
+                            0x00 0x23 0x71 0x00 0xFFF
+                            0x00 0x23 0x72 0x06 0xFFF
+                            0x00 0x23 0x73 0x7B 0xFFF
+                            0x00 0x23 0x74 0x00 0xFFF
+                            0x00 0x23 0x75 0x80 0xFFF
+                            0x00 0x23 0x76 0x00 0xFFF
+                            0x00 0x23 0x77 0x0D 0xFFF
+                            0x00 0x23 0x78 0x2A 0xFFF
+                            0x00 0x23 0x79 0x00 0xFFF
+                            0x00 0x23 0x7A 0x00 0xFFF
+                            0x00 0x23 0x7B 0x00 0xFFF
+                            0x00 0x23 0x7C 0x00 0xFFF
+                            0x00 0x23 0x7D 0x03 0xFFF
+                            0x00 0x23 0x7E 0x7B 0xFFF
+                            0x00 0x23 0xE0 0x00 0xFFF
+                            0x78 0x13 0x11 0x00 0xFFF
+                            0x05 0x13 0x29 0x00 0xFFF
+                            0x78 0x23 0x35 0x00 0xFFF>;
+
+        status = "disable";
+    };
+
+    am1080wq05: lcd-panel@4 { //for am MIPI panel setting
+        compatible = "am,am1080wq05";
+        panel-if = <1>; //0 for RGB, 1 for MIPI, 2 for MPU
+        panel-rgb-seq = <1>; //0 for BGR, 1 for RGB
+        panel-width = <800>;
+        panel-height = <1280>;
+        panel-pclk-div = <7>; //pixel clock = Peri_pll/(pclk_div+1)
+        panel-dsi-num-lane = <3>; //0-3: 1lane-4lane
+        //0-3: data0-data3, 4: clk
+        panel-dsi-txd0 = <0>;
+        panel-dsi-txd1 = <1>;
+        panel-dsi-txd2 = <4>;
+        panel-dsi-txd3 = <2>;
+        panel-dsi-txd4 = <3>;
+        panel-dsi-noncontinuous-clk = <0>; //0:continuous,1:noncontinuous
+        panel-dsi-t-pre = <1>; //t-pre, >=1
+        panel-dsi-t-post = <1>; //t-post=tlpx+t-prepare+t-zero+t-pre, >=1
+        panel-dsi-tx-gap = <1>; //ths-exit, >=1
+        panel-dsi-autoinsert-eotp = <0>; //0:not insert,1:auto-insert
+        //panel-dsi-htx-to-count = <0xFFFFFF>; //high speed TX timeout count
+        //panel-dsi-lrx-to-count = <0xFFFFFF>; //Low power RX timeout count
+        //panel-dsi-bta-to-count = <0xFFFFFF>; //Bus turn around timeout count
+        panel-dsi-t-wakeup = <0xc8>; //DPHY T-wakeup time
+        panel-dsi-pix-fifo-send-level = <512>; //buffer send level
+        //0-2:16-bit config 1-3; 3-4:18-bit config 1-2; 5:24-bit
+        panel-dsi-if-color-coding = <0x05>;
+        //0:16-bit;1:18-bit;2:18-bit loosely packed;3:24-bit
+        panel-dsi-pix-format = <0x03>;
+        panel-dsi-vsync-pol = <1>; //0:active low; 1:active high
+        panel-dsi-hsync-pol = <1>; //0:active low; 1:active high
+        //0:Non-burst mode with sync pulses;
+        //1:Noe-burst mode with sync events;
+        //2:Burst mode; 3:reserved
+        panel-dsi-video-mode = <2>;
+        panel-dsi-hfp = <16>; //H front porch blanking packet payload size in bytes
+        panel-dsi-hbp = <59>; //H back porch blanking packet payload size in bytes
+        panel-dsi-hsa = <5>; //H sync width blanking packet payload size in bytes
+        panel-dsi-mult-pkts-en = <0>; //0: single packet;1: two packets
+        panel-dsi-vbp = <3>; //V back porch lines
+        panel-dsi-vfp = <8>; //V front porch lines
+        panel-dsi-vsa = <5>;
+        //0:blanking packets send during BLLP;1:LP mode used for BLLP
+        panel-dsi-bllp-mode = <1>;
+        panel-dsi-use-null-pkt-bllp = <0>; //0:blanking packet; 1:Null packet
+        panel-dsi-vc = <0x00>; //Virtual channel
+        panel-dsi-cmd-type = <0x0>; //0:send in LP mode, 1:send in HS mode
+        panel-dsi-clk = <450>;
+        //add special config list here
+        panel-init-list = <0x00 0x39 0xF0 0x5A 0x5A 0xFFF //delay, type, data, end symbol
+                           0x00 0x39 0xF1 0x5A 0x5A 0xFFF
+                           0x00 0x39 0xFC 0xA5 0xA5 0xFFF
+                           0x00 0x39 0xD0 0x00 0x10 0xFFF
+                           0x00 0x39 0xB1 0x10 0xFFF
+                           0x00 0x39 0xB2 0x14 0x22 0x2F
+                                     0x04 0xFFF
+                           0x00 0x39 0xB5 0x01 0xFFF
+                           0x00 0x39 0xEE 0x00 0x00 0x1F
+                                     0x00 0x00 0x00 0x1F
+                                     0x00 0xFFF
+                           0x00 0x39 0xEF 0x56 0x34 0x43
+                                     0x65 0x90 0x80 0x24
+                                     0x80 0x00 0x91 0x11
+                                     0x11 0x11 0xFFF
+                           0x00 0x39 0xF7 0x04 0x08 0x09
+                                     0x0A 0x0B 0x0C 0x0D
+                                     0x0E 0x0F 0x16 0x17
+                                     0x10 0x01 0x01 0x01
+                                     0x01 0x04 0x08 0x09
+                                     0x0A 0x0B 0x0C 0x0D
+                                     0x0E 0x0F 0x16 0x17
+                                     0x10 0x01 0x01 0x01
+                                     0x01 0xFFF
+                           0x00 0x39 0xF2 0x02 0x08 0x08
+                                     0x40 0x10 0xFFF
+                           0x00 0x39 0xF6 0x60 0x25 0x26
+                                     0x00 0x00 0x00 0xFFF
+                           0x00 0x39 0xFA 0x04 0x35 0x07
+                                     0x0B 0x12 0x0B 0x10
+                                     0x16 0x1A 0x24 0x2C
+                                     0x33 0x3B 0x3B 0x33
+                                     0x34 0x33 0xFFF
+                           0x00 0x39 0xFB 0x04 0x35 0x07
+                                     0x0B 0x12 0x0B 0x10
+                                     0x16 0x1A 0x24 0x2C
+                                     0x33 0x3B 0x3B 0x33
+                                     0x34 0x33 0xFFF
+                           0x00 0x39 0xF3 0x01 0xC4 0xE0
+                                     0x62 0xD4 0x83 0x37
+                                     0x3C 0x24 0x00 0xFFF
+                           0x00 0x39 0xF4 0x00 0x02 0x03
+                                     0x26 0x03 0x02 0x09
+                                     0x00 0x07 0x16 0x16
+                                     0x03 0x00 0x08 0x08
+                                     0x03 0x19 0x1C 0x12
+                                     0x1C 0x1D 0x1E 0x1A
+                                     0x09 0x01 0x04 0x02
+                                     0x61 0x74 0x75 0x72
+                                     0x83 0x80 0x80 0xF0
+                                     0xFFF
+                           0x00 0x39 0xB0 0x01 0xFFF
+                           0x00 0x39 0xF5 0x2F 0x2F 0x5F
+                                     0xAB 0x98 0x52 0x0F
+                                     0x33 0x43 0x04 0x59
+                                     0x54 0x52 0x05 0x40
+                                     0x40 0x5D 0x59 0x40 0xFFF
+                           0x00 0x39 0xBC 0x01 0x4E 0x08 0xFFF
+                           0x00 0x39 0xE1 0x03 0x10 0x1C
+                                     0xA0 0x10 0xFFF
+                           0x00 0x39 0xFD 0x16 0x10 0x11
+                                     0x20 0x09 0xFFF
+                           0x00 0x39 0x35 0x00 0xFFF
+                           0x1E 0x39 0x11 0x00 0xFFF
+                           0x96 0x39 0xC3 0x40 0x00 0x28 0xFFF
+                           0xC8 0x39 0x29 0x00 0xFFF>;
+
+        status = "disable";
+    };
+};
\ No newline at end of file
diff --git a/arch/arm/boot/dts/anyka_ev500_nandflash0.dtsi b/arch/arm/boot/dts/anyka_ev500_nandflash0.dtsi
new file mode 100755
index 0000000..3d42f9e
--- /dev/null
+++ b/arch/arm/boot/dts/anyka_ev500_nandflash0.dtsi
@@ -0,0 +1,114 @@
+/*
+ * AK37D spi nandflash dts
+ *
+ * Copyright (C) 2018 Anyka(Guangzhou) Microelectronics Technology Co., Ltd.
+ *
+ * Author: Cao_Donghua <cao_donghua@anyka.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+&spif0 {
+     
+	GD5F1GQ4UB: spi-nandflash@0 { 
+		compatible = "gd,GD5F1GQ4UB";
+		nandflash-name = "GD5F1GQ4UB";
+		
+		/* spiflash GD5F1GQ4UB */
+		nandflash-jedec-id = <0xc8d1c8d1>; 
+		nandflash-ext-id = <0>;
+		nandflash-page_size = <2048>;
+		nandflash-page_per_block = <64>;
+		nandflash-block_size = <0x20000>;
+		nandflash-n_blocks = <1024>;
+		nandflash-oob_size = <64>;		  
+		nandflash-oob_up_skiplen = <0>;
+		nandflash-oob_seglen = <12>;
+		nandflash-oob_down_skiplen = <4>;	
+		nandflash-oob_seg_perpage = <4>;
+		nandflash-oob_vail_data_offset = <4>;
+
+		/*
+		* flags = SFLAG_DUAL_READ|SFLAG_QUAD_READ|SFLAG_QUAD_WRITE
+		* = 0x8A0
+		*/
+		nandflash-flags = <0x8A0>;
+
+		/* status reg bit map */
+		nandflash-b_wip = <0>;		
+		nandflash-b_wel = <1>;		
+		nandflash-b_efail = <2>;		
+		nandflash-b_pfail = <3>;		
+		nandflash-b_bp2 = <4>;		
+		nandflash-b_bp3 = <5>;		
+		nandflash-b_bp4 = <6>;		
+		nandflash-b_srp0 = <7>; 	
+		
+		nandflash-b_qe = <8>; 	
+		nandflash-b_srp1 = <9>;		
+		nandflash-b_lb = <10>;		
+
+		nandflash-b_cmp = <14>; 	
+		nandflash-b_sus = <15>; 		
+
+		status = "disable";
+	};
+
+	GD5F2GQ4UB: spi-nandflash@1 { 
+		compatible = "GD,GD5F2GQ4UB";
+		nandflash-name = "GD5F2GQ4UB";
+		
+		/* spiflash GD5F2GQ4UB */
+		nandflash-jedec-id = <0xc8d2c8d2>; 
+		nandflash-ext-id = <0>;
+		nandflash-page_size = <2048>;
+		nandflash-page_per_block = <64>;
+		nandflash-block_size = <0x20000>;
+		nandflash-n_blocks = <2048>;
+		nandflash-oob_size = <64>;		  
+		nandflash-oob_up_skiplen = <0>;
+		nandflash-oob_seglen = <12>;
+		nandflash-oob_down_skiplen = <4>;	
+		nandflash-oob_seg_perpage = <4>;
+		nandflash-oob_vail_data_offset = <4>;
+
+		/*
+		* flags = SFLAG_DUAL_READ|SFLAG_QUAD_READ|SFLAG_QUAD_WRITE
+		* = 0x8A0
+		*/
+		nandflash-flags = <0x8A0>;
+
+		/* status reg bit map */
+		nandflash-b_wip = <0>;		
+		nandflash-b_wel = <1>;		
+		nandflash-b_efail = <2>;		
+		nandflash-b_pfail = <3>;		
+		nandflash-b_bp2 = <4>;		
+		nandflash-b_bp3 = <5>;		
+		nandflash-b_bp4 = <6>;		
+		nandflash-b_srp0 = <7>; 	
+		
+		nandflash-b_qe = <8>; 	
+		nandflash-b_srp1 = <9>;		
+		nandflash-b_lb = <10>;		
+
+		nandflash-b_cmp = <14>; 	
+		nandflash-b_sus = <15>; 		
+
+		status = "disable";
+	}; 
+
+
+};
+
+
+
+
diff --git a/arch/arm/boot/dts/anyka_ev500_nandflash1.dtsi b/arch/arm/boot/dts/anyka_ev500_nandflash1.dtsi
new file mode 100755
index 0000000..88ff215
--- /dev/null
+++ b/arch/arm/boot/dts/anyka_ev500_nandflash1.dtsi
@@ -0,0 +1,114 @@
+/*
+ * AK37D spi nandflash dts
+ *
+ * Copyright (C) 2018 Anyka(Guangzhou) Microelectronics Technology Co., Ltd.
+ *
+ * Author: Cao_Donghua <cao_donghua@anyka.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+&spif1 {
+     
+	GD5F1GQ4UB: spi-nandflash@0 { 
+		compatible = "gd,GD5F1GQ4UB";
+		nandflash-name = "GD5F1GQ4UB";
+		
+		/* spiflash GD5F1GQ4UB */
+		nandflash-jedec-id = <0xc8d1c8d1>; 
+		nandflash-ext-id = <0>;
+		nandflash-page_size = <2048>;
+		nandflash-page_per_block = <64>;
+		nandflash-block_size = <0x20000>;
+		nandflash-n_blocks = <1024>;
+		nandflash-oob_size = <64>;		  
+		nandflash-oob_up_skiplen = <0>;
+		nandflash-oob_seglen = <12>;
+		nandflash-oob_down_skiplen = <4>;	
+		nandflash-oob_seg_perpage = <4>;
+		nandflash-oob_vail_data_offset = <4>;
+
+		/*
+		* flags = SFLAG_DUAL_READ|SFLAG_QUAD_READ|SFLAG_QUAD_WRITE
+		* = 0x8A0
+		*/
+		nandflash-flags = <0x8A0>;
+
+		/* status reg bit map */
+		nandflash-b_wip = <0>;		
+		nandflash-b_wel = <1>;		
+		nandflash-b_efail = <2>;		
+		nandflash-b_pfail = <3>;		
+		nandflash-b_bp2 = <4>;		
+		nandflash-b_bp3 = <5>;		
+		nandflash-b_bp4 = <6>;		
+		nandflash-b_srp0 = <7>; 	
+		
+		nandflash-b_qe = <8>; 	
+		nandflash-b_srp1 = <9>;		
+		nandflash-b_lb = <10>;		
+
+		nandflash-b_cmp = <14>; 	
+		nandflash-b_sus = <15>; 		
+
+		status = "disable";
+	}; 
+
+	GD5F2GQ4UB: spi-nandflash@1 { 
+		compatible = "GD,GD5F2GQ4UB";
+		nandflash-name = "GD5F2GQ4UB";
+		
+		/* spiflash GD5F2GQ4UB */
+		nandflash-jedec-id = <0xc8d2c8d2>; 
+		nandflash-ext-id = <0>;
+		nandflash-page_size = <2048>;
+		nandflash-page_per_block = <64>;
+		nandflash-block_size = <0x20000>;
+		nandflash-n_blocks = <2048>;
+		nandflash-oob_size = <64>;		  
+		nandflash-oob_up_skiplen = <0>;
+		nandflash-oob_seglen = <12>;
+		nandflash-oob_down_skiplen = <4>;	
+		nandflash-oob_seg_perpage = <4>;
+		nandflash-oob_vail_data_offset = <4>;
+
+		/*
+		* flags = SFLAG_DUAL_READ|SFLAG_QUAD_READ|SFLAG_QUAD_WRITE
+		* = 0x8A0
+		*/
+		nandflash-flags = <0x8A0>;
+
+		/* status reg bit map */
+		nandflash-b_wip = <0>;		
+		nandflash-b_wel = <1>;		
+		nandflash-b_efail = <2>;		
+		nandflash-b_pfail = <3>;		
+		nandflash-b_bp2 = <4>;		
+		nandflash-b_bp3 = <5>;		
+		nandflash-b_bp4 = <6>;		
+		nandflash-b_srp0 = <7>; 	
+		
+		nandflash-b_qe = <8>;	
+		nandflash-b_srp1 = <9>; 	
+		nandflash-b_lb = <10>;		
+
+		nandflash-b_cmp = <14>; 	
+		nandflash-b_sus = <15>; 		
+
+		status = "disable";
+	}; 
+
+
+};
+
+
+
+
diff --git a/arch/arm/boot/dts/anyka_ev500_norflash.dtsi b/arch/arm/boot/dts/anyka_ev500_norflash.dtsi
new file mode 100755
index 0000000..7046fa3
--- /dev/null
+++ b/arch/arm/boot/dts/anyka_ev500_norflash.dtsi
@@ -0,0 +1,2479 @@
+/*
+ * AK37D spi norflash dts
+ *
+ * Copyright (C) 2018 Anyka(Guangzhou) Microelectronics Technology Co., Ltd.
+ *
+ * Author: Cao_Donghua <cao_donghua@anyka.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+&spif0 {
+    
+    at25fs010: spi-norflash@0 { 
+        compatible = "atmel,at25fs010";
+        norflash-name = "at25fs010";
+		reg = <0>;
+		
+		/* spiflash at25fs010 */
+        norflash-jedec-id = <0x1f6601>; 
+        norflash-ext-id = <0>;
+        norflash-sector-size = <0x8000>;
+        norflash-n-sectors = <4>; 
+
+		/**
+		*  flags:chip character bits:
+		*  bit 0: under_protect flag; bit 1: fast read flag; bit 2: AAI flag; bit 3: support status2; bit 4: support dual io read; bit 5: support dual read
+		*  bit 6: support quad io read; bit 7: support quad read; bit 8: support dual io write; bit 9: support dual write; bit 10: support quad io write
+		*  bit 11: support quad write; bit 12: support 4k erase sector; bit 13: support status3; bit 14: support no QE ; bit 15:write status mode 
+		*/
+
+		/* 
+		*  flags = SFLAG_SECT_4K
+		*  wr_mode:
+		*  0:means one write status cmd can wirte all status regs; 1:means one write status cmd can only wirte one status reg
+		*  norflash-wr_flags: write wr startus regs count 
+		*/
+        norflash-flags = <0x1000>;
+		rd_status_cmd = <0x05>;
+		wr_status_cmd = <0x01>;
+		wr_mode = <0>;
+		norflash-wr_flags = <1>;
+
+		/* status reg bit map */
+        norflash-b-wip = <0>;
+        norflash-b-wel = <1>;
+        norflash-b-bp0 = <2>;
+        norflash-b-bp1 = <3>;
+        norflash-b-bp3 = <5>; 
+        norflash-b-bp4 = <6>;
+
+		/* as follow is wpen */
+		norflash-b-cmp = <7>; 
+			
+        status = "disable";
+    };
+
+    at25fs040: spi-norflash@1 { 
+        compatible = "atmel,at25fs040";
+        norflash-name = "at25fs040";
+		reg = <1>;
+		
+		/* spiflash at25fs040 */
+        norflash-jedec-id = <0x1f6604>; 
+        norflash-ext-id = <0>;
+        norflash-sector-size = <0x10000>;
+        norflash-n-sectors = <8>; 
+
+		/**
+		*  flags:chip character bits:
+		*  bit 0: under_protect flag; bit 1: fast read flag; bit 2: AAI flag; bit 3: support status2; bit 4: support dual io read; bit 5: support dual read
+		*  bit 6: support quad io read; bit 7: support quad read; bit 8: support dual io write; bit 9: support dual write; bit 10: support quad io write
+		*  bit 11: support quad write; bit 12: support 4k erase sector; bit 13: support status3; bit 14: support no QE ; bit 15:write status mode 
+		*/
+
+		/* 
+		*  flags = SFLAG_SECT_4K
+		*  wr_mode:
+		*	0:means one write status cmd can wirte all status regs; 1:means one write status cmd can only wirte one status reg
+		*  norflash-wr_flags: write wr startus regs count 
+		*/
+        norflash-flags = <0x1000>;
+		rd_status_cmd = <0x05>;
+		wr_status_cmd = <0x01>;
+		wr_mode = <0>;
+		norflash-wr_flags = <1>;
+
+		/* status reg bit map */
+        norflash-b-wip = <0>;
+        norflash-b-wel = <1>;
+        norflash-b-bp0 = <2>;
+        norflash-b-bp1 = <3>;
+        norflash-b-bp2 = <4>;
+        norflash-b-bp3 = <5>; 
+        norflash-b-bp4 = <6>; 
+
+		/* as follow is wpen */
+		norflash-b-cmp = <7>; 
+
+        status = "disable";
+    };
+
+    at25df041a: spi-norflash@2 { 
+        compatible = "atmel,at25df041a";
+        norflash-name = "at25df041a";
+		reg = <2>;
+		
+		/* spiflash at25df041a */
+        norflash-jedec-id = <0x1f4401>; 
+        norflash-ext-id = <0>;
+        norflash-sector-size = <0x10000>;
+        norflash-n-sectors = <8>; 
+
+		/**
+		*  flags:chip character bits:
+		*  bit 0: under_protect flag; bit 1: fast read flag; bit 2: AAI flag; bit 3: support status2; bit 4: support dual io read; bit 5: support dual read
+		*  bit 6: support quad io read; bit 7: support quad read; bit 8: support dual io write; bit 9: support dual write; bit 10: support quad io write
+		*  bit 11: support quad write; bit 12: support 4k erase sector; bit 13: support status3; bit 14: support no QE ; bit 15:write status mode 
+		*/
+
+		/* 
+		*  flags = SFLAG_SECT_4K
+		*  wr_mode:
+		*	0:means one write status cmd can wirte all status regs; 1:means one write status cmd can only wirte one status reg
+		*  norflash-wr_flags: write wr startus regs count 
+		*/
+        norflash-flags = <0x1000>;
+		rd_status_cmd = <0x05>;
+		wr_status_cmd = <0x01>;
+		wr_mode = <0>;
+		norflash-wr_flags = <1>;
+
+		/* status reg bit map */
+        norflash-b-wip = <0>;
+        norflash-b-wel = <1>;
+
+        status = "disable";
+    };
+
+    at25df641: spi-norflash@3 { 
+        compatible = "atmel,at25df641";
+        norflash-name = "at25df641";
+		reg = <3>;
+		
+		/* spiflash at25df641 */
+        norflash-jedec-id = <0x1f4800>; 
+        norflash-ext-id = <0>;
+        norflash-sector-size = <0x10000>;
+        norflash-n-sectors = <128>; 
+
+		/**
+		*  flags:chip character bits:
+		*  bit 0: under_protect flag; bit 1: fast read flag; bit 2: AAI flag; bit 3: support status2; bit 4: support dual io read; bit 5: support dual read
+		*  bit 6: support quad io read; bit 7: support quad read; bit 8: support dual io write; bit 9: support dual write; bit 10: support quad io write
+		*  bit 11: support quad write; bit 12: support 4k erase sector; bit 13: support status3; bit 14: support no QE ; bit 15:write status mode 
+		*/
+
+		/* 
+		*  flags = SFLAG_SECT_4K
+		*  wr_mode:
+		*	0:means one write status cmd can wirte all status regs; 1:means one write status cmd can only wirte one status reg
+		*  norflash-wr_flags: write wr startus regs count 
+		*/
+        norflash-flags = <0x1000>;
+		rd_status_cmd = <0x05>;
+		wr_status_cmd = <0x01>, <0x31>;
+		wr_mode = <1>;
+		norflash-wr_flags = <2>;
+
+		/* status reg bit map */
+        norflash-b-wip = <0>;
+        norflash-b-wel = <1>;
+
+        status = "disable";
+    };
+
+    at26f004: spi-norflash@4 { 
+        compatible = "atmel,at26f004";
+        norflash-name = "at26f004";
+		reg = <4>;
+		
+		/* spiflash at26f004 */
+        norflash-jedec-id = <0x1f0400>; 
+        norflash-ext-id = <0>;
+        norflash-sector-size = <0x10000>;
+        norflash-n-sectors = <8>; 
+
+		/**
+		*  flags:chip character bits:
+		*  bit 0: under_protect flag; bit 1: fast read flag; bit 2: AAI flag; bit 3: support status2; bit 4: support dual io read; bit 5: support dual read
+		*  bit 6: support quad io read; bit 7: support quad read; bit 8: support dual io write; bit 9: support dual write; bit 10: support quad io write
+		*  bit 11: support quad write; bit 12: support 4k erase sector; bit 13: support status3; bit 14: support no QE ; bit 15:write status mode 
+		*/
+
+		/* 
+		*  flags = SFLAG_SECT_4K
+		*  wr_mode:
+		*	0:means one write status cmd can wirte all status regs; 1:means one write status cmd can only wirte one status reg
+		*  norflash-wr_flags: write wr startus regs count 
+		*/
+        norflash-flags = <0x1000>;
+		rd_status_cmd = <0x05>;
+		wr_status_cmd = <0x01>;
+		wr_mode = <0>;
+		norflash-wr_flags = <1>;
+
+		/* status reg bit map */
+        norflash-b-wip = <0>;
+        norflash-b-wel = <1>;
+
+        status = "disable";
+    };
+
+    at26df081a: spi-norflash@5 { 
+        compatible = "atmel,at26df081a";
+        norflash-name = "at26df081a";
+		reg = <5>;
+		
+		/* spiflash at26df081a */
+        norflash-jedec-id = <0x1f4501>; 
+        norflash-ext-id = <0>;
+        norflash-sector-size = <0x10000>;
+        norflash-n-sectors = <16>; 
+
+		/**
+		*  flags:chip character bits:
+		*  bit 0: under_protect flag; bit 1: fast read flag; bit 2: AAI flag; bit 3: support status2; bit 4: support dual io read; bit 5: support dual read
+		*  bit 6: support quad io read; bit 7: support quad read; bit 8: support dual io write; bit 9: support dual write; bit 10: support quad io write
+		*  bit 11: support quad write; bit 12: support 4k erase sector; bit 13: support status3; bit 14: support no QE ; bit 15:write status mode 
+		*/
+
+		/* 
+		*  flags = SFLAG_SECT_4K
+		*  wr_mode:
+		*	0:means one write status cmd can wirte all status regs; 1:means one write status cmd can only wirte one status reg
+		*  norflash-wr_flags: write wr startus regs count 
+		*/
+        norflash-flags = <0x1000>;
+		rd_status_cmd = <0x05>;
+		wr_status_cmd = <0x01>, <0x31>;
+		wr_mode = <1>;
+		norflash-wr_flags = <2>;
+
+		/* status reg bit map */
+        norflash-b-wip = <0>;
+        norflash-b-wel = <1>;
+
+        status = "disable";
+    };
+
+    at26df161a: spi-norflash@6 { 
+        compatible = "atmel,at26df161a";
+        norflash-name = "at26df161a";
+		reg = <6>;
+		
+		/* spiflash atmel */
+        norflash-jedec-id = <0x1f4601>; 
+        norflash-ext-id = <0>;
+        norflash-sector-size = <0x10000>;
+        norflash-n-sectors = <32>; 
+
+		/**
+		*  flags:chip character bits:
+		*  bit 0: under_protect flag; bit 1: fast read flag; bit 2: AAI flag; bit 3: support status2; bit 4: support dual io read; bit 5: support dual read
+		*  bit 6: support quad io read; bit 7: support quad read; bit 8: support dual io write; bit 9: support dual write; bit 10: support quad io write
+		*  bit 11: support quad write; bit 12: support 4k erase sector; bit 13: support status3; bit 14: support no QE ; bit 15:write status mode 
+		*/
+
+		/* 
+		*  flags = SFLAG_SECT_4K
+		*  wr_mode:
+		*	0:means one write status cmd can wirte all status regs; 1:means one write status cmd can only wirte one status reg
+		*  norflash-wr_flags: write wr startus regs count 
+		*  no datasheet
+		*/
+        norflash-flags = <0x1000>;
+		rd_status_cmd = <0x05>;
+		wr_status_cmd = <0x01>;
+		wr_mode = <0>;
+		norflash-wr_flags = <1>;
+
+		/* status reg bit map */
+        norflash-b-wip = <0>;
+        norflash-b-wel = <1>;
+
+        status = "disable";
+    };
+
+    at26df321: spi-norflash@7 { 
+        compatible = "atmel,at26df321";
+        norflash-name = "at26df321";
+		reg = <7>;
+		
+		/* spiflash at26df321 */
+        norflash-jedec-id = <0x1f4701>; 
+        norflash-ext-id = <0>;
+        norflash-sector-size = <0x10000>;
+        norflash-n-sectors = <64>; 
+
+		/**
+		*  flags:chip character bits:
+		*  bit 0: under_protect flag; bit 1: fast read flag; bit 2: AAI flag; bit 3: support status2; bit 4: support dual io read; bit 5: support dual read
+		*  bit 6: support quad io read; bit 7: support quad read; bit 8: support dual io write; bit 9: support dual write; bit 10: support quad io write
+		*  bit 11: support quad write; bit 12: support 4k erase sector; bit 13: support status3; bit 14: support no QE ; bit 15:write status mode 
+		*/
+
+		/* 
+		*  flags = SFLAG_SECT_4K
+		*  wr_mode:
+		*	0:means one write status cmd can wirte all status regs; 1:means one write status cmd can only wirte one status reg
+		*  norflash-wr_flags: write wr startus regs count 
+		*/
+        norflash-flags = <0x1000>;
+		rd_status_cmd = <0x05>;
+		wr_status_cmd = <0x01>;
+		wr_mode = <0>;
+		norflash-wr_flags = <1>;
+
+		/* status reg bit map */
+        norflash-b-wip = <0>;
+        norflash-b-wel = <1>;
+
+        status = "disable";
+    };
+
+    mx25l3205d: spi-norflash@8 {  
+        compatible = "macronix,mx25l3205d";
+        norflash-name = "mx25l3205d";
+		reg = <8>;
+		
+		/* spiflash mx25l3205d */
+        norflash-jedec-id = <0xc22016>; 
+        norflash-ext-id = <0>;
+        norflash-sector-size = <0x10000>;
+        norflash-n-sectors = <64>; 
+
+		/**
+		*  flags:chip character bits:
+		*  bit 0: under_protect flag; bit 1: fast read flag; bit 2: AAI flag; bit 3: support status2; bit 4: support dual io read; bit 5: support dual read
+		*  bit 6: support quad io read; bit 7: support quad read; bit 8: support dual io write; bit 9: support dual write; bit 10: support quad io write
+		*  bit 11: support quad write; bit 12: support 4k erase sector; bit 13: support status3; bit 14: support no QE ; bit 15:write status mode 
+		*/
+
+		/* 
+		*  flags = SFLAG_SECT_4K|SFLAG_DUAL_READ
+		*  wr_mode:
+		*	0:means one write status cmd can wirte all status regs; 1:means one write status cmd can only wirte one status reg
+		*  norflash-wr_flags: write wr startus regs count 
+		*/
+        norflash-flags = <0x1020>;
+		rd_status_cmd = <0x05>;
+		wr_status_cmd = <0x01>;
+		wr_mode = <0>;
+		norflash-wr_flags = <1>;
+
+		/* status reg bit map */
+        norflash-b-wip = <0>;
+        norflash-b-wel = <1>;
+        norflash-b-bp0 = <2>;
+        norflash-b-bp1 = <3>;
+        norflash-b-bp2 = <4>;
+        norflash-b-bp3 = <5>; 
+		norflash-b-cmp = <6>; 
+
+        status = "disable";
+    };
+
+    mx25l6405d: spi-norflash@9 { 
+        compatible = "macronix,mx25l6405d";
+        norflash-name = "mx25l6405d";
+		reg = <9>;
+		
+		/* spiflash mx25l6405d */
+        norflash-jedec-id = <0xc22017>; 
+        norflash-ext-id = <0>;
+        norflash-sector-size = <0x10000>;
+        norflash-n-sectors = <128>; 
+
+		/**
+		*  flags:chip character bits:
+		*  bit 0: under_protect flag; bit 1: fast read flag; bit 2: AAI flag; bit 3: support status2; bit 4: support dual io read; bit 5: support dual read
+		*  bit 6: support quad io read; bit 7: support quad read; bit 8: support dual io write; bit 9: support dual write; bit 10: support quad io write
+		*  bit 11: support quad write; bit 12: support 4k erase sector; bit 13: support status3; bit 14: support no QE ; bit 15:write status mode 
+		*/
+
+		/* 
+		*  flags = SFLAG_SECT_4K|SFLAG_DUAL_READ
+		*  wr_mode:
+		*	0:means one write status cmd can wirte all status regs; 1:means one write status cmd can only wirte one status reg
+		*  norflash-wr_flags: write wr startus regs count 
+		*/
+        norflash-flags = <0x1020>;
+		rd_status_cmd = <0x05>;
+		wr_status_cmd = <0x01>;
+		wr_mode = <0>;
+		norflash-wr_flags = <1>;
+
+		/* status reg bit map */
+        norflash-b-wip = <0>;
+        norflash-b-wel = <1>;
+        norflash-b-bp0 = <2>;
+        norflash-b-bp1 = <3>;
+        norflash-b-bp2 = <4>;
+        norflash-b-bp3 = <5>; 
+		norflash-b-cmp = <6>; 
+
+        status = "disable";
+    };
+
+    mx25l12805d: spi-norflash@10 { 
+        compatible = "macronix,mx25l12805d";
+        norflash-name = "mx25l12805d";
+		reg = <10>;
+		
+		/* spiflash mx25l12805d */
+        norflash-jedec-id = <0xc22018>; 
+        norflash-ext-id = <0>;
+        norflash-sector-size = <0x10000>;
+        norflash-n-sectors = <256>; 
+
+		/**
+		*  flags:chip character bits:
+		*  bit 0: under_protect flag; bit 1: fast read flag; bit 2: AAI flag; bit 3: support status2; bit 4: support dual io read; bit 5: support dual read
+		*  bit 6: support quad io read; bit 7: support quad read; bit 8: support dual io write; bit 9: support dual write; bit 10: support quad io write
+		*  bit 11: support quad write; bit 12: support 4k erase sector; bit 13: support status3; bit 14: support no QE ; bit 15:write status mode 
+		*/
+
+		/* 
+		*  flags = SFLAG_SECT_4K | SFLAG_DUAL_IO_READ | SFLAG_QUAD_IO_READ | SFLAG_QUAD_IO_WRITE*  wr_mode:
+		*	0:means one write status cmd can wirte all status regs; 1:means one write status cmd can only wirte one status reg
+		*  norflash-wr_flags: write wr startus regs count 
+		*/
+        norflash-flags = <0x1450>;
+		rd_status_cmd = <0x05>;
+		wr_status_cmd = <0x01>;
+		wr_mode = <0>;
+		norflash-wr_flags = <1>;
+
+		/* status reg bit map */
+        norflash-b-wip = <0>;
+        norflash-b-wel = <1>;
+        norflash-b-bp0 = <2>;
+        norflash-b-bp1 = <3>;
+        norflash-b-bp2 = <4>;
+        norflash-b-bp3 = <5>; 
+
+        status = "disable";
+    };
+
+    mx25l12855e: spi-norflash@11 { 
+        compatible = "macronix,mx25l12855e";
+        norflash-name = "mx25l12855e";
+		reg = <11>;
+		
+		/* spiflash mx25l12855e */
+        norflash-jedec-id = <0xc22018>; 
+        norflash-ext-id = <0>;
+        norflash-sector-size = <0x10000>;
+        norflash-n-sectors = <256>; 
+
+		/**
+		*  flags:chip character bits:
+		*  bit 0: under_protect flag; bit 1: fast read flag; bit 2: AAI flag; bit 3: support status2; bit 4: support dual io read; bit 5: support dual read
+		*  bit 6: support quad io read; bit 7: support quad read; bit 8: support dual io write; bit 9: support dual write; bit 10: support quad io write
+		*  bit 11: support quad write; bit 12: support 4k erase sector; bit 13: support status3; bit 14: support no QE ; bit 15:write status mode 
+		*/
+
+		/* 
+		*  flags = SFLAG_SECT_4K | SFLAG_DUAL_READ
+		*  wr_mode:
+		*	0:means one write status cmd can wirte all status regs; 1:means one write status cmd can only wirte one status reg
+		*  norflash-wr_flags: write wr startus regs count 
+		*/
+        norflash-flags = <0x1020>;
+		rd_status_cmd = <0x05>;
+		wr_status_cmd = <0x01>;
+		wr_mode = <0>;
+		norflash-wr_flags = <1>;
+
+		/* status reg bit map */
+        norflash-b-wip = <0>;
+        norflash-b-wel = <1>;
+        norflash-b-bp0 = <2>;
+        norflash-b-bp1 = <3>;
+        norflash-b-bp2 = <4>;
+        norflash-b-bp3 = <5>; 
+        norflash-b-qe = <6>; 
+
+        status = "disable";
+    };
+
+    s25fl129p0: spi-norflash@12 { 
+        compatible = "spansion,s25fl129p0";
+        norflash-name = "s25fl129p0";
+		reg = <12>;
+		
+		/* spiflash s25fl129p0 */
+        norflash-jedec-id = <0x012018>; 
+        norflash-ext-id = <0x4d00>;
+        norflash-sector-size = <0x40000>;
+        norflash-n-sectors = <64>; 
+
+		/**
+		*  flags:chip character bits:
+		*  bit 0: under_protect flag; bit 1: fast read flag; bit 2: AAI flag; bit 3: support status2; bit 4: support dual io read; bit 5: support dual read
+		*  bit 6: support quad io read; bit 7: support quad read; bit 8: support dual io write; bit 9: support dual write; bit 10: support quad io write
+		*  bit 11: support quad write; bit 12: support 4k erase sector; bit 13: support status3; bit 14: support no QE ; bit 15:write status mode 
+		*/
+
+		/* 
+		*  flags = 0
+		*  wr_mode:
+		*	0:means one write status cmd can wirte all status regs; 1:means one write status cmd can only wirte one status reg
+		*  norflash-wr_flags: write wr startus regs count 
+		*/
+        norflash-flags = <0>;
+		rd_status_cmd = <0x05>;
+		wr_status_cmd = <0x01>;
+		wr_mode = <0>;
+		norflash-wr_flags = <1>;
+
+		/* status reg bit map */
+        norflash-b-wip = <0>;
+        norflash-b-wel = <1>;
+        norflash-b-bp0 = <2>;
+        norflash-b-bp1 = <3>;
+        norflash-b-bp2 = <4>;
+
+        status = "disable";
+    };
+
+    s25fl129p1: spi-norflash@13 { 
+        compatible = "spansion,s25fl129p1";
+        norflash-name = "s25fl129p1";
+		reg = <13>;
+		
+		/* spiflash s25fl129p1 */
+        norflash-jedec-id = <0x012018>; 
+        norflash-ext-id = <0x4d01>;
+        norflash-sector-size = <0x10000>;
+        norflash-n-sectors = <256>; 
+
+		/**
+		*  flags:chip character bits:
+		*  bit 0: under_protect flag; bit 1: fast read flag; bit 2: AAI flag; bit 3: support status2; bit 4: support dual io read; bit 5: support dual read
+		*  bit 6: support quad io read; bit 7: support quad read; bit 8: support dual io write; bit 9: support dual write; bit 10: support quad io write
+		*  bit 11: support quad write; bit 12: support 4k erase sector; bit 13: support status3; bit 14: support no QE ; bit 15:write status mode 
+		*/
+
+		/* 
+		*  flags = 0
+		*  wr_mode:
+		*	0:means one write status cmd can wirte all status regs; 1:means one write status cmd can only wirte one status reg
+		*  norflash-wr_flags: write wr startus regs count 
+		*/
+        norflash-flags = <0>;
+		rd_status_cmd = <0x05>;
+		wr_status_cmd = <0x01>;
+		wr_mode = <0>;
+		norflash-wr_flags = <1>;
+
+		/* status reg bit map */
+        norflash-b-wip = <0>;
+        norflash-b-wel = <1>;
+        norflash-b-bp0 = <2>;
+        norflash-b-bp1 = <3>;
+        norflash-b-bp2 = <4>;
+
+        status = "disable";
+    };
+
+    sst25vf040b: spi-norflash@14 { 
+        compatible = "sst,sst25vf040b";
+        norflash-name = "sst25vf040b";
+		reg = <14>;
+		
+		/* spiflash sst25vf040b */
+        norflash-jedec-id = <0xbf258d>; 
+        norflash-ext-id = <0>;
+        norflash-sector-size = <0x10000>;
+        norflash-n-sectors = <8>; 
+
+		/**
+		*  flags:chip character bits:
+		*  bit 0: under_protect flag; bit 1: fast read flag; bit 2: AAI flag; bit 3: support status2; bit 4: support dual io read; bit 5: support dual read
+		*  bit 6: support quad io read; bit 7: support quad read; bit 8: support dual io write; bit 9: support dual write; bit 10: support quad io write
+		*  bit 11: support quad write; bit 12: support 4k erase sector; bit 13: support status3; bit 14: support no QE ; bit 15:write status mode 
+		*/
+
+		/* 
+		*  flags = SFLAG_SECT_4K
+		*  wr_mode:
+		*	0:means one write status cmd can wirte all status regs; 1:means one write status cmd can only wirte one status reg
+		*  norflash-wr_flags: write wr startus regs count 
+		*/
+        norflash-flags = <0x1000>;
+		rd_status_cmd = <0x05>;
+		wr_status_cmd = <0x01>;
+		wr_mode = <0>;
+		norflash-wr_flags = <1>;
+
+		/* status reg bit map */
+        norflash-b-wip = <0>;
+        norflash-b-wel = <1>;
+        norflash-b-bp0 = <2>;
+        norflash-b-bp1 = <3>;
+        norflash-b-bp2 = <4>;
+        norflash-b-bp3 = <5>; 
+
+        status = "disable";
+    };
+
+    sst25vf080b: spi-norflash@15 { 
+        compatible = "sst,sst25vf080b";
+        norflash-name = "sst25vf080b";
+		reg = <15>;
+		
+		/* spiflash sst25vf080b */
+        norflash-jedec-id = <0xbf258e>; 
+        norflash-ext-id = <0>;
+        norflash-sector-size = <0x10000>;
+        norflash-n-sectors = <16>; 
+
+		/**
+		*  flags:chip character bits:
+		*  bit 0: under_protect flag; bit 1: fast read flag; bit 2: AAI flag; bit 3: support status2; bit 4: support dual io read; bit 5: support dual read
+		*  bit 6: support quad io read; bit 7: support quad read; bit 8: support dual io write; bit 9: support dual write; bit 10: support quad io write
+		*  bit 11: support quad write; bit 12: support 4k erase sector; bit 13: support status3; bit 14: support no QE ; bit 15:write status mode 
+		*/
+
+		/* 
+		*  flags = SFLAG_SECT_4K
+		*  wr_mode:
+		*	0:means one write status cmd can wirte all status regs; 1:means one write status cmd can only wirte one status reg
+		*  norflash-wr_flags: write wr startus regs count 
+		*/
+        norflash-flags = <0x1000>;
+		rd_status_cmd = <0x05>;
+		wr_status_cmd = <0x01>;
+		wr_mode = <0>;
+		norflash-wr_flags = <1>;
+
+		/* status reg bit map */
+        norflash-b-wip = <0>;
+        norflash-b-wel = <1>;
+        norflash-b-bp0 = <2>;
+        norflash-b-bp1 = <3>;
+        norflash-b-bp2 = <4>;
+        norflash-b-bp3 = <5>; 
+
+        status = "disable";
+    };
+
+    sst25vf016b: spi-norflash@16 { 
+        compatible = "sst,sst25vf016b";
+        norflash-name = "sst25vf016b";
+		reg = <16>;
+		
+		/* spiflash sst25vf016b */
+        norflash-jedec-id = <0xbf2541>; 
+        norflash-ext-id = <0>;
+        norflash-sector-size = <0x10000>;
+        norflash-n-sectors = <32>; 
+
+		/**
+		*  flags:chip character bits:
+		*  bit 0: under_protect flag; bit 1: fast read flag; bit 2: AAI flag; bit 3: support status2; bit 4: support dual io read; bit 5: support dual read
+		*  bit 6: support quad io read; bit 7: support quad read; bit 8: support dual io write; bit 9: support dual write; bit 10: support quad io write
+		*  bit 11: support quad write; bit 12: support 4k erase sector; bit 13: support status3; bit 14: support no QE ; bit 15:write status mode 
+		*/
+
+		/* 
+		*  flags = SFLAG_SECT_4K|SFLAG_COM_STATUS2|
+		*  SFLAG_DUAL_READ|SFLAG_QUAD_READ|SFLAG_DUAL_IO_READ|SFLAG_QUAD_IO_READ|SFLAG_QUAD_WRITE
+		*  wr_mode:
+		*	0:means one write status cmd can wirte all status regs; 1:means one write status cmd can only wirte one status reg
+		*  norflash-wr_flags: write wr startus regs count 
+		*/
+        norflash-flags = <0x1000>;
+		rd_status_cmd = <0x05>;
+		wr_status_cmd = <0x01>;
+		wr_mode = <0>;
+		norflash-wr_flags = <1>;
+
+		/* status reg bit map */
+        norflash-b-wip = <0>;
+        norflash-b-wel = <1>;
+        norflash-b-bp0 = <2>;
+        norflash-b-bp1 = <3>;
+        norflash-b-bp2 = <4>;
+        norflash-b-bp3 = <5>; 
+
+        status = "disable";
+    };
+
+    sst25vf032b: spi-norflash@17 { 
+        compatible = "sst,sst25vf032b";
+        norflash-name = "sst25vf032b";
+		reg = <17>;
+		
+		/* spiflash sst25vf032b */
+        norflash-jedec-id = <0xbf254a>; 
+        norflash-ext-id = <0>;
+        norflash-sector-size = <0x10000>;
+        norflash-n-sectors = <64>; 
+
+		/**
+		*  flags:chip character bits:
+		*  bit 0: under_protect flag; bit 1: fast read flag; bit 2: AAI flag; bit 3: support status2; bit 4: support dual io read; bit 5: support dual read
+		*  bit 6: support quad io read; bit 7: support quad read; bit 8: support dual io write; bit 9: support dual write; bit 10: support quad io write
+		*  bit 11: support quad write; bit 12: support 4k erase sector; bit 13: support status3; bit 14: support no QE ; bit 15:write status mode 
+		*/
+
+		/* 
+		*  flags = SFLAG_SECT_4K
+		*  wr_mode:
+		*	0:means one write status cmd can wirte all status regs; 1:means one write status cmd can only wirte one status reg
+		*  norflash-wr_flags: write wr startus regs count 
+		*/
+        norflash-flags = <0x1000>;
+		rd_status_cmd = <0x05>;
+		wr_status_cmd = <0x01>;
+		wr_mode = <0>;
+		norflash-wr_flags = <1>;
+
+		/* status reg bit map */
+        norflash-b-wip = <0>;
+        norflash-b-wel = <1>;
+        norflash-b-bp0 = <2>;
+        norflash-b-bp1 = <3>;
+        norflash-b-bp2 = <4>;
+        norflash-b-bp3 = <5>; 
+
+        status = "disable";
+    };
+
+    sst25wf512: spi-norflash@18 { 
+        compatible = "sst,sst25wf512";
+        norflash-name = "sst25wf512";
+		reg = <18>;
+		
+		/* spiflash sst25wf512 */
+        norflash-jedec-id = <0xbf2501>; 
+        norflash-ext-id = <0>;
+        norflash-sector-size = <0x10000>;
+        norflash-n-sectors = <1>; 
+
+		/**
+		*  flags:chip character bits:
+		*  bit 0: under_protect flag; bit 1: fast read flag; bit 2: AAI flag; bit 3: support status2; bit 4: support dual io read; bit 5: support dual read
+		*  bit 6: support quad io read; bit 7: support quad read; bit 8: support dual io write; bit 9: support dual write; bit 10: support quad io write
+		*  bit 11: support quad write; bit 12: support 4k erase sector; bit 13: support status3; bit 14: support no QE ; bit 15:write status mode 
+		*/
+
+		/* 
+		*  flags = SFLAG_SECT_4K
+		*  wr_mode:
+		*	0:means one write status cmd can wirte all status regs; 1:means one write status cmd can only wirte one status reg
+		*  norflash-wr_flags: write wr startus regs count 
+		*/
+        norflash-flags = <0x1000>;
+		rd_status_cmd = <0x05>;
+		wr_status_cmd = <0x01>;
+		wr_mode = <0>;
+		norflash-wr_flags = <1>;
+
+		/* status reg bit map */
+        norflash-b-wip = <0>;
+        norflash-b-wel = <1>;
+        norflash-b-bp0 = <2>;
+        norflash-b-bp1 = <3>;
+		norflash-b-bp2 = <4>;
+
+        status = "disable";
+    };
+
+    sst25wf010: spi-norflash@19 { 
+        compatible = "sst,sst25wf010";
+        norflash-name = "sst25wf010";
+		reg = <19>;
+		
+		/* spiflash sst25wf010 */
+        norflash-jedec-id = <0xbf2502>; 
+        norflash-ext-id = <0>;
+        norflash-sector-size = <0x10000>;
+        norflash-n-sectors = <2>; 
+
+		/**
+		*  flags:chip character bits:
+		*  bit 0: under_protect flag; bit 1: fast read flag; bit 2: AAI flag; bit 3: support status2; bit 4: support dual io read; bit 5: support dual read
+		*  bit 6: support quad io read; bit 7: support quad read; bit 8: support dual io write; bit 9: support dual write; bit 10: support quad io write
+		*  bit 11: support quad write; bit 12: support 4k erase sector; bit 13: support status3; bit 14: support no QE ; bit 15:write status mode 
+		*/
+
+		/* 
+		*  flags = SFLAG_SECT_4K|SFLAG_COM_STATUS2|
+		*  SFLAG_DUAL_READ|SFLAG_QUAD_READ|SFLAG_DUAL_IO_READ|SFLAG_QUAD_IO_READ|SFLAG_QUAD_WRITE
+		*  wr_mode:
+		*	0:means one write status cmd can wirte all status regs; 1:means one write status cmd can only wirte one status reg
+		*  norflash-wr_flags: write wr startus regs count 
+		*/
+        norflash-flags = <0x1000>;
+		rd_status_cmd = <0x05>;
+		wr_status_cmd = <0x01>;
+		wr_mode = <0>;
+		norflash-wr_flags = <1>;
+
+		/* status reg bit map */
+        norflash-b-wip = <0>;
+        norflash-b-wel = <1>;
+        norflash-b-bp0 = <2>;
+        norflash-b-bp1 = <3>;
+        norflash-b-bp2 = <4>;
+
+        status = "disable";
+    };
+
+    sst25wf020: spi-norflash@20 { 
+        compatible = "sst,sst25wf020";
+        norflash-name = "sst25wf020";
+		reg = <20>;
+		
+		/* spiflash sst25wf020 */
+        norflash-jedec-id = <0xbf2503>; 
+        norflash-ext-id = <0>;
+        norflash-sector-size = <0x10000>;
+        norflash-n-sectors = <4>; 
+
+		/**
+		*  flags:chip character bits:
+		*  bit 0: under_protect flag; bit 1: fast read flag; bit 2: AAI flag; bit 3: support status2; bit 4: support dual io read; bit 5: support dual read
+		*  bit 6: support quad io read; bit 7: support quad read; bit 8: support dual io write; bit 9: support dual write; bit 10: support quad io write
+		*  bit 11: support quad write; bit 12: support 4k erase sector; bit 13: support status3; bit 14: support no QE ; bit 15:write status mode 
+		*/
+
+		/* 
+		*  flags = SFLAG_SECT_4K|SFLAG_COM_STATUS2|
+		*  SFLAG_DUAL_READ|SFLAG_QUAD_READ|SFLAG_DUAL_IO_READ|SFLAG_QUAD_IO_READ|SFLAG_QUAD_WRITE
+		*  wr_mode:
+		*	0:means one write status cmd can wirte all status regs; 1:means one write status cmd can only wirte one status reg
+		*  norflash-wr_flags: write wr startus regs count 
+		*/
+        norflash-flags = <0x1000>;
+		rd_status_cmd = <0x05>;
+		wr_status_cmd = <0x01>;
+		wr_mode = <0>;
+		norflash-wr_flags = <1>;
+
+		/* status reg bit map */
+        norflash-b-wip = <0>;
+        norflash-b-wel = <1>;
+        norflash-b-bp0 = <2>;
+        norflash-b-bp1 = <3>;
+
+        status = "disable";
+    };
+
+    sst25wf040: spi-norflash@21 { 
+        compatible = "sst,sst25wf040";
+        norflash-name = "sst25wf040";
+		reg = <21>;
+		
+		/* spiflash sst25wf040 */
+        norflash-jedec-id = <0xbf2504>; 
+        norflash-ext-id = <0>;
+        norflash-sector-size = <0x10000>;
+        norflash-n-sectors = <8>; 
+
+		/**
+		*  flags:chip character bits:
+		*  bit 0: under_protect flag; bit 1: fast read flag; bit 2: AAI flag; bit 3: support status2; bit 4: support dual io read; bit 5: support dual read
+		*  bit 6: support quad io read; bit 7: support quad read; bit 8: support dual io write; bit 9: support dual write; bit 10: support quad io write
+		*  bit 11: support quad write; bit 12: support 4k erase sector; bit 13: support status3; bit 14: support no QE ; bit 15:write status mode 
+		*/
+
+		/* 
+		*  flags = SFLAG_SECT_4K|SFLAG_COM_STATUS2|
+		*  SFLAG_DUAL_READ|SFLAG_QUAD_READ|SFLAG_DUAL_IO_READ|SFLAG_QUAD_IO_READ|SFLAG_QUAD_WRITE
+		*  wr_mode:
+		*	0:means one write status cmd can wirte all status regs; 1:means one write status cmd can only wirte one status reg
+		*  norflash-wr_flags: write wr startus regs count 
+		*/
+        norflash-flags = <0x1000>;
+		rd_status_cmd = <0x05>;
+		wr_status_cmd = <0x01>;
+		wr_mode = <0>;
+		norflash-wr_flags = <1>;
+
+		/* status reg bit map */
+        norflash-b-wip = <0>;
+        norflash-b-wel = <1>;
+        norflash-b-bp0 = <2>;
+        norflash-b-bp1 = <3>;
+		norflash-b-bp2 = <4>;
+
+        status = "disable";
+    };
+
+    m25p05: spi-norflash@22 { 
+        compatible = "st,m25p05";
+        norflash-name = "m25p05";
+		reg = <22>;
+		
+		/* spiflash m25p05 */
+        norflash-jedec-id = <0x202010>; 
+        norflash-ext-id = <0>;
+        norflash-sector-size = <0x8000>;
+        norflash-n-sectors = <2>; 
+
+		/**
+		*  flags:chip character bits:
+		*  bit 0: under_protect flag; bit 1: fast read flag; bit 2: AAI flag; bit 3: support status2; bit 4: support dual io read; bit 5: support dual read
+		*  bit 6: support quad io read; bit 7: support quad read; bit 8: support dual io write; bit 9: support dual write; bit 10: support quad io write
+		*  bit 11: support quad write; bit 12: support 4k erase sector; bit 13: support status3; bit 14: support no QE ; bit 15:write status mode 
+		*/
+
+		/* 
+		*  flags = 0
+		*  wr_mode:
+		*	0:means one write status cmd can wirte all status regs; 1:means one write status cmd can only wirte one status reg
+		*  norflash-wr_flags: write wr startus regs count 
+		*/
+        norflash-flags = <0>;
+		rd_status_cmd = <0x05>;
+		wr_status_cmd = <0x01>;
+		wr_mode = <0>;
+		norflash-wr_flags = <1>;
+
+		/* status reg bit map */
+        norflash-b-wip = <0>;
+        norflash-b-wel = <1>;
+        norflash-b-bp0 = <2>;
+        norflash-b-bp1 = <3>;
+
+        status = "disable";
+    };
+
+    m25p10: spi-norflash@23 { 
+        compatible = "st,m25p10";
+        norflash-name = "m25p10";
+		reg = <23>;
+		
+		/* spiflash m25p10 */
+        norflash-jedec-id = <0x202011>; 
+        norflash-ext-id = <0>;
+        norflash-sector-size = <0x8000>;
+        norflash-n-sectors = <4>; 
+
+		/**
+		*  flags:chip character bits:
+		*  bit 0: under_protect flag; bit 1: fast read flag; bit 2: AAI flag; bit 3: support status2; bit 4: support dual io read; bit 5: support dual read
+		*  bit 6: support quad io read; bit 7: support quad read; bit 8: support dual io write; bit 9: support dual write; bit 10: support quad io write
+		*  bit 11: support quad write; bit 12: support 4k erase sector; bit 13: support status3; bit 14: support no QE ; bit 15:write status mode 
+		*/
+
+		/* 
+		*  flags = 0
+		*  wr_mode:
+		*	0:means one write status cmd can wirte all status regs; 1:means one write status cmd can only wirte one status reg
+		*  norflash-wr_flags: write wr startus regs count 
+		*  sector size:32kB
+		*/
+        norflash-flags = <0>;
+		rd_status_cmd = <0x05>;
+		wr_status_cmd = <0x01>;
+		wr_mode = <0>;
+		norflash-wr_flags = <1>;
+
+		/* status reg bit map */
+        norflash-b-wip = <0>;
+        norflash-b-wel = <1>;
+        norflash-b-bp0 = <2>;
+        norflash-b-bp1 = <3>;
+
+        status = "disable";
+    };
+
+    m25p20: spi-norflash@24 { 
+        compatible = "st,m25p20";
+        norflash-name = "m25p20";
+		reg = <24>;
+		
+		/* spiflash m25p20 */
+        norflash-jedec-id = <0x202012>; 
+        norflash-ext-id = <0>;
+        norflash-sector-size = <0x10000>;
+        norflash-n-sectors = <4>; 
+
+		/**
+		*  flags:chip character bits:
+		*  bit 0: under_protect flag; bit 1: fast read flag; bit 2: AAI flag; bit 3: support status2; bit 4: support dual io read; bit 5: support dual read
+		*  bit 6: support quad io read; bit 7: support quad read; bit 8: support dual io write; bit 9: support dual write; bit 10: support quad io write
+		*  bit 11: support quad write; bit 12: support 4k erase sector; bit 13: support status3; bit 14: support no QE ; bit 15:write status mode 
+		*/
+
+		/* 
+		*  flags = 0
+		*  wr_mode:
+		*	0:means one write status cmd can wirte all status regs; 1:means one write status cmd can only wirte one status reg
+		*  norflash-wr_flags: write wr startus regs count 
+		*/
+        norflash-flags = <0>;
+		rd_status_cmd = <0x05>;
+		wr_status_cmd = <0x01>;
+		wr_mode = <0>;
+		norflash-wr_flags = <1>;
+
+		/* status reg bit map */
+        norflash-b-wip = <0>;
+        norflash-b-wel = <1>;
+        norflash-b-bp0 = <2>;
+        norflash-b-bp1 = <3>;
+		norflash-b-bp2 = <4>;
+
+        status = "disable";
+    };
+
+    m25p40: spi-norflash@25 { 
+        compatible = "st,m25p40";
+        norflash-name = "m25p40";
+		reg = <25>;
+		
+		/* spiflash m25p40 */
+        norflash-jedec-id = <0x202013>; 
+        norflash-ext-id = <0>;
+        norflash-sector-size = <0x10000>;
+        norflash-n-sectors = <8>; 
+
+		/**
+		*  flags:chip character bits:
+		*  bit 0: under_protect flag; bit 1: fast read flag; bit 2: AAI flag; bit 3: support status2; bit 4: support dual io read; bit 5: support dual read
+		*  bit 6: support quad io read; bit 7: support quad read; bit 8: support dual io write; bit 9: support dual write; bit 10: support quad io write
+		*  bit 11: support quad write; bit 12: support 4k erase sector; bit 13: support status3; bit 14: support no QE ; bit 15:write status mode 
+		*/
+
+		/* 
+		*  flags = 0
+		*  wr_mode:
+		*	0:means one write status cmd can wirte all status regs; 1:means one write status cmd can only wirte one status reg
+		*  norflash-wr_flags: write wr startus regs count 
+		*/
+        norflash-flags = <0>;
+		rd_status_cmd = <0x05>;
+		wr_status_cmd = <0x01>;
+		wr_mode = <0>;
+		norflash-wr_flags = <1>;
+
+		/* status reg bit map */
+        norflash-b-wip = <0>;
+        norflash-b-wel = <1>;
+        norflash-b-bp0 = <2>;
+        norflash-b-bp1 = <3>;
+		norflash-b-bp2 = <4>;
+
+        status = "disable";
+    };
+
+    m25p80: spi-norflash@26 { 
+        compatible = "st,m25p80";
+        norflash-name = "m25p80";
+		reg = <26>;
+		
+		/* spiflash m25p80 */
+        norflash-jedec-id = <0x202014>; 
+        norflash-ext-id = <0>;
+        norflash-sector-size = <0x10000>;
+        norflash-n-sectors = <16>; 
+
+		/**
+		*  flags:chip character bits:
+		*  bit 0: under_protect flag; bit 1: fast read flag; bit 2: AAI flag; bit 3: support status2; bit 4: support dual io read; bit 5: support dual read
+		*  bit 6: support quad io read; bit 7: support quad read; bit 8: support dual io write; bit 9: support dual write; bit 10: support quad io write
+		*  bit 11: support quad write; bit 12: support 4k erase sector; bit 13: support status3; bit 14: support no QE ; bit 15:write status mode 
+		*/
+
+		/* 
+		*  flags = 0
+		*  wr_mode:
+		*	0:means one write status cmd can wirte all status regs; 1:means one write status cmd can only wirte one status reg
+		*  norflash-wr_flags: write wr startus regs count 
+		*/
+        norflash-flags = <0>;
+		rd_status_cmd = <0x05>;
+		wr_status_cmd = <0x01>;
+		wr_mode = <0>;
+		norflash-wr_flags = <1>;
+
+		/* status reg bit map */
+        norflash-b-wip = <0>;
+        norflash-b-wel = <1>;
+        norflash-b-bp0 = <2>;
+        norflash-b-bp1 = <3>;
+		norflash-b-bp2 = <4>;
+
+        status = "disable";
+    };
+
+    m25p16: spi-norflash@27 { 
+        compatible = "st,m25p16";
+        norflash-name = "m25p16";
+		reg = <27>;
+		
+		/* spiflash m25p16 */
+        norflash-jedec-id = <0x202015>; 
+        norflash-ext-id = <0>;
+        norflash-sector-size = <0x10000>;
+        norflash-n-sectors = <32>; 
+
+		/**
+		*  flags:chip character bits:
+		*  bit 0: under_protect flag; bit 1: fast read flag; bit 2: AAI flag; bit 3: support status2; bit 4: support dual io read; bit 5: support dual read
+		*  bit 6: support quad io read; bit 7: support quad read; bit 8: support dual io write; bit 9: support dual write; bit 10: support quad io write
+		*  bit 11: support quad write; bit 12: support 4k erase sector; bit 13: support status3; bit 14: support no QE ; bit 15:write status mode 
+		*/
+
+		/* 
+		*  flags = 0
+		*  wr_mode:
+		*	0:means one write status cmd can wirte all status regs; 1:means one write status cmd can only wirte one status reg
+		*  norflash-wr_flags: write wr startus regs count 
+		*/
+        norflash-flags = <0>;
+		rd_status_cmd = <0x05>;
+		wr_status_cmd = <0x01>;
+		wr_mode = <0>;
+		norflash-wr_flags = <1>;
+
+		/* status reg bit map */
+        norflash-b-wip = <0>;
+        norflash-b-wel = <1>;
+        norflash-b-bp0 = <2>;
+        norflash-b-bp1 = <3>;
+		norflash-b-bp2 = <4>;
+
+        status = "disable";
+    };
+
+    m25p32: spi-norflash@28 { 
+        compatible = "st,m25p32";
+        norflash-name = "m25p32";
+		reg = <28>;
+		
+		/* spiflash m25p32 */
+        norflash-jedec-id = <0x202016>; 
+        norflash-ext-id = <0>;
+        norflash-sector-size = <0x10000>;
+        norflash-n-sectors = <64>; 
+
+		/**
+		*  flags:chip character bits:
+		*  bit 0: under_protect flag; bit 1: fast read flag; bit 2: AAI flag; bit 3: support status2; bit 4: support dual io read; bit 5: support dual read
+		*  bit 6: support quad io read; bit 7: support quad read; bit 8: support dual io write; bit 9: support dual write; bit 10: support quad io write
+		*  bit 11: support quad write; bit 12: support 4k erase sector; bit 13: support status3; bit 14: support no QE ; bit 15:write status mode 
+		*/
+
+		/* 
+		*  flags = 0
+		*  wr_mode:
+		*	0:means one write status cmd can wirte all status regs; 1:means one write status cmd can only wirte one status reg
+		*  norflash-wr_flags: write wr startus regs count 
+		*/
+        norflash-flags = <0>;
+		rd_status_cmd = <0x05>;
+		wr_status_cmd = <0x01>;
+		wr_mode = <0>;
+		norflash-wr_flags = <1>;
+
+		/* status reg bit map */
+        norflash-b-wip = <0>;
+        norflash-b-wel = <1>;
+        norflash-b-bp0 = <2>;
+        norflash-b-bp1 = <3>;
+		norflash-b-bp2 = <4>;
+		
+        status = "disable";
+    };
+
+    m25p64: spi-norflash@29 { 
+        compatible = "st,m25p64";
+        norflash-name = "m25p64";
+		reg = <29>;
+		
+		/* spiflash m25p64 */
+        norflash-jedec-id = <0x202017>; 
+        norflash-ext-id = <0>;
+        norflash-sector-size = <0x10000>;
+        norflash-n-sectors = <128>; 
+
+		/**
+		*  flags:chip character bits:
+		*  bit 0: under_protect flag; bit 1: fast read flag; bit 2: AAI flag; bit 3: support status2; bit 4: support dual io read; bit 5: support dual read
+		*  bit 6: support quad io read; bit 7: support quad read; bit 8: support dual io write; bit 9: support dual write; bit 10: support quad io write
+		*  bit 11: support quad write; bit 12: support 4k erase sector; bit 13: support status3; bit 14: support no QE ; bit 15:write status mode 
+		*/
+
+		/* 
+		*  flags = 0
+		*  wr_mode:
+		*	0:means one write status cmd can wirte all status regs; 1:means one write status cmd can only wirte one status reg
+		*  norflash-wr_flags: write wr startus regs count 
+		*/
+        norflash-flags = <0>;
+		rd_status_cmd = <0x05>;
+		wr_status_cmd = <0x01>;
+		wr_mode = <0>;
+		norflash-wr_flags = <1>;
+
+		/* status reg bit map */
+        norflash-b-wip = <0>;
+        norflash-b-wel = <1>;
+        norflash-b-bp0 = <2>;
+        norflash-b-bp1 = <3>;
+		norflash-b-bp2 = <4>;
+		
+        status = "disable";
+    };
+
+    m25p128: spi-norflash@30 { 
+        compatible = "st,m25p128";
+        norflash-name = "m25p128";
+		reg = <30>;
+		
+		/* spiflash m25p128 */
+        norflash-jedec-id = <0x202018>; 
+        norflash-ext-id = <0>;
+        norflash-sector-size = <0x40000>;
+        norflash-n-sectors = <64>; 
+
+		/**
+		*  flags:chip character bits:
+		*  bit 0: under_protect flag; bit 1: fast read flag; bit 2: AAI flag; bit 3: support status2; bit 4: support dual io read; bit 5: support dual read
+		*  bit 6: support quad io read; bit 7: support quad read; bit 8: support dual io write; bit 9: support dual write; bit 10: support quad io write
+		*  bit 11: support quad write; bit 12: support 4k erase sector; bit 13: support status3; bit 14: support no QE ; bit 15:write status mode 
+		*/
+
+		/* 
+		*  flags = 0
+		*  wr_mode:
+		*	0:means one write status cmd can wirte all status regs; 1:means one write status cmd can only wirte one status reg
+		*  norflash-wr_flags: write wr startus regs count 
+		*/
+        norflash-flags = <0>;
+		rd_status_cmd = <0x05>;
+		wr_status_cmd = <0x01>;
+		wr_mode = <0>;
+		norflash-wr_flags = <1>;
+
+		/* status reg bit map */
+        norflash-b-wip = <0>;
+        norflash-b-wel = <1>;
+        norflash-b-bp0 = <2>;
+        norflash-b-bp1 = <3>;
+		norflash-b-bp2 = <4>;
+
+        status = "disable";
+    };
+
+    m45pe10: spi-norflash@31 { 
+        compatible = "st,m45pe10";
+        norflash-name = "m45pe10";
+		reg = <31>;
+		
+		/* spiflash m45pe10 */
+        norflash-jedec-id = <0x204011>; 
+        norflash-ext-id = <0>;
+        norflash-sector-size = <0x10000>;
+        norflash-n-sectors = <2>; 
+
+		/**
+		*  flags:chip character bits:
+		*  bit 0: under_protect flag; bit 1: fast read flag; bit 2: AAI flag; bit 3: support status2; bit 4: support dual io read; bit 5: support dual read
+		*  bit 6: support quad io read; bit 7: support quad read; bit 8: support dual io write; bit 9: support dual write; bit 10: support quad io write
+		*  bit 11: support quad write; bit 12: support 4k erase sector; bit 13: support status3; bit 14: support no QE ; bit 15:write status mode 
+		*/
+
+		/* 
+		*  flags = 0
+		*  wr_mode:
+		*	0:means one write status cmd can wirte all status regs; 1:means one write status cmd can only wirte one status reg
+		*  norflash-wr_flags: write wr startus regs count 
+		*/
+        norflash-flags = <0>;
+		rd_status_cmd = <0x05>;
+		//wr_status_cmd = <0x01>;
+		wr_mode = <3>;
+		norflash-wr_flags = <1>;
+
+		/* status reg bit map */
+        norflash-b-wip = <0>;
+        norflash-b-wel = <1>;
+
+        status = "disable";
+    };
+
+    m45pe80: spi-norflash@32 { 
+        compatible = "st,m45pe80";
+        norflash-name = "m45pe80";
+		reg = <32>;
+		
+		/* spiflash m45pe80 */
+        norflash-jedec-id = <0x204014>; 
+        norflash-ext-id = <0>;
+        norflash-sector-size = <0x10000>;
+        norflash-n-sectors = <16>; 
+
+		/**
+		*  flags:chip character bits:
+		*  bit 0: under_protect flag; bit 1: fast read flag; bit 2: AAI flag; bit 3: support status2; bit 4: support dual io read; bit 5: support dual read
+		*  bit 6: support quad io read; bit 7: support quad read; bit 8: support dual io write; bit 9: support dual write; bit 10: support quad io write
+		*  bit 11: support quad write; bit 12: support 4k erase sector; bit 13: support status3; bit 14: support no QE ; bit 15:write status mode 
+		*/
+
+		/* 
+		*  flags = 0
+		*  wr_mode:
+		*	0:means one write status cmd can wirte all status regs; 1:means one write status cmd can only wirte one status reg
+		*  norflash-wr_flags: write wr startus regs count 
+		*/
+        norflash-flags = <0>;
+		rd_status_cmd = <0x05>;
+		//wr_status_cmd = <0x01>;
+		wr_mode = <3>;
+		norflash-wr_flags = <1>;
+
+		/* status reg bit map */
+        norflash-b-wip = <0>;
+        norflash-b-wel = <1>;
+
+        status = "disable";
+    };
+
+    m45pe16: spi-norflash@33 { 
+        compatible = "st,m45pe16";
+        norflash-name = "m45pe16";
+		reg = <33>;
+		
+		/* spiflash m45pe16 */
+        norflash-jedec-id = <0x204015>; 
+        norflash-ext-id = <0>;
+        norflash-sector-size = <0x10000>;
+        norflash-n-sectors = <32>; 
+
+		/**
+		*  flags:chip character bits:
+		*  bit 0: under_protect flag; bit 1: fast read flag; bit 2: AAI flag; bit 3: support status2; bit 4: support dual io read; bit 5: support dual read
+		*  bit 6: support quad io read; bit 7: support quad read; bit 8: support dual io write; bit 9: support dual write; bit 10: support quad io write
+		*  bit 11: support quad write; bit 12: support 4k erase sector; bit 13: support status3; bit 14: support no QE ; bit 15:write status mode 
+		*/
+
+		/* 
+		*  flags = 0
+		*  wr_mode:
+		*	0:means one write status cmd can wirte all status regs; 1:means one write status cmd can only wirte one status reg
+		*   3:no wr status reg
+		*  norflash-wr_flags: write wr startus regs count , 
+		*  no wr status reg cmd, sector 64kB
+		*/
+        norflash-flags = <0>;
+		rd_status_cmd = <0x05>;
+		//wr_status_cmd = <0x01>;
+		wr_mode = <3>;
+		norflash-wr_flags = <1>;
+
+		/* status reg bit map */
+        norflash-b-wip = <0>;
+        norflash-b-wel = <1>;
+
+        status = "disable";
+    };
+
+    m25pe80: spi-norflash@34 { 
+        compatible = "st,m25pe80";
+        norflash-name = "m25pe80";
+		reg = <34>;
+		
+		/* spiflash m25pe80 */
+        norflash-jedec-id = <0x208014>; 
+        norflash-ext-id = <0>;
+        norflash-sector-size = <0x10000>;
+        norflash-n-sectors = <16>; 
+
+		/**
+		*  flags:chip character bits:
+		*  bit 0: under_protect flag; bit 1: fast read flag; bit 2: AAI flag; bit 3: support status2; bit 4: support dual io read; bit 5: support dual read
+		*  bit 6: support quad io read; bit 7: support quad read; bit 8: support dual io write; bit 9: support dual write; bit 10: support quad io write
+		*  bit 11: support quad write; bit 12: support 4k erase sector; bit 13: support status3; bit 14: support no QE ; bit 15:write status mode 
+		*/
+
+		/* 
+		*  flags = 0
+		*  wr_mode:
+		*	0:means one write status cmd can wirte all status regs; 1:means one write status cmd can only wirte one status reg
+		*  norflash-wr_flags: write wr startus regs count 
+		*/
+        norflash-flags = <0>;
+		rd_status_cmd = <0x05>;
+		wr_status_cmd = <0x01>;
+		wr_mode = <0>;
+		norflash-wr_flags = <1>;
+
+		/* status reg bit map */
+        norflash-b-wip = <0>;
+        norflash-b-wel = <1>;
+        norflash-b-bp0 = <2>;
+        norflash-b-bp1 = <3>;
+        norflash-b-bp2 = <4>;
+        norflash-b-srp0 = <7>;
+
+        status = "disable";
+    };
+
+    m25pe16: spi-norflash@35 { 
+        compatible = "st,m25pe16";
+        norflash-name = "m25pe16";
+		reg = <35>;
+		
+		/* spiflash m25pe16 */
+        norflash-jedec-id = <0x208015>; 
+        norflash-ext-id = <0>;
+        norflash-sector-size = <0x10000>;
+        norflash-n-sectors = <32>; 
+
+		/**
+		*  flags:chip character bits:
+		*  bit 0: under_protect flag; bit 1: fast read flag; bit 2: AAI flag; bit 3: support status2; bit 4: support dual io read; bit 5: support dual read
+		*  bit 6: support quad io read; bit 7: support quad read; bit 8: support dual io write; bit 9: support dual write; bit 10: support quad io write
+		*  bit 11: support quad write; bit 12: support 4k erase sector; bit 13: support status3; bit 14: support no QE ; bit 15:write status mode 
+		*/
+
+		/* 
+		*  flags = SFLAG_SECT_4K
+		*  wr_mode:
+		*	0:means one write status cmd can wirte all status regs; 1:means one write status cmd can only wirte one status reg
+		*  norflash-wr_flags: write wr startus regs count 
+		*/
+        norflash-flags = <0x1000>;
+		rd_status_cmd = <0x05>;
+		wr_status_cmd = <0x01>;
+		wr_mode = <0>;
+		norflash-wr_flags = <1>;
+
+		/* status reg bit map */
+        norflash-b-wip = <0>;
+        norflash-b-wel = <1>;
+        norflash-b-bp0 = <2>;
+        norflash-b-bp1 = <3>;
+        norflash-b-bp2 = <4>;
+
+        status = "disable";
+    };
+
+    w25x10: spi-norflash@36 { 
+        compatible = "winbond,w25x10";
+        norflash-name = "w25x10";
+		reg = <36>;
+		
+		/* spiflash w25x10 */
+        norflash-jedec-id = <0xef3011>; 
+        norflash-ext-id = <0>;
+        norflash-sector-size = <0x10000>;
+        norflash-n-sectors = <2>; 
+
+		/**
+		*  flags:chip character bits:
+		*  bit 0: under_protect flag; bit 1: fast read flag; bit 2: AAI flag; bit 3: support status2; bit 4: support dual io read; bit 5: support dual read
+		*  bit 6: support quad io read; bit 7: support quad read; bit 8: support dual io write; bit 9: support dual write; bit 10: support quad io write
+		*  bit 11: support quad write; bit 12: support 4k erase sector; bit 13: support status3; bit 14: support no QE ; bit 15:write status mode 
+		*/
+
+		/* 
+		*  flags = SFLAG_SECT_4K
+		*  wr_mode:
+		*	0:means one write status cmd can wirte all status regs; 1:means one write status cmd can only wirte one status reg
+		*  norflash-wr_flags: write wr startus regs count 
+		*/
+        norflash-flags = <0x1000>;
+		rd_status_cmd = <0x05>;
+		wr_status_cmd = <0x01>;
+		wr_mode = <0>;
+		norflash-wr_flags = <1>;
+
+		/* status reg bit map */
+        norflash-b-wip = <0>;
+        norflash-b-wel = <1>;
+        norflash-b-bp0 = <2>;
+        norflash-b-bp1 = <3>;
+        norflash-b-bp2 = <4>;
+        norflash-b-srp0 = <7>;
+
+        status = "disable";
+    };
+
+    w25x20: spi-norflash@37 { 
+        compatible = "winbond,w25x20";
+        norflash-name = "w25x20";
+		reg = <37>;
+		
+		/* spiflash w25x20 */
+        norflash-jedec-id = <0xef3012>; 
+        norflash-ext-id = <0>;
+        norflash-sector-size = <0x10000>;
+        norflash-n-sectors = <4>; 
+
+		/**
+		*  flags:chip character bits:
+		*  bit 0: under_protect flag; bit 1: fast read flag; bit 2: AAI flag; bit 3: support status2; bit 4: support dual io read; bit 5: support dual read
+		*  bit 6: support quad io read; bit 7: support quad read; bit 8: support dual io write; bit 9: support dual write; bit 10: support quad io write
+		*  bit 11: support quad write; bit 12: support 4k erase sector; bit 13: support status3; bit 14: support no QE ; bit 15:write status mode 
+		*/
+
+		/* 
+		*  flags = SFLAG_SECT_4K
+		*  wr_mode:
+		*	0:means one write status cmd can wirte all status regs; 1:means one write status cmd can only wirte one status reg
+		*  norflash-wr_flags: write wr startus regs count 
+		*/
+        norflash-flags = <0x1000>;
+		rd_status_cmd = <0x05>;
+		wr_status_cmd = <0x01>;
+		wr_mode = <0>;
+		norflash-wr_flags = <1>;
+
+		/* status reg bit map */
+        norflash-b-wip = <0>;
+        norflash-b-wel = <1>;
+        norflash-b-bp0 = <2>;
+        norflash-b-bp1 = <3>;
+        norflash-b-bp2 = <4>;
+        norflash-b-srp0 = <7>;
+
+        status = "disable";
+    };
+
+    w25x40: spi-norflash@38 { 
+        compatible = "winbond,w25x40";
+        norflash-name = "w25x40";
+		reg = <38>;
+		
+		/* spiflash w25x40 */
+        norflash-jedec-id = <0xef3013>; 
+        norflash-ext-id = <0>;
+        norflash-sector-size = <0x10000>;
+        norflash-n-sectors = <8>; 
+
+		/**
+		*  flags:chip character bits:
+		*  bit 0: under_protect flag; bit 1: fast read flag; bit 2: AAI flag; bit 3: support status2; bit 4: support dual io read; bit 5: support dual read
+		*  bit 6: support quad io read; bit 7: support quad read; bit 8: support dual io write; bit 9: support dual write; bit 10: support quad io write
+		*  bit 11: support quad write; bit 12: support 4k erase sector; bit 13: support status3; bit 14: support no QE ; bit 15:write status mode 
+		*/
+
+		/* 
+		*  flags = SFLAG_SECT_4K
+		*  wr_mode:
+		*	0:means one write status cmd can wirte all status regs; 1:means one write status cmd can only wirte one status reg
+		*  norflash-wr_flags: write wr startus regs count 
+		*/
+        norflash-flags = <0x1000>;
+		rd_status_cmd = <0x05>;
+		wr_status_cmd = <0x01>;
+		wr_mode = <0>;
+		norflash-wr_flags = <1>;
+
+		/* status reg bit map */
+        norflash-b-wip = <0>;
+        norflash-b-wel = <1>;
+        norflash-b-bp0 = <2>;
+        norflash-b-bp1 = <3>;
+        norflash-b-bp2 = <4>;
+        norflash-b-srp0 = <7>;
+
+        status = "disable";
+    };
+
+    w25x80: spi-norflash@39 { 
+        compatible = "winbond,w25x80";
+        norflash-name = "w25x80";
+		reg = <39>;
+		
+		/* spiflash w25x80 */
+        norflash-jedec-id = <0xef3014>; 
+        norflash-ext-id = <0>;
+        norflash-sector-size = <0x10000>;
+        norflash-n-sectors = <16>; 
+
+		/**
+		*  flags:chip character bits:
+		*  bit 0: under_protect flag; bit 1: fast read flag; bit 2: AAI flag; bit 3: support status2; bit 4: support dual io read; bit 5: support dual read
+		*  bit 6: support quad io read; bit 7: support quad read; bit 8: support dual io write; bit 9: support dual write; bit 10: support quad io write
+		*  bit 11: support quad write; bit 12: support 4k erase sector; bit 13: support status3; bit 14: support no QE ; bit 15:write status mode 
+		*/
+
+		/* 
+		*  flags = SFLAG_SECT_4K
+		*  wr_mode:
+		*	0:means one write status cmd can wirte all status regs; 1:means one write status cmd can only wirte one status reg
+		*  norflash-wr_flags: write wr startus regs count 
+		*/
+        norflash-flags = <0x1000>;
+		rd_status_cmd = <0x05>;
+		wr_status_cmd = <0x01>;
+		wr_mode = <0>;
+		norflash-wr_flags = <1>;
+
+		/* status reg bit map */
+        norflash-b-wip = <0>;
+        norflash-b-wel = <1>;
+        norflash-b-bp0 = <2>;
+        norflash-b-bp1 = <3>;
+        norflash-b-bp2 = <4>;
+        norflash-b-srp0 = <7>;
+
+        status = "disable";
+    };
+
+    w25x16: spi-norflash@40 { 
+        compatible = "winbond,w25x16";
+        norflash-name = "w25x16";
+		reg = <40>;
+		
+		/* spiflash w25x16 */
+        norflash-jedec-id = <0xef3015>; 
+        norflash-ext-id = <0>;
+        norflash-sector-size = <0x10000>;
+        norflash-n-sectors = <32>; 
+
+		/**
+		*  flags:chip character bits:
+		*  bit 0: under_protect flag; bit 1: fast read flag; bit 2: AAI flag; bit 3: support status2; bit 4: support dual io read; bit 5: support dual read
+		*  bit 6: support quad io read; bit 7: support quad read; bit 8: support dual io write; bit 9: support dual write; bit 10: support quad io write
+		*  bit 11: support quad write; bit 12: support 4k erase sector; bit 13: support status3; bit 14: support no QE ; bit 15:write status mode 
+		*/
+
+		/* 
+		*  flags = SFLAG_SECT_4K
+		*  wr_mode:
+		*	0:means one write status cmd can wirte all status regs; 1:means one write status cmd can only wirte one status reg
+		*  norflash-wr_flags: write wr startus regs count 
+		*/
+        norflash-flags = <0x1000>;
+		rd_status_cmd = <0x05>;
+		wr_status_cmd = <0x01>;
+		wr_mode = <0>;
+		norflash-wr_flags = <1>;
+
+		/* status reg bit map */
+        norflash-b-wip = <0>;
+        norflash-b-wel = <1>;
+        norflash-b-bp0 = <2>;
+        norflash-b-bp1 = <3>;
+        norflash-b-bp2 = <4>;
+        norflash-b-srp0 = <7>;
+
+        status = "disable";
+    };
+
+    w25x32: spi-norflash@41 { 
+        compatible = "winbond,w25x32";
+        norflash-name = "w25x32";
+		reg = <41>;
+		
+		/* spiflash w25x32 */
+        norflash-jedec-id = <0xef3016>; 
+        norflash-ext-id = <0>;
+        norflash-sector-size = <0x10000>;
+        norflash-n-sectors = <64>; 
+
+		/**
+		*  flags:chip character bits:
+		*  bit 0: under_protect flag; bit 1: fast read flag; bit 2: AAI flag; bit 3: support status2; bit 4: support dual io read; bit 5: support dual read
+		*  bit 6: support quad io read; bit 7: support quad read; bit 8: support dual io write; bit 9: support dual write; bit 10: support quad io write
+		*  bit 11: support quad write; bit 12: support 4k erase sector; bit 13: support status3; bit 14: support no QE ; bit 15:write status mode 
+		*/
+
+		/* 
+		*  flags = SFLAG_SECT_4K
+		*  wr_mode:
+		*	0:means one write status cmd can wirte all status regs; 1:means one write status cmd can only wirte one status reg
+		*  norflash-wr_flags: write wr startus regs count 
+		*/
+        norflash-flags = <0x1000>;
+		rd_status_cmd = <0x05>;
+		wr_status_cmd = <0x01>;
+		wr_mode = <0>;
+		norflash-wr_flags = <1>;
+
+		/* status reg bit map */
+        norflash-b-wip = <0>;
+        norflash-b-wel = <1>;
+        norflash-b-bp0 = <2>;
+        norflash-b-bp1 = <3>;
+        norflash-b-bp2 = <4>;
+        norflash-b-srp0 = <7>;
+
+        status = "disable";
+    };
+
+    w25x64: spi-norflash@42 { 
+        compatible = "winbond,w25x64";
+        norflash-name = "w25x64";
+		reg = <42>;
+		
+		/* spiflash w25x64 */
+        norflash-jedec-id = <0xef3017>; 
+        norflash-ext-id = <0>;
+        norflash-sector-size = <0x10000>;
+        norflash-n-sectors = <128>; 
+
+		/**
+		*  flags:chip character bits:
+		*  bit 0: under_protect flag; bit 1: fast read flag; bit 2: AAI flag; bit 3: support status2; bit 4: support dual io read; bit 5: support dual read
+		*  bit 6: support quad io read; bit 7: support quad read; bit 8: support dual io write; bit 9: support dual write; bit 10: support quad io write
+		*  bit 11: support quad write; bit 12: support 4k erase sector; bit 13: support status3; bit 14: support no QE ; bit 15:write status mode 
+		*/
+
+		/* 
+		*  flags = SFLAG_SECT_4K
+		*  wr_mode:
+		*	0:means one write status cmd can wirte all status regs; 1:means one write status cmd can only wirte one status reg
+		*  norflash-wr_flags: write wr startus regs count 
+		*/
+        norflash-flags = <0x1000>;
+		rd_status_cmd = <0x05>;
+		wr_status_cmd = <0x01>;
+		wr_mode = <0>;
+		norflash-wr_flags = <1>;
+
+		/* status reg bit map */
+        norflash-b-wip = <0>;
+        norflash-b-wel = <1>;
+        norflash-b-bp0 = <2>;
+        norflash-b-bp1 = <3>;
+        norflash-b-bp2 = <4>;
+        norflash-b-srp0 = <7>;
+
+        status = "disable";
+    };
+
+    w25q32: spi-norflash@43 { 
+        compatible = "winbond,w25q32";
+        norflash-name = "w25q32";
+		reg = <43>;
+		
+		/* spiflash w25q32 */
+        norflash-jedec-id = <0xef4016>; 
+        norflash-ext-id = <0>;
+        norflash-sector-size = <0x8000>;
+        norflash-n-sectors = <128>; 
+
+		/**
+		*  flags:chip character bits:
+		*  bit 0: under_protect flag; bit 1: fast read flag; bit 2: AAI flag; bit 3: support status2; bit 4: support dual io read; bit 5: support dual read
+		*  bit 6: support quad io read; bit 7: support quad read; bit 8: support dual io write; bit 9: support dual write; bit 10: support quad io write
+		*  bit 11: support quad write; bit 12: support 4k erase sector; bit 13: support status3; bit 14: support no QE ; bit 15:write status mode 
+		*/
+
+		/* 
+		*  flags = SFLAG_SECT_4K|SFLAG_COM_STATUS2|SFLAG_DUAL_READ|SFLAG_QUAD_READ|SFLAG_QUAD_WRITE
+		*  wr_mode:
+		*	0:means one write status cmd can wirte all status regs; 1:means one write status cmd can only wirte one status reg
+		*  norflash-wr_flags: write wr startus regs count 
+		*/
+        norflash-flags = <0x18A8>;
+		rd_status_cmd = <0x05>, <0x35>;
+		wr_status_cmd = <0x01>;
+		wr_mode = <0>;
+		norflash-wr_flags = <1>;
+
+		/* status reg bit map */
+        norflash-b-wip = <0>;
+        norflash-b-wel = <1>;
+        norflash-b-bp0 = <2>;
+        norflash-b-bp1 = <3>;
+        norflash-b-bp2 = <4>;
+        norflash-b-srp0 = <7>;
+        norflash-b-srp1 = <8>;
+        norflash-b-qe = <9>; 
+
+        status = "disable";
+    };
+
+    w25q64: spi-norflash@44 { 
+        compatible = "winbond,w25q64";
+        norflash-name = "w25q64";
+		reg = <44>;
+		
+		/* spiflash w25q64 */
+        norflash-jedec-id = <0xef4017>; 
+        norflash-ext-id = <0>;
+        norflash-sector-size = <0x10000>;
+        norflash-n-sectors = <128>; 
+
+		/**
+		*  flags:chip character bits:
+		*  bit 0: under_protect flag; bit 1: fast read flag; bit 2: AAI flag; bit 3: support status2; bit 4: support dual io read; bit 5: support dual read
+		*  bit 6: support quad io read; bit 7: support quad read; bit 8: support dual io write; bit 9: support dual write; bit 10: support quad io write
+		*  bit 11: support quad write; bit 12: support 4k erase sector; bit 13: support status3; bit 14: support no QE ; bit 15:write status mode 
+		*/
+
+		/* 
+		*  flags = SFLAG_SECT_4K|SFLAG_COM_STATUS2|SFLAG_DUAL_READ|SFLAG_QUAD_READ|SFLAG_QUAD_WRITE
+		*  wr_mode:
+		*	0:means one write status cmd can wirte all status regs; 1:means one write status cmd can only wirte one status reg
+		*  norflash-wr_flags: write wr startus regs count 
+		*/
+        norflash-flags = <0x18A8>;
+		rd_status_cmd = <0x05>, <0x35>;
+		wr_status_cmd = <0x01>;
+		wr_mode = <0>;
+		norflash-wr_flags = <2>;
+
+		/* status reg bit map */
+        norflash-b-wip = <0>;
+        norflash-b-wel = <1>;
+        norflash-b-bp0 = <2>;
+        norflash-b-bp1 = <3>;
+        norflash-b-bp2 = <4>;
+        norflash-b-srp1 = <8>;
+        norflash-b-qe = <9>; 
+		norflash-b-cmp = <14>; 
+        norflash-b-sus = <15>; 
+
+        status = "disable";
+    };
+
+    w25q128: spi-norflash@45 { 
+        compatible = "winbond,w25q128";
+        norflash-name = "w25q128";
+		reg = <45>;
+		
+		/* spiflash w25q128 */
+        norflash-jedec-id = <0xef4018>; 
+        norflash-ext-id = <0>;
+        norflash-sector-size = <0x10000>;
+        norflash-n-sectors = <256>; 
+
+		/**
+		*  flags:chip character bits:
+		*  bit 0: under_protect flag; bit 1: fast read flag; bit 2: AAI flag; bit 3: support status2; bit 4: support dual io read; bit 5: support dual read
+		*  bit 6: support quad io read; bit 7: support quad read; bit 8: support dual io write; bit 9: support dual write; bit 10: support quad io write
+		*  bit 11: support quad write; bit 12: support 4k erase sector; bit 13: support status3; bit 14: support no QE ; bit 15:write status mode 
+		*/
+
+		/* 
+		*  flags = SFLAG_SECT_4K|SFLAG_COM_STATUS2|SFLAG_DUAL_READ|SFLAG_QUAD_READ|SFLAG_QUAD_WRITE
+		*  wr_mode:
+		*	0:means one write status cmd can wirte all status regs; 1:means one write status cmd can only wirte one status reg
+		*  norflash-wr_flags: write wr startus regs count 
+		*/
+        norflash-flags = <0x18A8>;
+		rd_status_cmd = <0x05>, <0x35>, <0x15>;
+		wr_status_cmd = <0x01>, <0x31>, <0x11>;
+		wr_mode = <1>;
+		norflash-wr_flags = <2>;
+
+		/* status reg bit map */
+        norflash-b-wip = <0>;
+        norflash-b-wel = <1>;
+        norflash-b-bp0 = <2>;
+        norflash-b-bp1 = <3>;
+        norflash-b-bp2 = <4>;
+        norflash-b-srp0 = <7>;
+        norflash-b-srp1 = <8>;
+        norflash-b-qe = <9>;  
+		norflash-b-cmp = <14>; 
+        norflash-b-sus = <15>; 
+
+        status = "disable";
+    };
+
+    gd25q64: spi-norflash@46 { 
+        compatible = "gd,gd25q64";
+		#clock-cells = <1>;
+        norflash-name = "gd25q64";
+		reg = <46>;
+		
+		/* spiflash gd25q64&gd25q64c */
+        norflash-jedec-id = <0xc84017>; 
+        norflash-ext-id = <0>;
+        norflash-sector-size = <0x10000>;
+        norflash-n-sectors = <128>; 
+
+		/**
+		*  flags:chip character bits:
+		*  bit 0: under_protect flag; bit 1: fast read flag; bit 2: AAI flag; bit 3: support status2; bit 4: support dual io read; bit 5: support dual read
+		*  bit 6: support quad io read; bit 7: support quad read; bit 8: support dual io write; bit 9: support dual write; bit 10: support quad io write
+		*  bit 11: support quad write; bit 12: support 4k erase sector; bit 13: support status3; bit 14: support no QE ; bit 15:write status mode 
+		*/
+
+		/* 
+		*  flags = SFLAG_SECT_4K|SFLAG_COM_STATUS2|
+		*  SFLAG_DUAL_READ|SFLAG_QUAD_READ|SFLAG_DUAL_IO_READ|SFLAG_QUAD_IO_READ|SFLAG_QUAD_WRITE
+		*  wr_mode:
+		*	0:means one write status cmd can wirte all status regs; 1:means one write status cmd can only wirte one status reg
+		*  norflash-wr_flags: write wr startus regs count 
+		*/
+        norflash-flags = <0x18F8>;
+		rd_status_cmd = <0x05>, <0x35>, <0x15>;
+		wr_status_cmd = <0x01>, <0x31>;
+		wr_mode = <1>;
+		norflash-wr_flags = <2>;
+
+		/* status reg bit map */
+        norflash-b-wip = <0>;
+        norflash-b-wel = <1>;
+        norflash-b-bp0 = <2>;
+        norflash-b-bp1 = <3>;
+        norflash-b-bp2 = <4>;
+        norflash-b-bp3 = <5>; 
+        norflash-b-bp4 = <6>;
+        norflash-b-srp0 = <7>;
+        norflash-b-srp1 = <8>;
+        norflash-b-qe = <9>; 
+		norflash-b-cmp = <14>; 
+        norflash-b-sus = <15>; 
+
+        status = "disable";
+    };
+
+    gd25q128: spi-norflash@47 { 
+        compatible = "gd,gd25q128";
+        norflash-name = "gd25q128";
+		reg = <47>;
+		
+		/* spiflash gd25q128 */
+        norflash-jedec-id = <0xc84018>; 
+        norflash-ext-id = <0>;
+        norflash-sector-size = <0x10000>;
+        norflash-n-sectors = <256>; 
+
+		/**
+		*  flags:chip character bits:
+		*  bit 0: under_protect flag; bit 1: fast read flag; bit 2: AAI flag; bit 3: support status2; bit 4: support dual io read; bit 5: support dual read
+		*  bit 6: support quad io read; bit 7: support quad read; bit 8: support dual io write; bit 9: support dual write; bit 10: support quad io write
+		*  bit 11: support quad write; bit 12: support 4k erase sector; bit 13: support status3; bit 14: support no QE ; bit 15:write status mode 
+		*/
+
+		/* 
+		*  flags = SFLAG_SECT_4K|SFLAG_COM_STATUS2|
+		*  SFLAG_DUAL_READ|SFLAG_QUAD_READ|SFLAG_DUAL_IO_READ|SFLAG_QUAD_IO_READ|SFLAG_QUAD_WRITE
+		*  wr_mode:
+		*	0:means one write status cmd can wirte all status regs; 1:means one write status cmd can only wirte one status reg
+		*  norflash-wr_flags: write wr startus regs count 
+		*/
+        norflash-flags = <0x18F8>;
+		rd_status_cmd = <0x05>, <0x35>, <0x15>;
+		wr_status_cmd = <0x01>, <0x31>, <0x11>;
+		wr_mode = <1>;
+		norflash-wr_flags = <2>;
+
+		/* status reg bit map */
+        norflash-b-wip = <0>;
+        norflash-b-wel = <1>;
+        norflash-b-bp0 = <2>;
+        norflash-b-bp1 = <3>;
+        norflash-b-bp2 = <4>;
+        norflash-b-bp3 = <5>; 
+        norflash-b-bp4 = <6>;
+        norflash-b-srp0 = <7>;
+        norflash-b-srp1 = <8>;
+        norflash-b-qe = <9>; 
+		norflash-b-cmp = <14>; 
+        norflash-b-sus = <15>; 
+
+        status = "disable";
+    };
+
+    xm25qh64a: spi-norflash@48 { 
+        compatible = "xmc,xm25qh64a";
+        norflash-name = "xm25qh64a";
+		reg = <48>;
+		
+		/* spiflash xm25qh64a */
+        norflash-jedec-id = <0x207017>; 
+        norflash-ext-id = <0>;
+        norflash-sector-size = <0x10000>;
+        norflash-n-sectors = <128>; 
+
+		/**
+		*  flags:chip character bits:
+		*  bit 0: under_protect flag; bit 1: fast read flag; bit 2: AAI flag; bit 3: support status2; bit 4: support dual io read; bit 5: support dual read
+		*  bit 6: support quad io read; bit 7: support quad read; bit 8: support dual io write; bit 9: support dual write; bit 10: support quad io write
+		*  bit 11: support quad write; bit 12: support 4k erase sector; bit 13: support status3; bit 14: support no QE ; bit 15:write status mode 
+		*/
+
+		/* 
+		*  flags = SFLAG_SECT_4K|SFLAG_COM_STATUS2|
+		*  SFLAG_DUAL_READ|SFLAG_QUAD_READ|SFLAG_DUAL_IO_READ|SFLAG_QUAD_IO_READ|SFLAG_QUAD_WRITE
+		*  wr_mode:
+		*	0:means one write status cmd can wirte all status regs; 1:means one write status cmd can only wirte one status reg
+		*  norflash-wr_flags: write wr startus regs count 
+		*/
+        norflash-flags = <0x58F8>;
+		rd_status_cmd = <0x05>, <0x09>, <0x95>;
+		wr_status_cmd = <0x01>;
+		wr_mode = <0>;
+		norflash-wr_flags = <1>;
+
+		/* status reg bit map */
+        norflash-b-wip = <0>;
+        norflash-b-wel = <1>;
+        norflash-b-bp0 = <2>;
+        norflash-b-bp1 = <3>;
+        norflash-b-bp2 = <4>;
+        norflash-b-bp3 = <5>; 
+        norflash-b-srp0 = <7>;
+
+        status = "disable";
+    };
+
+    xm25qh128a: spi-norflash@49 { 
+        compatible = "xmc,xm25qh128a";
+        norflash-name = "xm25qh128a";
+		reg = <49>;
+		
+		/* spiflash xm25qh128a */
+        norflash-jedec-id = <0x207018>; 
+        norflash-ext-id = <0>;
+        norflash-sector-size = <0x10000>;
+        norflash-n-sectors = <256>; 
+
+		/**
+		*  flags:chip character bits:
+		*  bit 0: under_protect flag; bit 1: fast read flag; bit 2: AAI flag; bit 3: support status2; bit 4: support dual io read; bit 5: support dual read
+		*  bit 6: support quad io read; bit 7: support quad read; bit 8: support dual io write; bit 9: support dual write; bit 10: support quad io write
+		*  bit 11: support quad write; bit 12: support 4k erase sector; bit 13: support status3; bit 14: support no QE ; bit 15:write status mode 
+		*/
+
+		/* 
+		*  flags = SFLAG_QUAD_NO_QE|SFLAG_SECT_4K|SFLAG_COM_STATUS2|
+		*  SFLAG_DUAL_READ|SFLAG_QUAD_READ|SFLAG_DUAL_IO_READ|SFLAG_QUAD_IO_READ|SFLAG_QUAD_WRITE
+		*  wr_mode:
+		*	0:means one write status cmd can wirte all status regs; 1:means one write status cmd can only wirte one status reg
+		*  norflash-wr_flags: write wr startus regs count 
+		*/
+        norflash-flags = <0x58F8>;
+		rd_status_cmd = <0x05>, <0x09>, <0x95>;
+		wr_status_cmd = <0x01>;
+		wr_mode = <0>;
+		norflash-wr_flags = <1>;
+
+		/* status reg bit map */
+        norflash-b-wip = <0>;
+        norflash-b-wel = <1>;
+        norflash-b-bp0 = <2>;
+        norflash-b-bp1 = <3>;
+        norflash-b-bp2 = <4>;
+        norflash-b-bp3 = <5>; 
+        norflash-b-srp0 = <7>;
+
+        status = "disable";
+    };
+
+    pn26f64b: spi-norflash@50 { 
+        compatible = "pn,pn26f64b";
+        norflash-name = "pn26f64b";
+		reg = <50>;
+		
+		/* spiflash pn26f64b */
+        norflash-jedec-id = <0x1c7017>; 
+        norflash-ext-id = <0>;
+        norflash-sector-size = <0x10000>;
+        norflash-n-sectors = <128>; 
+
+		/**
+		*  flags:chip character bits:
+		*  bit 0: under_protect flag; bit 1: fast read flag; bit 2: AAI flag; bit 3: support status2; bit 4: support dual io read; bit 5: support dual read
+		*  bit 6: support quad io read; bit 7: support quad read; bit 8: support dual io write; bit 9: support dual write; bit 10: support quad io write
+		*  bit 11: support quad write; bit 12: support 4k erase sector; bit 13: support status3; bit 14: support no QE ; bit 15:write status mode 
+		*/
+
+		/* 
+		*  flags = SFLAG_QUAD_NO_QE|SFLAG_SECT_4K|SFLAG_COM_STATUS2|
+		*  SFLAG_DUAL_READ|SFLAG_QUAD_READ|SFLAG_DUAL_IO_READ|SFLAG_QUAD_IO_READ|SFLAG_QUAD_WRITE
+		*  = 0x58F8
+		*  wr_mode:
+		*	0:means one write status cmd can wirte all status regs; 1:means one write status cmd can only wirte one status reg
+		*  norflash-wr_flags: write wr startus regs count 
+		*/
+        norflash-flags = <0x58F8>;
+		rd_status_cmd = <0x05>, <0x09>, <0x95>;
+		wr_status_cmd = <0x01>;
+		wr_mode = <0>;
+		norflash-wr_flags = <1>;
+
+		/* status reg bit map */
+        norflash-b-wip = <0>;
+        norflash-b-wel = <1>;
+        norflash-b-bp0 = <2>;
+        norflash-b-bp1 = <3>;
+        norflash-b-bp2 = <4>;
+        norflash-b-bp3 = <5>; 
+        norflash-b-srp0 = <7>;
+
+        status = "disable";
+    };
+
+    by25q64a: spi-norflash@51 { 
+        compatible = "by,by25q64a";
+        norflash-name = "by25q64a";
+		reg = <51>;
+		
+		/* spiflash by25q64a */
+        norflash-jedec-id = <0x684017>; 
+        norflash-ext-id = <0>;
+        norflash-sector-size = <0x10000>;
+        norflash-n-sectors = <128>; 
+
+		/**
+		*  flags:chip character bits:
+		*  bit 0: under_protect flag; bit 1: fast read flag; bit 2: AAI flag; bit 3: support status2; bit 4: support dual io read; bit 5: support dual read
+		*  bit 6: support quad io read; bit 7: support quad read; bit 8: support dual io write; bit 9: support dual write; bit 10: support quad io write
+		*  bit 11: support quad write; bit 12: support 4k erase sector; bit 13: support status3; bit 14: support no QE ; bit 15:write status mode 
+		*/
+
+		/* 
+		*  flags = SFLAG_SECT_4K|SFLAG_COM_STATUS2|
+		*  SFLAG_DUAL_READ|SFLAG_QUAD_READ|SFLAG_DUAL_IO_READ|SFLAG_QUAD_IO_READ|SFLAG_QUAD_WRITE
+		*  wr_mode:
+		*	0:means one write status cmd can wirte all status regs; 1:means one write status cmd can only wirte one status reg
+		*  norflash-wr_flags: write wr startus regs count 
+		*/
+        norflash-flags = <0x18F8>;
+		rd_status_cmd = <0x05>, <0x35>, <0x15>;
+		wr_status_cmd = <0x01>, <0x31>, <0x11>;
+		wr_mode = <1>;
+		norflash-wr_flags = <2>;
+
+		/* status reg bit map */
+        norflash-b-wip = <0>;
+        norflash-b-wel = <1>;
+        norflash-b-bp0 = <2>;
+        norflash-b-bp1 = <3>;
+        norflash-b-bp2 = <4>;
+        norflash-b-bp3 = <5>; 
+        norflash-b-bp4 = <6>;
+        norflash-b-srp0 = <7>;
+        norflash-b-srp1 = <8>;
+        norflash-b-qe = <9>; 
+        norflash-b-lb = <10>; 
+		norflash-b-cmp = <14>; 
+        norflash-b-sus = <15>; 
+
+        status = "disable";
+    };
+
+    by25q128a: spi-norflash@52 { 
+        compatible = "by,by25q128a";
+        norflash-name = "by25q128a";
+		reg = <52>;
+		
+		/* spiflash by25q128a */
+        norflash-jedec-id = <0x684018>; 
+        norflash-ext-id = <0>;
+        norflash-sector-size = <0x10000>;
+        norflash-n-sectors = <256>; 
+
+		/**
+		*  flags:chip character bits:
+		*  bit 0: under_protect flag; bit 1: fast read flag; bit 2: AAI flag; bit 3: support status2; bit 4: support dual io read; bit 5: support dual read
+		*  bit 6: support quad io read; bit 7: support quad read; bit 8: support dual io write; bit 9: support dual write; bit 10: support quad io write
+		*  bit 11: support quad write; bit 12: support 4k erase sector; bit 13: support status3; bit 14: support no QE ; bit 15:write status mode 
+		*/
+
+		/* 
+		*  flags = SFLAG_SECT_4K|SFLAG_COM_STATUS2|
+		*  SFLAG_DUAL_READ|SFLAG_QUAD_READ|SFLAG_DUAL_IO_READ|SFLAG_QUAD_IO_READ|SFLAG_QUAD_WRITE
+		*  wr_mode:
+		*	0:means one write status cmd can wirte all status regs; 1:means one write status cmd can only wirte one status reg
+		*  norflash-wr_flags: write wr startus regs count 
+		*/
+        norflash-flags = <0x18F8>;
+		rd_status_cmd = <0x05>, <0x35>, <0x15>;
+		wr_status_cmd = <0x01>, <0x31>, <0x11>;
+		wr_mode = <1>;
+		norflash-wr_flags = <2>;
+
+		/* status reg bit map */
+        norflash-b-wip = <0>;
+        norflash-b-wel = <1>;
+        norflash-b-bp0 = <2>;
+        norflash-b-bp1 = <3>;
+        norflash-b-bp2 = <4>;
+        norflash-b-bp3 = <5>; 
+        norflash-b-bp4 = <6>;
+        norflash-b-srp0 = <7>;
+        norflash-b-srp1 = <8>;
+        norflash-b-qe = <9>; 
+        norflash-b-lb = <10>; 
+		norflash-b-cmp = <14>; 
+        norflash-b-sus = <15>; 
+
+        status = "disable";
+    };
+
+    fm25q64: spi-norflash@53 { 
+        compatible = "fm,fm25q64";
+        norflash-name = "fm25q64";
+		reg = <53>;
+		
+		/* spiflash fm25q64 */
+        norflash-jedec-id = <0xa14017>; 
+        norflash-ext-id = <0>;
+        norflash-sector-size = <0x10000>;
+        norflash-n-sectors = <128>; 
+
+		/**
+		*  flags:chip character bits:
+		*  bit 0: under_protect flag; bit 1: fast read flag; bit 2: AAI flag; bit 3: support status2; bit 4: support dual io read; bit 5: support dual read
+		*  bit 6: support quad io read; bit 7: support quad read; bit 8: support dual io write; bit 9: support dual write; bit 10: support quad io write
+		*  bit 11: support quad write; bit 12: support 4k erase sector; bit 13: support status3; bit 14: support no QE ; bit 15:write status mode 
+		*/
+
+		/* 
+		*  flags = SFLAG_SECT_4K|SFLAG_COM_STATUS2|
+		*  SFLAG_DUAL_READ|SFLAG_QUAD_READ|SFLAG_DUAL_IO_READ|SFLAG_QUAD_IO_READ|SFLAG_QUAD_WRITE
+		*  wr_mode:
+		*	0:means one write status cmd can wirte all status regs; 1:means one write status cmd can only wirte one status reg
+		*  norflash-wr_flags: write wr startus regs count 
+		*/
+        norflash-flags = <0x18F8>;
+		rd_status_cmd = <0x05>, <0x35>, <0x15>;
+		wr_status_cmd = <0x01>, <0x31>, <0x11>;
+		wr_mode = <1>;
+		norflash-wr_flags = <2>;
+
+		/* status reg bit map */
+        norflash-b-wip = <0>;
+        norflash-b-wel = <1>;
+        norflash-b-bp0 = <2>;
+        norflash-b-bp1 = <3>;
+        norflash-b-bp2 = <4>;
+        norflash-b-srp0 = <7>;
+        norflash-b-srp1 = <8>;
+        norflash-b-qe = <9>; 
+        norflash-b-lb = <10>; 
+		norflash-b-cmp = <14>; 
+        norflash-b-sus = <15>; 
+
+        status = "disable";
+    };
+
+    fm25q128: spi-norflash@54 { 
+        compatible = "fm,fm25q128";
+        norflash-name = "fm25q128";
+		reg = <54>;
+		
+		/* spiflash fm25q128 */
+        norflash-jedec-id = <0xa14018>; 
+        norflash-ext-id = <0>;
+        norflash-sector-size = <0x10000>;
+        norflash-n-sectors = <256>; 
+
+		/**
+		*  flags:chip character bits:
+		*  bit 0: under_protect flag; bit 1: fast read flag; bit 2: AAI flag; bit 3: support status2; bit 4: support dual io read; bit 5: support dual read
+		*  bit 6: support quad io read; bit 7: support quad read; bit 8: support dual io write; bit 9: support dual write; bit 10: support quad io write
+		*  bit 11: support quad write; bit 12: support 4k erase sector; bit 13: support status3; bit 14: support no QE ; bit 15:write status mode 
+		*/
+
+		/* 
+		*  flags = SFLAG_SECT_4K|SFLAG_COM_STATUS2|
+		*  SFLAG_DUAL_READ|SFLAG_QUAD_READ|SFLAG_DUAL_IO_READ|SFLAG_QUAD_IO_READ|SFLAG_QUAD_WRITE
+		*  wr_mode:
+		*	0:means one write status cmd can wirte all status regs; 1:means one write status cmd can only wirte one status reg
+		*  norflash-wr_flags: write wr startus regs count 
+		*/
+        norflash-flags = <0x18F8>;
+		rd_status_cmd = <0x05>, <0x35>, <0x15>;
+		wr_status_cmd = <0x01>, <0x31>, <0x11>;
+		wr_mode = <1>;
+		norflash-wr_flags = <2>;
+
+		/* status reg bit map */
+        norflash-b-wip = <0>;
+        norflash-b-wel = <1>;
+        norflash-b-bp0 = <2>;
+        norflash-b-bp1 = <3>;
+        norflash-b-bp2 = <4>;
+		norflash-b-cmp = <6>; 
+        norflash-b-srp0 = <7>;
+        norflash-b-qe = <9>; 
+
+        status = "disable";
+    };
+
+    zb25vq32: spi-norflash@55 { 
+        compatible = "zb,zb25vq32";
+        norflash-name = "zb25vq32";
+		reg = <55>;
+		
+		/* spiflash zb25vq32 */
+        norflash-jedec-id = <0x5e4016>; 
+        norflash-ext-id = <0>;
+        norflash-sector-size = <0x8000>;
+        norflash-n-sectors = <128>; 
+
+		/**
+		*  flags:chip character bits:
+		*  bit 0: under_protect flag; bit 1: fast read flag; bit 2: AAI flag; bit 3: support status2; bit 4: support dual io read; bit 5: support dual read
+		*  bit 6: support quad io read; bit 7: support quad read; bit 8: support dual io write; bit 9: support dual write; bit 10: support quad io write
+		*  bit 11: support quad write; bit 12: support 4k erase sector; bit 13: support status3; bit 14: support no QE ; bit 15:write status mode 
+		*/
+
+		/* 
+		*  flags = SFLAG_SECT_4K|SFLAG_COM_STATUS2|
+		*  SFLAG_DUAL_READ|SFLAG_QUAD_READ|SFLAG_DUAL_IO_READ|SFLAG_QUAD_IO_READ|SFLAG_QUAD_WRITE
+		*  wr_mode:
+		*	0:means one write status cmd can wirte all status regs; 1:means one write status cmd can only wirte one status reg
+		*  norflash-wr_flags: write wr startus regs count 
+		*/
+        norflash-flags = <0x18F8>;
+		rd_status_cmd = <0x05>, <0x35>, <0x15>;
+		wr_status_cmd = <0x01>, <0x31>, <0x11>;
+		wr_mode = <1>;
+		norflash-wr_flags = <2>;
+
+		/* status reg bit map */
+        norflash-b-wip = <0>;
+        norflash-b-wel = <1>;
+        norflash-b-bp0 = <2>;
+        norflash-b-bp1 = <3>;
+        norflash-b-bp2 = <4>;
+        norflash-b-srp0 = <7>;
+        norflash-b-srp1 = <8>;
+        norflash-b-qe = <9>; 
+        norflash-b-lb = <10>; 
+		norflash-b-cmp = <14>; 
+        norflash-b-sus = <15>; 
+
+        status = "disable";
+    };
+
+    zd25q64a: spi-norflash@56 { 
+        compatible = "zd,zd25q64a";
+        norflash-name = "zd25q64a";
+		reg = <56>;
+		
+		/* spiflash zd25q64a */
+        norflash-jedec-id = <0xba4017>; 
+        norflash-ext-id = <0>;
+        norflash-sector-size = <0x10000>;
+        norflash-n-sectors = <128>; 
+
+		/**
+		*  flags:chip character bits:
+		*  bit 0: under_protect flag; bit 1: fast read flag; bit 2: AAI flag; bit 3: support status2; bit 4: support dual io read; bit 5: support dual read
+		*  bit 6: support quad io read; bit 7: support quad read; bit 8: support dual io write; bit 9: support dual write; bit 10: support quad io write
+		*  bit 11: support quad write; bit 12: support 4k erase sector; bit 13: support status3; bit 14: support no QE ; bit 15:write status mode 
+		*/
+
+		/* 
+		*  flags = SFLAG_SECT_4K|SFLAG_COM_STATUS2|
+		*  SFLAG_DUAL_READ|SFLAG_QUAD_READ|SFLAG_DUAL_IO_READ|SFLAG_QUAD_IO_READ|SFLAG_QUAD_WRITE
+		*  wr_mode:
+		*	0:means one write status cmd can wirte all status regs; 1:means one write status cmd can only wirte one status reg
+		*  norflash-wr_flags: write wr startus regs count 
+		*/
+        norflash-flags = <0x18F8>;
+		rd_status_cmd = <0x05>;
+		wr_status_cmd = <0x01>;
+		wr_mode = <0>;
+		norflash-wr_flags = <1>;
+
+		/* status reg bit map */
+        norflash-b-wip = <0>;
+        norflash-b-wel = <1>;
+        norflash-b-bp0 = <2>;
+        norflash-b-bp1 = <3>;
+        norflash-b-bp2 = <4>;
+        norflash-b-bp3 = <6>; 
+        norflash-b-srp0 = <7>;
+
+        status = "disable";
+    };
+
+    zb25vq64: spi-norflash@57 { 
+        compatible = "zb,zb25vq64";
+        norflash-name = "zb25vq64";
+		reg = <57>;
+		
+		/* spiflash zb25vq64 */
+        norflash-jedec-id = <0x5e4017>; 
+        norflash-ext-id = <0>;
+        norflash-sector-size = <0x10000>;
+        norflash-n-sectors = <128>; 
+
+		/**
+		*  flags:chip character bits:
+		*  bit 0: under_protect flag; bit 1: fast read flag; bit 2: AAI flag; bit 3: support status2; bit 4: support dual io read; bit 5: support dual read
+		*  bit 6: support quad io read; bit 7: support quad read; bit 8: support dual io write; bit 9: support dual write; bit 10: support quad io write
+		*  bit 11: support quad write; bit 12: support 4k erase sector; bit 13: support status3; bit 14: support no QE ; bit 15:write status mode 
+		*/
+
+		/* 
+		*  flags = SFLAG_SECT_4K|SFLAG_COM_STATUS2|
+		*  SFLAG_DUAL_READ|SFLAG_QUAD_READ|SFLAG_DUAL_IO_READ|SFLAG_QUAD_IO_READ|SFLAG_QUAD_WRITE
+		*  wr_mode:
+		*	0:means one write status cmd can wirte all status regs; 1:means one write status cmd can only wirte one status reg
+		*  norflash-wr_flags: write wr startus regs count 
+		*/
+        norflash-flags = <0x18F8>;
+		rd_status_cmd = <0x05>, <0x35>, <0x15>;
+		wr_status_cmd = <0x01>, <0x31>, <0x11>;
+		wr_mode = <1>;
+		norflash-wr_flags = <2>;
+
+		/* status reg bit map */
+        norflash-b-wip = <0>;
+        norflash-b-wel = <1>;
+        norflash-b-bp0 = <2>;
+        norflash-b-bp1 = <3>;
+        norflash-b-bp2 = <4>;
+        norflash-b-srp0 = <7>;
+        norflash-b-srp1 = <8>;
+        norflash-b-qe = <9>; 
+        norflash-b-lb = <10>; 
+		norflash-b-cmp = <14>; 
+        norflash-b-sus = <15>; 
+
+        status = "disable";
+    };
+
+    zb25vq128: spi-norflash@58 { 
+        compatible = "zb,zb25vq128";
+        norflash-name = "zb25vq128";
+		reg = <58>;
+		
+		/* spiflash zb25vq128 */
+        norflash-jedec-id = <0x5e4018>; 
+        norflash-ext-id = <0>;
+        norflash-sector-size = <0x10000>;
+        norflash-n-sectors = <256>; 
+
+		/**
+		*  flags:chip character bits:
+		*  bit 0: under_protect flag; bit 1: fast read flag; bit 2: AAI flag; bit 3: support status2; bit 4: support dual io read; bit 5: support dual read
+		*  bit 6: support quad io read; bit 7: support quad read; bit 8: support dual io write; bit 9: support dual write; bit 10: support quad io write
+		*  bit 11: support quad write; bit 12: support 4k erase sector; bit 13: support status3; bit 14: support no QE ; bit 15:write status mode 
+		*/
+
+		/* 
+		*  flags = SFLAG_SECT_4K|SFLAG_COM_STATUS2|
+		*  SFLAG_DUAL_READ|SFLAG_QUAD_READ|SFLAG_DUAL_IO_READ|SFLAG_QUAD_IO_READ|SFLAG_QUAD_WRITE
+		*  = 0x18F8
+		*  wr_mode:
+		*	0:means one write status cmd can wirte all status regs; 1:means one write status cmd can only wirte one status reg
+		*  norflash-wr_flags: write wr startus regs count 
+		*/
+        norflash-flags = <0x18F8>;
+		rd_status_cmd = <0x05>, <0x35>, <0x15>;
+		wr_status_cmd = <0x01>, <0x31>, <0x11>;
+		wr_mode = <1>;
+		norflash-wr_flags = <2>;
+
+		/* status reg bit map */
+        norflash-b-wip = <0>;
+        norflash-b-wel = <1>;
+        norflash-b-bp0 = <2>;
+        norflash-b-bp1 = <3>;
+        norflash-b-bp2 = <4>;
+        norflash-b-srp0 = <7>;
+        norflash-b-srp1 = <8>;
+        norflash-b-qe = <9>; 
+        norflash-b-lb = <10>; 
+		norflash-b-cmp = <14>; 
+        norflash-b-sus = <15>; 
+
+        status = "disable";
+    };
+};
+
diff --git a/arch/arm/boot/dts/anyka_ev501.dtsi b/arch/arm/boot/dts/anyka_ev501.dtsi
new file mode 100755
index 0000000..4b3b833
--- /dev/null
+++ b/arch/arm/boot/dts/anyka_ev501.dtsi
@@ -0,0 +1,102 @@
+/*
+ * AK37D 128M memory chip dts
+ *
+ * Copyright (C) 2018 Anyka(Guangzhou) Microelectronics Technology Co., Ltd.
+ *
+ * Author: Feilong Dong <dong_feilong@anyka.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include "anyka_ev500_common.dtsi"
+
+/ {
+    model = "anyka,ak3790d";
+    compatible = "anyka,ak3790d","anyka,ak3918ev501","anyka,ak3751d","anyka,ak3761d";
+
+	chosen {
+		/* No padding required - the uboot can do that. */
+		//bootargs = "console=ttySAK0,115200";
+		bootargs = "console=ttySAK0,115200n8 root=/dev/mtdblock6 rootfstype=squashfs init=/sbin/init mem=128M memsize=128M";
+	};
+
+	cpus {
+	    #address-cells = <1>;
+	    #size-cells = <0>;
+
+	    cpu@0 {
+	        compatible = "arm, arm926ej-s";
+	        device_type = "cpu";
+	        reg = <0>;
+	        d-cache-line-size = <32>;  // 32 bytes
+	        i-cache-line-size = <32>;  // 32 bytes
+	        d-cache-size = <0x8000>;
+	        i-cache-size = <0x8000>;
+	        timebase-frequency = <0>;
+	        bus-frequency = <0>;
+	        clock-frequency = <0>;
+	    };
+	};
+
+    memory {
+	    device_type = "memory";
+	    reg = <0x80000000 0x08000000>;
+	};
+
+    reserved-memory {
+        #address-cells = <1>;
+        #size-cells = <1>;
+        ranges;
+        cma_reserved: cma_reserved@85C00000 {
+            compatible = "shared-dma-pool";
+            linux,cma-default;
+            reusable;
+            size = <0x800000>;
+            reg = <0x85C00000 0x800000>;
+            status = "okay";
+        };
+        dma_reserved: dma_reserved@81400000 {
+            /*compatible = "shared-dma-pool";*/
+            /*linux,cma-default;*/
+            /*reusable;*/
+            size = <0x4800000>;
+            reg = <0x81400000 0x4800000>;
+            status = "okay";
+        };
+    };
+
+    ion {
+        compatible = "anyka,ak3790d-ion-reserve";
+        memory-region = <&cma_reserved>, <&dma_reserved>;
+        #address-cells = <1>;
+        #size-cells = <1>;
+        heaps-nr = <2>;
+        ranges;
+
+        cma_reserved_heap: cma_reserved_heap {
+            compatible = "anyka,cma-reserve";
+            ion-id = <0>;
+            base-address = <0x85C00000>;
+            size = <0x800000>;
+            align = <0x4>;
+            status = "okay";
+        };
+
+        dma_reserved_heap: dma_reserved_heap {
+            compatible = "anyka,dma-reserve";
+            ion-id = <1>;
+            base-address = <0x81400000>;
+            size = <0x4800000>;
+            align = <0x4>;
+            status = "okay";
+        };
+    };
+};
diff --git a/arch/arm/boot/dts/c500_cbd_ak3760d_dsi_v1.0.0.dts b/arch/arm/boot/dts/c500_cbd_ak3760d_dsi_v1.0.0.dts
new file mode 100755
index 0000000..4e6fd25
--- /dev/null
+++ b/arch/arm/boot/dts/c500_cbd_ak3760d_dsi_v1.0.0.dts
@@ -0,0 +1,684 @@
+/*
+ * AK37D dev board dts
+ *
+ * Copyright (C) 2018 Anyka(Guangzhou) Microelectronics Technology Co., Ltd.
+ *
+ * Author: Feilong Dong <dong_feilong@anyka.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+/dts-v1/;
+#include "anyka_ev500.dtsi"
+#include "anyka_ev500_lcd.dtsi"
+#include "anyka_ev500_norflash.dtsi"
+#include "anyka_ev500_nandflash1.dtsi"
+
+/ {
+    compatible = "anyka,ak3790d";
+    model = "AK3760D dev board";
+	version = "V1.0.02";
+};
+
+&gpio {
+    /* anyka,function sharepin func index according to table 2-1 sharepin-list */
+    /* index: 0: PIN default func, 1: FUNCTION1, 2: FUNCTION2, 3: FUNCTION3, 4: FUNCTION4 */
+    /* anyka,pull config value bit[31:24]--slew rate, bit[23:16]--ie, bit[15:8]--drive, bit[7:0]--pupd config */
+    /* bit[31:24]--slew rate, 0: slow, 1: fast */
+    /* bit[23:16]--ie, input enable, 0: disable, 1: enable */
+    /* bit[15:8]--drive, drive strength, 4levels value: 0x0-0x3 */
+    /* bit[7:0]--bit[7]: open drain 0:disable, 1:enable (only for gpio31/32);
+				pupd config, bit[6:4] 1:enable/ 0:disable, bit[3:0] 0:select PU /1:select PD */
+
+    ircut_pins: ircut_pins {
+        anyka,pins = <71>;
+        anyka,function = <0>;
+        anyka,pull = <0x01010310>;
+    };
+
+    dvp12bits_pins: dvp12bits_pins {
+        anyka,pins = <25 26 27 28 109 110 111 112 113 114 115 116 117 118 119 120>;
+        anyka,function = <1>;
+        anyka,pull = <0x01010310>;
+    };
+
+    dvp10bits_pins: dvp10bits_pins {
+        //anyka,pins = <25 26 27 28 109 110 111 112 113 114 115 116 117 118>;
+        anyka,pins = <25 26 27 28 109 110 111 112 113 114 115 116 117 118 119 120>;
+        anyka,function = <1>;
+        anyka,pull = <0x01010310>;
+    };
+
+    dvp8bits_pins: dvp8bits_pins {
+        //anyka,pins = <25 26 27 28 109 110 111 112 113 114 115 116>;
+        anyka,pins = <25 26 27 28 109 110 111 112 113 114 115 116 117 118 119 120>;
+        anyka,function = <1>;
+        anyka,pull = <0x01010310>;
+    };
+
+    mipi0_2lane_pins: mipi0_2lane_pins {
+        anyka,pins = <25 115 116 117 118 119 120>;
+        anyka,function = <1 2 2 2 2 2 2>;
+        anyka,pull = <0x01010310>;
+    };
+
+    mipi0_1lane_pins: mipi0_1lane_pins {
+        anyka,pins = <25 117 118 119 120>;
+        anyka,function = <1 2 2 2 2>;
+        anyka,pull = <0x01010310>;
+    };
+
+    mipi1_2lane_pins: mipi1_2lane_pins {
+        anyka,pins = <26 109 110 111 112 113 114>;
+        anyka,function = <1 2 2 2 2 2 2>;
+        anyka,pull = <0x01010310>;
+    };
+
+    mipi1_1lane_pins: mipi1_1lane_pins {
+        anyka,pins = <26 111 112 113 114>;
+        anyka,function = <1 2 2 2 2>;
+        anyka,pull = <0x01010310>;
+    };
+
+    csi0_sclk_pin: csi0_sclk_pin {
+        anyka,pins = <25>;
+        anyka,function = <1>;
+        anyka,pull = <0x01010310>;
+    };
+
+    csi1_sclk_pin: csi1_sclk_pin {
+        anyka,pins = <26>;
+        anyka,function = <1>;
+        anyka,pull = <0x01010310>;
+    };
+
+    i2c0_pins: i2c0_pins {
+        anyka,pins = <31 32>;
+        anyka,function = <1>;
+        anyka,pull = <0x01010380>;
+        //anyka,pull = <0x01011110>;
+    };
+
+    mci0_pins: mci0_pins {
+        anyka,pins = <33 34 35 36 37 38 39 40 41 42>;
+        anyka,function = <1>;
+        anyka,pull = <0x10010 0x10010 0x10010 0x10010 0x10010 0x10010 0x10010 0x10010 0x10010 0x10010>;/* 4 line */ 
+    };
+
+    mci1_pins: mci1_pins {
+        anyka,pins = <43 44 45 46 47 48>;
+        anyka,function = <1>;
+        anyka,pull = <0x10010 0x10000 0x10010 0x10010 0x10010 0x10010>; /* 4 line */
+
+        /* 1 line */
+        /*
+        anyka,pins = <43 44 45>;
+        anyka,function = <1>;
+        anyka,pull = <0x10010 0x10000 0x10010>;*/
+    };
+    
+    mci2_pins: mci2_pins {
+    /*
+        anyka,pins = <91 92 93 94 95 96>;
+        anyka,function = <2 2 3 3 3 3>;
+        anyka,pull = <0x01010010 0x01010010 0x01010010 0x01010010 0x01010010 0x01010010>;
+    */
+	    // 1 line with D[1] as sdio interrupt pin
+        anyka,pins = <93 94 95 96>;
+        anyka,function = <3>;
+        anyka,pull = <0x01010010 0x01010010 0x01010010 0x01010010>;
+    };
+
+    mmc_power_pins:mmc_power_pins{
+        anyka,pins = <81>;
+	    anyka,function = <0>;
+        anyka,pull = <0x01000310>;
+    };
+
+    sdio_wifi_pins:sdio_wifi_pins{
+        anyka,pins = <72>;
+	    anyka,function = <0>;
+        anyka,pull = <0x01000310>;
+    };
+
+    spiflash_pins: spiflash_pins {
+        anyka,pins = <12 82 67 68 69 70>; /* 4 LINE mode, 12 is spi nor cs, 18 is spinand cs*/
+        anyka,function = <1 0 0 0 0 0>;
+        anyka,pull = <0x01010010>;
+    };
+
+    lcd_reset_pins: lcd_reset_pins {
+	    anyka,pins = <83>;
+	    anyka,function = <0>;
+        anyka,pull = <0x01000310>;
+    };
+
+	gpiokey_pins:gpiokey_pins {
+			anyka,pins = <74>;
+			anyka,function = <0>;
+			anyka,pull = <0x01010010>;
+		};
+
+	ts_irq_pins:ts_irq_pins {
+			anyka,pins = <78>;
+			anyka,function = <0>;
+			anyka,pull = <0x01010111>;
+		};
+				
+    /*speak_en and linein_detect gpio setting */
+    speak_pins: speak_pins {
+        anyka,pins = <76>; 
+        anyka,function = <0>;
+        anyka,pull = <0x01010010>;
+    };
+    
+    uart0_pins: uart0_pins {
+        anyka,pins = <1 2>;
+        anyka,function = <1>;
+        anyka,pull = <0x01010010>;
+    };
+    
+    i2c2_pins: i2c2_pins {
+        anyka,pins = <97 98>;
+        anyka,function = <3>;
+        anyka,pull = <0x01011110>;
+    };
+
+	phy_reset_pins: phy_reset_pins {		
+		anyka,pins = <80>;		
+	    anyka,function = <0>;
+        anyka,pull = <0x01000010>;
+    };
+
+    gslX680_pins: gslX680_pins {
+		anyka,pins = <78 79>;
+	    anyka,function = <0>;
+        anyka,pull = <0x01000010>;
+    };
+
+    icn85xx_pins: icn85xx_pins {
+		anyka,pins = <36 38>;
+	    anyka,function = <0>;
+        anyka,pull = <0x01000010>;
+    };
+
+    ethernet_pins_rmii: ethernet_pins_rmii {
+		anyka,pins 		= <10 11 13 14 15 19 20 23 24 49>;
+        anyka,function 	= <1>;
+        anyka,pull = <0x01010011 0x01010010 0x01010011 0x01010011 0x01010011 0x01010011 0x01010011 0x01010011 0x01010011 0x01010110>;
+    };
+};
+
+&rtc {
+	   /* 
+	   ** rtc osc_source_select, 0 means INTERNAL RC OSC, 1 means EXTERNAL XTAL 
+	   */
+		osc-select = <0>;
+    status = "okay";
+};
+
+&watchdog {
+		/*max feed dog time = 357s, default setting time = 10s. */
+    def_heartbeat = <10>;
+    status = "okay";
+};
+
+&gui {
+    status = "okay";
+};
+
+&vencoder {
+    status = "okay";
+};
+
+&vdecoder {
+    status = "okay";
+};
+
+&usb {
+    status = "okay"; 
+};
+
+&mmc0 {
+    bus-width = <0x8>;
+    max-frequency = <50000000>;
+    /*
+     *  detect mode:
+     *  (1) non-removable;
+     *  (2) detect-gpio/detect-gpios: card detect using gpio
+     *      for example:
+     *      detect-gpio = <&gpio 77 1>;  or detect-gpios = <&gpio 77 1>;  
+     *  (3) cd_clk: card detect using MCLK
+     *  default is non-removable
+     */
+    cd_clk;
+    /* if support highspeed, using cap-sd-highspeed */
+    cap-sd-highspeed;
+    pinctrl-names = "default";
+    pinctrl-0 = <&mci0_pins>;
+    status = "disable";
+};
+
+&mmc1 {
+    bus-width = <0x4>;
+    max-frequency = <50000000>;
+    /*
+     *  detect mode:
+     *  (1) non-removable;
+     *  (2) detect-gpio/detect-gpios: card detect using gpio
+     *      for example:
+     *      detect-gpio = <&gpio 77 1>;  or detect-gpios = <&gpio 77 1>;  
+     *  (3) cd_clk: card detect using MCLK
+     *  default is non-removable
+     */
+    cd_clk;
+    /* if support highspeed, using cap-sd-highspeed */
+    cap-sd-highspeed;
+    pinctrl-names = "default";
+    pinctrl-0 = <&mci1_pins>,<&mmc_power_pins>;
+    power-pins = <&gpio 81 1>;
+    /* initial power pin value*/
+    power-pins-value = <0>; 
+    power-inverted;
+    status = "okay";
+};
+
+&mmc2 {
+    bus-width = <0x1>;
+    max-frequency = <50000000>;
+    /*
+     *  detect mode:
+     *  (1) non-removable;
+     *  (2) detect-gpio/detect-gpios: card detect using gpio
+     *      detect-gpio = <&gpio 77 1>;
+     *      or
+     *      detect-gpios = <&gpio 77 1>;
+     *  (3) cd_clk: card detect using MCLK
+     *  default is non-removable
+     */
+    non-removable;
+    /* if support sdio, using cap-sdio-irq*/
+    cap-sdio-irq;
+    /* if support highspeed, using cap-sd-highspeed */
+    cap-sd-highspeed;
+    pinctrl-names = "default";
+    pinctrl-0 = <&mci2_pins> , <&sdio_wifi_pins>;
+    power-pins = <&gpio 72 1>; 
+    /* initial power pin value*/
+    power-pins-value = <1>; 
+    status = "okay";
+};
+
+&dac {
+     pinctrl-names = "default";
+	   pinctrl-0 = <&speak_pins>;
+	   /* 
+	   ** speak-down,linein-detect,hp-mute,hp-detect
+	   ** 1 means enable these four function
+	   ** 0 means disable these four function
+	   */
+	   speak-down = <1>;
+	   linein-detect = <0>;
+	   hp-mute = <0>;
+	   hp-detect = <0>;
+	   speak-gpios = <&gpio 76 1>;
+	   //linein-gpios = <&gpio 54 1>;    
+     status = "okay";
+};	 
+
+&saradc{
+    /* SAR ADC VREF selection
+    * 0:To select AVCC 3.3V as VREF for SAR ADC.
+    * 1:To select 3.0V generated from BGR as VREF for SAR ADC.
+    */
+    vref-select = <1>;
+    /*
+    * 0:To disable BAT voltage divider. 
+    * 1:To enable BAT voltage divider divided by 2.
+    */
+    battery-divider = <1>;
+    /*
+    * Sampling number
+    * Read the sampling data for N times and then calculate the average value.
+    * N ranges from 1 to 7.
+    */
+     sampling-num = <3>;
+     status = "okay";
+};
+
+&spi0 {
+    pinctrl-names = "default";
+    pinctrl-0 = <&spiflash_pins>;
+    cs-gpios = <&gpio 12 1>, <&gpio 82 1>;
+    spi-bus-frequency = <80000000>;
+    status = "okay";
+};
+
+&spif0 {
+	status = "okay";
+};
+
+&spif1 {
+   	status = "okay";
+};
+
+&gd25q64{
+   	status = "okay";
+};
+
+&gd25q128{
+   	status = "okay";
+};
+
+
+&GD5F1GQ4UB {
+   	status = "okay";
+};
+
+&GD5F2GQ4UB {
+   	status = "okay";
+};
+
+
+&uart0 {
+    pinctrl-names = "default";
+	pinctrl-0 = <&uart0_pins>;
+    status = "okay";
+};
+
+&i2c0 {
+    pinctrl-names = "default";
+    pinctrl-0 = <&i2c0_pins>;
+    
+    clock-frequency = <312000>;
+    sda-delay = <100>;
+    status = "okay";
+	#address-cells = <1>;
+	#size-cells = <0>;
+    
+	sensor0: camera@0x30{
+		compatible = "anyka,sensor0";
+		reg = <0x30>;
+
+		/*0xffff means the gpio is invalid*/
+		reset-gpio = <&gpio 3 1>;
+		pwdn-gpio = <&gpio 0xffff 1>;
+
+		port {
+			sensor0_0: endpoint@0 {
+				remote-endpoint = <&vi_0_0>;
+			};
+		};
+	};
+};
+
+&i2c1 {
+    pinctrl-names = "default";
+    //pinctrl-0 = <&i2c1_pins>;
+    
+    clock-frequency = <312000>;
+    sda-delay = <100>;
+    status = "disable";
+};
+
+&i2c2 {
+    pinctrl-names = "default";
+    pinctrl-0 = <&i2c2_pins>;
+    
+    clock-frequency = <312000>;
+    sda-delay = <100>;
+    status = "okay";
+    
+    touch-screen@40 {
+		    compatible = "anyka,ak3790d-i2c-touchscreen-gslX680";
+		    reg = <0x40>;
+		    /* MIPI touch-pane irq and reset gpio setting */
+		    pinctrl-names = "default";
+            pinctrl-0 = <&gslX680_pins>;
+            irq-gpio = <&gpio 78 1>;
+            reset-gpio = <&gpio 79 1>;
+            TP_MAX_X = <1280>;
+            TP_MAX_Y = <800>;
+            status = "okay";
+	  };
+		       
+	  touch-screen@48 {
+		   compatible = "anyka,ak3790d-i2c-touchscreen-icn85xx";
+		    reg = <0x48>;
+		    /* RGB touch-pane irq and reset gpio setting */
+            pinctrl-names = "default";
+            pinctrl-0 = <&icn85xx_pins>;
+            irq-gpio = <&gpio 36 1>;
+            reset-gpio = <&gpio 38 1>;
+            TP_MAX_X = <1024>;
+            TP_MAX_Y = <600>;
+            status = "disable";
+	  }; 
+	  
+};
+
+&ethernet {
+    pinctrl-names = "default";
+    pinctrl-0 = <&ethernet_pins_rmii &phy_reset_pins>;
+    reset-gpios = <&gpio 80 1>;
+    status = "okay";
+};
+
+&ircut {
+    pinctrl-names = "default";
+    pinctrl-0 = <&ircut_pins>;
+
+	ircut-a = "71";
+	/*set the level for day mode. range: 0, 1*/
+	ircut-a-day-level = "0";
+	status = "okay";
+};
+
+&photosensitive {
+    //pinctrl-names = "default";
+    //pinctrl-0 = <&photosensitive_pins>;
+
+	/*range: saradc~1, gpio number*/
+	photosensitive-port = "saradc0";
+	/*the level for day mode, range: low, high*/
+	photosensitive-day-level = "high";
+	status = "okay";
+};
+
+&leds {
+	pinctrl-names = "default";
+	//pinctrl-0 = <&led_pins>;
+	led-gpios = <&gpio 29 1
+                 &gpio 30 1>;
+	status = "okay";
+};
+
+&adkeys {
+	status = "disable";
+};
+
+&gpiokeys {
+		#address-cells = <1>;
+		#size-cells = <0>;
+		pinctrl-0 = <&gpiokey_pins>;
+		pinctrl-names = "default";
+		
+	key_detect {
+		label = "key_detect";
+		gpios = <&gpio 74 1>;
+		linux,code = <116>;
+		debounce-interval = <100>;
+		wakeup-source;
+	};
+	
+	//status = "okay";
+};
+
+
+&motor0 {
+	status = "disable";
+};
+
+&motor1 {
+	status = "disable";
+};
+
+&pwm0 {
+	pinctrl-names = "default";
+
+	//pinctrl-0 = <&pwm0_pins>;
+	/*
+	**frequency of PWM ranges from 92H to 6MHz.
+	**duty of PWM ranges from 1 to 65535.
+	**Minimum duty cycle:1/65536
+	**Maximum duty cyscle:65535/65536.
+	**period-ns: period of the PWM signal (in nanoseconds)
+        **duty-ns: duty cycle of the PWM signal (in nanoseconds)
+	**pwm-enable = 0 means disable pwm function.
+	**pwm-enable = 1 means enable pwm function.
+	*/
+	period-ns = <1000000>;
+	duty-ns = <500000>;
+	pwm-enable = <1>;
+	status = "disable";
+};
+
+&pwm1 {
+	pinctrl-names = "default";
+
+	//pinctrl-0 = <&pwm1_pins>;
+	/*
+	**frequency of PWM ranges from 92H to 6MHz.
+	**duty of PWM ranges from 1 to 65535.
+	**Minimum duty cycle:1/65536
+	**Maximum duty cyscle:65535/65536.
+	**period-ns: period of the PWM signal (in nanoseconds)
+        **duty-ns: duty cycle of the PWM signal (in nanoseconds)
+	**pwm-enable = 0 means disable pwm function.
+	**pwm-enable = 1 means enable pwm function.
+	*/
+	period-ns = <1000000>;
+	duty-ns = <500000>;
+	pwm-enable = <1>;
+	status = "disable";
+};
+
+&pwm2 {
+	pinctrl-names = "default";
+
+	//pinctrl-0 = <&pwm2_pins>;
+	/*
+	**frequency of PWM ranges from 92H to 6MHz.
+	**duty of PWM ranges from 1 to 65535.
+	**Minimum duty cycle:1/65536
+	**Maximum duty cyscle:65535/65536.
+	**period-ns: period of the PWM signal (in nanoseconds)
+        **duty-ns: duty cycle of the PWM signal (in nanoseconds)
+	**pwm-enable = 0 means disable pwm function.
+	**pwm-enable = 1 means enable pwm function.
+	*/
+	period-ns = <1000000>;
+	duty-ns = <500000>;
+	pwm-enable = <1>;
+	status = "disable";
+};
+
+&pwm3 {
+	pinctrl-names = "default";
+
+	//pinctrl-0 = <&pwm3_pins>;
+	/*
+	**frequency of PWM ranges from 92H to 6MHz.
+	**duty of PWM ranges from 1 to 65535.
+	**Minimum duty cycle:1/65536
+	**Maximum duty cyscle:65535/65536.
+	**period-ns: period of the PWM signal (in nanoseconds)
+        **duty-ns: duty cycle of the PWM signal (in nanoseconds)
+	**pwm-enable = 0 means disable pwm function.
+	**pwm-enable = 1 means enable pwm function.
+	*/
+	period-ns = <1000000>;
+	duty-ns = <500000>;
+	pwm-enable = <1>;
+	status = "disable";
+};
+
+&pwm4 {
+	pinctrl-names = "default";
+	//pinctrl-0 = <&pwm4_pins>;
+	/*
+	**frequency of PWM ranges from 92H to 6MHz.
+	**duty of PWM ranges from 1 to 65535.
+	**Minimum duty cycle:1/65536
+	**Maximum duty cyscle:65535/65536.
+	**period-ns: period of the PWM signal (in nanoseconds)
+        **duty-ns: duty cycle of the PWM signal (in nanoseconds)
+	**pwm-enable = 0 means disable pwm function.
+	**pwm-enable = 1 means enable pwm function.
+	*/
+	period-ns = <1000000>;
+	duty-ns = <500000>;
+	pwm-enable = <1>;
+	status = "disable";
+};
+
+&lcdc {
+    pinctrl-names = "default";
+    pinctrl-0 = <&lcd_reset_pins>; //<&lcd_pins>,<&lcd_reset_pins>; //lcd_pins for rgb lcd, lcd_reset_pins only for mipi lcd
+    reset-pins = <&gpio 83 1>; //only for mipi lcd
+    
+    lcd-logo-width = <600>;
+    lcd-logo-height = <165>;
+    //[fmt1:fmt0] 00 16bits input(RGB565 or BGR565)
+    //[fmt1:fmt0] 01 24bits input(RGB888 or BGR888)
+    //[fmt1:fmt0] 10 or 11 32bits input(ARGB888 ABGR888 RGBA888 BGRA888)
+    lcd-logo-fmt0 = <1>;
+    lcd-logo-fmt1 = <0>;
+    lcd-logo-rgb-seq = <1>; //0 for BGR, 1 for RGB
+    
+    lcd-fb-type = <1>; //0:single buffer; 1:double buffer
+    status = "okay";
+};
+
+&sat101cp40 {
+    status = "okay";
+};
+
+
+&sat101at40 {
+    status = "disable";
+};
+
+&vi0{
+	pinctrl-names = "dvp12bits", "dvp10bits", "dvp8bits",
+		"mipi0_2lane", "mipi0_1lane", "mipi1_2lane", "mipi1_1lane",
+		"csi0_sclk", "csi1_sclk";
+    pinctrl-0 = <&dvp12bits_pins>;
+    pinctrl-1 = <&dvp10bits_pins>;
+    pinctrl-2 = <&dvp8bits_pins>;
+    pinctrl-3 = <&mipi0_2lane_pins>;
+    pinctrl-4 = <&mipi0_1lane_pins>;
+    pinctrl-5 = <&mipi1_2lane_pins>;
+    pinctrl-6 = <&mipi1_1lane_pins>;
+    pinctrl-7 = <&csi0_sclk_pin>;
+    pinctrl-8 = <&csi1_sclk_pin>;
+    status = "okay";
+
+	port@0 {
+		#address-cells = <1>;
+		#size-cells = <0>;
+
+		vi_0_0: endpoint@0 {
+			reg = <0>;
+			remote-endpoint = <&sensor0_0>;
+		};
+	};
+};
diff --git a/arch/arm/boot/dts/c500_cbd_ak3760d_dsi_v1.0.0_spinand.dts b/arch/arm/boot/dts/c500_cbd_ak3760d_dsi_v1.0.0_spinand.dts
new file mode 100755
index 0000000..f22faca
--- /dev/null
+++ b/arch/arm/boot/dts/c500_cbd_ak3760d_dsi_v1.0.0_spinand.dts
@@ -0,0 +1,676 @@
+/*
+ * AK37D dev board dts
+ *
+ * Copyright (C) 2018 Anyka(Guangzhou) Microelectronics Technology Co., Ltd.
+ *
+ * Author: Feilong Dong <dong_feilong@anyka.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+/dts-v1/;
+#include "anyka_ev500.dtsi"
+#include "anyka_ev500_lcd.dtsi"
+#include "anyka_ev500_nandflash0.dtsi"
+
+/ {
+    compatible = "anyka,ak3790d";
+    model = "AK3760D dev board";
+	version = "V1.0.02";
+
+	chosen {
+		/* No padding required - the uboot can do that. */
+		bootargs = "console=ttySAK0,115200n8 root=/dev/mtdblock6 rootfstype=yaffs2 init=/sbin/init mem=64M memsize=64M";
+	};
+};
+
+&gpio {
+    /* anyka,function sharepin func index according to table 2-1 sharepin-list */
+    /* index: 0: PIN default func, 1: FUNCTION1, 2: FUNCTION2, 3: FUNCTION3, 4: FUNCTION4 */
+    /* anyka,pull config value bit[31:24]--slew rate, bit[23:16]--ie, bit[15:8]--drive, bit[7:0]--pupd config */
+    /* bit[31:24]--slew rate, 0: slow, 1: fast */
+    /* bit[23:16]--ie, input enable, 0: disable, 1: enable */
+    /* bit[15:8]--drive, drive strength, 4levels value: 0x0-0x3 */
+    /* bit[7:0]--bit[7]: open drain 0:disable, 1:enable (only for gpio31/32);
+				pupd config, bit[6:4] 1:enable/ 0:disable, bit[3:0] 0:select PU /1:select PD */
+
+    ircut_pins: ircut_pins {
+        anyka,pins = <71>;
+        anyka,function = <0>;
+        anyka,pull = <0x01010310>;
+    };
+
+    dvp12bits_pins: dvp12bits_pins {
+        anyka,pins = <25 26 27 28 109 110 111 112 113 114 115 116 117 118 119 120>;
+        anyka,function = <1>;
+        anyka,pull = <0x01010310>;
+    };
+
+    dvp10bits_pins: dvp10bits_pins {
+        //anyka,pins = <25 26 27 28 109 110 111 112 113 114 115 116 117 118>;
+        anyka,pins = <25 26 27 28 109 110 111 112 113 114 115 116 117 118 119 120>;
+        anyka,function = <1>;
+        anyka,pull = <0x01010310>;
+    };
+
+    dvp8bits_pins: dvp8bits_pins {
+        //anyka,pins = <25 26 27 28 109 110 111 112 113 114 115 116>;
+        anyka,pins = <25 26 27 28 109 110 111 112 113 114 115 116 117 118 119 120>;
+        anyka,function = <1>;
+        anyka,pull = <0x01010310>;
+    };
+
+    mipi0_2lane_pins: mipi0_2lane_pins {
+        anyka,pins = <25 115 116 117 118 119 120>;
+        anyka,function = <1 2 2 2 2 2 2>;
+        anyka,pull = <0x01010310>;
+    };
+
+    mipi0_1lane_pins: mipi0_1lane_pins {
+        anyka,pins = <25 117 118 119 120>;
+        anyka,function = <1 2 2 2 2>;
+        anyka,pull = <0x01010310>;
+    };
+
+    mipi1_2lane_pins: mipi1_2lane_pins {
+        anyka,pins = <26 109 110 111 112 113 114>;
+        anyka,function = <1 2 2 2 2 2 2>;
+        anyka,pull = <0x01010310>;
+    };
+
+    mipi1_1lane_pins: mipi1_1lane_pins {
+        anyka,pins = <26 111 112 113 114>;
+        anyka,function = <1 2 2 2 2>;
+        anyka,pull = <0x01010310>;
+    };
+
+    csi0_sclk_pin: csi0_sclk_pin {
+        anyka,pins = <25>;
+        anyka,function = <1>;
+        anyka,pull = <0x01010310>;
+    };
+
+    csi1_sclk_pin: csi1_sclk_pin {
+        anyka,pins = <26>;
+        anyka,function = <1>;
+        anyka,pull = <0x01010310>;
+    };
+
+    i2c0_pins: i2c0_pins {
+        anyka,pins = <31 32>;
+        anyka,function = <1>;
+        anyka,pull = <0x01010380>;
+        //anyka,pull = <0x01011110>;
+    };
+
+    mci0_pins: mci0_pins {
+        anyka,pins = <33 34 35 36 37 38 39 40 41 42>;
+        anyka,function = <1>;
+        anyka,pull = <0x10010 0x10010 0x10010 0x10010 0x10010 0x10010 0x10010 0x10010 0x10010 0x10010>;/* 4 line */ 
+    };
+
+    mci1_pins: mci1_pins {
+        anyka,pins = <43 44 45 46 47 48>;
+        anyka,function = <1>;
+        anyka,pull = <0x10010 0x10000 0x10010 0x10010 0x10010 0x10010>; /* 4 line */
+
+        /* 1 line */
+        /*
+        anyka,pins = <43 44 45>;
+        anyka,function = <1>;
+        anyka,pull = <0x10010 0x10000 0x10010>;*/
+    };
+    
+    mci2_pins: mci2_pins {
+    /*
+        anyka,pins = <91 92 93 94 95 96>;
+        anyka,function = <2 2 3 3 3 3>;
+        anyka,pull = <0x01010010 0x01010010 0x01010010 0x01010010 0x01010010 0x01010010>;
+    */
+	    // 1 line with D[1] as sdio interrupt pin
+        anyka,pins = <93 94 95 96>;
+        anyka,function = <3>;
+        anyka,pull = <0x01010010 0x01010010 0x01010010 0x01010010>;
+    };
+
+    mmc_power_pins:mmc_power_pins{
+        anyka,pins = <81>;
+	    anyka,function = <0>;
+        anyka,pull = <0x01000310>;
+    };
+
+    sdio_wifi_pins:sdio_wifi_pins{
+        anyka,pins = <72>;
+	    anyka,function = <0>;
+        anyka,pull = <0x01000310>;
+    };
+
+    spiflash_pins: spiflash_pins {
+        anyka,pins = <12 82 67 68 69 70>; /* 4 LINE mode, 12 is spi nor cs, 18 is spinand cs*/
+        anyka,function = <1 0 0 0 0 0>;
+        anyka,pull = <0x01010010>;
+    };
+
+    lcd_reset_pins: lcd_reset_pins {
+	    anyka,pins = <83>;
+	    anyka,function = <0>;
+        anyka,pull = <0x01000310>;
+    };
+
+	gpiokey_pins:gpiokey_pins {
+			anyka,pins = <74>;
+			anyka,function = <0>;
+			anyka,pull = <0x01010010>;
+		};
+
+	ts_irq_pins:ts_irq_pins {
+			anyka,pins = <78>;
+			anyka,function = <0>;
+			anyka,pull = <0x01010111>;
+		};
+				
+    /*speak_en and linein_detect gpio setting */
+    speak_pins: speak_pins {
+        anyka,pins = <76>; 
+        anyka,function = <0>;
+        anyka,pull = <0x01010010>;
+    };
+    
+    uart0_pins: uart0_pins {
+        anyka,pins = <1 2>;
+        anyka,function = <1>;
+        anyka,pull = <0x01010010>;
+    };
+    
+    i2c2_pins: i2c2_pins {
+        anyka,pins = <97 98>;
+        anyka,function = <3>;
+        anyka,pull = <0x01011110>;
+    };
+
+	phy_reset_pins: phy_reset_pins {		
+		anyka,pins = <80>;		
+	    anyka,function = <0>;
+        anyka,pull = <0x01000010>;
+    };
+
+    gslX680_pins: gslX680_pins {
+        anyka,pins = <78 79>;
+        anyka,function = <0>;
+        anyka,pull = <0x01000010>;
+    };
+
+    icn85xx_pins: icn85xx_pins {
+        anyka,pins = <36 38>;
+        anyka,function = <0>;
+        anyka,pull = <0x01000010>;
+    };
+
+    ethernet_pins_rmii: ethernet_pins_rmii {
+		anyka,pins 		= <10 11 13 14 15 19 20 23 24 49>;
+        anyka,function 	= <1>;
+        anyka,pull = <0x01010011 0x01010010 0x01010011 0x01010011 0x01010011 0x01010011 0x01010011 0x01010011 0x01010011 0x01010110>;
+    };
+};
+
+&rtc {
+	   /* 
+	   ** rtc osc_source_select, 0 means INTERNAL RC OSC, 1 means EXTERNAL XTAL 
+	   */
+		osc-select = <0>;
+    status = "okay";
+};
+
+&watchdog {
+		/*max feed dog time = 357s, default setting time = 10s. */
+    def_heartbeat = <10>;
+    status = "okay";
+};
+
+&gui {
+    status = "okay";
+};
+
+&vencoder {
+    status = "okay";
+};
+
+&vdecoder {
+    status = "okay";
+};
+
+&usb {
+    status = "okay"; 
+};
+
+&mmc0 {
+    bus-width = <0x8>;
+    max-frequency = <50000000>;
+    /*
+     *  detect mode:
+     *  (1) non-removable;
+     *  (2) detect-gpio/detect-gpios: card detect using gpio
+     *      for example:
+     *      detect-gpio = <&gpio 77 1>;  or detect-gpios = <&gpio 77 1>;  
+     *  (3) cd_clk: card detect using MCLK
+     *  default is non-removable
+     */
+    cd_clk;
+    /* if support highspeed, using cap-sd-highspeed */
+    cap-sd-highspeed;
+    pinctrl-names = "default";
+    pinctrl-0 = <&mci0_pins>;
+    status = "disable";
+};
+
+&mmc1 {
+    bus-width = <0x4>;
+    max-frequency = <50000000>;
+    /*
+     *  detect mode:
+     *  (1) non-removable;
+     *  (2) detect-gpio/detect-gpios: card detect using gpio
+     *      for example:
+     *      detect-gpio = <&gpio 77 1>;  or detect-gpios = <&gpio 77 1>;  
+     *  (3) cd_clk: card detect using MCLK
+     *  default is non-removable
+     */
+    cd_clk;
+    /* if support highspeed, using cap-sd-highspeed */
+    cap-sd-highspeed;
+    pinctrl-names = "default";
+    pinctrl-0 = <&mci1_pins>,<&mmc_power_pins>;
+    power-pins = <&gpio 81 1>;
+    /* initial power pin value*/
+    power-pins-value = <0>; 
+    power-inverted;
+    status = "okay";
+};
+
+&mmc2 {
+    bus-width = <0x1>;
+    max-frequency = <50000000>;
+    /*
+     *  detect mode:
+     *  (1) non-removable;
+     *  (2) detect-gpio/detect-gpios: card detect using gpio
+     *      detect-gpio = <&gpio 77 1>;
+     *      or
+     *      detect-gpios = <&gpio 77 1>;
+     *  (3) cd_clk: card detect using MCLK
+     *  default is non-removable
+     */
+    non-removable;
+    /* if support sdio, using cap-sdio-irq*/
+    cap-sdio-irq;
+    /* if support highspeed, using cap-sd-highspeed */
+    cap-sd-highspeed;
+    pinctrl-names = "default";
+    pinctrl-0 = <&mci2_pins> , <&sdio_wifi_pins>;
+    power-pins = <&gpio 72 1>; 
+    /* initial power pin value*/
+    power-pins-value = <1>; 
+    status = "okay";
+};
+
+&dac {
+     pinctrl-names = "default";
+	   pinctrl-0 = <&speak_pins>;
+	   /* 
+	   ** speak-down,linein-detect,hp-mute,hp-detect
+	   ** 1 means enable these four function
+	   ** 0 means disable these four function
+	   */
+	   speak-down = <1>;
+	   linein-detect = <0>;
+	   hp-mute = <0>;
+	   hp-detect = <0>;
+	   speak-gpios = <&gpio 76 1>;
+	   //linein-gpios = <&gpio 54 1>;    
+     status = "okay";
+};	 
+
+&saradc{
+    /* SAR ADC VREF selection
+    * 0:To select AVCC 3.3V as VREF for SAR ADC.
+    * 1:To select 3.0V generated from BGR as VREF for SAR ADC.
+    */
+    vref-select = <1>;
+    /*
+    * 0:To disable BAT voltage divider. 
+    * 1:To enable BAT voltage divider divided by 2.
+    */
+    battery-divider = <1>;
+    /*
+    * Sampling number
+    * Read the sampling data for N times and then calculate the average value.
+    * N ranges from 1 to 7.
+    */
+     sampling-num = <3>;
+     status = "okay";
+};
+
+&spi0 {
+    pinctrl-names = "default";
+    pinctrl-0 = <&spiflash_pins>;
+    cs-gpios = <&gpio 12 1>, <&gpio 82 1>;
+    spi-bus-frequency = <80000000>;
+    status = "okay";
+};
+
+&spif0 {
+	compatible = "anyka,ak-spinand";
+	status = "okay";
+};
+
+&GD5F1GQ4UB {
+   	status = "okay";
+};
+
+&GD5F2GQ4UB {
+   	status = "okay";
+};
+
+
+&uart0 {
+    pinctrl-names = "default";
+	pinctrl-0 = <&uart0_pins>;
+    status = "okay";
+};
+
+&i2c0 {
+    pinctrl-names = "default";
+    pinctrl-0 = <&i2c0_pins>;
+    
+    clock-frequency = <312000>;
+    sda-delay = <100>;
+    status = "okay";
+	#address-cells = <1>;
+	#size-cells = <0>;
+    
+	sensor0: camera@0x30{
+		compatible = "anyka,sensor0";
+		reg = <0x30>;
+
+		/*0xffff means the gpio is invalid*/
+		reset-gpio = <&gpio 3 1>;
+		pwdn-gpio = <&gpio 0xffff 1>;
+
+		port {
+			sensor0_0: endpoint@0 {
+				remote-endpoint = <&vi_0_0>;
+			};
+		};
+	};
+};
+
+&i2c1 {
+    pinctrl-names = "default";
+    //pinctrl-0 = <&i2c1_pins>;
+    
+    clock-frequency = <312000>;
+    sda-delay = <100>;
+    status = "disable";
+};
+
+&i2c2 {
+    pinctrl-names = "default";
+    pinctrl-0 = <&i2c2_pins>;
+    
+    clock-frequency = <312000>;
+    sda-delay = <100>;
+    status = "okay";
+    
+    touch-screen@40 {
+		    compatible = "anyka,ak3790d-i2c-touchscreen-gslX680";
+		    reg = <0x40>;
+		    /* MIPI touch-pane irq and reset gpio setting */
+		    pinctrl-names = "default";
+            pinctrl-0 = <&gslX680_pins>;
+            irq-gpio = <&gpio 78 1>;
+            reset-gpio = <&gpio 79 1>;
+            TP_MAX_X = <1280>;
+            TP_MAX_Y = <800>;
+            status = "okay";
+	  };
+		       
+	  touch-screen@48 {
+		   compatible = "anyka,ak3790d-i2c-touchscreen-icn85xx";
+		    reg = <0x48>;
+		    /* RGB touch-pane irq and reset gpio setting */
+            pinctrl-names = "default";
+            pinctrl-0 = <&icn85xx_pins>;
+            irq-gpio = <&gpio 36 1>;
+            reset-gpio = <&gpio 38 1>;
+            TP_MAX_X = <1024>;
+            TP_MAX_Y = <600>;
+            status = "disable";
+	  }; 
+	  
+};
+
+&ethernet {
+    pinctrl-names = "default";
+    pinctrl-0 = <&ethernet_pins_rmii &phy_reset_pins>;
+    reset-gpios = <&gpio 80 1>;
+    status = "okay";
+};
+
+&ircut {
+    pinctrl-names = "default";
+    pinctrl-0 = <&ircut_pins>;
+
+	ircut-a = "71";
+	/*set the level for day mode. range: 0, 1*/
+	ircut-a-day-level = "0";
+	status = "okay";
+};
+
+&photosensitive {
+    //pinctrl-names = "default";
+    //pinctrl-0 = <&photosensitive_pins>;
+
+	/*range: saradc~1, gpio number*/
+	photosensitive-port = "saradc0";
+	/*the level for day mode, range: low, high*/
+	photosensitive-day-level = "high";
+	status = "okay";
+};
+
+&leds {
+	pinctrl-names = "default";
+	//pinctrl-0 = <&led_pins>;
+	led-gpios = <&gpio 29 1
+                 &gpio 30 1>;
+	status = "okay";
+};
+
+&adkeys {
+	status = "disable";
+};
+
+&gpiokeys {
+		#address-cells = <1>;
+		#size-cells = <0>;
+		pinctrl-0 = <&gpiokey_pins>;
+		pinctrl-names = "default";
+		
+	key_detect {
+		label = "key_detect";
+		gpios = <&gpio 74 1>;
+		linux,code = <116>;
+		debounce-interval = <100>;
+		wakeup-source;
+	};
+	
+	//status = "okay";
+};
+
+
+&motor0 {
+	status = "disable";
+};
+
+&motor1 {
+	status = "disable";
+};
+
+&pwm0 {
+	pinctrl-names = "default";
+
+	//pinctrl-0 = <&pwm0_pins>;
+	/*
+	**frequency of PWM ranges from 92H to 6MHz.
+	**duty of PWM ranges from 1 to 65535.
+	**Minimum duty cycle:1/65536
+	**Maximum duty cyscle:65535/65536.
+	**period-ns: period of the PWM signal (in nanoseconds)
+        **duty-ns: duty cycle of the PWM signal (in nanoseconds)
+	**pwm-enable = 0 means disable pwm function.
+	**pwm-enable = 1 means enable pwm function.
+	*/
+	period-ns = <1000000>;
+	duty-ns = <500000>;
+	pwm-enable = <1>;
+	status = "disable";
+};
+
+&pwm1 {
+	pinctrl-names = "default";
+
+	//pinctrl-0 = <&pwm1_pins>;
+	/*
+	**frequency of PWM ranges from 92H to 6MHz.
+	**duty of PWM ranges from 1 to 65535.
+	**Minimum duty cycle:1/65536
+	**Maximum duty cyscle:65535/65536.
+	**period-ns: period of the PWM signal (in nanoseconds)
+        **duty-ns: duty cycle of the PWM signal (in nanoseconds)
+	**pwm-enable = 0 means disable pwm function.
+	**pwm-enable = 1 means enable pwm function.
+	*/
+	period-ns = <1000000>;
+	duty-ns = <500000>;
+	pwm-enable = <1>;
+	status = "disable";
+};
+
+&pwm2 {
+	pinctrl-names = "default";
+
+	//pinctrl-0 = <&pwm2_pins>;
+	/*
+	**frequency of PWM ranges from 92H to 6MHz.
+	**duty of PWM ranges from 1 to 65535.
+	**Minimum duty cycle:1/65536
+	**Maximum duty cyscle:65535/65536.
+	**period-ns: period of the PWM signal (in nanoseconds)
+        **duty-ns: duty cycle of the PWM signal (in nanoseconds)
+	**pwm-enable = 0 means disable pwm function.
+	**pwm-enable = 1 means enable pwm function.
+	*/
+	period-ns = <1000000>;
+	duty-ns = <500000>;
+	pwm-enable = <1>;
+	status = "disable";
+};
+
+&pwm3 {
+	pinctrl-names = "default";
+
+	//pinctrl-0 = <&pwm3_pins>;
+	/*
+	**frequency of PWM ranges from 92H to 6MHz.
+	**duty of PWM ranges from 1 to 65535.
+	**Minimum duty cycle:1/65536
+	**Maximum duty cyscle:65535/65536.
+	**period-ns: period of the PWM signal (in nanoseconds)
+        **duty-ns: duty cycle of the PWM signal (in nanoseconds)
+	**pwm-enable = 0 means disable pwm function.
+	**pwm-enable = 1 means enable pwm function.
+	*/
+	period-ns = <1000000>;
+	duty-ns = <500000>;
+	pwm-enable = <1>;
+	status = "disable";
+};
+
+&pwm4 {
+	pinctrl-names = "default";
+	//pinctrl-0 = <&pwm4_pins>;
+	/*
+	**frequency of PWM ranges from 92H to 6MHz.
+	**duty of PWM ranges from 1 to 65535.
+	**Minimum duty cycle:1/65536
+	**Maximum duty cyscle:65535/65536.
+	**period-ns: period of the PWM signal (in nanoseconds)
+        **duty-ns: duty cycle of the PWM signal (in nanoseconds)
+	**pwm-enable = 0 means disable pwm function.
+	**pwm-enable = 1 means enable pwm function.
+	*/
+	period-ns = <1000000>;
+	duty-ns = <500000>;
+	pwm-enable = <1>;
+	status = "disable";
+};
+
+&lcdc {
+    pinctrl-names = "default";
+    pinctrl-0 = <&lcd_reset_pins>; //<&lcd_pins>,<&lcd_reset_pins>; //lcd_pins for rgb lcd, lcd_reset_pins only for mipi lcd
+    reset-pins = <&gpio 83 1>; //only for mipi lcd
+    
+    lcd-logo-width = <600>;
+    lcd-logo-height = <165>;
+    //[fmt1:fmt0] 00 16bits input(RGB565 or BGR565)
+    //[fmt1:fmt0] 01 24bits input(RGB888 or BGR888)
+    //[fmt1:fmt0] 10 or 11 32bits input(ARGB888 ABGR888 RGBA888 BGRA888)
+    lcd-logo-fmt0 = <1>;
+    lcd-logo-fmt1 = <0>;
+    lcd-logo-rgb-seq = <1>; //0 for BGR, 1 for RGB
+    
+    lcd-fb-type = <1>; //0:single buffer; 1:double buffer
+    status = "okay";
+};
+
+&sat101cp40 {
+    status = "okay";
+};
+
+
+&sat101at40 {
+    status = "disable";
+};
+
+&vi0{
+	pinctrl-names = "dvp12bits", "dvp10bits", "dvp8bits",
+		"mipi0_2lane", "mipi0_1lane", "mipi1_2lane", "mipi1_1lane",
+		"csi0_sclk", "csi1_sclk";
+    pinctrl-0 = <&dvp12bits_pins>;
+    pinctrl-1 = <&dvp10bits_pins>;
+    pinctrl-2 = <&dvp8bits_pins>;
+    pinctrl-3 = <&mipi0_2lane_pins>;
+    pinctrl-4 = <&mipi0_1lane_pins>;
+    pinctrl-5 = <&mipi1_2lane_pins>;
+    pinctrl-6 = <&mipi1_1lane_pins>;
+    pinctrl-7 = <&csi0_sclk_pin>;
+    pinctrl-8 = <&csi1_sclk_pin>;
+    status = "okay";
+
+	port@0 {
+		#address-cells = <1>;
+		#size-cells = <0>;
+
+		vi_0_0: endpoint@0 {
+			reg = <0>;
+			remote-endpoint = <&sensor0_0>;
+		};
+	};
+};
diff --git a/arch/arm/boot/dts/c500_cbd_ak3760d_rgb_v1.0.0.dts b/arch/arm/boot/dts/c500_cbd_ak3760d_rgb_v1.0.0.dts
new file mode 100755
index 0000000..d163d9b
--- /dev/null
+++ b/arch/arm/boot/dts/c500_cbd_ak3760d_rgb_v1.0.0.dts
@@ -0,0 +1,645 @@
+/*
+ * AK37D dev board dts
+ *
+ * Copyright (C) 2018 Anyka(Guangzhou) Microelectronics Technology Co., Ltd.
+ *
+ * Author: Feilong Dong <dong_feilong@anyka.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+/dts-v1/;
+#include "anyka_ev500.dtsi"
+#include "anyka_ev500_lcd.dtsi"
+#include "anyka_ev500_norflash.dtsi"
+
+/ {
+    compatible = "anyka,ak3790d";
+    model = "AK3760D dev board";
+	version = "V1.0.02";
+};
+
+&gpio {
+    /* anyka,function sharepin func index according to table 2-1 sharepin-list */
+    /* index: 0: PIN default func, 1: FUNCTION1, 2: FUNCTION2, 3: FUNCTION3, 4: FUNCTION4 */
+    /* anyka,pull config value bit[31:24]--slew rate, bit[23:16]--ie, bit[15:8]--drive, bit[7:0]--pupd config */
+    /* bit[31:24]--slew rate, 0: slow, 1: fast */
+    /* bit[23:16]--ie, input enable, 0: disable, 1: enable */
+    /* bit[15:8]--drive, drive strength, 4levels value: 0x0-0x3 */
+    /* bit[7:0]--bit[7]: open drain 0:disable, 1:enable (only for gpio31/32);
+				pupd config, bit[6:4] 1:enable/ 0:disable, bit[3:0] 0:select PU /1:select PD */
+
+    ircut_pins: ircut_pins {
+        anyka,pins = <42>;
+        anyka,function = <0>;
+        anyka,pull = <0x01010310>;
+    };
+
+    dvp12bits_pins: dvp12bits_pins {
+        anyka,pins = <25 26 27 28 109 110 111 112 113 114 115 116 117 118 119 120>;
+        anyka,function = <1>;
+        anyka,pull = <0x01010310>;
+    };
+
+    dvp10bits_pins: dvp10bits_pins {
+        //anyka,pins = <25 26 27 28 109 110 111 112 113 114 115 116 117 118>;
+        anyka,pins = <25 26 27 28 109 110 111 112 113 114 115 116 117 118 119 120>;
+        anyka,function = <1>;
+        anyka,pull = <0x01010310>;
+    };
+
+    dvp8bits_pins: dvp8bits_pins {
+        //anyka,pins = <25 26 27 28 109 110 111 112 113 114 115 116>;
+        anyka,pins = <25 26 27 28 109 110 111 112 113 114 115 116 117 118 119 120>;
+        anyka,function = <1>;
+        anyka,pull = <0x01010310>;
+    };
+
+    mipi0_2lane_pins: mipi0_2lane_pins {
+        anyka,pins = <25 115 116 117 118 119 120>;
+        anyka,function = <1 2 2 2 2 2 2>;
+        anyka,pull = <0x01010310>;
+    };
+
+    mipi0_1lane_pins: mipi0_1lane_pins {
+        anyka,pins = <25 117 118 119 120>;
+        anyka,function = <1 2 2 2 2>;
+        anyka,pull = <0x01010310>;
+    };
+
+    mipi1_2lane_pins: mipi1_2lane_pins {
+        anyka,pins = <26 109 110 111 112 113 114>;
+        anyka,function = <1 2 2 2 2 2 2>;
+        anyka,pull = <0x01010310>;
+    };
+
+    mipi1_1lane_pins: mipi1_1lane_pins {
+        anyka,pins = <26 111 112 113 114>;
+        anyka,function = <1 2 2 2 2>;
+        anyka,pull = <0x01010310>;
+    };
+
+    csi0_sclk_pin: csi0_sclk_pin {
+        anyka,pins = <25>;
+        anyka,function = <1>;
+        anyka,pull = <0x01010310>;
+    };
+
+    csi1_sclk_pin: csi1_sclk_pin {
+        anyka,pins = <26>;
+        anyka,function = <1>;
+        anyka,pull = <0x01010310>;
+    };
+
+    i2c0_pins: i2c0_pins {
+        anyka,pins = <31 32>;
+        anyka,function = <1>;
+        anyka,pull = <0x01010380>;
+        //anyka,pull = <0x01011110>;
+    };
+
+	mci1_pins: mci1_pins {
+        anyka,pins = <43 44 45 46 47 48>;
+        anyka,function = <1>;
+        anyka,pull = <0x10010 0x10000 0x10010 0x10010 0x10010 0x10010>;/* 4 line */
+
+        /* 1 line */
+        /*anyka,pins = <43 44 45>;*/
+        /*anyka,function = <1>;*/
+        /*anyka,pull = <0x10010 0x10000 0x10010>;*/  
+    };
+    
+    mci2_pins: mci2_pins {
+        //4 line with GPIO91-96
+        /*anyka,pins = <91 92 93 94 95 96>;
+        anyka,function = <2 2 3 3 3 3>;
+        anyka,pull = <0x01010010 0x01010010 0x01010010 0x01010010 0x01010010 0x01010010>; */
+
+        // 1 line with GPIO93-95
+        /*
+        anyka,pins = <93 94 95>;
+        anyka,function = <3>;
+        anyka,pull = <0x01010010 0x01010010 0x01010010>;*/
+
+        // 1 line with GPIO19 20 24, with 23 sdio irq pin
+        anyka,pins = <19 20  23 24>;
+        anyka,function = <2>;
+        anyka,pull = <0x01010010 0x01010010 0x01010010 0x01010010>;
+
+        // 4 line
+        /*
+        anyka,pins = <14 15 19 20  23 24>;
+        anyka,function = <2>;
+		anyka,pull = <0x01010010 0x01010010 0x01010010 0x01010010 0x01010010 0x01010010>;*/
+    };
+
+    spiflash_pins: spiflash_pins {
+        anyka,pins = <12 67 68 69 70>; /* 4 LINE mode, 12 is spi nor cs*/
+        anyka,function = <1 0 0 0 0>;
+        anyka,pull = <0x01010010>;
+    };
+
+		gpiokey_pins:gpiokey_pins {
+			anyka,pins = <39>;
+			anyka,function = <0>;
+			anyka,pull = <0x01010010>;
+		};
+		
+
+		/* gpio83 and gpio84  are used as i2c */
+    lcd_pins: lcd_pins {
+        anyka,pins = <74 71 72 73
+        	          75 76 77 78
+        	          79 80 81 82
+        	          85 86
+        	          87 88 89 90
+        	          91 92 93 94
+        	          95 96 97 98>;
+        anyka,function = <1>;
+        anyka,pull = <0x01010310>;
+    };
+    
+    uart0_pins: uart0_pins {
+        anyka,pins = <1 2>;
+        anyka,function = <1>;
+        anyka,pull = <0x01010010>;
+    };
+    
+    i2c2_pins: i2c2_pins {
+        anyka,pins = <83 84>;
+        anyka,function = <2>;
+        anyka,pull = <0x01011110>;
+    };
+
+     pwm4_pins: pwm4_pins {
+        anyka,pins = <41>;
+        anyka,function = <2>;
+        anyka,pull = <0x01011110>;
+    };
+
+    phy_reset_pins: phy_reset_pins {
+          anyka,pins = <23>;
+          anyka,function = <0>;
+        anyka,pull = <0x01000010>;
+    };
+
+    gslX680_pins: gslX680_pins {
+        anyka,pins = <78 79>;
+        anyka,function = <0>;
+        anyka,pull = <0x01000010>;
+    };
+
+    icn85xx_pins: icn85xx_pins {
+		anyka,pins = <36 38>;
+	    anyka,function = <0>;
+        anyka,pull = <0x01000010>;
+    };
+
+    ethernet_pins_rmii: ethernet_pins_rmii {
+		    anyka,pins 		= <10 11 13 14 15 19 20 24 49>;
+        anyka,function 	= <1>;
+        anyka,pull = <0x01010011 0x01010010 0x01010011 0x01010011 0x01010011 0x01010011 0x01010011  0x01010011 0x01010110>;
+    };
+};
+
+&rtc {
+	   /* 
+	   ** rtc osc_source_select, 0 means INTERNAL RC OSC, 1 means EXTERNAL XTAL 
+	   */
+		osc-select = <0>;
+    status = "okay";
+};
+
+&watchdog {
+	/*max feed dog time = 357s, default setting time = 10s. */
+    def_heartbeat = <10>;
+    status = "okay";
+};
+
+&gui {
+    status = "okay";
+};
+
+&vencoder {
+    status = "okay";
+};
+
+&vdecoder {
+    status = "okay";
+};
+
+&usb {
+    status = "okay"; 
+};
+
+
+&mmc1 {
+    bus-width = <0x4>;
+    max-frequency = <50000000>;
+    /*
+     *  detect mode:
+     *  (1) non-removable;
+     *  (2) detect-gpio/detect-gpios: card detect using gpio
+     *      for example:
+     *      detect-gpio = <&gpio 77 1>;  or detect-gpios = <&gpio 77 1>;  
+     *  (3) cd_clk: card detect using MCLK
+     *  default is non-removable
+     */
+    cd_clk;
+    /* if support highspeed, using cap-sd-highspeed */
+    cap-sd-highspeed;
+    pinctrl-names = "default";
+    pinctrl-0 = <&mci1_pins>;
+    status = "okay";
+};
+
+&mmc2 {
+    bus-width = <0x1>;
+    max-frequency = <50000000>;
+    /*
+     *  detect mode:
+     *  (1) non-removable;
+     *  (2) detect-gpio/detect-gpios: card detect using gpio
+     *      for example:
+     *      detect-gpio = <&gpio 77 1>;  or detect-gpios = <&gpio 77 1>;  
+     *  (3) cd_clk: card detect using MCLK
+     *  default is non-removable
+     */
+    non-removable;
+    /* if support sdio, using cap-sdio-irq*/
+    cap-sdio-irq;
+    /* if support highspeed, using cap-sd-highspeed */
+    cap-sd-highspeed;
+    pinctrl-names = "default";
+    pinctrl-0 = <&mci2_pins>;
+    status = "disable";
+};
+
+&dac {
+	pinctrl-names = "default";
+	//pinctrl-0 = <&speak_pins>;
+	/*
+	 ** speak-down,linein-detect,hp-mute,hp-detect
+	 ** 1 means enable these four function
+	 ** 0 means disable these four function
+	 */
+	speak-down = <1>;
+	linein-detect = <0>;
+	hp-mute = <0>;
+	hp-detect = <0>;
+	//speak-gpios = <&gpio 76 1>;
+	//linein-gpios = <&gpio 54 1>;
+	status = "okay";
+};
+
+&saradc{
+    /* SAR ADC VREF selection
+    * 0:To select AVCC 3.3V as VREF for SAR ADC.
+    * 1:To select 3.0V generated from BGR as VREF for SAR ADC.
+    */
+    vref-select = <1>;
+    /*
+    * 0:To disable BAT voltage divider. 
+    * 1:To enable BAT voltage divider divided by 2.
+    */
+    battery-divider = <1>;
+    /*
+    * Sampling number
+    * Read the sampling data for N times and then calculate the average value.
+    * N ranges from 1 to 7.
+    */
+     sampling-num = <3>;
+     status = "okay";
+};
+
+&spi0 {
+    pinctrl-names = "default";
+    pinctrl-0 = <&spiflash_pins>;
+    cs-gpios = <&gpio 12 1>;
+    spi-bus-frequency = <80000000>;
+    status = "okay";   
+
+};
+
+&spif0 {
+	status = "okay";
+};
+
+&gd25q64{
+   	status = "okay";
+};
+
+&gd25q128{
+   	status = "okay";
+};
+
+&uart0 {
+    pinctrl-names = "default";
+	pinctrl-0 = <&uart0_pins>;
+    status = "okay";
+};
+
+&i2c0 {
+    pinctrl-names = "default";
+    pinctrl-0 = <&i2c0_pins>;
+
+    clock-frequency = <312000>;
+    sda-delay = <100>;
+    status = "okay";
+	#address-cells = <1>;
+	#size-cells = <0>;
+
+	sensor0: camera@0x30{
+		compatible = "anyka,sensor0";
+		reg = <0x30>;
+
+		/*0xffff means the gpio is invalid*/
+		reset-gpio = <&gpio 3 1>;
+		pwdn-gpio = <&gpio 0xffff 1>;
+
+		port {
+			sensor0_0: endpoint@0 {
+				remote-endpoint = <&vi_0_0>;
+			};
+		};
+	};
+};
+
+&i2c1 {
+    pinctrl-names = "default";
+    //pinctrl-0 = <&i2c1_pins>;
+    
+    clock-frequency = <312000>;
+    sda-delay = <100>;
+    status = "disable";
+};
+
+&i2c2 {
+    pinctrl-names = "default";
+    pinctrl-0 = <&i2c2_pins>;
+
+    clock-frequency = <312000>;
+    sda-delay = <100>;
+    status = "okay";
+    
+    touch-screen@40 {
+		    compatible = "anyka,ak3790d-i2c-touchscreen-gslX680";
+		    reg = <0x40>;
+		    /* MIPI touch-pane irq and reset gpio setting */
+		    pinctrl-names = "default";
+            pinctrl-0 = <&gslX680_pins>;
+            irq-gpio = <&gpio 78 1>;
+            reset-gpio = <&gpio 79 1>;
+            TP_MAX_X = <1280>;
+            TP_MAX_Y = <800>;
+            status = "disable";
+	  };
+		       
+	  touch-screen@48 {
+		   compatible = "anyka,ak3790d-i2c-touchscreen-icn85xx";
+		    reg = <0x48>;
+		    /* RGB touch-pane irq and reset gpio setting */
+            pinctrl-names = "default";
+            pinctrl-0 = <&icn85xx_pins>;
+            irq-gpio = <&gpio 36 1>;
+            reset-gpio = <&gpio 38 1>;
+            TP_MAX_X = <1024>;
+            TP_MAX_Y = <600>;
+            status = "okay";
+	  }; 
+};
+
+&ethernet {
+    pinctrl-names = "default";
+    pinctrl-0 = <&ethernet_pins_rmii &phy_reset_pins>;
+    reset-gpios = <&gpio 23 1>;
+    status = "okay";
+};
+
+&ircut {
+    pinctrl-names = "default";
+    pinctrl-0 = <&ircut_pins>;
+
+	ircut-a = "42";
+	/*set the level for day mode. range: 0, 1*/
+	ircut-a-day-level = "0";
+	status = "okay";
+};
+
+&photosensitive {
+    //pinctrl-names = "default";
+    //pinctrl-0 = <&photosensitive_pins>;
+
+	/*range: saradc~1, gpio number*/
+	photosensitive-port = "saradc0";
+	/*the level for day mode, range: low, high*/
+	photosensitive-day-level = "high";
+	status = "okay";
+};
+
+&leds {
+	pinctrl-names = "default";
+	//pinctrl-0 = <&led_pins>;
+	//led-gpios = <&gpio 29 1
+                 //&gpio 30 1>;
+	status = "disable";
+};
+
+&adkeys {
+	status = "disable";
+};
+
+&gpiokeys {
+		#address-cells = <1>;
+		#size-cells = <0>;
+		pinctrl-0 = <&gpiokey_pins>;
+		pinctrl-names = "default";
+		
+	key_detect {
+		label = "key_detect";
+		gpios = <&gpio 39 1>;
+		linux,code = <116>;
+		debounce-interval = <100>;
+		wakeup-source;
+	};
+	
+	//status = "okay";
+};
+
+
+&motor0 {
+	status = "disable";
+};
+
+&motor1 {
+	status = "disable";
+};
+
+&pwm0 {
+	pinctrl-names = "default";
+
+	//pinctrl-0 = <&pwm0_pins>;
+	/*
+	**frequency of PWM ranges from 92H to 6MHz.
+	**duty of PWM ranges from 1 to 65535.
+	**Minimum duty cycle:1/65536
+	**Maximum duty cyscle:65535/65536.
+	**period-ns: period of the PWM signal (in nanoseconds)
+        **duty-ns: duty cycle of the PWM signal (in nanoseconds)
+	**pwm-enable = 0 means disable pwm function.
+	**pwm-enable = 1 means enable pwm function.
+	*/
+	period-ns = <1000000>;
+	duty-ns = <500000>;
+	pwm-enable = <1>;
+
+	status = "disable";
+};
+
+&pwm1 {
+	pinctrl-names = "default";
+
+	//pinctrl-0 = <&pwm1_pins>;
+	/*
+	**frequency of PWM ranges from 92H to 6MHz.
+	**duty of PWM ranges from 1 to 65535.
+	**Minimum duty cycle:1/65536
+	**Maximum duty cyscle:65535/65536.
+	**period-ns: period of the PWM signal (in nanoseconds)
+        **duty-ns: duty cycle of the PWM signal (in nanoseconds)
+	**pwm-enable = 0 means disable pwm function.
+	**pwm-enable = 1 means enable pwm function.
+	*/
+	period-ns = <1000000>;
+	duty-ns = <500000>;
+	pwm-enable = <1>;
+
+	status = "disable";
+};
+
+&pwm2 {
+	pinctrl-names = "default";
+
+	//pinctrl-0 = <&pwm2_pins>;
+	/*
+	**frequency of PWM ranges from 92H to 6MHz.
+	**duty of PWM ranges from 1 to 65535.
+	**Minimum duty cycle:1/65536
+	**Maximum duty cyscle:65535/65536.
+	**period-ns: period of the PWM signal (in nanoseconds)
+        **duty-ns: duty cycle of the PWM signal (in nanoseconds)
+	**pwm-enable = 0 means disable pwm function.
+	**pwm-enable = 1 means enable pwm function.
+	*/
+	period-ns = <1000000>;
+	duty-ns = <500000>;
+	pwm-enable = <1>;
+
+	status = "disable";
+};
+
+&pwm3 {
+	pinctrl-names = "default";
+
+	//pinctrl-0 = <&pwm3_pins>;
+	/*
+	**frequency of PWM ranges from 92H to 6MHz.
+	**duty of PWM ranges from 1 to 65535.
+	**Minimum duty cycle:1/65536
+	**Maximum duty cyscle:65535/65536.
+	**period-ns: period of the PWM signal (in nanoseconds)
+        **duty-ns: duty cycle of the PWM signal (in nanoseconds)
+	**pwm-enable = 0 means disable pwm function.
+	**pwm-enable = 1 means enable pwm function.
+	*/
+	period-ns = <1000000>;
+	duty-ns = <500000>;
+	pwm-enable = <1>;
+	status = "disable";
+};
+
+&pwm4 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pwm4_pins>;
+	/*
+	**frequency of PWM ranges from 92H to 6MHz.
+	**duty of PWM ranges from 1 to 65535.
+	**Minimum duty cycle:1/65536
+	**Maximum duty cyscle:65535/65536.
+	**period-ns: period of the PWM signal (in nanoseconds)
+        **duty-ns: duty cycle of the PWM signal (in nanoseconds)
+	**pwm-enable = 0 means disable pwm function.
+	**pwm-enable = 1 means enable pwm function.
+	*/
+	period-ns = <1000000>;
+	duty-ns = <500000>;
+	pwm-enable = <1>;
+	status = "okay";
+};
+
+&lcdc {
+    pinctrl-names = "default";
+    pinctrl-0 = <&lcd_pins>; //<&lcd_pins>,<&lcd_reset_pins>; //lcd_reset_pins only for mipi lcd
+    
+    lcd-logo-width = <600>;
+    lcd-logo-height = <165>;
+    //[fmt1:fmt0] 00 16bits input(RGB565 or BGR565)
+    //[fmt1:fmt0] 01 24bits input(RGB888 or BGR888)
+    //[fmt1:fmt0] 10 or 11 32bits input(ARGB888 ABGR888 RGBA888 BGRA888)
+    lcd-logo-fmt0 = <1>;
+    lcd-logo-fmt1 = <0>;
+    lcd-logo-rgb-seq = <1>; //0 for BGR, 1 for RGB
+    
+    lcd-fb-type = <1>; //0:single buffer; 1:double buffer
+    status = "okay";
+};
+
+&sat101cp40 {
+    status = "disable";
+};
+
+&sat070cp50 {
+    status = "disable";
+};
+
+&adt07016BR50 {
+    status = "okay";
+};
+
+&am1080wq05 {
+    status = "disable";
+};
+
+&vi0{
+	pinctrl-names = "dvp12bits", "dvp10bits", "dvp8bits",
+		"mipi0_2lane", "mipi0_1lane", "mipi1_2lane", "mipi1_1lane",
+		"csi0_sclk", "csi1_sclk";
+    pinctrl-0 = <&dvp12bits_pins>;
+    pinctrl-1 = <&dvp10bits_pins>;
+    pinctrl-2 = <&dvp8bits_pins>;
+    pinctrl-3 = <&mipi0_2lane_pins>;
+    pinctrl-4 = <&mipi0_1lane_pins>;
+    pinctrl-5 = <&mipi1_2lane_pins>;
+    pinctrl-6 = <&mipi1_1lane_pins>;
+    pinctrl-7 = <&csi0_sclk_pin>;
+    pinctrl-8 = <&csi1_sclk_pin>;
+    status = "okay";
+
+	port@0 {
+		#address-cells = <1>;
+		#size-cells = <0>;
+
+		vi_0_0: endpoint@0 {
+			reg = <0>;
+			remote-endpoint = <&sensor0_0>;
+		};
+	};
+};
diff --git a/arch/arm/boot/dts/c500_cbd_ak3760d_rgb_v1.0.0_spinand.dts b/arch/arm/boot/dts/c500_cbd_ak3760d_rgb_v1.0.0_spinand.dts
new file mode 100755
index 0000000..34a4e7b
--- /dev/null
+++ b/arch/arm/boot/dts/c500_cbd_ak3760d_rgb_v1.0.0_spinand.dts
@@ -0,0 +1,653 @@
+/*
+ * AK37D dev board dts
+ *
+ * Copyright (C) 2018 Anyka(Guangzhou) Microelectronics Technology Co., Ltd.
+ *
+ * Author: Feilong Dong <dong_feilong@anyka.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+/dts-v1/;
+#include "anyka_ev500.dtsi"
+#include "anyka_ev500_lcd.dtsi"
+#include "anyka_ev500_nandflash0.dtsi"
+
+/ {
+    compatible = "anyka,ak3790d";
+    model = "AK3760D dev board";
+	version = "V1.0.02";
+
+	chosen {
+		/* No padding required - the uboot can do that. */
+		bootargs = "console=ttySAK0,115200n8 root=/dev/mtdblock6 rootfstype=yaffs2 init=/sbin/init mem=64M memsize=64M";
+	};
+};
+
+&gpio {
+    /* anyka,function sharepin func index according to table 2-1 sharepin-list */
+    /* index: 0: PIN default func, 1: FUNCTION1, 2: FUNCTION2, 3: FUNCTION3, 4: FUNCTION4 */
+    /* anyka,pull config value bit[31:24]--slew rate, bit[23:16]--ie, bit[15:8]--drive, bit[7:0]--pupd config */
+    /* bit[31:24]--slew rate, 0: slow, 1: fast */
+    /* bit[23:16]--ie, input enable, 0: disable, 1: enable */
+    /* bit[15:8]--drive, drive strength, 4levels value: 0x0-0x3 */
+    /* bit[7:0]--bit[7]: open drain 0:disable, 1:enable (only for gpio31/32);
+				pupd config, bit[6:4] 1:enable/ 0:disable, bit[3:0] 0:select PU /1:select PD */
+
+    ircut_pins: ircut_pins {
+        anyka,pins = <42>;
+        anyka,function = <0>;
+        anyka,pull = <0x01010310>;
+    };
+
+    dvp12bits_pins: dvp12bits_pins {
+        anyka,pins = <25 26 27 28 109 110 111 112 113 114 115 116 117 118 119 120>;
+        anyka,function = <1>;
+        anyka,pull = <0x01010310>;
+    };
+
+    dvp10bits_pins: dvp10bits_pins {
+        //anyka,pins = <25 26 27 28 109 110 111 112 113 114 115 116 117 118>;
+        anyka,pins = <25 26 27 28 109 110 111 112 113 114 115 116 117 118 119 120>;
+        anyka,function = <1>;
+        anyka,pull = <0x01010310>;
+    };
+
+    dvp8bits_pins: dvp8bits_pins {
+        //anyka,pins = <25 26 27 28 109 110 111 112 113 114 115 116>;
+        anyka,pins = <25 26 27 28 109 110 111 112 113 114 115 116 117 118 119 120>;
+        anyka,function = <1>;
+        anyka,pull = <0x01010310>;
+    };
+
+    mipi0_2lane_pins: mipi0_2lane_pins {
+        anyka,pins = <25 115 116 117 118 119 120>;
+        anyka,function = <1 2 2 2 2 2 2>;
+        anyka,pull = <0x01010310>;
+    };
+
+    mipi0_1lane_pins: mipi0_1lane_pins {
+        anyka,pins = <25 117 118 119 120>;
+        anyka,function = <1 2 2 2 2>;
+        anyka,pull = <0x01010310>;
+    };
+
+    mipi1_2lane_pins: mipi1_2lane_pins {
+        anyka,pins = <26 109 110 111 112 113 114>;
+        anyka,function = <1 2 2 2 2 2 2>;
+        anyka,pull = <0x01010310>;
+    };
+
+    mipi1_1lane_pins: mipi1_1lane_pins {
+        anyka,pins = <26 111 112 113 114>;
+        anyka,function = <1 2 2 2 2>;
+        anyka,pull = <0x01010310>;
+    };
+
+    csi0_sclk_pin: csi0_sclk_pin {
+        anyka,pins = <25>;
+        anyka,function = <1>;
+        anyka,pull = <0x01010310>;
+    };
+
+    csi1_sclk_pin: csi1_sclk_pin {
+        anyka,pins = <26>;
+        anyka,function = <1>;
+        anyka,pull = <0x01010310>;
+    };
+
+    i2c0_pins: i2c0_pins {
+        anyka,pins = <31 32>;
+        anyka,function = <1>;
+        anyka,pull = <0x01010380>;
+        //anyka,pull = <0x01011110>;
+    };
+
+	mci1_pins: mci1_pins {
+        anyka,pins = <43 44 45 46 47 48>;
+        anyka,function = <1>;
+        anyka,pull = <0x10010 0x10000 0x10010 0x10010 0x10010 0x10010>;/* 4 line */
+
+        /* 1 line */
+        /*anyka,pins = <43 44 45>;*/
+        /*anyka,function = <1>;*/
+        /*anyka,pull = <0x10010 0x10000 0x10010>;*/  
+    };
+    
+    mci2_pins: mci2_pins {
+        //4 line with GPIO91-96
+        /*anyka,pins = <91 92 93 94 95 96>;
+        anyka,function = <2 2 3 3 3 3>;
+        anyka,pull = <0x01010010 0x01010010 0x01010010 0x01010010 0x01010010 0x01010010>; */
+
+        // 1 line with GPIO93-95
+        /*
+        anyka,pins = <93 94 95>;
+        anyka,function = <3>;
+        anyka,pull = <0x01010010 0x01010010 0x01010010>;*/
+
+        // 1 line with GPIO19 20 24, with 23 sdio irq pin
+        anyka,pins = <19 20  23 24>;
+        anyka,function = <2>;
+        anyka,pull = <0x01010010 0x01010010 0x01010010 0x01010010>;
+
+        // 4 line
+        /*
+        anyka,pins = <14 15 19 20  23 24>;
+        anyka,function = <2>;
+		anyka,pull = <0x01010010 0x01010010 0x01010010 0x01010010 0x01010010 0x01010010>;*/
+    };
+
+    spiflash_pins: spiflash_pins {
+        anyka,pins = <12 67 68 69 70>; /* 4 LINE mode, 12 is spi nor cs*/
+        anyka,function = <1 0 0 0 0>;
+        anyka,pull = <0x01010010>;
+    };
+
+		gpiokey_pins:gpiokey_pins {
+			anyka,pins = <39>;
+			anyka,function = <0>;
+			anyka,pull = <0x01010010>;
+		};
+		
+
+		/* gpio83 and gpio84  are used as i2c */
+    lcd_pins: lcd_pins {
+        anyka,pins = <74 71 72 73
+        	          75 76 77 78
+        	          79 80 81 82
+        	          85 86
+        	          87 88 89 90
+        	          91 92 93 94
+        	          95 96 97 98>;
+        anyka,function = <1>;
+        anyka,pull = <0x01010310>;
+    };
+    
+    uart0_pins: uart0_pins {
+        anyka,pins = <1 2>;
+        anyka,function = <1>;
+        anyka,pull = <0x01010010>;
+    };
+    
+    i2c2_pins: i2c2_pins {
+        anyka,pins = <83 84>;
+        anyka,function = <2>;
+        anyka,pull = <0x01011110>;
+    };
+
+     pwm4_pins: pwm4_pins {
+        anyka,pins = <41>;
+        anyka,function = <2>;
+        anyka,pull = <0x01011110>;
+    };
+
+    phy_reset_pins: phy_reset_pins {
+		    anyka,pins = <23>;		
+	      anyka,function = <0>;
+        anyka,pull = <0x01000010>;
+    };
+
+    gslX680_pins: gslX680_pins {
+        anyka,pins = <78 79>;
+        anyka,function = <0>;
+        anyka,pull = <0x01000010>;
+    };
+
+    icn85xx_pins: icn85xx_pins {
+        anyka,pins = <36 38>;
+        anyka,function = <0>;
+        anyka,pull = <0x01000010>;
+    };
+
+
+    ethernet_pins_rmii: ethernet_pins_rmii {
+		    anyka,pins 		= <10 11 13 14 15 19 20 24 49>;
+        anyka,function 	= <1>;
+        anyka,pull = <0x01010011 0x01010010 0x01010011 0x01010011 0x01010011 0x01010011 0x01010011  0x01010011 0x01010110>;
+    };
+};
+
+&rtc {
+	   /* 
+	   ** rtc osc_source_select, 0 means INTERNAL RC OSC, 1 means EXTERNAL XTAL 
+	   */
+		osc-select = <0>;
+    status = "okay";
+};
+
+&watchdog {
+	/*max feed dog time = 357s, default setting time = 10s. */
+    def_heartbeat = <10>;
+    status = "okay";
+};
+
+&gui {
+    status = "okay";
+};
+
+&vencoder {
+    status = "okay";
+};
+
+&vdecoder {
+    status = "okay";
+};
+
+&usb {
+    status = "okay"; 
+};
+
+
+&mmc1 {
+    bus-width = <0x4>;
+    max-frequency = <50000000>;
+    /*
+     *  detect mode:
+     *  (1) non-removable;
+     *  (2) detect-gpio/detect-gpios: card detect using gpio
+     *      for example:
+     *      detect-gpio = <&gpio 77 1>;  or detect-gpios = <&gpio 77 1>;  
+     *  (3) cd_clk: card detect using MCLK
+     *  default is non-removable
+     */
+    cd_clk;
+    /* if support highspeed, using cap-sd-highspeed */
+    cap-sd-highspeed;
+    pinctrl-names = "default";
+    pinctrl-0 = <&mci1_pins>;
+    status = "okay";
+};
+
+&mmc2 {
+    bus-width = <0x1>;
+    max-frequency = <50000000>;
+    /*
+     *  detect mode:
+     *  (1) non-removable;
+     *  (2) detect-gpio/detect-gpios: card detect using gpio
+     *      for example:
+     *      detect-gpio = <&gpio 77 1>;  or detect-gpios = <&gpio 77 1>;  
+     *  (3) cd_clk: card detect using MCLK
+     *  default is non-removable
+     */
+    non-removable;
+    /* if support sdio, using cap-sdio-irq*/
+    cap-sdio-irq;
+    /* if support highspeed, using cap-sd-highspeed */
+    cap-sd-highspeed;
+    pinctrl-names = "default";
+    pinctrl-0 = <&mci2_pins>;
+    status = "disable";
+};
+
+&dac {
+	pinctrl-names = "default";
+	//pinctrl-0 = <&speak_pins>;
+	/*
+	 ** speak-down,linein-detect,hp-mute,hp-detect
+	 ** 1 means enable these four function
+	 ** 0 means disable these four function
+	 */
+	speak-down = <1>;
+	linein-detect = <0>;
+	hp-mute = <0>;
+	hp-detect = <0>;
+	//speak-gpios = <&gpio 76 1>;
+	//linein-gpios = <&gpio 54 1>;
+	status = "okay";
+};
+
+&saradc{
+    /* SAR ADC VREF selection
+    * 0:To select AVCC 3.3V as VREF for SAR ADC.
+    * 1:To select 3.0V generated from BGR as VREF for SAR ADC.
+    */
+    vref-select = <1>;
+    /*
+    * 0:To disable BAT voltage divider. 
+    * 1:To enable BAT voltage divider divided by 2.
+    */
+    battery-divider = <1>;
+    /*
+    * Sampling number
+    * Read the sampling data for N times and then calculate the average value.
+    * N ranges from 1 to 7.
+    */
+     sampling-num = <3>;
+     status = "okay";
+};
+
+&spi0 {
+    pinctrl-names = "default";
+    pinctrl-0 = <&spiflash_pins>;
+    cs-gpios = <&gpio 12 1>;
+    spi-bus-frequency = <80000000>;
+    status = "okay";
+
+};
+
+&spif0 {
+	compatible = "anyka,ak-spinand";
+	status = "okay";
+};
+
+&GD5F1GQ4UB {
+   	status = "okay";
+};
+
+&GD5F2GQ4UB {
+   	status = "okay";
+};
+
+&uart0 {
+    pinctrl-names = "default";
+	pinctrl-0 = <&uart0_pins>;
+    status = "okay";
+};
+
+&i2c0 {
+    pinctrl-names = "default";
+    pinctrl-0 = <&i2c0_pins>;
+
+    clock-frequency = <312000>;
+    sda-delay = <100>;
+    status = "okay";
+	#address-cells = <1>;
+	#size-cells = <0>;
+
+	sensor0: camera@0x30{
+		compatible = "anyka,sensor0";
+		reg = <0x30>;
+
+		/*0xffff means the gpio is invalid*/
+		reset-gpio = <&gpio 3 1>;
+		pwdn-gpio = <&gpio 0xffff 1>;
+
+		port {
+			sensor0_0: endpoint@0 {
+				remote-endpoint = <&vi_0_0>;
+			};
+		};
+	};
+};
+
+&i2c1 {
+    pinctrl-names = "default";
+    //pinctrl-0 = <&i2c1_pins>;
+    
+    clock-frequency = <312000>;
+    sda-delay = <100>;
+    status = "disable";
+};
+
+&i2c2 {
+    pinctrl-names = "default";
+    pinctrl-0 = <&i2c2_pins>;
+
+    clock-frequency = <312000>;
+    sda-delay = <100>;
+    status = "okay";
+    
+    touch-screen@40 {
+		    compatible = "anyka,ak3790d-i2c-touchscreen-gslX680";
+		    reg = <0x40>;
+		    /* MIPI touch-pane irq and reset gpio setting */
+		    pinctrl-names = "default";
+            pinctrl-0 = <&gslX680_pins>;
+            irq-gpio = <&gpio 78 1>;
+            reset-gpio = <&gpio 79 1>;
+            TP_MAX_X = <1280>;
+            TP_MAX_Y = <800>;
+            status = "disable";
+	  };
+		       
+	  touch-screen@48 {
+		   compatible = "anyka,ak3790d-i2c-touchscreen-icn85xx";
+		    reg = <0x48>;
+		    /* RGB touch-pane irq and reset gpio setting */
+            pinctrl-names = "default";
+            pinctrl-0 = <&icn85xx_pins>;
+            irq-gpio = <&gpio 36 1>;
+            reset-gpio = <&gpio 38 1>;
+            TP_MAX_X = <1024>;
+            TP_MAX_Y = <600>;
+            status = "okay";
+	  }; 
+	  
+};
+
+&ethernet {
+    pinctrl-names = "default";
+    pinctrl-0 = <&ethernet_pins_rmii &phy_reset_pins>;
+    reset-gpios = <&gpio 23 1>;
+    status = "okay";
+};
+
+&ircut {
+    pinctrl-names = "default";
+    pinctrl-0 = <&ircut_pins>;
+
+	ircut-a = "42";
+	/*set the level for day mode. range: 0, 1*/
+	ircut-a-day-level = "0";
+	status = "okay";
+};
+
+&photosensitive {
+    //pinctrl-names = "default";
+    //pinctrl-0 = <&photosensitive_pins>;
+
+	/*range: saradc~1, gpio number*/
+	photosensitive-port = "saradc0";
+	/*the level for day mode, range: low, high*/
+	photosensitive-day-level = "high";
+	status = "okay";
+};
+
+&leds {
+	pinctrl-names = "default";
+	//pinctrl-0 = <&led_pins>;
+	//led-gpios = <&gpio 29 1
+                 //&gpio 30 1>;
+	status = "disable";
+};
+
+&adkeys {
+	status = "disable";
+};
+
+&gpiokeys {
+		#address-cells = <1>;
+		#size-cells = <0>;
+		pinctrl-0 = <&gpiokey_pins>;
+		pinctrl-names = "default";
+		
+	key_detect {
+		label = "key_detect";
+		gpios = <&gpio 39 1>;
+		linux,code = <116>;
+		debounce-interval = <100>;
+		wakeup-source;
+	};
+	
+	//status = "okay";
+};
+
+
+&motor0 {
+	status = "disable";
+};
+
+&motor1 {
+	status = "disable";
+};
+
+&pwm0 {
+	pinctrl-names = "default";
+
+	//pinctrl-0 = <&pwm0_pins>;
+	/*
+	**frequency of PWM ranges from 92H to 6MHz.
+	**duty of PWM ranges from 1 to 65535.
+	**Minimum duty cycle:1/65536
+	**Maximum duty cyscle:65535/65536.
+	**period-ns: period of the PWM signal (in nanoseconds)
+        **duty-ns: duty cycle of the PWM signal (in nanoseconds)
+	**pwm-enable = 0 means disable pwm function.
+	**pwm-enable = 1 means enable pwm function.
+	*/
+	period-ns = <1000000>;
+	duty-ns = <500000>;
+	pwm-enable = <1>;
+
+	status = "disable";
+};
+
+&pwm1 {
+	pinctrl-names = "default";
+
+	//pinctrl-0 = <&pwm1_pins>;
+	/*
+	**frequency of PWM ranges from 92H to 6MHz.
+	**duty of PWM ranges from 1 to 65535.
+	**Minimum duty cycle:1/65536
+	**Maximum duty cyscle:65535/65536.
+	**period-ns: period of the PWM signal (in nanoseconds)
+        **duty-ns: duty cycle of the PWM signal (in nanoseconds)
+	**pwm-enable = 0 means disable pwm function.
+	**pwm-enable = 1 means enable pwm function.
+	*/
+	period-ns = <1000000>;
+	duty-ns = <500000>;
+	pwm-enable = <1>;
+
+	status = "disable";
+};
+
+&pwm2 {
+	pinctrl-names = "default";
+
+	//pinctrl-0 = <&pwm2_pins>;
+	/*
+	**frequency of PWM ranges from 92H to 6MHz.
+	**duty of PWM ranges from 1 to 65535.
+	**Minimum duty cycle:1/65536
+	**Maximum duty cyscle:65535/65536.
+	**period-ns: period of the PWM signal (in nanoseconds)
+        **duty-ns: duty cycle of the PWM signal (in nanoseconds)
+	**pwm-enable = 0 means disable pwm function.
+	**pwm-enable = 1 means enable pwm function.
+	*/
+	period-ns = <1000000>;
+	duty-ns = <500000>;
+	pwm-enable = <1>;
+
+	status = "disable";
+};
+
+&pwm3 {
+	pinctrl-names = "default";
+
+	//pinctrl-0 = <&pwm3_pins>;
+	/*
+	**frequency of PWM ranges from 92H to 6MHz.
+	**duty of PWM ranges from 1 to 65535.
+	**Minimum duty cycle:1/65536
+	**Maximum duty cyscle:65535/65536.
+	**period-ns: period of the PWM signal (in nanoseconds)
+        **duty-ns: duty cycle of the PWM signal (in nanoseconds)
+	**pwm-enable = 0 means disable pwm function.
+	**pwm-enable = 1 means enable pwm function.
+	*/
+	period-ns = <1000000>;
+	duty-ns = <500000>;
+	pwm-enable = <1>;
+	status = "disable";
+};
+
+&pwm4 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pwm4_pins>;
+	/*
+	**frequency of PWM ranges from 92H to 6MHz.
+	**duty of PWM ranges from 1 to 65535.
+	**Minimum duty cycle:1/65536
+	**Maximum duty cyscle:65535/65536.
+	**period-ns: period of the PWM signal (in nanoseconds)
+        **duty-ns: duty cycle of the PWM signal (in nanoseconds)
+	**pwm-enable = 0 means disable pwm function.
+	**pwm-enable = 1 means enable pwm function.
+	*/
+	period-ns = <1000000>;
+	duty-ns = <500000>;
+	pwm-enable = <1>;
+	status = "okay";
+};
+
+&lcdc {
+    pinctrl-names = "default";
+    pinctrl-0 = <&lcd_pins>; //<&lcd_pins>,<&lcd_reset_pins>; //lcd_reset_pins only for mipi lcd
+    
+    lcd-logo-width = <600>;
+    lcd-logo-height = <165>;
+    //[fmt1:fmt0] 00 16bits input(RGB565 or BGR565)
+    //[fmt1:fmt0] 01 24bits input(RGB888 or BGR888)
+    //[fmt1:fmt0] 10 or 11 32bits input(ARGB888 ABGR888 RGBA888 BGRA888)
+    lcd-logo-fmt0 = <1>;
+    lcd-logo-fmt1 = <0>;
+    lcd-logo-rgb-seq = <1>; //0 for BGR, 1 for RGB
+    
+    lcd-fb-type = <1>; //0:single buffer; 1:double buffer
+    status = "okay";
+};
+
+&sat101cp40 {
+    status = "disable";
+};
+
+&sat070cp50 {
+    status = "disable";
+};
+
+&adt07016BR50 {
+    status = "okay";
+};
+
+&am1080wq05 {
+    status = "disable";
+};
+
+&vi0{
+	pinctrl-names = "dvp12bits", "dvp10bits", "dvp8bits",
+		"mipi0_2lane", "mipi0_1lane", "mipi1_2lane", "mipi1_1lane",
+		"csi0_sclk", "csi1_sclk";
+    pinctrl-0 = <&dvp12bits_pins>;
+    pinctrl-1 = <&dvp10bits_pins>;
+    pinctrl-2 = <&dvp8bits_pins>;
+    pinctrl-3 = <&mipi0_2lane_pins>;
+    pinctrl-4 = <&mipi0_1lane_pins>;
+    pinctrl-5 = <&mipi1_2lane_pins>;
+    pinctrl-6 = <&mipi1_1lane_pins>;
+    pinctrl-7 = <&csi0_sclk_pin>;
+    pinctrl-8 = <&csi1_sclk_pin>;
+    status = "okay";
+
+	port@0 {
+		#address-cells = <1>;
+		#size-cells = <0>;
+
+		vi_0_0: endpoint@0 {
+			reg = <0>;
+			remote-endpoint = <&sensor0_0>;
+		};
+	};
+};
diff --git a/arch/arm/boot/dts/c500_cbd_ak3761d_dsi_v1.0.0.dts b/arch/arm/boot/dts/c500_cbd_ak3761d_dsi_v1.0.0.dts
new file mode 100755
index 0000000..84ea6ad
--- /dev/null
+++ b/arch/arm/boot/dts/c500_cbd_ak3761d_dsi_v1.0.0.dts
@@ -0,0 +1,686 @@
+/*
+ * AK37D dev board dts
+ *
+ * Copyright (C) 2018 Anyka(Guangzhou) Microelectronics Technology Co., Ltd.
+ *
+ * Author: Feilong Dong <dong_feilong@anyka.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+/dts-v1/;
+#include "anyka_ev501.dtsi"
+#include "anyka_ev500_lcd.dtsi"
+#include "anyka_ev500_norflash.dtsi"
+#include "anyka_ev500_nandflash1.dtsi"
+
+/ {
+    compatible = "anyka,ak3790d";
+    model = "AK3760D dev board";
+	version = "V1.0.02";
+};
+
+&gpio {
+    /* anyka,function sharepin func index according to table 2-1 sharepin-list */
+    /* index: 0: PIN default func, 1: FUNCTION1, 2: FUNCTION2, 3: FUNCTION3, 4: FUNCTION4 */
+    /* anyka,pull config value bit[31:24]--slew rate, bit[23:16]--ie, bit[15:8]--drive, bit[7:0]--pupd config */
+    /* bit[31:24]--slew rate, 0: slow, 1: fast */
+    /* bit[23:16]--ie, input enable, 0: disable, 1: enable */
+    /* bit[15:8]--drive, drive strength, 4levels value: 0x0-0x3 */
+    /* bit[7:0]--bit[7]: open drain 0:disable, 1:enable (only for gpio31/32);
+				pupd config, bit[6:4] 1:enable/ 0:disable, bit[3:0] 0:select PU /1:select PD */
+
+    ircut_pins: ircut_pins {
+        anyka,pins = <71>;
+        anyka,function = <0>;
+        anyka,pull = <0x01010310>;
+    };
+
+    dvp12bits_pins: dvp12bits_pins {
+        anyka,pins = <25 26 27 28 109 110 111 112 113 114 115 116 117 118 119 120>;
+        anyka,function = <1>;
+        anyka,pull = <0x01010310>;
+    };
+
+    dvp10bits_pins: dvp10bits_pins {
+        //anyka,pins = <25 26 27 28 109 110 111 112 113 114 115 116 117 118>;
+        anyka,pins = <25 26 27 28 109 110 111 112 113 114 115 116 117 118 119 120>;
+        anyka,function = <1>;
+        anyka,pull = <0x01010310>;
+    };
+
+    dvp8bits_pins: dvp8bits_pins {
+        //anyka,pins = <25 26 27 28 109 110 111 112 113 114 115 116>;
+        anyka,pins = <25 26 27 28 109 110 111 112 113 114 115 116 117 118 119 120>;
+        anyka,function = <1>;
+        anyka,pull = <0x01010310>;
+    };
+
+    mipi0_2lane_pins: mipi0_2lane_pins {
+        anyka,pins = <25 115 116 117 118 119 120>;
+        anyka,function = <1 2 2 2 2 2 2>;
+        anyka,pull = <0x01010310>;
+    };
+
+    mipi0_1lane_pins: mipi0_1lane_pins {
+        anyka,pins = <25 117 118 119 120>;
+        anyka,function = <1 2 2 2 2>;
+        anyka,pull = <0x01010310>;
+    };
+
+    mipi1_2lane_pins: mipi1_2lane_pins {
+        anyka,pins = <26 109 110 111 112 113 114>;
+        anyka,function = <1 2 2 2 2 2 2>;
+        anyka,pull = <0x01010310>;
+    };
+
+    mipi1_1lane_pins: mipi1_1lane_pins {
+        anyka,pins = <26 111 112 113 114>;
+        anyka,function = <1 2 2 2 2>;
+        anyka,pull = <0x01010310>;
+    };
+
+    csi0_sclk_pin: csi0_sclk_pin {
+        anyka,pins = <25>;
+        anyka,function = <1>;
+        anyka,pull = <0x01010310>;
+    };
+
+    csi1_sclk_pin: csi1_sclk_pin {
+        anyka,pins = <26>;
+        anyka,function = <1>;
+        anyka,pull = <0x01010310>;
+    };
+
+    i2c0_pins: i2c0_pins {
+        anyka,pins = <31 32>;
+        anyka,function = <1>;
+        anyka,pull = <0x01010380>;
+        //anyka,pull = <0x01011110>;
+    };
+
+    mci0_pins: mci0_pins {
+        anyka,pins = <33 34 35 36 37 38 39 40 41 42>;
+        anyka,function = <1>;
+        anyka,pull = <0x10010 0x10010 0x10010 0x10010 0x10010 0x10010 0x10010 0x10010 0x10010 0x10010>;/* 4 line */ 
+    };
+
+    mci1_pins: mci1_pins {
+        anyka,pins = <43 44 45 46 47 48>;
+        anyka,function = <1>;
+        anyka,pull = <0x10010 0x10000 0x10010 0x10010 0x10010 0x10010>; /* 4 line */
+
+        /* 1 line */
+        /*
+        anyka,pins = <43 44 45>;
+        anyka,function = <1>;
+        anyka,pull = <0x10010 0x10000 0x10010>;*/
+    };
+    
+    mci2_pins: mci2_pins {
+    /*
+        anyka,pins = <91 92 93 94 95 96>;
+        anyka,function = <2 2 3 3 3 3>;
+        anyka,pull = <0x01010010 0x01010010 0x01010010 0x01010010 0x01010010 0x01010010>; 
+    */
+	// 1 line with D[1] as sdio interrupt pin
+        anyka,pins = <93 94 95 96>;
+        anyka,function = <3>;
+        anyka,pull = <0x01010010 0x01010010 0x01010010 0x01010010>;
+       
+
+    };
+
+    mmc_power_pins:mmc_power_pins{
+        anyka,pins = <81>;
+	    anyka,function = <0>;
+        anyka,pull = <0x01000310>;
+    };
+
+   sdio_wifi_pins:sdio_wifi_pins{
+        anyka,pins = <72>;
+	    anyka,function = <0>;
+        anyka,pull = <0x01000310>;
+    };
+
+    spiflash_pins: spiflash_pins {
+        anyka,pins = <12 82 67 68 69 70>; /* 4 LINE mode, 12 is spi nor cs, 18 is spinand cs*/
+        anyka,function = <1 0 0 0 0 0>;
+        anyka,pull = <0x01010010>;
+    };
+
+    lcd_reset_pins: lcd_reset_pins {
+	    anyka,pins = <83>;
+	    anyka,function = <0>;
+        anyka,pull = <0x01000310>;
+    };
+
+		gpiokey_pins:gpiokey_pins {
+			anyka,pins = <74>;
+			anyka,function = <0>;
+			anyka,pull = <0x01010010>;
+		};
+
+		ts_irq_pins:ts_irq_pins {
+			anyka,pins = <78>;
+			anyka,function = <0>;
+			anyka,pull = <0x01010111>;
+		};
+				
+    /*speak_en and linein_detect gpio setting */
+    speak_pins: speak_pins {
+        anyka,pins = <76>; 
+        anyka,function = <0>;
+        anyka,pull = <0x01010010>;
+    };
+    
+    uart0_pins: uart0_pins {
+        anyka,pins = <1 2>;
+        anyka,function = <1>;
+        anyka,pull = <0x01010010>;
+    };
+    
+    i2c2_pins: i2c2_pins {
+        anyka,pins = <97 98>;
+        anyka,function = <3>;
+        anyka,pull = <0x01011110>;
+    };
+
+	phy_reset_pins: phy_reset_pins {
+		anyka,pins = <80>;		
+	    anyka,function = <0>;
+        anyka,pull = <0x01000010>;
+    };
+
+    gslX680_pins: gslX680_pins {
+        anyka,pins = <78 79>;
+        anyka,function = <0>;
+        anyka,pull = <0x01000010>;
+    };
+
+    icn85xx_pins: icn85xx_pins {
+        anyka,pins = <36 38>;
+        anyka,function = <0>;
+        anyka,pull = <0x01000010>;
+    };
+
+
+    ethernet_pins_rmii: ethernet_pins_rmii {
+		anyka,pins 		= <10 11 13 14 15 19 20 23 24 49>;
+        anyka,function 	= <1>;
+        anyka,pull = <0x01010011 0x01010010 0x01010011 0x01010011 0x01010011 0x01010011 0x01010011 0x01010011 0x01010011 0x01010110>;
+    };
+};
+
+&rtc {
+	   /* 
+	   ** rtc osc_source_select, 0 means INTERNAL RC OSC, 1 means EXTERNAL XTAL 
+	   */
+		osc-select = <0>;
+    status = "okay";
+};
+
+&watchdog {
+		/*max feed dog time = 357s, default setting time = 10s. */
+    def_heartbeat = <10>;
+    status = "okay";
+};
+
+&gui {
+    status = "okay";
+};
+
+&vencoder {
+    status = "okay";
+};
+
+&vdecoder {
+    status = "okay";
+};
+
+&usb {
+    status = "okay"; 
+};
+
+&mmc0 {
+    bus-width = <0x8>;
+    max-frequency = <50000000>;
+    /*
+     *  detect mode:
+     *  (1) non-removable;
+     *  (2) detect-gpio/detect-gpios: card detect using gpio
+     *      for example:
+     *      detect-gpio = <&gpio 77 1>;  or detect-gpios = <&gpio 77 1>;  
+     *  (3) cd_clk: card detect using MCLK
+     *  default is non-removable
+     */
+    cd_clk;
+    /* if support highspeed, using cap-sd-highspeed */
+    cap-sd-highspeed;
+    pinctrl-names = "default";
+    pinctrl-0 = <&mci0_pins>;
+    status = "disable";
+};
+
+&mmc1 {
+    bus-width = <0x4>;
+    max-frequency = <50000000>;
+    /*
+     *  detect mode:
+     *  (1) non-removable;
+     *  (2) detect-gpio/detect-gpios: card detect using gpio
+     *      for example:
+     *      detect-gpio = <&gpio 77 1>;  or detect-gpios = <&gpio 77 1>;  
+     *  (3) cd_clk: card detect using MCLK
+     *  default is non-removable
+     */
+    cd_clk;
+    /* if support highspeed, using cap-sd-highspeed */
+    cap-sd-highspeed;
+    pinctrl-names = "default";
+    pinctrl-0 = <&mci1_pins>,<&mmc_power_pins>;
+    power-pins = <&gpio 81 1>;
+    /* initial power pin value*/
+    power-pins-value = <0>; 
+    power-inverted;
+    status = "okay";
+};
+
+&mmc2 {
+    bus-width = <0x1>;
+    max-frequency = <50000000>;
+    /*
+     *  detect mode:
+     *  (1) non-removable;
+     *  (2) detect-gpio/detect-gpios: card detect using gpio
+     *      detect-gpio = <&gpio 77 1>;
+     *      or
+     *      detect-gpios = <&gpio 77 1>;
+     *  (3) cd_clk: card detect using MCLK
+     *  default is non-removable
+     */
+    non-removable;
+    /* if support sdio, using cap-sdio-irq*/
+    cap-sdio-irq;
+    /* if support highspeed, using cap-sd-highspeed */
+    cap-sd-highspeed;
+    pinctrl-names = "default";
+    pinctrl-0 = <&mci2_pins> , <&sdio_wifi_pins>;
+    power-pins = <&gpio 72 1>; 
+    /* initial power pin value*/
+    power-pins-value = <1>; 
+    status = "okay";
+};
+
+&dac {
+     pinctrl-names = "default";
+	   pinctrl-0 = <&speak_pins>;
+	   /* 
+	   ** speak-down,linein-detect,hp-mute,hp-detect
+	   ** 1 means enable these four function
+	   ** 0 means disable these four function
+	   */
+	   speak-down = <1>;
+	   linein-detect = <0>;
+	   hp-mute = <0>;
+	   hp-detect = <0>;
+	   speak-gpios = <&gpio 76 1>;
+	   //linein-gpios = <&gpio 54 1>;    
+     status = "okay";
+};	 
+
+&saradc{
+    /* SAR ADC VREF selection
+    * 0:To select AVCC 3.3V as VREF for SAR ADC.
+    * 1:To select 3.0V generated from BGR as VREF for SAR ADC.
+    */
+    vref-select = <1>;
+    /*
+    * 0:To disable BAT voltage divider. 
+    * 1:To enable BAT voltage divider divided by 2.
+    */
+    battery-divider = <1>;
+    /*
+    * Sampling number
+    * Read the sampling data for N times and then calculate the average value.
+    * N ranges from 1 to 7.
+    */
+     sampling-num = <3>;
+     status = "okay";
+};
+
+&spi0 {
+    pinctrl-names = "default";
+    pinctrl-0 = <&spiflash_pins>;
+    cs-gpios = <&gpio 12 1>, <&gpio 82 1>;
+    spi-bus-frequency = <80000000>;
+    status = "okay";
+};
+
+&spif0 {
+	status = "okay";
+};
+
+&spif1 {
+   	status = "okay";
+};
+
+&gd25q64{
+   	status = "okay";
+};
+
+&gd25q128{
+   	status = "okay";
+};
+
+&GD5F1GQ4UB {
+   	status = "okay";
+};
+
+&GD5F2GQ4UB {
+   	status = "okay";
+};
+
+
+&uart0 {
+    pinctrl-names = "default";
+	pinctrl-0 = <&uart0_pins>;
+    status = "okay";
+};
+
+&i2c0 {
+    pinctrl-names = "default";
+    pinctrl-0 = <&i2c0_pins>;
+
+    clock-frequency = <312000>;
+    sda-delay = <100>;
+    status = "okay";
+	#address-cells = <1>;
+	#size-cells = <0>;
+    
+	sensor0: camera@0x30{
+		compatible = "anyka,sensor0";
+		reg = <0x30>;
+
+		/*0xffff means the gpio is invalid*/
+		reset-gpio = <&gpio 3 1>;
+		pwdn-gpio = <&gpio 0xffff 1>;
+
+		port {
+			sensor0_0: endpoint@0 {
+				remote-endpoint = <&vi_0_0>;
+			};
+		};
+	};
+};
+
+&i2c1 {
+    pinctrl-names = "default";
+    //pinctrl-0 = <&i2c1_pins>;
+    
+    clock-frequency = <312000>;
+    sda-delay = <100>;
+    status = "disable";
+};
+
+&i2c2 {
+    pinctrl-names = "default";
+    pinctrl-0 = <&i2c2_pins>;
+
+    clock-frequency = <312000>;
+    sda-delay = <100>;
+    status = "okay";
+    
+    touch-screen@40 {
+		    compatible = "anyka,ak3790d-i2c-touchscreen-gslX680";
+		    reg = <0x40>;
+		    /* MIPI touch-pane irq and reset gpio setting */
+		    pinctrl-names = "default";
+            pinctrl-0 = <&gslX680_pins>;
+            irq-gpio = <&gpio 78 1>;
+            reset-gpio = <&gpio 79 1>;
+            TP_MAX_X = <1280>;
+            TP_MAX_Y = <800>;
+            status = "okay";
+	  };
+		       
+	  touch-screen@48 {
+		   compatible = "anyka,ak3790d-i2c-touchscreen-icn85xx";
+		    reg = <0x48>;
+		    /* RGB touch-pane irq and reset gpio setting */
+            pinctrl-names = "default";
+            pinctrl-0 = <&icn85xx_pins>;
+            irq-gpio = <&gpio 36 1>;
+            reset-gpio = <&gpio 38 1>;
+            TP_MAX_X = <1024>;
+            TP_MAX_Y = <600>;
+            status = "disable";
+	  }; 
+	  
+};
+
+&ethernet {
+    pinctrl-names = "default";
+    pinctrl-0 = <&ethernet_pins_rmii &phy_reset_pins>;
+    reset-gpios = <&gpio 80 1>;
+    status = "okay";
+};
+
+&ircut {
+    pinctrl-names = "default";
+    pinctrl-0 = <&ircut_pins>;
+
+	ircut-a = "71";
+	/*set the level for day mode. range: 0, 1*/
+	ircut-a-day-level = "0";
+	status = "okay";
+};
+
+&photosensitive {
+    //pinctrl-names = "default";
+    //pinctrl-0 = <&photosensitive_pins>;
+
+	/*range: saradc~1, gpio number*/
+	photosensitive-port = "saradc0";
+	/*the level for day mode, range: low, high*/
+	photosensitive-day-level = "high";
+	status = "okay";
+};
+
+&leds {
+	pinctrl-names = "default";
+	//pinctrl-0 = <&led_pins>;
+	led-gpios = <&gpio 29 1
+                 &gpio 30 1>;
+	status = "okay";
+};
+
+&adkeys {
+	status = "disable";
+};
+
+&gpiokeys {
+		#address-cells = <1>;
+		#size-cells = <0>;
+		pinctrl-0 = <&gpiokey_pins>;
+		pinctrl-names = "default";
+		
+	key_detect {
+		label = "key_detect";
+		gpios = <&gpio 74 1>;
+		linux,code = <116>;
+		debounce-interval = <100>;
+		wakeup-source;
+	};
+	
+	//status = "okay";
+};
+
+
+&motor0 {
+	status = "disable";
+};
+
+&motor1 {
+	status = "disable";
+};
+
+&pwm0 {
+	pinctrl-names = "default";
+
+	//pinctrl-0 = <&pwm0_pins>;
+	/*
+	**frequency of PWM ranges from 92H to 6MHz.
+	**duty of PWM ranges from 1 to 65535.
+	**Minimum duty cycle:1/65536
+	**Maximum duty cyscle:65535/65536.
+	**period-ns: period of the PWM signal (in nanoseconds)
+        **duty-ns: duty cycle of the PWM signal (in nanoseconds)
+	**pwm-enable = 0 means disable pwm function.
+	**pwm-enable = 1 means enable pwm function.
+	*/
+	period-ns = <1000000>;
+	duty-ns = <500000>;
+	pwm-enable = <1>;
+	status = "disable";
+};
+
+&pwm1 {
+	pinctrl-names = "default";
+
+	//pinctrl-0 = <&pwm1_pins>;
+	/*
+	**frequency of PWM ranges from 92H to 6MHz.
+	**duty of PWM ranges from 1 to 65535.
+	**Minimum duty cycle:1/65536
+	**Maximum duty cyscle:65535/65536.
+	**period-ns: period of the PWM signal (in nanoseconds)
+        **duty-ns: duty cycle of the PWM signal (in nanoseconds)
+	**pwm-enable = 0 means disable pwm function.
+	**pwm-enable = 1 means enable pwm function.
+	*/
+	period-ns = <1000000>;
+	duty-ns = <500000>;
+	pwm-enable = <1>;
+	status = "disable";
+};
+
+&pwm2 {
+	pinctrl-names = "default";
+
+	//pinctrl-0 = <&pwm2_pins>;
+	/*
+	**frequency of PWM ranges from 92H to 6MHz.
+	**duty of PWM ranges from 1 to 65535.
+	**Minimum duty cycle:1/65536
+	**Maximum duty cyscle:65535/65536.
+	**period-ns: period of the PWM signal (in nanoseconds)
+        **duty-ns: duty cycle of the PWM signal (in nanoseconds)
+	**pwm-enable = 0 means disable pwm function.
+	**pwm-enable = 1 means enable pwm function.
+	*/
+	period-ns = <1000000>;
+	duty-ns = <500000>;
+	pwm-enable = <1>;
+	status = "disable";
+};
+
+&pwm3 {
+	pinctrl-names = "default";
+
+	//pinctrl-0 = <&pwm3_pins>;
+	/*
+	**frequency of PWM ranges from 92H to 6MHz.
+	**duty of PWM ranges from 1 to 65535.
+	**Minimum duty cycle:1/65536
+	**Maximum duty cyscle:65535/65536.
+	**period-ns: period of the PWM signal (in nanoseconds)
+        **duty-ns: duty cycle of the PWM signal (in nanoseconds)
+	**pwm-enable = 0 means disable pwm function.
+	**pwm-enable = 1 means enable pwm function.
+	*/
+	period-ns = <1000000>;
+	duty-ns = <500000>;
+	pwm-enable = <1>;
+	status = "disable";
+};
+
+&pwm4 {
+	pinctrl-names = "default";
+	//pinctrl-0 = <&pwm4_pins>;
+	/*
+	**frequency of PWM ranges from 92H to 6MHz.
+	**duty of PWM ranges from 1 to 65535.
+	**Minimum duty cycle:1/65536
+	**Maximum duty cyscle:65535/65536.
+	**period-ns: period of the PWM signal (in nanoseconds)
+        **duty-ns: duty cycle of the PWM signal (in nanoseconds)
+	**pwm-enable = 0 means disable pwm function.
+	**pwm-enable = 1 means enable pwm function.
+	*/
+	period-ns = <1000000>;
+	duty-ns = <500000>;
+	pwm-enable = <1>;
+	status = "disable";
+};
+
+&lcdc {
+    pinctrl-names = "default";
+    pinctrl-0 = <&lcd_reset_pins>; //<&lcd_pins>,<&lcd_reset_pins>; //lcd_pins for rgb lcd, lcd_reset_pins only for mipi lcd
+    reset-pins = <&gpio 83 1>; //only for mipi lcd
+    
+    lcd-logo-width = <600>;
+    lcd-logo-height = <165>;
+    //[fmt1:fmt0] 00 16bits input(RGB565 or BGR565)
+    //[fmt1:fmt0] 01 24bits input(RGB888 or BGR888)
+    //[fmt1:fmt0] 10 or 11 32bits input(ARGB888 ABGR888 RGBA888 BGRA888)
+    lcd-logo-fmt0 = <1>;
+    lcd-logo-fmt1 = <0>;
+    lcd-logo-rgb-seq = <1>; //0 for BGR, 1 for RGB
+    
+    lcd-fb-type = <1>; //0:single buffer; 1:double buffer
+    status = "okay";
+};
+
+&sat101cp40 {
+    status = "okay";
+};
+
+
+&am1080wq05 {
+    status = "disable";
+};
+
+&vi0{
+	pinctrl-names = "dvp12bits", "dvp10bits", "dvp8bits",
+		"mipi0_2lane", "mipi0_1lane", "mipi1_2lane", "mipi1_1lane",
+		"csi0_sclk", "csi1_sclk";
+    pinctrl-0 = <&dvp12bits_pins>;
+    pinctrl-1 = <&dvp10bits_pins>;
+    pinctrl-2 = <&dvp8bits_pins>;
+    pinctrl-3 = <&mipi0_2lane_pins>;
+    pinctrl-4 = <&mipi0_1lane_pins>;
+    pinctrl-5 = <&mipi1_2lane_pins>;
+    pinctrl-6 = <&mipi1_1lane_pins>;
+    pinctrl-7 = <&csi0_sclk_pin>;
+    pinctrl-8 = <&csi1_sclk_pin>;
+    status = "okay";
+
+	port@0 {
+		#address-cells = <1>;
+		#size-cells = <0>;
+
+		vi_0_0: endpoint@0 {
+			reg = <0>;
+			remote-endpoint = <&sensor0_0>;
+		};
+	};
+};
diff --git a/arch/arm/boot/dts/c500_cbd_ak3761d_dsi_v1.0.0_spinand.dts b/arch/arm/boot/dts/c500_cbd_ak3761d_dsi_v1.0.0_spinand.dts
new file mode 100755
index 0000000..bd3f605
--- /dev/null
+++ b/arch/arm/boot/dts/c500_cbd_ak3761d_dsi_v1.0.0_spinand.dts
@@ -0,0 +1,679 @@
+/*
+ * AK37D dev board dts
+ *
+ * Copyright (C) 2018 Anyka(Guangzhou) Microelectronics Technology Co., Ltd.
+ *
+ * Author: Feilong Dong <dong_feilong@anyka.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+/dts-v1/;
+#include "anyka_ev501.dtsi"
+#include "anyka_ev500_lcd.dtsi"
+#include "anyka_ev500_nandflash0.dtsi"
+
+/ {
+    compatible = "anyka,ak3790d";
+    model = "AK3760D dev board";
+	version = "V1.0.02";
+
+	chosen {
+		/* No padding required - the uboot can do that. */
+		bootargs = "console=ttySAK0,115200n8 root=/dev/mtdblock6 rootfstype=yaffs2 init=/sbin/init mem=128M memsize=128M";
+	};
+};
+
+&gpio {
+    /* anyka,function sharepin func index according to table 2-1 sharepin-list */
+    /* index: 0: PIN default func, 1: FUNCTION1, 2: FUNCTION2, 3: FUNCTION3, 4: FUNCTION4 */
+    /* anyka,pull config value bit[31:24]--slew rate, bit[23:16]--ie, bit[15:8]--drive, bit[7:0]--pupd config */
+    /* bit[31:24]--slew rate, 0: slow, 1: fast */
+    /* bit[23:16]--ie, input enable, 0: disable, 1: enable */
+    /* bit[15:8]--drive, drive strength, 4levels value: 0x0-0x3 */
+    /* bit[7:0]--bit[7]: open drain 0:disable, 1:enable (only for gpio31/32);
+				pupd config, bit[6:4] 1:enable/ 0:disable, bit[3:0] 0:select PU /1:select PD */
+
+    ircut_pins: ircut_pins {
+        anyka,pins = <71>;
+        anyka,function = <0>;
+        anyka,pull = <0x01010310>;
+    };
+
+    dvp12bits_pins: dvp12bits_pins {
+        anyka,pins = <25 26 27 28 109 110 111 112 113 114 115 116 117 118 119 120>;
+        anyka,function = <1>;
+        anyka,pull = <0x01010310>;
+    };
+
+    dvp10bits_pins: dvp10bits_pins {
+        //anyka,pins = <25 26 27 28 109 110 111 112 113 114 115 116 117 118>;
+        anyka,pins = <25 26 27 28 109 110 111 112 113 114 115 116 117 118 119 120>;
+        anyka,function = <1>;
+        anyka,pull = <0x01010310>;
+    };
+
+    dvp8bits_pins: dvp8bits_pins {
+        //anyka,pins = <25 26 27 28 109 110 111 112 113 114 115 116>;
+        anyka,pins = <25 26 27 28 109 110 111 112 113 114 115 116 117 118 119 120>;
+        anyka,function = <1>;
+        anyka,pull = <0x01010310>;
+    };
+
+    mipi0_2lane_pins: mipi0_2lane_pins {
+        anyka,pins = <25 115 116 117 118 119 120>;
+        anyka,function = <1 2 2 2 2 2 2>;
+        anyka,pull = <0x01010310>;
+    };
+
+    mipi0_1lane_pins: mipi0_1lane_pins {
+        anyka,pins = <25 117 118 119 120>;
+        anyka,function = <1 2 2 2 2>;
+        anyka,pull = <0x01010310>;
+    };
+
+    mipi1_2lane_pins: mipi1_2lane_pins {
+        anyka,pins = <26 109 110 111 112 113 114>;
+        anyka,function = <1 2 2 2 2 2 2>;
+        anyka,pull = <0x01010310>;
+    };
+
+    mipi1_1lane_pins: mipi1_1lane_pins {
+        anyka,pins = <26 111 112 113 114>;
+        anyka,function = <1 2 2 2 2>;
+        anyka,pull = <0x01010310>;
+    };
+
+    csi0_sclk_pin: csi0_sclk_pin {
+        anyka,pins = <25>;
+        anyka,function = <1>;
+        anyka,pull = <0x01010310>;
+    };
+
+    csi1_sclk_pin: csi1_sclk_pin {
+        anyka,pins = <26>;
+        anyka,function = <1>;
+        anyka,pull = <0x01010310>;
+    };
+
+    i2c0_pins: i2c0_pins {
+        anyka,pins = <31 32>;
+        anyka,function = <1>;
+        anyka,pull = <0x01010380>;
+        //anyka,pull = <0x01011110>;
+    };
+
+    mci0_pins: mci0_pins {
+        anyka,pins = <33 34 35 36 37 38 39 40 41 42>;
+        anyka,function = <1>;
+        anyka,pull = <0x10010 0x10010 0x10010 0x10010 0x10010 0x10010 0x10010 0x10010 0x10010 0x10010>;/* 4 line */ 
+    };
+
+    mci1_pins: mci1_pins {
+        anyka,pins = <43 44 45 46 47 48>;
+        anyka,function = <1>;
+        anyka,pull = <0x10010 0x10000 0x10010 0x10010 0x10010 0x10010>; /* 4 line */
+
+        /* 1 line */
+        /*
+        anyka,pins = <43 44 45>;
+        anyka,function = <1>;
+        anyka,pull = <0x10010 0x10000 0x10010>;*/
+    };
+    
+    mci2_pins: mci2_pins {
+    /*
+        anyka,pins = <91 92 93 94 95 96>;
+        anyka,function = <2 2 3 3 3 3>;
+        anyka,pull = <0x01010010 0x01010010 0x01010010 0x01010010 0x01010010 0x01010010>; 
+    */
+	// 1 line with D[1] as sdio interrupt pin
+        anyka,pins = <93 94 95 96>;
+        anyka,function = <3>;
+        anyka,pull = <0x01010010 0x01010010 0x01010010 0x01010010>;
+       
+
+    };
+
+    mmc_power_pins:mmc_power_pins{
+        anyka,pins = <81>;
+	    anyka,function = <0>;
+        anyka,pull = <0x01000310>;
+    };
+
+   sdio_wifi_pins:sdio_wifi_pins{
+        anyka,pins = <72>;
+	    anyka,function = <0>;
+        anyka,pull = <0x01000310>;
+    };
+
+    spiflash_pins: spiflash_pins {
+        anyka,pins = <12 82 67 68 69 70>; /* 4 LINE mode, 12 is spi nor cs, 18 is spinand cs*/
+        anyka,function = <1 0 0 0 0 0>;
+        anyka,pull = <0x01010010>;
+    };
+
+    lcd_reset_pins: lcd_reset_pins {
+	    anyka,pins = <83>;
+	    anyka,function = <0>;
+        anyka,pull = <0x01000310>;
+    };
+
+		gpiokey_pins:gpiokey_pins {
+			anyka,pins = <74>;
+			anyka,function = <0>;
+			anyka,pull = <0x01010010>;
+		};
+
+		ts_irq_pins:ts_irq_pins {
+			anyka,pins = <78>;
+			anyka,function = <0>;
+			anyka,pull = <0x01010111>;
+		};
+				
+    /*speak_en and linein_detect gpio setting */
+    speak_pins: speak_pins {
+        anyka,pins = <76>; 
+        anyka,function = <0>;
+        anyka,pull = <0x01010010>;
+    };
+    
+    uart0_pins: uart0_pins {
+        anyka,pins = <1 2>;
+        anyka,function = <1>;
+        anyka,pull = <0x01010010>;
+    };
+    
+    i2c2_pins: i2c2_pins {
+        anyka,pins = <97 98>;
+        anyka,function = <3>;
+        anyka,pull = <0x01011110>;
+    };
+
+	phy_reset_pins: phy_reset_pins {		
+		anyka,pins = <80>;		
+	    anyka,function = <0>;
+        anyka,pull = <0x01000010>;
+    };
+
+    gslX680_pins: gslX680_pins {
+		anyka,pins = <78 79>;
+	    anyka,function = <0>;
+        anyka,pull = <0x01000010>;
+    };
+
+    icn85xx_pins: icn85xx_pins {
+		anyka,pins = <36 38>;
+	    anyka,function = <0>;
+        anyka,pull = <0x01000010>;
+    };
+
+
+    ethernet_pins_rmii: ethernet_pins_rmii {
+		anyka,pins 		= <10 11 13 14 15 19 20 23 24 49>;
+        anyka,function 	= <1>;
+        anyka,pull = <0x01010011 0x01010010 0x01010011 0x01010011 0x01010011 0x01010011 0x01010011 0x01010011 0x01010011 0x01010110>;
+    };
+};
+
+&rtc {
+	   /* 
+	   ** rtc osc_source_select, 0 means INTERNAL RC OSC, 1 means EXTERNAL XTAL 
+	   */
+		osc-select = <0>;
+    status = "okay";
+};
+
+&watchdog {
+		/*max feed dog time = 357s, default setting time = 10s. */
+    def_heartbeat = <10>;
+    status = "okay";
+};
+
+&gui {
+    status = "okay";
+};
+
+&vencoder {
+    status = "okay";
+};
+
+&vdecoder {
+    status = "okay";
+};
+
+&usb {
+    status = "okay"; 
+};
+
+&mmc0 {
+    bus-width = <0x8>;
+    max-frequency = <50000000>;
+    /*
+     *  detect mode:
+     *  (1) non-removable;
+     *  (2) detect-gpio/detect-gpios: card detect using gpio
+     *      for example:
+     *      detect-gpio = <&gpio 77 1>;  or detect-gpios = <&gpio 77 1>;  
+     *  (3) cd_clk: card detect using MCLK
+     *  default is non-removable
+     */
+    cd_clk;
+    /* if support highspeed, using cap-sd-highspeed */
+    cap-sd-highspeed;
+    pinctrl-names = "default";
+    pinctrl-0 = <&mci0_pins>;
+    status = "disable";
+};
+
+&mmc1 {
+    bus-width = <0x4>;
+    max-frequency = <50000000>;
+    /*
+     *  detect mode:
+     *  (1) non-removable;
+     *  (2) detect-gpio/detect-gpios: card detect using gpio
+     *      for example:
+     *      detect-gpio = <&gpio 77 1>;  or detect-gpios = <&gpio 77 1>;  
+     *  (3) cd_clk: card detect using MCLK
+     *  default is non-removable
+     */
+    cd_clk;
+    /* if support highspeed, using cap-sd-highspeed */
+    cap-sd-highspeed;
+    pinctrl-names = "default";
+    pinctrl-0 = <&mci1_pins>,<&mmc_power_pins>;
+    power-pins = <&gpio 81 1>;
+    /* initial power pin value*/
+    power-pins-value = <0>; 
+    power-inverted;
+    status = "okay";
+};
+
+&mmc2 {
+    bus-width = <0x1>;
+    max-frequency = <50000000>;
+    /*
+     *  detect mode:
+     *  (1) non-removable;
+     *  (2) detect-gpio/detect-gpios: card detect using gpio
+     *      detect-gpio = <&gpio 77 1>;
+     *      or
+     *      detect-gpios = <&gpio 77 1>;
+     *  (3) cd_clk: card detect using MCLK
+     *  default is non-removable
+     */
+    non-removable;
+    /* if support sdio, using cap-sdio-irq*/
+    cap-sdio-irq;
+    /* if support highspeed, using cap-sd-highspeed */
+    cap-sd-highspeed;
+    pinctrl-names = "default";
+    pinctrl-0 = <&mci2_pins> , <&sdio_wifi_pins>;
+    power-pins = <&gpio 72 1>; 
+    /* initial power pin value*/
+    power-pins-value = <1>; 
+    status = "okay";
+};
+
+&dac {
+     pinctrl-names = "default";
+	   pinctrl-0 = <&speak_pins>;
+	   /* 
+	   ** speak-down,linein-detect,hp-mute,hp-detect
+	   ** 1 means enable these four function
+	   ** 0 means disable these four function
+	   */
+	   speak-down = <1>;
+	   linein-detect = <0>;
+	   hp-mute = <0>;
+	   hp-detect = <0>;
+	   speak-gpios = <&gpio 76 1>;
+	   //linein-gpios = <&gpio 54 1>;    
+     status = "okay";
+};	 
+
+&saradc{
+    /* SAR ADC VREF selection
+    * 0:To select AVCC 3.3V as VREF for SAR ADC.
+    * 1:To select 3.0V generated from BGR as VREF for SAR ADC.
+    */
+    vref-select = <1>;
+    /*
+    * 0:To disable BAT voltage divider. 
+    * 1:To enable BAT voltage divider divided by 2.
+    */
+    battery-divider = <1>;
+    /*
+    * Sampling number
+    * Read the sampling data for N times and then calculate the average value.
+    * N ranges from 1 to 7.
+    */
+     sampling-num = <3>;
+     status = "okay";
+};
+
+&spi0 {
+    pinctrl-names = "default";
+    pinctrl-0 = <&spiflash_pins>;
+    cs-gpios = <&gpio 12 1>, <&gpio 82 1>;
+    spi-bus-frequency = <80000000>;
+    status = "okay";
+    
+};
+
+&spif0 {
+	compatible = "anyka,ak-spinand";
+	status = "okay";
+};
+
+&GD5F1GQ4UB {
+   	status = "okay";
+};
+
+&GD5F2GQ4UB {
+   	status = "okay";
+};
+
+&uart0 {
+    pinctrl-names = "default";
+	pinctrl-0 = <&uart0_pins>;
+    status = "okay";
+};
+
+&i2c0 {
+    pinctrl-names = "default";
+    pinctrl-0 = <&i2c0_pins>;
+
+    clock-frequency = <312000>;
+    sda-delay = <100>;
+    status = "okay";
+	#address-cells = <1>;
+	#size-cells = <0>;
+    
+	sensor0: camera@0x30{
+		compatible = "anyka,sensor0";
+		reg = <0x30>;
+
+		/*0xffff means the gpio is invalid*/
+		reset-gpio = <&gpio 3 1>;
+		pwdn-gpio = <&gpio 0xffff 1>;
+
+		port {
+			sensor0_0: endpoint@0 {
+				remote-endpoint = <&vi_0_0>;
+			};
+		};
+	};
+};
+
+&i2c1 {
+    pinctrl-names = "default";
+    //pinctrl-0 = <&i2c1_pins>;
+    
+    clock-frequency = <312000>;
+    sda-delay = <100>;
+    status = "disable";
+};
+
+&i2c2 {
+    pinctrl-names = "default";
+    pinctrl-0 = <&i2c2_pins>;
+
+    clock-frequency = <312000>;
+    sda-delay = <100>;
+    status = "okay";
+    
+     touch-screen@40 {
+		    compatible = "anyka,ak3790d-i2c-touchscreen-gslX680";
+		    reg = <0x40>;
+		    /* MIPI touch-pane irq and reset gpio setting */
+		    pinctrl-names = "default";
+            pinctrl-0 = <&gslX680_pins>;
+            irq-gpio = <&gpio 78 1>;
+            reset-gpio = <&gpio 79 1>;
+            TP_MAX_X = <1280>;
+            TP_MAX_Y = <800>;
+            status = "okay";
+	  };
+		       
+	  touch-screen@48 {
+		   compatible = "anyka,ak3790d-i2c-touchscreen-icn85xx";
+		    reg = <0x48>;
+		    /* RGB touch-pane irq and reset gpio setting */
+            pinctrl-names = "default";
+            pinctrl-0 = <&icn85xx_pins>;
+            irq-gpio = <&gpio 36 1>;
+            reset-gpio = <&gpio 38 1>;
+            TP_MAX_X = <1024>;
+            TP_MAX_Y = <600>;
+            status = "disable";
+	  }; 
+	  
+};
+
+&ethernet {
+    pinctrl-names = "default";
+    pinctrl-0 = <&ethernet_pins_rmii &phy_reset_pins>;
+    reset-gpios = <&gpio 80 1>;
+    status = "okay";
+};
+
+&ircut {
+    pinctrl-names = "default";
+    pinctrl-0 = <&ircut_pins>;
+
+	ircut-a = "71";
+	/*set the level for day mode. range: 0, 1*/
+	ircut-a-day-level = "0";
+	status = "okay";
+};
+
+&photosensitive {
+    //pinctrl-names = "default";
+    //pinctrl-0 = <&photosensitive_pins>;
+
+	/*range: saradc~1, gpio number*/
+	photosensitive-port = "saradc0";
+	/*the level for day mode, range: low, high*/
+	photosensitive-day-level = "high";
+	status = "okay";
+};
+
+&leds {
+	pinctrl-names = "default";
+	//pinctrl-0 = <&led_pins>;
+	led-gpios = <&gpio 29 1
+                 &gpio 30 1>;
+	status = "okay";
+};
+
+&adkeys {
+	status = "disable";
+};
+
+&gpiokeys {
+		#address-cells = <1>;
+		#size-cells = <0>;
+		pinctrl-0 = <&gpiokey_pins>;
+		pinctrl-names = "default";
+		
+	key_detect {
+		label = "key_detect";
+		gpios = <&gpio 74 1>;
+		linux,code = <116>;
+		debounce-interval = <100>;
+		wakeup-source;
+	};
+	
+	//status = "okay";
+};
+
+
+&motor0 {
+	status = "disable";
+};
+
+&motor1 {
+	status = "disable";
+};
+
+&pwm0 {
+	pinctrl-names = "default";
+
+	//pinctrl-0 = <&pwm0_pins>;
+	/*
+	**frequency of PWM ranges from 92H to 6MHz.
+	**duty of PWM ranges from 1 to 65535.
+	**Minimum duty cycle:1/65536
+	**Maximum duty cyscle:65535/65536.
+	**period-ns: period of the PWM signal (in nanoseconds)
+        **duty-ns: duty cycle of the PWM signal (in nanoseconds)
+	**pwm-enable = 0 means disable pwm function.
+	**pwm-enable = 1 means enable pwm function.
+	*/
+	period-ns = <1000000>;
+	duty-ns = <500000>;
+	pwm-enable = <1>;
+	status = "disable";
+};
+
+&pwm1 {
+	pinctrl-names = "default";
+
+	//pinctrl-0 = <&pwm1_pins>;
+	/*
+	**frequency of PWM ranges from 92H to 6MHz.
+	**duty of PWM ranges from 1 to 65535.
+	**Minimum duty cycle:1/65536
+	**Maximum duty cyscle:65535/65536.
+	**period-ns: period of the PWM signal (in nanoseconds)
+        **duty-ns: duty cycle of the PWM signal (in nanoseconds)
+	**pwm-enable = 0 means disable pwm function.
+	**pwm-enable = 1 means enable pwm function.
+	*/
+	period-ns = <1000000>;
+	duty-ns = <500000>;
+	pwm-enable = <1>;
+	status = "disable";
+};
+
+&pwm2 {
+	pinctrl-names = "default";
+
+	//pinctrl-0 = <&pwm2_pins>;
+	/*
+	**frequency of PWM ranges from 92H to 6MHz.
+	**duty of PWM ranges from 1 to 65535.
+	**Minimum duty cycle:1/65536
+	**Maximum duty cyscle:65535/65536.
+	**period-ns: period of the PWM signal (in nanoseconds)
+        **duty-ns: duty cycle of the PWM signal (in nanoseconds)
+	**pwm-enable = 0 means disable pwm function.
+	**pwm-enable = 1 means enable pwm function.
+	*/
+	period-ns = <1000000>;
+	duty-ns = <500000>;
+	pwm-enable = <1>;
+	status = "disable";
+};
+
+&pwm3 {
+	pinctrl-names = "default";
+
+	//pinctrl-0 = <&pwm3_pins>;
+	/*
+	**frequency of PWM ranges from 92H to 6MHz.
+	**duty of PWM ranges from 1 to 65535.
+	**Minimum duty cycle:1/65536
+	**Maximum duty cyscle:65535/65536.
+	**period-ns: period of the PWM signal (in nanoseconds)
+        **duty-ns: duty cycle of the PWM signal (in nanoseconds)
+	**pwm-enable = 0 means disable pwm function.
+	**pwm-enable = 1 means enable pwm function.
+	*/
+	period-ns = <1000000>;
+	duty-ns = <500000>;
+	pwm-enable = <1>;
+	status = "disable";
+};
+
+&pwm4 {
+	pinctrl-names = "default";
+	//pinctrl-0 = <&pwm4_pins>;
+	/*
+	**frequency of PWM ranges from 92H to 6MHz.
+	**duty of PWM ranges from 1 to 65535.
+	**Minimum duty cycle:1/65536
+	**Maximum duty cyscle:65535/65536.
+	**period-ns: period of the PWM signal (in nanoseconds)
+        **duty-ns: duty cycle of the PWM signal (in nanoseconds)
+	**pwm-enable = 0 means disable pwm function.
+	**pwm-enable = 1 means enable pwm function.
+	*/
+	period-ns = <1000000>;
+	duty-ns = <500000>;
+	pwm-enable = <1>;
+	status = "disable";
+};
+
+&lcdc {
+    pinctrl-names = "default";
+    pinctrl-0 = <&lcd_reset_pins>; //<&lcd_pins>,<&lcd_reset_pins>; //lcd_pins for rgb lcd, lcd_reset_pins only for mipi lcd
+    reset-pins = <&gpio 83 1>; //only for mipi lcd
+    
+    lcd-logo-width = <600>;
+    lcd-logo-height = <165>;
+    //[fmt1:fmt0] 00 16bits input(RGB565 or BGR565)
+    //[fmt1:fmt0] 01 24bits input(RGB888 or BGR888)
+    //[fmt1:fmt0] 10 or 11 32bits input(ARGB888 ABGR888 RGBA888 BGRA888)
+    lcd-logo-fmt0 = <1>;
+    lcd-logo-fmt1 = <0>;
+    lcd-logo-rgb-seq = <1>; //0 for BGR, 1 for RGB
+    
+    lcd-fb-type = <1>; //0:single buffer; 1:double buffer
+    status = "okay";
+};
+
+&sat101cp40 {
+    status = "okay";
+};
+
+
+&am1080wq05 {
+    status = "disable";
+};
+
+&vi0{
+	pinctrl-names = "dvp12bits", "dvp10bits", "dvp8bits",
+		"mipi0_2lane", "mipi0_1lane", "mipi1_2lane", "mipi1_1lane",
+		"csi0_sclk", "csi1_sclk";
+    pinctrl-0 = <&dvp12bits_pins>;
+    pinctrl-1 = <&dvp10bits_pins>;
+    pinctrl-2 = <&dvp8bits_pins>;
+    pinctrl-3 = <&mipi0_2lane_pins>;
+    pinctrl-4 = <&mipi0_1lane_pins>;
+    pinctrl-5 = <&mipi1_2lane_pins>;
+    pinctrl-6 = <&mipi1_1lane_pins>;
+    pinctrl-7 = <&csi0_sclk_pin>;
+    pinctrl-8 = <&csi1_sclk_pin>;
+    status = "okay";
+
+	port@0 {
+		#address-cells = <1>;
+		#size-cells = <0>;
+
+		vi_0_0: endpoint@0 {
+			reg = <0>;
+			remote-endpoint = <&sensor0_0>;
+		};
+	};
+};
diff --git a/arch/arm/boot/dts/c500_cbd_ak3761d_rgb_v1.0.0.dts b/arch/arm/boot/dts/c500_cbd_ak3761d_rgb_v1.0.0.dts
new file mode 100755
index 0000000..1a91311
--- /dev/null
+++ b/arch/arm/boot/dts/c500_cbd_ak3761d_rgb_v1.0.0.dts
@@ -0,0 +1,649 @@
+/*
+ * AK37D dev board dts
+ *
+ * Copyright (C) 2018 Anyka(Guangzhou) Microelectronics Technology Co., Ltd.
+ *
+ * Author: Feilong Dong <dong_feilong@anyka.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+/dts-v1/;
+#include "anyka_ev501.dtsi"
+#include "anyka_ev500_lcd.dtsi"
+#include "anyka_ev500_norflash.dtsi"
+
+
+/ {
+    compatible = "anyka,ak3790d";
+    model = "AK3760D dev board";
+	version = "V1.0.02";
+};
+
+&gpio {
+    /* anyka,function sharepin func index according to table 2-1 sharepin-list */
+    /* index: 0: PIN default func, 1: FUNCTION1, 2: FUNCTION2, 3: FUNCTION3, 4: FUNCTION4 */
+    /* anyka,pull config value bit[31:24]--slew rate, bit[23:16]--ie, bit[15:8]--drive, bit[7:0]--pupd config */
+    /* bit[31:24]--slew rate, 0: slow, 1: fast */
+    /* bit[23:16]--ie, input enable, 0: disable, 1: enable */
+    /* bit[15:8]--drive, drive strength, 4levels value: 0x0-0x3 */
+    /* bit[7:0]--bit[7]: open drain 0:disable, 1:enable (only for gpio31/32);
+				pupd config, bit[6:4] 1:enable/ 0:disable, bit[3:0] 0:select PU /1:select PD */
+
+    ircut_pins: ircut_pins {
+        anyka,pins = <42>;
+        anyka,function = <0>;
+        anyka,pull = <0x01010310>;
+    };
+
+    dvp12bits_pins: dvp12bits_pins {
+        anyka,pins = <25 26 27 28 109 110 111 112 113 114 115 116 117 118 119 120>;
+        anyka,function = <1>;
+        anyka,pull = <0x01010310>;
+    };
+
+    dvp10bits_pins: dvp10bits_pins {
+        //anyka,pins = <25 26 27 28 109 110 111 112 113 114 115 116 117 118>;
+        anyka,pins = <25 26 27 28 109 110 111 112 113 114 115 116 117 118 119 120>;
+        anyka,function = <1>;
+        anyka,pull = <0x01010310>;
+    };
+
+    dvp8bits_pins: dvp8bits_pins {
+        //anyka,pins = <25 26 27 28 109 110 111 112 113 114 115 116>;
+        anyka,pins = <25 26 27 28 109 110 111 112 113 114 115 116 117 118 119 120>;
+        anyka,function = <1>;
+        anyka,pull = <0x01010310>;
+    };
+
+    mipi0_2lane_pins: mipi0_2lane_pins {
+        anyka,pins = <25 115 116 117 118 119 120>;
+        anyka,function = <1 2 2 2 2 2 2>;
+        anyka,pull = <0x01010310>;
+    };
+
+    mipi0_1lane_pins: mipi0_1lane_pins {
+        anyka,pins = <25 117 118 119 120>;
+        anyka,function = <1 2 2 2 2>;
+        anyka,pull = <0x01010310>;
+    };
+
+    mipi1_2lane_pins: mipi1_2lane_pins {
+        anyka,pins = <26 109 110 111 112 113 114>;
+        anyka,function = <1 2 2 2 2 2 2>;
+        anyka,pull = <0x01010310>;
+    };
+
+    mipi1_1lane_pins: mipi1_1lane_pins {
+        anyka,pins = <26 111 112 113 114>;
+        anyka,function = <1 2 2 2 2>;
+        anyka,pull = <0x01010310>;
+    };
+
+    csi0_sclk_pin: csi0_sclk_pin {
+        anyka,pins = <25>;
+        anyka,function = <1>;
+        anyka,pull = <0x01010310>;
+    };
+
+    csi1_sclk_pin: csi1_sclk_pin {
+        anyka,pins = <26>;
+        anyka,function = <1>;
+        anyka,pull = <0x01010310>;
+    };
+
+    i2c0_pins: i2c0_pins {
+        anyka,pins = <31 32>;
+        anyka,function = <1>;
+        anyka,pull = <0x01010380>;
+        //anyka,pull = <0x01011110>;
+    };
+
+	mci1_pins: mci1_pins {
+        anyka,pins = <43 44 45 46 47 48>;
+        anyka,function = <1>;
+        anyka,pull = <0x10010 0x10000 0x10010 0x10010 0x10010 0x10010>;/* 4 line */
+
+        /* 1 line */
+        /*anyka,pins = <43 44 45>;*/
+        /*anyka,function = <1>;*/
+        /*anyka,pull = <0x10010 0x10000 0x10010>;*/  
+    };
+    
+    mci2_pins: mci2_pins {
+        //4 line with GPIO91-96
+        /*anyka,pins = <91 92 93 94 95 96>;
+        anyka,function = <2 2 3 3 3 3>;
+        anyka,pull = <0x01010010 0x01010010 0x01010010 0x01010010 0x01010010 0x01010010>; */
+
+        // 1 line with GPIO93-95
+        /*
+        anyka,pins = <93 94 95>;
+        anyka,function = <3>;
+        anyka,pull = <0x01010010 0x01010010 0x01010010>;*/
+
+        // 1 line with GPIO19 20 24, with 23 sdio irq pin
+        anyka,pins = <19 20  23 24>;
+        anyka,function = <2>;
+        anyka,pull = <0x01010010 0x01010010 0x01010010 0x01010010>;
+
+        // 4 line
+        /*
+        anyka,pins = <14 15 19 20  23 24>;
+        anyka,function = <2>;
+		anyka,pull = <0x01010010 0x01010010 0x01010010 0x01010010 0x01010010 0x01010010>;*/
+    };
+
+    spiflash_pins: spiflash_pins {
+        anyka,pins = <12 67 68 69 70>; /* 4 LINE mode, 12 is spi nor cs*/
+        anyka,function = <1 0 0 0 0>;
+        anyka,pull = <0x01010010>;
+    };
+
+		gpiokey_pins:gpiokey_pins {
+			anyka,pins = <39>;
+			anyka,function = <0>;
+			anyka,pull = <0x01010010>;
+		};
+		
+
+		/* gpio83 and gpio84  are used as i2c */
+    lcd_pins: lcd_pins {
+        anyka,pins = <74 71 72 73
+        	          75 76 77 78
+        	          79 80 81 82
+        	          85 86
+        	          87 88 89 90
+        	          91 92 93 94
+        	          95 96 97 98>;
+        anyka,function = <1>;
+        anyka,pull = <0x01010310>;
+    };
+    
+    uart0_pins: uart0_pins {
+        anyka,pins = <1 2>;
+        anyka,function = <1>;
+        anyka,pull = <0x01010010>;
+    };
+    
+    i2c2_pins: i2c2_pins {
+        anyka,pins = <83 84>;
+        anyka,function = <2>;
+        anyka,pull = <0x01011110>;
+    };
+
+     pwm4_pins: pwm4_pins {
+        anyka,pins = <41>;
+        anyka,function = <2>;
+        anyka,pull = <0x01011110>;
+    };
+
+	  phy_reset_pins: phy_reset_pins {
+		    anyka,pins = <23>;
+	      anyka,function = <0>;
+        anyka,pull = <0x01000010>;
+    };
+
+    gslX680_pins: gslX680_pins {
+        anyka,pins = <78 79>;
+        anyka,function = <0>;
+        anyka,pull = <0x01000010>;
+    };
+
+    icn85xx_pins: icn85xx_pins {
+        anyka,pins = <36 38>;
+        anyka,function = <0>;
+        anyka,pull = <0x01000010>;
+    };
+
+
+
+    ethernet_pins_rmii: ethernet_pins_rmii {
+		    anyka,pins 		= <10 11 13 14 15 19 20 24 49>;
+        anyka,function 	= <1>;
+        anyka,pull = <0x01010011 0x01010010 0x01010011 0x01010011 0x01010011 0x01010011 0x01010011  0x01010011 0x01010110>;
+    };
+};
+
+&rtc {
+	   /* 
+	   ** rtc osc_source_select, 0 means INTERNAL RC OSC, 1 means EXTERNAL XTAL 
+	   */
+		osc-select = <0>;
+    status = "okay";
+};
+
+&watchdog {
+	/*max feed dog time = 357s, default setting time = 10s. */
+    def_heartbeat = <10>;
+    status = "okay";
+};
+
+&gui {
+    status = "okay";
+};
+
+&vencoder {
+    status = "okay";
+};
+
+&vdecoder {
+    status = "okay";
+};
+
+&usb {
+    status = "okay"; 
+};
+
+
+&mmc1 {
+    bus-width = <0x4>;
+    max-frequency = <50000000>;
+    /*
+     *  detect mode:
+     *  (1) non-removable;
+     *  (2) detect-gpio/detect-gpios: card detect using gpio
+     *      for example:
+     *      detect-gpio = <&gpio 77 1>;  or detect-gpios = <&gpio 77 1>;  
+     *  (3) cd_clk: card detect using MCLK
+     *  default is non-removable
+     */
+    cd_clk;
+    /* if support highspeed, using cap-sd-highspeed */
+    cap-sd-highspeed;
+    pinctrl-names = "default";
+    pinctrl-0 = <&mci1_pins>;
+    status = "okay";
+};
+
+&mmc2 {
+    bus-width = <0x1>;
+    max-frequency = <50000000>;
+    /*
+     *  detect mode:
+     *  (1) non-removable;
+     *  (2) detect-gpio/detect-gpios: card detect using gpio
+     *      for example:
+     *      detect-gpio = <&gpio 77 1>;  or detect-gpios = <&gpio 77 1>;  
+     *  (3) cd_clk: card detect using MCLK
+     *  default is non-removable
+     */
+    non-removable;
+    /* if support sdio, using cap-sdio-irq*/
+    cap-sdio-irq;
+    /* if support highspeed, using cap-sd-highspeed */
+    cap-sd-highspeed;
+    pinctrl-names = "default";
+    pinctrl-0 = <&mci2_pins>;
+    status = "disable";
+};
+
+&dac {
+	pinctrl-names = "default";
+	//pinctrl-0 = <&speak_pins>;
+	/*
+	 ** speak-down,linein-detect,hp-mute,hp-detect
+	 ** 1 means enable these four function
+	 ** 0 means disable these four function
+	 */
+	speak-down = <1>;
+	linein-detect = <0>;
+	hp-mute = <0>;
+	hp-detect = <0>;
+	//speak-gpios = <&gpio 76 1>;
+	//linein-gpios = <&gpio 54 1>;
+	status = "okay";
+};
+
+&saradc{
+    /* SAR ADC VREF selection
+    * 0:To select AVCC 3.3V as VREF for SAR ADC.
+    * 1:To select 3.0V generated from BGR as VREF for SAR ADC.
+    */
+    vref-select = <1>;
+    /*
+    * 0:To disable BAT voltage divider. 
+    * 1:To enable BAT voltage divider divided by 2.
+    */
+    battery-divider = <1>;
+    /*
+    * Sampling number
+    * Read the sampling data for N times and then calculate the average value.
+    * N ranges from 1 to 7.
+    */
+     sampling-num = <3>;
+     status = "okay";
+};
+
+&spi0 {
+    pinctrl-names = "default";
+    pinctrl-0 = <&spiflash_pins>;
+    cs-gpios = <&gpio 12 1>;
+    spi-bus-frequency = <80000000>;
+    status = "okay";
+};
+
+&spif0 {
+	status = "okay";
+};
+
+&gd25q64{
+   	status = "okay";
+};
+
+&gd25q128{
+   	status = "okay";
+};
+
+&uart0 {
+    pinctrl-names = "default";
+	pinctrl-0 = <&uart0_pins>;
+    status = "okay";
+};
+
+&i2c0 {
+    pinctrl-names = "default";
+    pinctrl-0 = <&i2c0_pins>;
+
+    clock-frequency = <312000>;
+    sda-delay = <100>;
+    status = "okay";
+	#address-cells = <1>;
+	#size-cells = <0>;
+
+	sensor0: camera@0x30{
+		compatible = "anyka,sensor0";
+		reg = <0x30>;
+
+		/*0xffff means the gpio is invalid*/
+		reset-gpio = <&gpio 3 1>;
+		pwdn-gpio = <&gpio 0xffff 1>;
+
+		port {
+			sensor0_0: endpoint@0 {
+				remote-endpoint = <&vi_0_0>;
+			};
+		};
+	};
+};
+
+&i2c1 {
+    pinctrl-names = "default";
+    //pinctrl-0 = <&i2c1_pins>;
+    
+    clock-frequency = <312000>;
+    sda-delay = <100>;
+    status = "disable";
+};
+
+&i2c2 {
+    pinctrl-names = "default";
+    pinctrl-0 = <&i2c2_pins>;
+
+    clock-frequency = <312000>;
+    sda-delay = <100>;
+    status = "okay";
+    
+    touch-screen@40 {
+		    compatible = "anyka,ak3790d-i2c-touchscreen-gslX680";
+		    reg = <0x40>;
+		    /* MIPI touch-pane irq and reset gpio setting */
+		    pinctrl-names = "default";
+            pinctrl-0 = <&gslX680_pins>;
+            irq-gpio = <&gpio 78 1>;
+            reset-gpio = <&gpio 79 1>;
+            TP_MAX_X = <1280>;
+            TP_MAX_Y = <800>;
+            status = "disable";
+	  };
+		       
+	  touch-screen@48 {
+		   compatible = "anyka,ak3790d-i2c-touchscreen-icn85xx";
+		    reg = <0x48>;
+		    /* RGB touch-pane irq and reset gpio setting */
+            pinctrl-names = "default";
+            pinctrl-0 = <&icn85xx_pins>;
+            irq-gpio = <&gpio 36 1>;
+            reset-gpio = <&gpio 38 1>;
+
+            TP_MAX_X = <1024>;
+            TP_MAX_Y = <600>;
+            status = "okay";
+	  }; 
+	  
+};
+
+&ethernet {
+    pinctrl-names = "default";
+    pinctrl-0 = <&ethernet_pins_rmii &phy_reset_pins>;
+    reset-gpios = <&gpio 23 1>;
+    status = "okay";
+};
+
+&ircut {
+    pinctrl-names = "default";
+    pinctrl-0 = <&ircut_pins>;
+
+	ircut-a = "42";
+	/*set the level for day mode. range: 0, 1*/
+	ircut-a-day-level = "0";
+	status = "okay";
+};
+
+&photosensitive {
+    //pinctrl-names = "default";
+    //pinctrl-0 = <&photosensitive_pins>;
+
+	/*range: saradc~1, gpio number*/
+	photosensitive-port = "saradc0";
+	/*the level for day mode, range: low, high*/
+	photosensitive-day-level = "high";
+	status = "okay";
+};
+
+&leds {
+	pinctrl-names = "default";
+	//pinctrl-0 = <&led_pins>;
+	//led-gpios = <&gpio 29 1
+                 //&gpio 30 1>;
+	status = "disable";
+};
+
+&adkeys {
+	status = "disable";
+};
+
+&gpiokeys {
+		#address-cells = <1>;
+		#size-cells = <0>;
+		pinctrl-0 = <&gpiokey_pins>;
+		pinctrl-names = "default";
+		
+	key_detect {
+		label = "key_detect";
+		gpios = <&gpio 39 1>;
+		linux,code = <116>;
+		debounce-interval = <100>;
+		wakeup-source;
+	};
+	
+	//status = "okay";
+};
+
+
+&motor0 {
+	status = "disable";
+};
+
+&motor1 {
+	status = "disable";
+};
+
+&pwm0 {
+	pinctrl-names = "default";
+
+	//pinctrl-0 = <&pwm0_pins>;
+	/*
+	**frequency of PWM ranges from 92H to 6MHz.
+	**duty of PWM ranges from 1 to 65535.
+	**Minimum duty cycle:1/65536
+	**Maximum duty cyscle:65535/65536.
+	**period-ns: period of the PWM signal (in nanoseconds)
+        **duty-ns: duty cycle of the PWM signal (in nanoseconds)
+	**pwm-enable = 0 means disable pwm function.
+	**pwm-enable = 1 means enable pwm function.
+	*/
+	period-ns = <1000000>;
+	duty-ns = <500000>;
+	pwm-enable = <1>;
+
+	status = "disable";
+};
+
+&pwm1 {
+	pinctrl-names = "default";
+
+	//pinctrl-0 = <&pwm1_pins>;
+	/*
+	**frequency of PWM ranges from 92H to 6MHz.
+	**duty of PWM ranges from 1 to 65535.
+	**Minimum duty cycle:1/65536
+	**Maximum duty cyscle:65535/65536.
+	**period-ns: period of the PWM signal (in nanoseconds)
+        **duty-ns: duty cycle of the PWM signal (in nanoseconds)
+	**pwm-enable = 0 means disable pwm function.
+	**pwm-enable = 1 means enable pwm function.
+	*/
+	period-ns = <1000000>;
+	duty-ns = <500000>;
+	pwm-enable = <1>;
+
+	status = "disable";
+};
+
+&pwm2 {
+	pinctrl-names = "default";
+
+	//pinctrl-0 = <&pwm2_pins>;
+	/*
+	**frequency of PWM ranges from 92H to 6MHz.
+	**duty of PWM ranges from 1 to 65535.
+	**Minimum duty cycle:1/65536
+	**Maximum duty cyscle:65535/65536.
+	**period-ns: period of the PWM signal (in nanoseconds)
+        **duty-ns: duty cycle of the PWM signal (in nanoseconds)
+	**pwm-enable = 0 means disable pwm function.
+	**pwm-enable = 1 means enable pwm function.
+	*/
+	period-ns = <1000000>;
+	duty-ns = <500000>;
+	pwm-enable = <1>;
+
+	status = "disable";
+};
+
+&pwm3 {
+	pinctrl-names = "default";
+
+	//pinctrl-0 = <&pwm3_pins>;
+	/*
+	**frequency of PWM ranges from 92H to 6MHz.
+	**duty of PWM ranges from 1 to 65535.
+	**Minimum duty cycle:1/65536
+	**Maximum duty cyscle:65535/65536.
+	**period-ns: period of the PWM signal (in nanoseconds)
+        **duty-ns: duty cycle of the PWM signal (in nanoseconds)
+	**pwm-enable = 0 means disable pwm function.
+	**pwm-enable = 1 means enable pwm function.
+	*/
+	period-ns = <1000000>;
+	duty-ns = <500000>;
+	pwm-enable = <1>;
+	status = "disable";
+};
+
+&pwm4 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pwm4_pins>;
+	/*
+	**frequency of PWM ranges from 92H to 6MHz.
+	**duty of PWM ranges from 1 to 65535.
+	**Minimum duty cycle:1/65536
+	**Maximum duty cyscle:65535/65536.
+	**period-ns: period of the PWM signal (in nanoseconds)
+        **duty-ns: duty cycle of the PWM signal (in nanoseconds)
+	**pwm-enable = 0 means disable pwm function.
+	**pwm-enable = 1 means enable pwm function.
+	*/
+	period-ns = <1000000>;
+	duty-ns = <500000>;
+	pwm-enable = <1>;
+	status = "okay";
+};
+
+&lcdc {
+    pinctrl-names = "default";
+    pinctrl-0 = <&lcd_pins>; //<&lcd_pins>,<&lcd_reset_pins>; //lcd_reset_pins only for mipi lcd
+    
+    lcd-logo-width = <600>;
+    lcd-logo-height = <165>;
+    //[fmt1:fmt0] 00 16bits input(RGB565 or BGR565)
+    //[fmt1:fmt0] 01 24bits input(RGB888 or BGR888)
+    //[fmt1:fmt0] 10 or 11 32bits input(ARGB888 ABGR888 RGBA888 BGRA888)
+    lcd-logo-fmt0 = <1>;
+    lcd-logo-fmt1 = <0>;
+    lcd-logo-rgb-seq = <1>; //0 for BGR, 1 for RGB
+    
+    lcd-fb-type = <1>; //0:single buffer; 1:double buffer
+    status = "okay";
+};
+
+&sat101cp40 {
+    status = "disable";
+};
+
+&sat070cp50 {
+    status = "disable";
+};
+
+&adt07016BR50 {
+    status = "okay";
+};
+
+&am1080wq05 {
+    status = "disable";
+};
+
+&vi0{
+	pinctrl-names = "dvp12bits", "dvp10bits", "dvp8bits",
+		"mipi0_2lane", "mipi0_1lane", "mipi1_2lane", "mipi1_1lane",
+		"csi0_sclk", "csi1_sclk";
+    pinctrl-0 = <&dvp12bits_pins>;
+    pinctrl-1 = <&dvp10bits_pins>;
+    pinctrl-2 = <&dvp8bits_pins>;
+    pinctrl-3 = <&mipi0_2lane_pins>;
+    pinctrl-4 = <&mipi0_1lane_pins>;
+    pinctrl-5 = <&mipi1_2lane_pins>;
+    pinctrl-6 = <&mipi1_1lane_pins>;
+    pinctrl-7 = <&csi0_sclk_pin>;
+    pinctrl-8 = <&csi1_sclk_pin>;
+    status = "okay";
+
+	port@0 {
+		#address-cells = <1>;
+		#size-cells = <0>;
+
+		vi_0_0: endpoint@0 {
+			reg = <0>;
+			remote-endpoint = <&sensor0_0>;
+		};
+	};
+};
diff --git a/arch/arm/boot/dts/c500_cbd_ak3761d_rgb_v1.0.0_spinand.dts b/arch/arm/boot/dts/c500_cbd_ak3761d_rgb_v1.0.0_spinand.dts
new file mode 100755
index 0000000..b3463eb
--- /dev/null
+++ b/arch/arm/boot/dts/c500_cbd_ak3761d_rgb_v1.0.0_spinand.dts
@@ -0,0 +1,653 @@
+/*
+ * AK37D dev board dts
+ *
+ * Copyright (C) 2018 Anyka(Guangzhou) Microelectronics Technology Co., Ltd.
+ *
+ * Author: Feilong Dong <dong_feilong@anyka.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+/dts-v1/;
+#include "anyka_ev501.dtsi"
+#include "anyka_ev500_lcd.dtsi"
+#include "anyka_ev500_nandflash0.dtsi"
+
+/ {
+    compatible = "anyka,ak3790d";
+    model = "AK3760D dev board";
+	version = "V1.0.02";
+
+	chosen {
+		/* No padding required - the uboot can do that. */
+		bootargs = "console=ttySAK0,115200n8 root=/dev/mtdblock6 rootfstype=yaffs2 init=/sbin/init mem=128M memsize=128M";
+	};
+};
+
+&gpio {
+    /* anyka,function sharepin func index according to table 2-1 sharepin-list */
+    /* index: 0: PIN default func, 1: FUNCTION1, 2: FUNCTION2, 3: FUNCTION3, 4: FUNCTION4 */
+    /* anyka,pull config value bit[31:24]--slew rate, bit[23:16]--ie, bit[15:8]--drive, bit[7:0]--pupd config */
+    /* bit[31:24]--slew rate, 0: slow, 1: fast */
+    /* bit[23:16]--ie, input enable, 0: disable, 1: enable */
+    /* bit[15:8]--drive, drive strength, 4levels value: 0x0-0x3 */
+    /* bit[7:0]--bit[7]: open drain 0:disable, 1:enable (only for gpio31/32);
+				pupd config, bit[6:4] 1:enable/ 0:disable, bit[3:0] 0:select PU /1:select PD */
+
+    ircut_pins: ircut_pins {
+        anyka,pins = <42>;
+        anyka,function = <0>;
+        anyka,pull = <0x01010310>;
+    };
+
+    dvp12bits_pins: dvp12bits_pins {
+        anyka,pins = <25 26 27 28 109 110 111 112 113 114 115 116 117 118 119 120>;
+        anyka,function = <1>;
+        anyka,pull = <0x01010310>;
+    };
+
+    dvp10bits_pins: dvp10bits_pins {
+        //anyka,pins = <25 26 27 28 109 110 111 112 113 114 115 116 117 118>;
+        anyka,pins = <25 26 27 28 109 110 111 112 113 114 115 116 117 118 119 120>;
+        anyka,function = <1>;
+        anyka,pull = <0x01010310>;
+    };
+
+    dvp8bits_pins: dvp8bits_pins {
+        //anyka,pins = <25 26 27 28 109 110 111 112 113 114 115 116>;
+        anyka,pins = <25 26 27 28 109 110 111 112 113 114 115 116 117 118 119 120>;
+        anyka,function = <1>;
+        anyka,pull = <0x01010310>;
+    };
+
+    mipi0_2lane_pins: mipi0_2lane_pins {
+        anyka,pins = <25 115 116 117 118 119 120>;
+        anyka,function = <1 2 2 2 2 2 2>;
+        anyka,pull = <0x01010310>;
+    };
+
+    mipi0_1lane_pins: mipi0_1lane_pins {
+        anyka,pins = <25 117 118 119 120>;
+        anyka,function = <1 2 2 2 2>;
+        anyka,pull = <0x01010310>;
+    };
+
+    mipi1_2lane_pins: mipi1_2lane_pins {
+        anyka,pins = <26 109 110 111 112 113 114>;
+        anyka,function = <1 2 2 2 2 2 2>;
+        anyka,pull = <0x01010310>;
+    };
+
+    mipi1_1lane_pins: mipi1_1lane_pins {
+        anyka,pins = <26 111 112 113 114>;
+        anyka,function = <1 2 2 2 2>;
+        anyka,pull = <0x01010310>;
+    };
+
+    csi0_sclk_pin: csi0_sclk_pin {
+        anyka,pins = <25>;
+        anyka,function = <1>;
+        anyka,pull = <0x01010310>;
+    };
+
+    csi1_sclk_pin: csi1_sclk_pin {
+        anyka,pins = <26>;
+        anyka,function = <1>;
+        anyka,pull = <0x01010310>;
+    };
+    i2c0_pins: i2c0_pins {
+        anyka,pins = <31 32>;
+        anyka,function = <1>;
+        anyka,pull = <0x01010380>;
+        //anyka,pull = <0x01011110>;
+    };
+
+	mci1_pins: mci1_pins {
+        anyka,pins = <43 44 45 46 47 48>;
+        anyka,function = <1>;
+        anyka,pull = <0x10010 0x10000 0x10010 0x10010 0x10010 0x10010>;/* 4 line */
+
+        /* 1 line */
+        /*anyka,pins = <43 44 45>;*/
+        /*anyka,function = <1>;*/
+        /*anyka,pull = <0x10010 0x10000 0x10010>;*/  
+    };
+    
+    mci2_pins: mci2_pins {
+        //4 line with GPIO91-96
+        /*anyka,pins = <91 92 93 94 95 96>;
+        anyka,function = <2 2 3 3 3 3>;
+        anyka,pull = <0x01010010 0x01010010 0x01010010 0x01010010 0x01010010 0x01010010>; */
+
+        // 1 line with GPIO93-95
+        /*
+        anyka,pins = <93 94 95>;
+        anyka,function = <3>;
+        anyka,pull = <0x01010010 0x01010010 0x01010010>;*/
+
+        // 1 line with GPIO19 20 24, with 23 sdio irq pin
+        anyka,pins = <19 20  23 24>;
+        anyka,function = <2>;
+        anyka,pull = <0x01010010 0x01010010 0x01010010 0x01010010>;
+
+        // 4 line
+        /*
+        anyka,pins = <14 15 19 20  23 24>;
+        anyka,function = <2>;
+		anyka,pull = <0x01010010 0x01010010 0x01010010 0x01010010 0x01010010 0x01010010>;*/
+    };
+
+    spiflash_pins: spiflash_pins {
+        anyka,pins = <12 67 68 69 70>; /* 4 LINE mode, 12 is spi nor cs*/
+        anyka,function = <1 0 0 0 0>;
+        anyka,pull = <0x01010010>;
+    };
+
+		gpiokey_pins:gpiokey_pins {
+			anyka,pins = <39>;
+			anyka,function = <0>;
+			anyka,pull = <0x01010010>;
+		};
+		
+
+		/* gpio83 and gpio84  are used as i2c */
+    lcd_pins: lcd_pins {
+        anyka,pins = <74 71 72 73
+        	          75 76 77 78
+        	          79 80 81 82
+        	          85 86
+        	          87 88 89 90
+        	          91 92 93 94
+        	          95 96 97 98>;
+        anyka,function = <1>;
+        anyka,pull = <0x01010310>;
+    };
+    
+    uart0_pins: uart0_pins {
+        anyka,pins = <1 2>;
+        anyka,function = <1>;
+        anyka,pull = <0x01010010>;
+    };
+    
+    i2c2_pins: i2c2_pins {
+        anyka,pins = <83 84>;
+        anyka,function = <2>;
+        anyka,pull = <0x01011110>;
+    };
+
+     pwm4_pins: pwm4_pins {
+        anyka,pins = <41>;
+        anyka,function = <2>;
+        anyka,pull = <0x01011110>;
+    };
+
+	  phy_reset_pins: phy_reset_pins {		
+		    anyka,pins = <23>;		
+	      anyka,function = <0>;
+        anyka,pull = <0x01000010>;
+    };
+
+    gslX680_pins: gslX680_pins {
+        anyka,pins = <78 79>;
+        anyka,function = <0>;
+        anyka,pull = <0x01000010>;
+    };
+
+    icn85xx_pins: icn85xx_pins {
+        anyka,pins = <36 38>;
+        anyka,function = <0>;
+        anyka,pull = <0x01000010>;
+    };
+
+    ethernet_pins_rmii: ethernet_pins_rmii {
+		    anyka,pins 		= <10 11 13 14 15 19 20 24 49>;
+        anyka,function 	= <1>;
+        anyka,pull = <0x01010011 0x01010010 0x01010011 0x01010011 0x01010011 0x01010011 0x01010011  0x01010011 0x01010110>;
+    };
+};
+
+&rtc {
+	   /* 
+	   ** rtc osc_source_select, 0 means INTERNAL RC OSC, 1 means EXTERNAL XTAL 
+	   */
+		osc-select = <0>;
+    status = "okay";
+};
+
+&watchdog {
+	/*max feed dog time = 357s, default setting time = 10s. */
+    def_heartbeat = <10>;
+    status = "okay";
+};
+
+&gui {
+    status = "okay";
+};
+
+&vencoder {
+    status = "okay";
+};
+
+&vdecoder {
+    status = "okay";
+};
+
+&usb {
+    status = "okay"; 
+};
+
+
+&mmc1 {
+    bus-width = <0x4>;
+    max-frequency = <50000000>;
+    /*
+     *  detect mode:
+     *  (1) non-removable;
+     *  (2) detect-gpio/detect-gpios: card detect using gpio
+     *      for example:
+     *      detect-gpio = <&gpio 77 1>;  or detect-gpios = <&gpio 77 1>;  
+     *  (3) cd_clk: card detect using MCLK
+     *  default is non-removable
+     */
+    cd_clk;
+    /* if support highspeed, using cap-sd-highspeed */
+    cap-sd-highspeed;
+    pinctrl-names = "default";
+    pinctrl-0 = <&mci1_pins>;
+    status = "okay";
+};
+
+&mmc2 {
+    bus-width = <0x1>;
+    max-frequency = <50000000>;
+    /*
+     *  detect mode:
+     *  (1) non-removable;
+     *  (2) detect-gpio/detect-gpios: card detect using gpio
+     *      for example:
+     *      detect-gpio = <&gpio 77 1>;  or detect-gpios = <&gpio 77 1>;  
+     *  (3) cd_clk: card detect using MCLK
+     *  default is non-removable
+     */
+    non-removable;
+    /* if support sdio, using cap-sdio-irq*/
+    cap-sdio-irq;
+    /* if support highspeed, using cap-sd-highspeed */
+    cap-sd-highspeed;
+    pinctrl-names = "default";
+    pinctrl-0 = <&mci2_pins>;
+    status = "disable";
+};
+
+&dac {
+	pinctrl-names = "default";
+	//pinctrl-0 = <&speak_pins>;
+	/*
+	 ** speak-down,linein-detect,hp-mute,hp-detect
+	 ** 1 means enable these four function
+	 ** 0 means disable these four function
+	 */
+	speak-down = <1>;
+	linein-detect = <0>;
+	hp-mute = <0>;
+	hp-detect = <0>;
+	//speak-gpios = <&gpio 76 1>;
+	//linein-gpios = <&gpio 54 1>;
+	status = "okay";
+};
+
+&saradc{
+    /* SAR ADC VREF selection
+    * 0:To select AVCC 3.3V as VREF for SAR ADC.
+    * 1:To select 3.0V generated from BGR as VREF for SAR ADC.
+    */
+    vref-select = <1>;
+    /*
+    * 0:To disable BAT voltage divider. 
+    * 1:To enable BAT voltage divider divided by 2.
+    */
+    battery-divider = <1>;
+    /*
+    * Sampling number
+    * Read the sampling data for N times and then calculate the average value.
+    * N ranges from 1 to 7.
+    */
+     sampling-num = <3>;
+     status = "okay";
+};
+
+&spi0 {
+    pinctrl-names = "default";
+    pinctrl-0 = <&spiflash_pins>;
+    cs-gpios = <&gpio 12 1>;
+    spi-bus-frequency = <80000000>;
+    status = "okay";
+};
+
+&spif0 {
+	compatible = "anyka,ak-spinand";
+	status = "okay";
+};
+
+&GD5F1GQ4UB {
+   	status = "okay";
+};
+
+&GD5F2GQ4UB {
+   	status = "okay";
+};
+
+
+&uart0 {
+    pinctrl-names = "default";
+	pinctrl-0 = <&uart0_pins>;
+    status = "okay";
+};
+
+&i2c0 {
+    pinctrl-names = "default";
+    pinctrl-0 = <&i2c0_pins>;
+
+    clock-frequency = <312000>;
+    sda-delay = <100>;
+    status = "okay";
+	#address-cells = <1>;
+	#size-cells = <0>;
+
+	sensor0: camera@0x30{
+		compatible = "anyka,sensor0";
+		reg = <0x30>;
+
+		/*0xffff means the gpio is invalid*/
+		reset-gpio = <&gpio 3 1>;
+		pwdn-gpio = <&gpio 0xffff 1>;
+
+		port {
+			sensor0_0: endpoint@0 {
+				remote-endpoint = <&vi_0_0>;
+			};
+		};
+	};
+};
+
+&i2c1 {
+    pinctrl-names = "default";
+    //pinctrl-0 = <&i2c1_pins>;
+    
+    clock-frequency = <312000>;
+    sda-delay = <100>;
+    status = "disable";
+};
+
+&i2c2 {
+    pinctrl-names = "default";
+    pinctrl-0 = <&i2c2_pins>;
+
+    clock-frequency = <312000>;
+    sda-delay = <100>;
+    status = "okay";
+    
+    touch-screen@40 {
+		    compatible = "anyka,ak3790d-i2c-touchscreen-gslX680";
+		    reg = <0x40>;
+		    /* MIPI touch-pane irq and reset gpio setting */
+		    pinctrl-names = "default";
+            pinctrl-0 = <&gslX680_pins>;
+            irq-gpio = <&gpio 78 1>;
+            reset-gpio = <&gpio 79 1>;
+            TP_MAX_X = <1280>;
+            TP_MAX_Y = <800>;
+            status = "disable";
+	  };
+		       
+	  touch-screen@48 {
+		   compatible = "anyka,ak3790d-i2c-touchscreen-icn85xx";
+		    reg = <0x48>;
+		    /* RGB touch-pane irq and reset gpio setting */
+            pinctrl-names = "default";
+            pinctrl-0 = <&icn85xx_pins>;
+            irq-gpio = <&gpio 36 1>;
+            reset-gpio = <&gpio 38 1>;
+
+            TP_MAX_X = <1024>;
+            TP_MAX_Y = <600>;
+
+            status = "okay";
+	  }; 
+	  
+};
+
+&ethernet {
+    pinctrl-names = "default";
+    pinctrl-0 = <&ethernet_pins_rmii &phy_reset_pins>;
+    reset-gpios = <&gpio 23 1>;
+    status = "okay";
+};
+
+&ircut {
+    pinctrl-names = "default";
+    pinctrl-0 = <&ircut_pins>;
+
+	ircut-a = "42";
+	/*set the level for day mode. range: 0, 1*/
+	ircut-a-day-level = "0";
+	status = "okay";
+};
+
+&photosensitive {
+    //pinctrl-names = "default";
+    //pinctrl-0 = <&photosensitive_pins>;
+
+	/*range: saradc~1, gpio number*/
+	photosensitive-port = "saradc0";
+	/*the level for day mode, range: low, high*/
+	photosensitive-day-level = "high";
+	status = "okay";
+};
+
+&leds {
+	pinctrl-names = "default";
+	//pinctrl-0 = <&led_pins>;
+	//led-gpios = <&gpio 29 1
+                 //&gpio 30 1>;
+	status = "disable";
+};
+
+&adkeys {
+	status = "disable";
+};
+
+&gpiokeys {
+		#address-cells = <1>;
+		#size-cells = <0>;
+		pinctrl-0 = <&gpiokey_pins>;
+		pinctrl-names = "default";
+		
+	key_detect {
+		label = "key_detect";
+		gpios = <&gpio 39 1>;
+		linux,code = <116>;
+		debounce-interval = <100>;
+		wakeup-source;
+	};
+	
+	//status = "okay";
+};
+
+
+&motor0 {
+	status = "disable";
+};
+
+&motor1 {
+	status = "disable";
+};
+
+&pwm0 {
+	pinctrl-names = "default";
+
+	//pinctrl-0 = <&pwm0_pins>;
+	/*
+	**frequency of PWM ranges from 92H to 6MHz.
+	**duty of PWM ranges from 1 to 65535.
+	**Minimum duty cycle:1/65536
+	**Maximum duty cyscle:65535/65536.
+	**period-ns: period of the PWM signal (in nanoseconds)
+        **duty-ns: duty cycle of the PWM signal (in nanoseconds)
+	**pwm-enable = 0 means disable pwm function.
+	**pwm-enable = 1 means enable pwm function.
+	*/
+	period-ns = <1000000>;
+	duty-ns = <500000>;
+	pwm-enable = <1>;
+
+	status = "disable";
+};
+
+&pwm1 {
+	pinctrl-names = "default";
+
+	//pinctrl-0 = <&pwm1_pins>;
+	/*
+	**frequency of PWM ranges from 92H to 6MHz.
+	**duty of PWM ranges from 1 to 65535.
+	**Minimum duty cycle:1/65536
+	**Maximum duty cyscle:65535/65536.
+	**period-ns: period of the PWM signal (in nanoseconds)
+        **duty-ns: duty cycle of the PWM signal (in nanoseconds)
+	**pwm-enable = 0 means disable pwm function.
+	**pwm-enable = 1 means enable pwm function.
+	*/
+	period-ns = <1000000>;
+	duty-ns = <500000>;
+	pwm-enable = <1>;
+
+	status = "disable";
+};
+
+&pwm2 {
+	pinctrl-names = "default";
+
+	//pinctrl-0 = <&pwm2_pins>;
+	/*
+	**frequency of PWM ranges from 92H to 6MHz.
+	**duty of PWM ranges from 1 to 65535.
+	**Minimum duty cycle:1/65536
+	**Maximum duty cyscle:65535/65536.
+	**period-ns: period of the PWM signal (in nanoseconds)
+        **duty-ns: duty cycle of the PWM signal (in nanoseconds)
+	**pwm-enable = 0 means disable pwm function.
+	**pwm-enable = 1 means enable pwm function.
+	*/
+	period-ns = <1000000>;
+	duty-ns = <500000>;
+	pwm-enable = <1>;
+
+	status = "disable";
+};
+
+&pwm3 {
+	pinctrl-names = "default";
+
+	//pinctrl-0 = <&pwm3_pins>;
+	/*
+	**frequency of PWM ranges from 92H to 6MHz.
+	**duty of PWM ranges from 1 to 65535.
+	**Minimum duty cycle:1/65536
+	**Maximum duty cyscle:65535/65536.
+	**period-ns: period of the PWM signal (in nanoseconds)
+        **duty-ns: duty cycle of the PWM signal (in nanoseconds)
+	**pwm-enable = 0 means disable pwm function.
+	**pwm-enable = 1 means enable pwm function.
+	*/
+	period-ns = <1000000>;
+	duty-ns = <500000>;
+	pwm-enable = <1>;
+	status = "disable";
+};
+
+&pwm4 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pwm4_pins>;
+	/*
+	**frequency of PWM ranges from 92H to 6MHz.
+	**duty of PWM ranges from 1 to 65535.
+	**Minimum duty cycle:1/65536
+	**Maximum duty cyscle:65535/65536.
+	**period-ns: period of the PWM signal (in nanoseconds)
+        **duty-ns: duty cycle of the PWM signal (in nanoseconds)
+	**pwm-enable = 0 means disable pwm function.
+	**pwm-enable = 1 means enable pwm function.
+	*/
+	period-ns = <1000000>;
+	duty-ns = <500000>;
+	pwm-enable = <1>;
+	status = "okay";
+};
+
+&lcdc {
+    pinctrl-names = "default";
+    pinctrl-0 = <&lcd_pins>; //<&lcd_pins>,<&lcd_reset_pins>; //lcd_reset_pins only for mipi lcd
+    
+    lcd-logo-width = <600>;
+    lcd-logo-height = <165>;
+    //[fmt1:fmt0] 00 16bits input(RGB565 or BGR565)
+    //[fmt1:fmt0] 01 24bits input(RGB888 or BGR888)
+    //[fmt1:fmt0] 10 or 11 32bits input(ARGB888 ABGR888 RGBA888 BGRA888)
+    lcd-logo-fmt0 = <1>;
+    lcd-logo-fmt1 = <0>;
+    lcd-logo-rgb-seq = <1>; //0 for BGR, 1 for RGB
+    
+    lcd-fb-type = <1>; //0:single buffer; 1:double buffer
+    status = "okay";
+};
+
+&sat101cp40 {
+    status = "disable";
+};
+
+&sat070cp50 {
+    status = "disable";
+};
+
+&adt07016BR50 {
+    status = "okay";
+};
+
+&am1080wq05 {
+    status = "disable";
+};
+
+&vi0{
+	pinctrl-names = "dvp12bits", "dvp10bits", "dvp8bits",
+		"mipi0_2lane", "mipi0_1lane", "mipi1_2lane", "mipi1_1lane",
+		"csi0_sclk", "csi1_sclk";
+    pinctrl-0 = <&dvp12bits_pins>;
+    pinctrl-1 = <&dvp10bits_pins>;
+    pinctrl-2 = <&dvp8bits_pins>;
+    pinctrl-3 = <&mipi0_2lane_pins>;
+    pinctrl-4 = <&mipi0_1lane_pins>;
+    pinctrl-5 = <&mipi1_2lane_pins>;
+    pinctrl-6 = <&mipi1_1lane_pins>;
+    pinctrl-7 = <&csi0_sclk_pin>;
+    pinctrl-8 = <&csi1_sclk_pin>;
+    status = "okay";
+
+	port@0 {
+		#address-cells = <1>;
+		#size-cells = <0>;
+
+		vi_0_0: endpoint@0 {
+			reg = <0>;
+			remote-endpoint = <&sensor0_0>;
+		};
+	};
+};
diff --git a/arch/arm/boot/dts/c500_cbd_ak3918ev500_v1.0.0.dts b/arch/arm/boot/dts/c500_cbd_ak3918ev500_v1.0.0.dts
new file mode 100755
index 0000000..a66af54
--- /dev/null
+++ b/arch/arm/boot/dts/c500_cbd_ak3918ev500_v1.0.0.dts
@@ -0,0 +1,394 @@
+/*
+ * AK3918EV500 dev board dts
+ *
+ * Copyright (C) 2018 Anyka(Guangzhou) Microelectronics Technology Co., Ltd.
+ *
+ * Author: Feilong Dong <dong_feilong@anyka.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+/dts-v1/;
+#include "anyka_ev500.dtsi"
+#include "anyka_ev500_lcd.dtsi"
+#include "anyka_ev500_norflash.dtsi"
+#include "anyka_ev500_nandflash1.dtsi"
+
+/ {
+    compatible = "anyka,ak3918ev500";
+    model = "AK3918EV500 dev board";
+	version = "V1.0.01";
+};
+
+&gpio {
+    /* anyka,function sharepin func index according to table 2-1 sharepin-list */
+    /* index: 0: PIN default func, 1: FUNCTION1, 2: FUNCTION2, 3: FUNCTION3, 4: FUNCTION4 */
+    /* anyka,pull config value bit[31:24]--slew rate, bit[23:16]--ie, bit[15:8]--drive, bit[7:0]--pupd config */
+    /* bit[31:24]--slew rate, 0: slow, 1: fast */
+    /* bit[23:16]--ie, input enable, 0: disable, 1: enable */
+    /* bit[15:8]--drive, drive strength, 4levels value: 0x0-0x3 */
+    /* bit[7:0]--pupd config, bit[7:4] 1:enable/ 0:disable, bit[3:0] 0:select PU /1:select PD */
+
+    mci1_pins: mci1_pins {
+        anyka,pins = <43 44 45 46 47 48>;
+        anyka,function = <1>;
+        anyka,pull = <0x10010 0x10000 0x10010 0x10010 0x10010 0x10010>; /* 4 line */
+
+        // 1 line 
+        /*
+        anyka,pins = <43 44 45>;
+        anyka,function = <1>;
+        anyka,pull = <0x10010 0x10000 0x10010>;*/
+    };
+    
+    mci2_pins: mci2_pins {
+		// 1 line with D[1] as sdio interrupt pin
+        anyka,pins = <93 94 95 96>;
+        anyka,function = <3>;
+        anyka,pull = <0x01010010 0x01010010 0x01010010 0x01010010>;
+    };
+
+    mmc_power_pins:mmc_power_pins{
+        anyka,pins = <5>;
+	    anyka,function = <0>;
+        anyka,pull = <0x01000301>;
+    };
+
+    sdio_wifi_pins:sdio_wifi_pins{
+        anyka,pins = <97>;
+	    anyka,function = <0>;
+        anyka,pull = <0x01000310>;
+    };
+
+    spiflash_pins: spiflash_pins {
+        anyka,pins = <12 3 67 68 69 70>; /* 4 LINE mode, 12 is spi nor cs, 3 is spinand cs*/
+        anyka,function = <1 0 0 0 0 0>;
+        anyka,pull = <0x01010010>;
+    };
+
+    lcd_reset_pins: lcd_reset_pins {
+	    anyka,pins = <83>;
+	    anyka,function = <0>;
+        anyka,pull = <0x01000310>;
+    };
+
+	gpiokey_pins:gpiokey_pins {
+			anyka,pins = <98>;
+			anyka,function = <0>;
+			anyka,pull = <0x01010010>;
+		};
+				
+    /*speak_en and linein_detect gpio setting */
+    speak_pins: speak_pins {
+        anyka,pins = <53>; 
+        anyka,function = <0>;
+        anyka,pull = <0x01010010>;
+    };
+    
+    uart0_pins: uart0_pins {
+        anyka,pins = <1 2>;
+        anyka,function = <1>;
+        anyka,pull = <0x01010010>;
+    };
+    
+	phy_reset_pins: phy_reset_pins {		
+		anyka,pins = <54>;		
+	    anyka,function = <0>;
+        anyka,pull = <0x01000010>;
+    };
+
+    ethernet_pins_rmii: ethernet_pins_rmii {
+		anyka,pins 		= <10 11 13 14 15 19 20 23 24 49>;
+        anyka,function 	= <1>;
+        anyka,pull = <0x01010011 0x01010010 0x01010011 0x01010011 0x01010011 0x01010011 0x01010011 0x01010011 0x01010011 0x01010110>;
+    };
+};
+
+&rtc {
+	   /* 
+	   ** rtc osc_source_select, 0 means INTERNAL RC OSC, 1 means EXTERNAL XTAL 
+	   */
+		osc-select = <0>;
+    status = "okay";
+};
+
+&watchdog {
+		/*max feed dog time = 357s, default setting time = 10s. */
+    def_heartbeat = <10>;
+    status = "okay";
+};
+
+&gui {
+    status = "okay";
+};
+
+&vencoder {
+    status = "okay";
+};
+
+&vdecoder {
+    status = "okay";
+};
+
+&usb {
+    status = "okay"; 
+};
+
+&mmc1 {
+    bus-width = <0x4>;
+    max-frequency = <50000000>;
+    /*
+     *  detect mode:
+     *  (1) non-removable;
+     *  (2) detect-gpio/detect-gpios: card detect using gpio
+     *      for example:
+     *      detect-gpio = <&gpio 77 1>;  or detect-gpios = <&gpio 77 1>;  
+     *  (3) cd_clk: card detect using MCLK
+     *  default is non-removable
+     */
+    cd_clk;
+    /* if support highspeed, using cap-sd-highspeed */
+    cap-sd-highspeed;
+    pinctrl-names = "default";
+    pinctrl-0 = <&mci1_pins>,<&mmc_power_pins>;
+    power-pins = <&gpio 5 1>;
+    /* initial power pin value*/
+    power-pins-value = <0>; 
+    power-inverted;
+    status = "okay";
+};
+
+&mmc2 {
+    bus-width = <0x1>;
+    max-frequency = <50000000>;
+    /*
+     *  detect mode:
+     *  (1) non-removable;
+     *  (2) detect-gpio/detect-gpios: card detect using gpio
+     *      detect-gpio = <&gpio 77 1>;  
+     *      or 
+     *      detect-gpios = <&gpio 77 1>;  
+     *  (3) cd_clk: card detect using MCLK
+     *  default is non-removable
+     */
+    non-removable;
+    /* if support sdio, using cap-sdio-irq*/
+    cap-sdio-irq;
+    /* if support highspeed, using cap-sd-highspeed */
+    cap-sd-highspeed;
+    pinctrl-names = "default";
+    pinctrl-0 = <&mci2_pins> , <&sdio_wifi_pins>;
+    power-pins = <&gpio 72 1>; 
+    /* initial power pin value*/
+    power-pins-value = <1>; 
+    status = "okay";
+};
+
+&dac {
+     pinctrl-names = "default";
+	   pinctrl-0 = <&speak_pins>;
+	   /* 
+	   ** speak-down,linein-detect,hp-mute,hp-detect
+	   ** 1 means enable these four function
+	   ** 0 means disable these four function
+	   */
+	   speak-down = <1>;
+	   linein-detect = <0>;
+	   hp-mute = <0>;
+	   hp-detect = <0>;
+	   speak-gpios = <&gpio 53 1>;
+	   //linein-gpios = <&gpio 54 1>;    
+     status = "okay";
+};	 
+
+&saradc{
+    /* SAR ADC VREF selection
+    * 0:To select AVCC 3.3V as VREF for SAR ADC.
+    * 1:To select 3.0V generated from BGR as VREF for SAR ADC.
+    */
+    vref-select = <1>;
+    /*
+    * 0:To disable BAT voltage divider. 
+    * 1:To enable BAT voltage divider divided by 2.
+    */
+    battery-divider = <1>;
+    /*
+    * Sampling number
+    * Read the sampling data for N times and then calculate the average value.
+    * N ranges from 1 to 7.
+    */
+     sampling-num = <3>;
+     status = "okay";
+};
+
+&spi0 {
+    pinctrl-names = "default";
+    pinctrl-0 = <&spiflash_pins>;
+    cs-gpios = <&gpio 12 1>, <&gpio 3 1>;
+    spi-bus-frequency = <80000000>;
+    status = "okay";
+};
+
+&spif0 {
+	status = "okay";
+};
+
+&spif1 {
+   	status = "okay";
+};
+
+&gd25q64{
+   	status = "okay";
+};
+
+&gd25q128{
+   	status = "okay";
+};
+
+&GD5F1GQ4UB {
+   	status = "okay";
+};
+
+&GD5F2GQ4UB {
+   	status = "okay";
+};
+
+&uart0 {
+    pinctrl-names = "default";
+	pinctrl-0 = <&uart0_pins>;
+    status = "okay";
+};
+
+&i2c0 {
+    pinctrl-names = "default";
+    //pinctrl-0 = <&i2c0_pins>;
+    
+    clock-frequency = <312000>;
+    sda-delay = <100>;
+    status = "disable";
+    
+    sensor {
+        compatible = "anyka,sensor";
+        status = "disable";
+    };
+};
+
+&i2c1 {
+    pinctrl-names = "default";
+    //pinctrl-0 = <&i2c1_pins>;
+    
+    clock-frequency = <312000>;
+    sda-delay = <100>;
+    status = "disable";
+};
+
+
+&ethernet {
+    pinctrl-names = "default";
+    pinctrl-0 = <&ethernet_pins_rmii &phy_reset_pins>;
+    reset-gpios = <&gpio 54  1>;
+    status = "okay";
+};
+
+&leds {
+	pinctrl-names = "default";
+	//pinctrl-0 = <&led_pins>;
+	led-gpios = <&gpio 4 1>;
+	status = "okay";
+};
+
+&adkeys {
+	status = "disable";
+};
+
+&gpiokeys {
+		#address-cells = <1>;
+		#size-cells = <0>;
+		pinctrl-0 = <&gpiokey_pins>;
+		pinctrl-names = "default";
+		
+		key_detect {
+		label = "key_detect";
+		gpios = <&gpio 98 1>;
+		linux,code = <116>;
+		debounce-interval = <100>;
+		wakeup-source;
+		};
+	
+	//status = "okay";
+};
+
+&motor0 {
+	status = "disable";
+};
+
+&motor1 {
+	status = "disable";
+};
+
+&pwm0 {
+	pinctrl-names = "default";
+	/* frequency of PWM ranges from 92H to 6MHz.*/
+	pwm-frequency = <2000000>;
+	//pinctrl-0 = <&pwm0_pins>;
+	status = "disable";
+};
+
+&pwm1 {
+	pinctrl-names = "default";
+	/* frequency of PWM ranges from 92H to 6MHz.*/
+	pwm-frequency = <2000000>;
+	//pinctrl-0 = <&pwm1_pins>;
+	status = "disable";
+};
+
+&pwm2 {
+	pinctrl-names = "default";
+	/* frequency of PWM ranges from 92H to 6MHz.*/
+	pwm-frequency = <2000000>;
+	//pinctrl-0 = <&pwm2_pins>;
+	status = "disable";
+};
+
+&pwm3 {
+	pinctrl-names = "default";
+	/* frequency of PWM ranges from 92H to 6MHz.*/
+	pwm-frequency = <2000000>;
+	//pinctrl-0 = <&pwm3_pins>;
+	status = "disable";
+};
+
+&lcdc {
+    pinctrl-names = "default";
+    pinctrl-0 = <&lcd_reset_pins>; //<&lcd_pins>,<&lcd_reset_pins>; //lcd_pins for rgb lcd, lcd_reset_pins only for mipi lcd
+    reset-pins = <&gpio 83 1>; //only for mipi lcd
+    
+    lcd-logo-width = <600>;
+    lcd-logo-height = <165>;
+    //[fmt1:fmt0] 00 16bits input(RGB565 or BGR565)
+    //[fmt1:fmt0] 01 24bits input(RGB888 or BGR888)
+    //[fmt1:fmt0] 10 or 11 32bits input(ARGB888 ABGR888 RGBA888 BGRA888)
+    lcd-logo-fmt0 = <1>;
+    lcd-logo-fmt1 = <0>;
+    lcd-logo-rgb-seq = <1>; //0 for BGR, 1 for RGB
+    
+    lcd-fb-type = <1>; //0:single buffer; 1:double buffer
+    status = "okay";
+};
+
+&sat101cp40 {
+    status = "okay";
+};
+
+
+&sat101at40 {
+    status = "disable";
+};
diff --git a/arch/arm/boot/dts/c500_cbd_ak3918ev500_v1.0.0_spinand.dts b/arch/arm/boot/dts/c500_cbd_ak3918ev500_v1.0.0_spinand.dts
new file mode 100755
index 0000000..230e2a3
--- /dev/null
+++ b/arch/arm/boot/dts/c500_cbd_ak3918ev500_v1.0.0_spinand.dts
@@ -0,0 +1,387 @@
+/*
+ * AK3918EV500 dev board dts
+ *
+ * Copyright (C) 2018 Anyka(Guangzhou) Microelectronics Technology Co., Ltd.
+ *
+ * Author: Feilong Dong <dong_feilong@anyka.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+/dts-v1/;
+#include "anyka_ev500.dtsi"
+#include "anyka_ev500_lcd.dtsi"
+#include "anyka_ev500_nandflash0.dtsi"
+
+/ {
+    compatible = "anyka,ak3918ev500";
+    model = "AK3918EV500 dev board";
+	version = "V1.0.01";
+    
+    chosen {
+		/* No padding required - the uboot can do that. */
+		bootargs = "console=ttySAK0,115200n8 root=/dev/mtdblock6 rootfstype=yaffs2 init=/sbin/init mem=64M memsize=64M";
+	};
+};
+
+&gpio {
+    /* anyka,function sharepin func index according to table 2-1 sharepin-list */
+    /* index: 0: PIN default func, 1: FUNCTION1, 2: FUNCTION2, 3: FUNCTION3, 4: FUNCTION4 */
+    /* anyka,pull config value bit[31:24]--slew rate, bit[23:16]--ie, bit[15:8]--drive, bit[7:0]--pupd config */
+    /* bit[31:24]--slew rate, 0: slow, 1: fast */
+    /* bit[23:16]--ie, input enable, 0: disable, 1: enable */
+    /* bit[15:8]--drive, drive strength, 4levels value: 0x0-0x3 */
+    /* bit[7:0]--pupd config, bit[7:4] 1:enable/ 0:disable, bit[3:0] 0:select PU /1:select PD */
+
+    mci1_pins: mci1_pins {
+        anyka,pins = <43 44 45 46 47 48>;
+        anyka,function = <1>;
+        anyka,pull = <0x10010 0x10000 0x10010 0x10010 0x10010 0x10010>; /* 4 line */
+
+        // 1 line 
+        /*
+        anyka,pins = <43 44 45>;
+        anyka,function = <1>;
+        anyka,pull = <0x10010 0x10000 0x10010>;*/
+    };
+    
+    mci2_pins: mci2_pins {
+		// 1 line with D[1] as sdio interrupt pin
+        anyka,pins = <93 94 95 96>;
+        anyka,function = <3>;
+        anyka,pull = <0x01010010 0x01010010 0x01010010 0x01010010>;
+    };
+
+    mmc_power_pins:mmc_power_pins{
+        anyka,pins = <5>;
+	    anyka,function = <0>;
+        anyka,pull = <0x01000301>;
+    };
+
+    sdio_wifi_pins:sdio_wifi_pins{
+        anyka,pins = <97>;
+	    anyka,function = <0>;
+        anyka,pull = <0x01000310>;
+    };
+
+    spiflash_pins: spiflash_pins {
+        anyka,pins = <12 3 67 68 69 70>; /* 4 LINE mode, 12 is spi nor cs, 3 is spinand cs*/
+        anyka,function = <1 0 0 0 0 0>;
+        anyka,pull = <0x01010010>;
+    };
+
+    lcd_reset_pins: lcd_reset_pins {
+	    anyka,pins = <83>;
+	    anyka,function = <0>;
+        anyka,pull = <0x01000310>;
+    };
+
+	gpiokey_pins:gpiokey_pins {
+			anyka,pins = <98>;
+			anyka,function = <0>;
+			anyka,pull = <0x01010010>;
+		};
+				
+    /*speak_en and linein_detect gpio setting */
+    speak_pins: speak_pins {
+        anyka,pins = <53>; 
+        anyka,function = <0>;
+        anyka,pull = <0x01010010>;
+    };
+    
+    uart0_pins: uart0_pins {
+        anyka,pins = <1 2>;
+        anyka,function = <1>;
+        anyka,pull = <0x01010010>;
+    };
+    
+	phy_reset_pins: phy_reset_pins {		
+		anyka,pins = <54>;		
+	    anyka,function = <0>;
+        anyka,pull = <0x01000010>;
+    };
+
+    ethernet_pins_rmii: ethernet_pins_rmii {
+		anyka,pins 		= <10 11 13 14 15 19 20 23 24 49>;
+        anyka,function 	= <1>;
+        anyka,pull = <0x01010011 0x01010010 0x01010011 0x01010011 0x01010011 0x01010011 0x01010011 0x01010011 0x01010011 0x01010110>;
+    };
+};
+
+&rtc {
+	   /* 
+	   ** rtc osc_source_select, 0 means INTERNAL RC OSC, 1 means EXTERNAL XTAL 
+	   */
+		osc-select = <0>;
+    status = "okay";
+};
+
+&watchdog {
+		/*max feed dog time = 357s, default setting time = 10s. */
+    def_heartbeat = <10>;
+    status = "okay";
+};
+
+&gui {
+    status = "okay";
+};
+
+&vencoder {
+    status = "okay";
+};
+
+&vdecoder {
+    status = "okay";
+};
+
+&usb {
+    status = "okay"; 
+};
+
+&mmc1 {
+    bus-width = <0x4>;
+    max-frequency = <50000000>;
+    /*
+     *  detect mode:
+     *  (1) non-removable;
+     *  (2) detect-gpio/detect-gpios: card detect using gpio
+     *      for example:
+     *      detect-gpio = <&gpio 77 1>;  or detect-gpios = <&gpio 77 1>;  
+     *  (3) cd_clk: card detect using MCLK
+     *  default is non-removable
+     */
+    cd_clk;
+    /* if support highspeed, using cap-sd-highspeed */
+    cap-sd-highspeed;
+    pinctrl-names = "default";
+    pinctrl-0 = <&mci1_pins>,<&mmc_power_pins>;
+    power-pins = <&gpio 5 1>;
+    /* initial power pin value*/
+    power-pins-value = <0>; 
+    power-inverted;
+    status = "okay";
+};
+
+&mmc2 {
+    bus-width = <0x1>;
+    max-frequency = <50000000>;
+    /*
+     *  detect mode:
+     *  (1) non-removable;
+     *  (2) detect-gpio/detect-gpios: card detect using gpio
+     *      detect-gpio = <&gpio 77 1>;  
+     *      or 
+     *      detect-gpios = <&gpio 77 1>;  
+     *  (3) cd_clk: card detect using MCLK
+     *  default is non-removable
+     */
+    non-removable;
+    /* if support sdio, using cap-sdio-irq*/
+    cap-sdio-irq;
+    /* if support highspeed, using cap-sd-highspeed */
+    cap-sd-highspeed;
+    pinctrl-names = "default";
+    pinctrl-0 = <&mci2_pins> , <&sdio_wifi_pins>;
+    power-pins = <&gpio 72 1>; 
+    /* initial power pin value*/
+    power-pins-value = <1>; 
+    status = "okay";
+};
+
+&dac {
+     pinctrl-names = "default";
+	   pinctrl-0 = <&speak_pins>;
+	   /* 
+	   ** speak-down,linein-detect,hp-mute,hp-detect
+	   ** 1 means enable these four function
+	   ** 0 means disable these four function
+	   */
+	   speak-down = <1>;
+	   linein-detect = <0>;
+	   hp-mute = <0>;
+	   hp-detect = <0>;
+	   speak-gpios = <&gpio 53 1>;
+	   //linein-gpios = <&gpio 54 1>;    
+     status = "okay";
+};	 
+
+&saradc{
+    /* SAR ADC VREF selection
+    * 0:To select AVCC 3.3V as VREF for SAR ADC.
+    * 1:To select 3.0V generated from BGR as VREF for SAR ADC.
+    */
+    vref-select = <1>;
+    /*
+    * 0:To disable BAT voltage divider. 
+    * 1:To enable BAT voltage divider divided by 2.
+    */
+    battery-divider = <1>;
+    /*
+    * Sampling number
+    * Read the sampling data for N times and then calculate the average value.
+    * N ranges from 1 to 7.
+    */
+     sampling-num = <3>;
+     status = "okay";
+};
+
+&spi0 {
+    pinctrl-names = "default";
+    pinctrl-0 = <&spiflash_pins>;
+    cs-gpios = <&gpio 12 1>, <&gpio 3 1>;
+    spi-bus-frequency = <80000000>;
+    status = "okay";
+};
+
+&spif0 {
+	compatible = "anyka,ak-spinand";
+	status = "okay";
+};
+
+&GD5F1GQ4UB {
+   	status = "okay";
+};
+
+&GD5F2GQ4UB {
+   	status = "okay";
+};
+
+&uart0 {
+    pinctrl-names = "default";
+	pinctrl-0 = <&uart0_pins>;
+    status = "okay";
+};
+
+&i2c0 {
+    pinctrl-names = "default";
+    //pinctrl-0 = <&i2c0_pins>;
+    
+    clock-frequency = <312000>;
+    sda-delay = <100>;
+    status = "disable";
+    
+    sensor {
+        compatible = "anyka,sensor";
+        status = "disable";
+    };
+};
+
+&i2c1 {
+    pinctrl-names = "default";
+    //pinctrl-0 = <&i2c1_pins>;
+    
+    clock-frequency = <312000>;
+    sda-delay = <100>;
+    status = "disable";
+};
+
+
+&ethernet {
+    pinctrl-names = "default";
+    pinctrl-0 = <&ethernet_pins_rmii &phy_reset_pins>;
+    reset-gpios = <&gpio 54  1>;
+    status = "okay";
+};
+
+&leds {
+	pinctrl-names = "default";
+	//pinctrl-0 = <&led_pins>;
+	led-gpios = <&gpio 4 1>;
+	status = "okay";
+};
+
+&adkeys {
+	status = "disable";
+};
+
+&gpiokeys {
+		#address-cells = <1>;
+		#size-cells = <0>;
+		pinctrl-0 = <&gpiokey_pins>;
+		pinctrl-names = "default";
+		
+		key_detect {
+		label = "key_detect";
+		gpios = <&gpio 98 1>;
+		linux,code = <116>;
+		debounce-interval = <100>;
+		wakeup-source;
+		};
+	
+	//status = "okay";
+};
+
+&motor0 {
+	status = "disable";
+};
+
+&motor1 {
+	status = "disable";
+};
+
+&pwm0 {
+	pinctrl-names = "default";
+	/* frequency of PWM ranges from 92H to 6MHz.*/
+	pwm-frequency = <2000000>;
+	//pinctrl-0 = <&pwm0_pins>;
+	status = "disable";
+};
+
+&pwm1 {
+	pinctrl-names = "default";
+	/* frequency of PWM ranges from 92H to 6MHz.*/
+	pwm-frequency = <2000000>;
+	//pinctrl-0 = <&pwm1_pins>;
+	status = "disable";
+};
+
+&pwm2 {
+	pinctrl-names = "default";
+	/* frequency of PWM ranges from 92H to 6MHz.*/
+	pwm-frequency = <2000000>;
+	//pinctrl-0 = <&pwm2_pins>;
+	status = "disable";
+};
+
+&pwm3 {
+	pinctrl-names = "default";
+	/* frequency of PWM ranges from 92H to 6MHz.*/
+	pwm-frequency = <2000000>;
+	//pinctrl-0 = <&pwm3_pins>;
+	status = "disable";
+};
+
+&lcdc {
+    pinctrl-names = "default";
+    pinctrl-0 = <&lcd_reset_pins>; //<&lcd_pins>,<&lcd_reset_pins>; //lcd_pins for rgb lcd, lcd_reset_pins only for mipi lcd
+    reset-pins = <&gpio 83 1>; //only for mipi lcd
+    
+    lcd-logo-width = <600>;
+    lcd-logo-height = <165>;
+    //[fmt1:fmt0] 00 16bits input(RGB565 or BGR565)
+    //[fmt1:fmt0] 01 24bits input(RGB888 or BGR888)
+    //[fmt1:fmt0] 10 or 11 32bits input(ARGB888 ABGR888 RGBA888 BGRA888)
+    lcd-logo-fmt0 = <1>;
+    lcd-logo-fmt1 = <0>;
+    lcd-logo-rgb-seq = <1>; //0 for BGR, 1 for RGB
+    
+    lcd-fb-type = <1>; //0:single buffer; 1:double buffer
+    status = "okay";
+};
+
+&sat101cp40 {
+    status = "okay";
+};
+
+
+&sat101at40 {
+    status = "disable";
+};
diff --git a/arch/arm/boot/dts/sh3d_cbd_ak3790d_v1.0.0.dts b/arch/arm/boot/dts/sh3d_cbd_ak3790d_v1.0.0.dts
new file mode 100755
index 0000000..a77bf02
--- /dev/null
+++ b/arch/arm/boot/dts/sh3d_cbd_ak3790d_v1.0.0.dts
@@ -0,0 +1,326 @@
+/*
+ * AK37D svt board dts
+ *
+ * Copyright (C) 2018 Anyka(Guangzhou) Microelectronics Technology Co., Ltd.
+ *
+ * Author: Feilong Dong <dong_feilong@anyka.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+/dts-v1/;
+#include "anyka_ev501.dtsi"
+#include "anyka_ev500_lcd.dtsi"
+
+/ {
+    compatible = "anyka,ak3790d";
+    model = "AK3790D SVT board";
+};
+
+  
+  
+  
+  &gpio {
+    /* anyka,function sharepin func index according to table 2-1 sharepin-list */
+    /* index: 0: PIN default func, 1: FUNCTION1, 2: FUNCTION2, 3: FUNCTION3, 4: FUNCTION4 */
+    /* anyka,pull config value bit[31:24]--slew rate, bit[23:16]--ie, bit[15:8]--drive, bit[7:0]--pupd config */
+    /* bit[31:24]--slew rate, 0: slow, 1: fast */
+    /* bit[23:16]--ie, input enable, 0: disable, 1: enable */
+    /* bit[15:8]--drive, drive strength, 4levels value: 0x0-0x3 */
+    /* bit[7:0]--pupd config, bit[7:4] 1:enable/ 0:disable, bit[3:0] 0:select PU /1:select PD */
+
+    mci0_pins: mci0_pins {
+        anyka,pins = <33 34 35 36 37 38 39 40 41 42>;
+        anyka,function = <1>;
+        anyka,pull = <0x10010 0x10010 0x10010 0x10010 0x10010 0x10010 0x10010 0x10010 0x10010 0x10010>;/* 4 line */ 
+    };
+
+    mci1_pins: mci1_pins {
+		anyka,pins = <43 44 45 46 47 48>;
+        anyka,function = <1>;
+        anyka,pull = <0x10010 0x10000 0x10010 0x10010 0x10010 0x10010>;// 4 line
+        /*
+		// 1 line 
+        anyka,pins = <43 44 45>;
+        anyka,function = <1>;
+        anyka,pull = <0x10010 0x10000 0x10010>;
+		*/
+
+    };
+    
+    mci2_pins: mci2_pins {
+        anyka,pins = <91 92 93 94 95 96>;
+        anyka,function = <2 2 3 3 3 3>;
+        anyka,pull = <0x01010010 0x01010010 0x01010010 0x01010010 0x01010010 0x01010010>; /* 4 line */
+
+        /* 1 line */
+        /*anyka,pins = <93 94 95>;*/
+        /*anyka,function = <3>;*/
+        /*anyka,pull = <0x01010010 0x01010010 0x01010010>;*/ 
+    };
+   
+    spiflash_pins: spiflash_pins {
+        anyka,pins = <12 18 67 68 69 70>; /* 4 LINE mode, 12 is spi nor cs, 18 is spinand cs*/
+        anyka,function = <1 0 0 0 0 0>;
+        anyka,pull = <0x01010010>;
+    };
+    
+    lcd_pins: lcd_pins {
+        anyka,pins = <74 71 72 73
+        	          75 76 77 78
+        	          79 80 81 82
+        	          83 84 85 86
+        	          87 88 89 90
+        	          91 92 93 94
+        	          95 96 97 98>;
+        anyka,function = <1>;
+        anyka,pull = <0x01010310>;
+    };
+
+    speak_pins: speak_pins {
+        anyka,pins = <44>; 
+        anyka,function = <0>;
+        anyka,pull = <1>;
+    };
+
+    uart0_pins: uart0_pins {
+        anyka,pins = <1 2>;
+        anyka,function = <1>;
+        anyka,pull = <0x01010010>;
+    };
+
+	phy_reset_pins: phy_reset_pins {		
+		anyka,pins = <36>;		
+	    anyka,function = <0>;
+        anyka,pull = <0x01000010>;
+    };
+
+    ethernet_pins_rmii: ethernet_pins_rmii {
+		anyka,pins 		= <10 11 13 14 15 19 20 23 24 49>;
+        anyka,function 	= <1>;
+        anyka,pull = <0x01010011 0x01010010 0x01010011 0x01010011 0x01010011 0x01010011 0x01010011 0x01010011 0x01010011 0x01010110>;
+    };
+};
+
+&rtc {
+	   /* 
+	   ** rtc osc_source_select, 0 means INTERNAL RC OSC, 1 means EXTERNAL XTAL 
+	   */
+		osc-select = <0>;
+    status = "okay";
+};
+
+&watchdog {
+    def_heartbeat = <10>;
+    status = "okay";
+};
+
+&gui {
+    status = "okay";
+};
+
+&vdecoder {
+    status = "okay";
+};
+
+&mmc0 {
+    bus-width = <0x8>;
+    max-frequency = <50000000>;
+    /*
+     *  detect mode:
+     *  (1) non-removable;
+     *  (2) detect-gpio/detect-gpios: card detect using gpio
+     *      detect-gpio = <&gpio 77 1>;  
+     *      or 
+     *      detect-gpios = <&gpio 77 1>;  
+     *  (3) cd_clk: card detect using MCLK
+     *  default is non-removable
+     */
+    cd_clk;
+    /* if support highspeed, using cap-sd-highspeed */
+    cap-sd-highspeed;
+    pinctrl-names = "default";
+    pinctrl-0 = <&mci0_pins>;
+    status = "disable";
+};
+
+&mmc1 {
+    bus-width = <0x4>;
+    max-frequency = <50000000>;
+    /*
+     *  detect mode:
+     *  (1) non-removable;
+     *  (2) detect-gpio/detect-gpios: card detect using gpio
+     *      detect-gpio = <&gpio 77 1>;  
+     *      or 
+     *      detect-gpios = <&gpio 77 1>;  
+     *  (3) cd_clk: card detect using MCLK
+     *  default is non-removable
+     */
+    non-removable;
+    /* if support highspeed, using cap-sd-highspeed */
+    cap-sd-highspeed;
+    pinctrl-names = "default";
+    pinctrl-0 = <&mci1_pins>;
+    status = "okay";
+};
+
+&mmc2 {
+    bus-width = <0x1>;
+    max-frequency = <50000000>;
+    /*
+     *  detect mode:
+     *  (1) non-removable;
+     *  (2) detect-gpio/detect-gpios: card detect using gpio
+     *      detect-gpio = <&gpio 77 1>;  
+     *      or 
+     *      detect-gpios = <&gpio 77 1>;  
+     *  (3) cd_clk: card detect using MCLK
+     *  default is non-removable
+     */
+    non-removable;
+    /* if support sdio, using cap-sdio-irq*/
+    cap-sdio-irq;
+    /* if support highspeed, using cap-sd-highspeed */
+    cap-sd-highspeed;
+    pinctrl-names = "default";
+    pinctrl-0 = <&mci2_pins>;
+    status = "disable";
+};
+
+&dac {
+    pinctrl-names = "default";
+    //pinctrl-0 = <&speak_pins>;
+    speak-gpios = <&gpio 44 1>;
+    status = "disable";
+};	       
+
+&saradc{
+     status = "okay";
+};
+&spi0 {
+    pinctrl-names = "default";
+    pinctrl-0 = <&spiflash_pins>;
+    cs-gpios = <&gpio 12 1>, <&gpio 18 1>;
+    spi-bus-frequency = <80000000>;
+    status = "okay";
+    
+    spi-flash@0 {
+	    compatible = "anyka,ak-spiflash";
+		reg = <0>; /* Chip select 0 */
+		spi-max-frequency = <80000000>;
+		status = "okay";
+	};
+
+	spi-flash@1 {
+	    compatible = "anyka,ak-spinand";
+	    reg = <1>; /* Chip select 1 */
+	    spi-max-frequency = <80000000>;
+	    status = "disable";
+	};
+};
+
+&uart0 {
+    pinctrl-names = "default";
+	pinctrl-0 = <&uart0_pins>;
+    status = "okay";
+};
+
+&i2c0 {
+    pinctrl-names = "default";
+    //pinctrl-0 = <&i2c0_pins>;
+    status = "disable";
+    
+    sensor {
+        compatible = "anyka,sensor";
+        status = "disable";
+    };
+};
+
+&ethernet {
+    pinctrl-names = "default";
+    pinctrl-0 = <&ethernet_pins_rmii &phy_reset_pins>;
+    reset-gpios = <&gpio 36 1>;
+    status = "okay";
+};
+
+&leds {
+	pinctrl-names = "default";
+	//pinctrl-0 = <&led_pins>;
+	led-gpios = <&gpio 29 1
+                 &gpio 30 1>;
+	status = "okay";
+};
+
+&adkeys {
+	status = "disable";
+};
+
+&motor0 {
+	status = "disable";
+};
+
+&motor1 {
+	status = "disable";
+};
+
+&pwm0 {
+	pinctrl-names = "default";
+	/* frequency of PWM ranges from 92H to 6MHz.*/
+	pwm-frequency = <2000000>;
+	//pinctrl-0 = <&pwm0_pins>;
+	status = "disable";
+};
+
+&pwm1 {
+	pinctrl-names = "default";
+	/* frequency of PWM ranges from 92H to 6MHz.*/
+	pwm-frequency = <2000000>;
+	//pinctrl-0 = <&pwm1_pins>;
+	status = "disable";
+};
+
+&pwm2 {
+	pinctrl-names = "default";
+	/* frequency of PWM ranges from 92H to 6MHz.*/
+	pwm-frequency = <2000000>;
+	//pinctrl-0 = <&pwm2_pins>;
+	status = "disable";
+};
+
+&pwm3 {
+	pinctrl-names = "default";
+	/* frequency of PWM ranges from 92H to 6MHz.*/
+	pwm-frequency = <2000000>;
+	//pinctrl-0 = <&pwm2_pins>;
+	status = "disable";
+};
+
+&lcdc {
+    pinctrl-names = "default";
+    pinctrl-0 = <&lcd_pins>; //<&lcd_pins>,<&lcd_reset_pins>; //lcd_reset_pins only for mipi lcd
+    
+    lcd-logo-width = <600>;
+    lcd-logo-height = <165>;
+    //[fmt1:fmt0] 00 16bits input(RGB565 or BGR565)
+    //[fmt1:fmt0] 01 24bits input(RGB888 or BGR888)
+    //[fmt1:fmt0] 10 or 11 32bits input(ARGB888 ABGR888 RGBA888 BGRA888)
+    lcd-logo-fmt0 = <1>;
+    lcd-logo-fmt1 = <0>;
+    lcd-logo-rgb-seq = <1>; //0 for BGR, 1 for RGB
+    
+    lcd-fb-type = <1>; //0:single buffer; 1:double buffer
+    status = "okay";
+};
+
+&sat070cp50 {
+    status = "okay";
+};
diff --git a/arch/arm/configs/anycloudv500_debug_defconfig b/arch/arm/configs/anycloudv500_debug_defconfig
new file mode 100755
index 0000000..242dbfe
--- /dev/null
+++ b/arch/arm/configs/anycloudv500_debug_defconfig
@@ -0,0 +1,2000 @@
+#
+# Automatically generated file; DO NOT EDIT.
+# Linux/arm 4.4.162 Kernel Configuration
+#
+CONFIG_ARM=y
+CONFIG_SYS_SUPPORTS_APM_EMULATION=y
+CONFIG_HAVE_PROC_CPU=y
+CONFIG_STACKTRACE_SUPPORT=y
+CONFIG_HAVE_LATENCYTOP_SUPPORT=y
+CONFIG_LOCKDEP_SUPPORT=y
+CONFIG_TRACE_IRQFLAGS_SUPPORT=y
+CONFIG_RWSEM_XCHGADD_ALGORITHM=y
+CONFIG_FIX_EARLYCON_MEM=y
+CONFIG_GENERIC_HWEIGHT=y
+CONFIG_GENERIC_CALIBRATE_DELAY=y
+CONFIG_NEED_DMA_MAP_STATE=y
+CONFIG_ARCH_SUPPORTS_UPROBES=y
+CONFIG_VECTORS_BASE=0xffff0000
+# CONFIG_ARM_PATCH_PHYS_VIRT is not set
+CONFIG_PHYS_OFFSET=0x80000000
+CONFIG_GENERIC_BUG=y
+CONFIG_PGTABLE_LEVELS=2
+CONFIG_DEFCONFIG_LIST="/lib/modules/$UNAME_RELEASE/.config"
+CONFIG_IRQ_WORK=y
+CONFIG_BUILDTIME_EXTABLE_SORT=y
+
+#
+# General setup
+#
+CONFIG_BROKEN_ON_SMP=y
+CONFIG_INIT_ENV_ARG_LIMIT=32
+CONFIG_CROSS_COMPILE=""
+# CONFIG_COMPILE_TEST is not set
+CONFIG_LOCALVERSION="V1.4"
+# CONFIG_LOCALVERSION_AUTO is not set
+CONFIG_HAVE_KERNEL_GZIP=y
+CONFIG_HAVE_KERNEL_LZMA=y
+CONFIG_HAVE_KERNEL_XZ=y
+CONFIG_HAVE_KERNEL_LZO=y
+CONFIG_HAVE_KERNEL_LZ4=y
+# CONFIG_KERNEL_GZIP is not set
+# CONFIG_KERNEL_LZMA is not set
+CONFIG_KERNEL_XZ=y
+# CONFIG_KERNEL_LZO is not set
+# CONFIG_KERNEL_LZ4 is not set
+CONFIG_DEFAULT_HOSTNAME="(none)"
+# CONFIG_SWAP is not set
+CONFIG_SYSVIPC=y
+CONFIG_SYSVIPC_SYSCTL=y
+# CONFIG_POSIX_MQUEUE is not set
+# CONFIG_CROSS_MEMORY_ATTACH is not set
+# CONFIG_FHANDLE is not set
+# CONFIG_USELIB is not set
+# CONFIG_AUDIT is not set
+CONFIG_HAVE_ARCH_AUDITSYSCALL=y
+
+#
+# IRQ subsystem
+#
+CONFIG_GENERIC_IRQ_PROBE=y
+CONFIG_GENERIC_IRQ_SHOW=y
+CONFIG_GENERIC_IRQ_SHOW_LEVEL=y
+CONFIG_HARDIRQS_SW_RESEND=y
+CONFIG_IRQ_DOMAIN=y
+CONFIG_HANDLE_DOMAIN_IRQ=y
+# CONFIG_IRQ_DOMAIN_DEBUG is not set
+CONFIG_IRQ_FORCED_THREADING=y
+CONFIG_GENERIC_CLOCKEVENTS=y
+
+#
+# Timers subsystem
+#
+CONFIG_TICK_ONESHOT=y
+CONFIG_NO_HZ_COMMON=y
+# CONFIG_HZ_PERIODIC is not set
+CONFIG_NO_HZ_IDLE=y
+CONFIG_NO_HZ=y
+CONFIG_HIGH_RES_TIMERS=y
+
+#
+# CPU/Task time and stats accounting
+#
+CONFIG_TICK_CPU_ACCOUNTING=y
+# CONFIG_VIRT_CPU_ACCOUNTING_GEN is not set
+# CONFIG_IRQ_TIME_ACCOUNTING is not set
+
+#
+# RCU Subsystem
+#
+CONFIG_PREEMPT_RCU=y
+# CONFIG_RCU_EXPERT is not set
+CONFIG_SRCU=y
+# CONFIG_TASKS_RCU is not set
+CONFIG_RCU_STALL_COMMON=y
+# CONFIG_TREE_RCU_TRACE is not set
+# CONFIG_RCU_EXPEDITE_BOOT is not set
+# CONFIG_BUILD_BIN2C is not set
+# CONFIG_IKCONFIG is not set
+CONFIG_LOG_BUF_SHIFT=17
+CONFIG_GENERIC_SCHED_CLOCK=y
+# CONFIG_CGROUPS is not set
+# CONFIG_CHECKPOINT_RESTORE is not set
+# CONFIG_SCHED_AUTOGROUP is not set
+# CONFIG_SYSFS_DEPRECATED is not set
+CONFIG_RELAY=y
+# CONFIG_BLK_DEV_INITRD is not set
+CONFIG_CC_OPTIMIZE_FOR_PERFORMANCE=y
+# CONFIG_CC_OPTIMIZE_FOR_SIZE is not set
+CONFIG_SYSCTL=y
+CONFIG_ANON_INODES=y
+CONFIG_HAVE_UID16=y
+CONFIG_BPF=y
+CONFIG_EXPERT=y
+CONFIG_UID16=y
+CONFIG_MULTIUSER=y
+# CONFIG_SGETMASK_SYSCALL is not set
+# CONFIG_SYSFS_SYSCALL is not set
+# CONFIG_SYSCTL_SYSCALL is not set
+CONFIG_KALLSYMS=y
+# CONFIG_KALLSYMS_ALL is not set
+CONFIG_PRINTK=y
+CONFIG_BUG=y
+CONFIG_BASE_FULL=y
+CONFIG_FUTEX=y
+CONFIG_EPOLL=y
+CONFIG_SIGNALFD=y
+CONFIG_TIMERFD=y
+CONFIG_EVENTFD=y
+# CONFIG_BPF_SYSCALL is not set
+CONFIG_SHMEM=y
+CONFIG_AIO=y
+CONFIG_ADVISE_SYSCALLS=y
+# CONFIG_USERFAULTFD is not set
+# CONFIG_MEMBARRIER is not set
+CONFIG_EMBEDDED=y
+CONFIG_HAVE_PERF_EVENTS=y
+CONFIG_PERF_USE_VMALLOC=y
+
+#
+# Kernel Performance Events And Counters
+#
+# CONFIG_PERF_EVENTS is not set
+# CONFIG_VM_EVENT_COUNTERS is not set
+# CONFIG_SLUB_DEBUG is not set
+# CONFIG_COMPAT_BRK is not set
+# CONFIG_SLAB is not set
+CONFIG_SLUB=y
+# CONFIG_SLOB is not set
+# CONFIG_SYSTEM_DATA_VERIFICATION is not set
+# CONFIG_PROFILING is not set
+CONFIG_TRACEPOINTS=y
+CONFIG_HAVE_OPROFILE=y
+# CONFIG_KPROBES is not set
+CONFIG_JUMP_LABEL=y
+# CONFIG_STATIC_KEYS_SELFTEST is not set
+# CONFIG_UPROBES is not set
+# CONFIG_HAVE_64BIT_ALIGNED_ACCESS is not set
+CONFIG_ARCH_USE_BUILTIN_BSWAP=y
+CONFIG_HAVE_KPROBES=y
+CONFIG_HAVE_KRETPROBES=y
+CONFIG_HAVE_OPTPROBES=y
+CONFIG_HAVE_ARCH_TRACEHOOK=y
+CONFIG_HAVE_DMA_ATTRS=y
+CONFIG_HAVE_DMA_CONTIGUOUS=y
+CONFIG_GENERIC_SMP_IDLE_THREAD=y
+CONFIG_GENERIC_IDLE_POLL_SETUP=y
+CONFIG_HAVE_REGS_AND_STACK_ACCESS_API=y
+CONFIG_HAVE_CLK=y
+CONFIG_HAVE_DMA_API_DEBUG=y
+CONFIG_HAVE_PERF_REGS=y
+CONFIG_HAVE_PERF_USER_STACK_DUMP=y
+CONFIG_HAVE_ARCH_JUMP_LABEL=y
+CONFIG_ARCH_WANT_IPC_PARSE_VERSION=y
+CONFIG_HAVE_ARCH_SECCOMP_FILTER=y
+CONFIG_HAVE_CC_STACKPROTECTOR=y
+# CONFIG_CC_STACKPROTECTOR is not set
+CONFIG_CC_STACKPROTECTOR_NONE=y
+# CONFIG_CC_STACKPROTECTOR_REGULAR is not set
+# CONFIG_CC_STACKPROTECTOR_STRONG is not set
+CONFIG_HAVE_CONTEXT_TRACKING=y
+CONFIG_HAVE_VIRT_CPU_ACCOUNTING_GEN=y
+CONFIG_HAVE_IRQ_TIME_ACCOUNTING=y
+CONFIG_HAVE_MOD_ARCH_SPECIFIC=y
+CONFIG_MODULES_USE_ELF_REL=y
+CONFIG_ARCH_HAS_ELF_RANDOMIZE=y
+CONFIG_CLONE_BACKWARDS=y
+CONFIG_OLD_SIGSUSPEND3=y
+CONFIG_OLD_SIGACTION=y
+
+#
+# GCOV-based kernel profiling
+#
+# CONFIG_GCOV_KERNEL is not set
+CONFIG_ARCH_HAS_GCOV_PROFILE_ALL=y
+CONFIG_HAVE_GENERIC_DMA_COHERENT=y
+CONFIG_RT_MUTEXES=y
+CONFIG_BASE_SMALL=0
+CONFIG_MODULES=y
+# CONFIG_MODULE_FORCE_LOAD is not set
+CONFIG_MODULE_UNLOAD=y
+# CONFIG_MODULE_FORCE_UNLOAD is not set
+# CONFIG_MODVERSIONS is not set
+# CONFIG_MODULE_SRCVERSION_ALL is not set
+# CONFIG_MODULE_SIG is not set
+# CONFIG_MODULE_COMPRESS is not set
+CONFIG_MODULES_TREE_LOOKUP=y
+CONFIG_BLOCK=y
+# CONFIG_LBDAF is not set
+# CONFIG_BLK_DEV_BSG is not set
+# CONFIG_BLK_DEV_BSGLIB is not set
+# CONFIG_BLK_DEV_INTEGRITY is not set
+# CONFIG_BLK_CMDLINE_PARSER is not set
+
+#
+# Partition Types
+#
+# CONFIG_PARTITION_ADVANCED is not set
+CONFIG_MSDOS_PARTITION=y
+CONFIG_EFI_PARTITION=y
+
+#
+# IO Schedulers
+#
+CONFIG_IOSCHED_NOOP=y
+# CONFIG_IOSCHED_DEADLINE is not set
+# CONFIG_IOSCHED_CFQ is not set
+CONFIG_DEFAULT_NOOP=y
+CONFIG_DEFAULT_IOSCHED="noop"
+CONFIG_UNINLINE_SPIN_UNLOCK=y
+CONFIG_ARCH_SUPPORTS_ATOMIC_RMW=y
+# CONFIG_FREEZER is not set
+
+#
+# System Type
+#
+CONFIG_MMU=y
+CONFIG_ARCH_AK=y
+CONFIG_MACH_AK3790D=y
+
+#
+# Processor Type
+#
+CONFIG_CPU_ARM926T=y
+CONFIG_CPU_32v5=y
+CONFIG_CPU_ABRT_EV5TJ=y
+CONFIG_CPU_PABRT_LEGACY=y
+CONFIG_CPU_CACHE_VIVT=y
+CONFIG_CPU_COPY_V4WB=y
+CONFIG_CPU_TLB_V4WBI=y
+CONFIG_CPU_CP15=y
+CONFIG_CPU_CP15_MMU=y
+CONFIG_CPU_USE_DOMAINS=y
+
+#
+# Processor Features
+#
+# CONFIG_ARCH_PHYS_ADDR_T_64BIT is not set
+# CONFIG_ARM_THUMB is not set
+# CONFIG_CPU_ICACHE_DISABLE is not set
+# CONFIG_CPU_DCACHE_DISABLE is not set
+# CONFIG_CPU_DCACHE_WRITETHROUGH is not set
+# CONFIG_CPU_CACHE_ROUND_ROBIN is not set
+CONFIG_NEED_KUSER_HELPERS=y
+CONFIG_KUSER_HELPERS=y
+# CONFIG_CACHE_L2X0 is not set
+CONFIG_ARM_L1_CACHE_SHIFT=5
+# CONFIG_ARM_KERNMEM_PERMS is not set
+
+#
+# Bus support
+#
+# CONFIG_PCI_DOMAINS_GENERIC is not set
+# CONFIG_PCI_SYSCALL is not set
+# CONFIG_PCCARD is not set
+
+#
+# Kernel Features
+#
+CONFIG_VMSPLIT_3G=y
+# CONFIG_VMSPLIT_3G_OPT is not set
+# CONFIG_VMSPLIT_2G is not set
+# CONFIG_VMSPLIT_1G is not set
+CONFIG_PAGE_OFFSET=0xC0000000
+CONFIG_ARCH_NR_GPIO=0
+# CONFIG_PREEMPT_NONE is not set
+# CONFIG_PREEMPT_VOLUNTARY is not set
+CONFIG_PREEMPT=y
+CONFIG_PREEMPT_COUNT=y
+CONFIG_HZ_FIXED=0
+CONFIG_HZ_100=y
+# CONFIG_HZ_200 is not set
+# CONFIG_HZ_250 is not set
+# CONFIG_HZ_300 is not set
+# CONFIG_HZ_500 is not set
+# CONFIG_HZ_1000 is not set
+CONFIG_HZ=100
+CONFIG_SCHED_HRTICK=y
+CONFIG_AEABI=y
+# CONFIG_OABI_COMPAT is not set
+# CONFIG_ARCH_SPARSEMEM_DEFAULT is not set
+# CONFIG_ARCH_SELECT_MEMORY_MODEL is not set
+CONFIG_HAVE_ARCH_PFN_VALID=y
+# CONFIG_HIGHMEM is not set
+CONFIG_CPU_SW_DOMAIN_PAN=y
+CONFIG_ARCH_WANT_GENERAL_HUGETLB=y
+# CONFIG_ARM_MODULE_PLTS is not set
+CONFIG_FLATMEM=y
+CONFIG_FLAT_NODE_MEM_MAP=y
+CONFIG_HAVE_MEMBLOCK=y
+CONFIG_NO_BOOTMEM=y
+CONFIG_MEMORY_ISOLATION=y
+# CONFIG_HAVE_BOOTMEM_INFO_NODE is not set
+CONFIG_SPLIT_PTLOCK_CPUS=999999
+CONFIG_COMPACTION=y
+CONFIG_MIGRATION=y
+# CONFIG_PHYS_ADDR_T_64BIT is not set
+CONFIG_ZONE_DMA_FLAG=0
+# CONFIG_KSM is not set
+CONFIG_DEFAULT_MMAP_MIN_ADDR=4096
+CONFIG_NEED_PER_CPU_KM=y
+# CONFIG_CLEANCACHE is not set
+CONFIG_CMA=y
+# CONFIG_CMA_DEBUG is not set
+# CONFIG_CMA_DEBUGFS is not set
+CONFIG_CMA_AREAS=7
+# CONFIG_CMA_AGGRESSIVE is not set
+# CONFIG_ZPOOL is not set
+# CONFIG_ZBUD is not set
+# CONFIG_ZSMALLOC is not set
+# CONFIG_IDLE_PAGE_TRACKING is not set
+CONFIG_FRAME_VECTOR=y
+CONFIG_FORCE_MAX_ZONEORDER=11
+CONFIG_ALIGNMENT_TRAP=y
+# CONFIG_UACCESS_WITH_MEMCPY is not set
+# CONFIG_SECCOMP is not set
+CONFIG_SWIOTLB=y
+CONFIG_IOMMU_HELPER=y
+
+#
+# Boot options
+#
+CONFIG_USE_OF=y
+# CONFIG_ATAGS is not set
+CONFIG_ZBOOT_ROM_TEXT=0
+CONFIG_ZBOOT_ROM_BSS=0
+# CONFIG_ARM_APPENDED_DTB is not set
+CONFIG_CMDLINE=""
+# CONFIG_XIP_KERNEL is not set
+# CONFIG_KEXEC is not set
+# CONFIG_CRASH_DUMP is not set
+# CONFIG_AUTO_ZRELADDR is not set
+
+#
+# CPU Power Management
+#
+
+#
+# CPU Frequency scaling
+#
+# CONFIG_CPU_FREQ is not set
+
+#
+# CPU Idle
+#
+# CONFIG_CPU_IDLE is not set
+# CONFIG_ARCH_NEEDS_CPU_IDLE_COUPLED is not set
+
+#
+# Floating point emulation
+#
+
+#
+# At least one emulation must be selected
+#
+# CONFIG_VFP is not set
+
+#
+# Userspace binary formats
+#
+CONFIG_BINFMT_ELF=y
+# CONFIG_BINFMT_SCRIPT is not set
+# CONFIG_HAVE_AOUT is not set
+# CONFIG_BINFMT_MISC is not set
+# CONFIG_COREDUMP is not set
+
+#
+# Power management options
+#
+# CONFIG_SUSPEND is not set
+# CONFIG_PM is not set
+CONFIG_ARCH_SUSPEND_POSSIBLE=y
+# CONFIG_ARM_CPU_SUSPEND is not set
+CONFIG_ARCH_HIBERNATION_POSSIBLE=y
+CONFIG_NET=y
+CONFIG_NET_INGRESS=y
+
+#
+# Networking options
+#
+CONFIG_PACKET=y
+# CONFIG_PACKET_DIAG is not set
+CONFIG_UNIX=y
+CONFIG_UNIX_DIAG=y
+CONFIG_XFRM=y
+# CONFIG_XFRM_USER is not set
+# CONFIG_XFRM_SUB_POLICY is not set
+# CONFIG_XFRM_MIGRATE is not set
+# CONFIG_XFRM_STATISTICS is not set
+# CONFIG_NET_KEY is not set
+CONFIG_INET=y
+CONFIG_IP_MULTICAST=y
+# CONFIG_IP_ADVANCED_ROUTER is not set
+CONFIG_IP_PNP=y
+CONFIG_IP_PNP_DHCP=y
+CONFIG_IP_PNP_BOOTP=y
+CONFIG_IP_PNP_RARP=y
+# CONFIG_NET_IPIP is not set
+# CONFIG_NET_IPGRE_DEMUX is not set
+# CONFIG_NET_IP_TUNNEL is not set
+# CONFIG_IP_MROUTE is not set
+# CONFIG_SYN_COOKIES is not set
+# CONFIG_NET_IPVTI is not set
+# CONFIG_NET_UDP_TUNNEL is not set
+# CONFIG_NET_FOU is not set
+# CONFIG_INET_AH is not set
+# CONFIG_INET_ESP is not set
+# CONFIG_INET_IPCOMP is not set
+# CONFIG_INET_XFRM_TUNNEL is not set
+# CONFIG_INET_TUNNEL is not set
+CONFIG_INET_XFRM_MODE_TRANSPORT=y
+CONFIG_INET_XFRM_MODE_TUNNEL=y
+CONFIG_INET_XFRM_MODE_BEET=y
+CONFIG_INET_LRO=y
+CONFIG_INET_DIAG=y
+CONFIG_INET_TCP_DIAG=y
+CONFIG_INET_UDP_DIAG=y
+# CONFIG_TCP_CONG_ADVANCED is not set
+CONFIG_TCP_CONG_CUBIC=y
+CONFIG_DEFAULT_TCP_CONG="cubic"
+# CONFIG_TCP_MD5SIG is not set
+# CONFIG_IPV6 is not set
+CONFIG_NETWORK_SECMARK=y
+# CONFIG_NET_PTP_CLASSIFY is not set
+# CONFIG_NETWORK_PHY_TIMESTAMPING is not set
+CONFIG_NETFILTER=y
+# CONFIG_NETFILTER_DEBUG is not set
+CONFIG_NETFILTER_ADVANCED=y
+
+#
+# Core Netfilter Configuration
+#
+CONFIG_NETFILTER_INGRESS=y
+# CONFIG_NETFILTER_NETLINK_ACCT is not set
+# CONFIG_NETFILTER_NETLINK_QUEUE is not set
+# CONFIG_NETFILTER_NETLINK_LOG is not set
+# CONFIG_NF_CONNTRACK is not set
+# CONFIG_NF_TABLES is not set
+# CONFIG_NETFILTER_XTABLES is not set
+# CONFIG_IP_SET is not set
+# CONFIG_IP_VS is not set
+
+#
+# IP: Netfilter Configuration
+#
+# CONFIG_NF_DEFRAG_IPV4 is not set
+# CONFIG_NF_DUP_IPV4 is not set
+# CONFIG_NF_LOG_ARP is not set
+# CONFIG_NF_LOG_IPV4 is not set
+# CONFIG_NF_REJECT_IPV4 is not set
+# CONFIG_IP_NF_IPTABLES is not set
+# CONFIG_IP_NF_ARPTABLES is not set
+# CONFIG_IP_DCCP is not set
+CONFIG_IP_SCTP=y
+# CONFIG_SCTP_DBG_OBJCNT is not set
+CONFIG_SCTP_DEFAULT_COOKIE_HMAC_MD5=y
+# CONFIG_SCTP_DEFAULT_COOKIE_HMAC_SHA1 is not set
+# CONFIG_SCTP_DEFAULT_COOKIE_HMAC_NONE is not set
+CONFIG_SCTP_COOKIE_HMAC_MD5=y
+# CONFIG_SCTP_COOKIE_HMAC_SHA1 is not set
+# CONFIG_RDS is not set
+# CONFIG_TIPC is not set
+# CONFIG_ATM is not set
+# CONFIG_L2TP is not set
+# CONFIG_BRIDGE is not set
+CONFIG_HAVE_NET_DSA=y
+# CONFIG_NET_DSA is not set
+# CONFIG_VLAN_8021Q is not set
+# CONFIG_DECNET is not set
+# CONFIG_LLC2 is not set
+# CONFIG_IPX is not set
+# CONFIG_ATALK is not set
+# CONFIG_X25 is not set
+# CONFIG_LAPB is not set
+# CONFIG_PHONET is not set
+# CONFIG_IEEE802154 is not set
+# CONFIG_NET_SCHED is not set
+# CONFIG_DCB is not set
+# CONFIG_BATMAN_ADV is not set
+# CONFIG_OPENVSWITCH is not set
+# CONFIG_VSOCKETS is not set
+# CONFIG_NETLINK_DIAG is not set
+# CONFIG_MPLS is not set
+# CONFIG_HSR is not set
+# CONFIG_NET_SWITCHDEV is not set
+# CONFIG_NET_L3_MASTER_DEV is not set
+CONFIG_NET_RX_BUSY_POLL=y
+CONFIG_BQL=y
+# CONFIG_BPF_JIT is not set
+
+#
+# Network testing
+#
+# CONFIG_NET_PKTGEN is not set
+# CONFIG_HAMRADIO is not set
+# CONFIG_CAN is not set
+# CONFIG_IRDA is not set
+# CONFIG_BT is not set
+# CONFIG_AF_RXRPC is not set
+CONFIG_WIRELESS=y
+CONFIG_WIRELESS_EXT=y
+CONFIG_WEXT_CORE=y
+CONFIG_WEXT_PROC=y
+CONFIG_WEXT_PRIV=y
+CONFIG_CFG80211=m
+# CONFIG_NL80211_TESTMODE is not set
+# CONFIG_CFG80211_DEVELOPER_WARNINGS is not set
+# CONFIG_CFG80211_REG_DEBUG is not set
+# CONFIG_CFG80211_CERTIFICATION_ONUS is not set
+CONFIG_CFG80211_DEFAULT_PS=y
+# CONFIG_CFG80211_DEBUGFS is not set
+# CONFIG_CFG80211_INTERNAL_REGDB is not set
+CONFIG_CFG80211_CRDA_SUPPORT=y
+CONFIG_CFG80211_WEXT=y
+# CONFIG_LIB80211 is not set
+CONFIG_MAC80211=m
+CONFIG_MAC80211_HAS_RC=y
+CONFIG_MAC80211_RC_MINSTREL=y
+CONFIG_MAC80211_RC_MINSTREL_HT=y
+# CONFIG_MAC80211_RC_MINSTREL_VHT is not set
+CONFIG_MAC80211_RC_DEFAULT_MINSTREL=y
+CONFIG_MAC80211_RC_DEFAULT="minstrel_ht"
+# CONFIG_MAC80211_MESH is not set
+# CONFIG_MAC80211_LEDS is not set
+# CONFIG_MAC80211_DEBUGFS is not set
+# CONFIG_MAC80211_MESSAGE_TRACING is not set
+# CONFIG_MAC80211_DEBUG_MENU is not set
+CONFIG_MAC80211_STA_HASH_MAX_SIZE=0
+# CONFIG_WIMAX is not set
+# CONFIG_RFKILL is not set
+# CONFIG_NET_9P is not set
+# CONFIG_CAIF is not set
+# CONFIG_CEPH_LIB is not set
+# CONFIG_NFC is not set
+# CONFIG_LWTUNNEL is not set
+# CONFIG_DST_CACHE is not set
+CONFIG_HAVE_BPF_JIT=y
+
+#
+# Device Drivers
+#
+
+#
+# Generic Driver Options
+#
+CONFIG_UEVENT_HELPER=y
+CONFIG_UEVENT_HELPER_PATH="/sbin/hotplug"
+CONFIG_DEVTMPFS=y
+CONFIG_DEVTMPFS_MOUNT=y
+# CONFIG_STANDALONE is not set
+# CONFIG_PREVENT_FIRMWARE_BUILD is not set
+# CONFIG_FW_LOADER is not set
+# CONFIG_ALLOW_DEV_COREDUMP is not set
+# CONFIG_DEBUG_DRIVER is not set
+# CONFIG_DEBUG_DEVRES is not set
+# CONFIG_SYS_HYPERVISOR is not set
+# CONFIG_GENERIC_CPU_DEVICES is not set
+CONFIG_DMA_SHARED_BUFFER=y
+# CONFIG_FENCE_TRACE is not set
+CONFIG_DMA_CMA=y
+
+#
+# Default contiguous memory area size:
+#
+CONFIG_CMA_SIZE_MBYTES=30
+CONFIG_CMA_SIZE_SEL_MBYTES=y
+# CONFIG_CMA_SIZE_SEL_PERCENTAGE is not set
+# CONFIG_CMA_SIZE_SEL_MIN is not set
+# CONFIG_CMA_SIZE_SEL_MAX is not set
+CONFIG_CMA_ALIGNMENT=8
+
+#
+# Bus devices
+#
+# CONFIG_BRCMSTB_GISB_ARB is not set
+# CONFIG_VEXPRESS_CONFIG is not set
+# CONFIG_CONNECTOR is not set
+
+CONFIG_MTD=y
+# CONFIG_MTD_TESTS is not set
+# CONFIG_MTD_REDBOOT_PARTS is not set
+# CONFIG_MTD_CMDLINE_PARTS is not set
+# CONFIG_MTD_AFS_PARTS is not set
+# CONFIG_MTD_OF_PARTS is not set
+# CONFIG_MTD_AR7_PARTS is not set
+
+#
+# User Modules And Translation Layers
+#
+CONFIG_MTD_BLKDEVS=y
+CONFIG_MTD_BLOCK=y
+# CONFIG_FTL is not set
+# CONFIG_NFTL is not set
+# CONFIG_INFTL is not set
+# CONFIG_RFD_FTL is not set
+# CONFIG_SSFDC is not set
+# CONFIG_SM_FTL is not set
+# CONFIG_MTD_OOPS is not set
+# CONFIG_MTD_PARTITIONED_MASTER is not set
+
+#
+# RAM/ROM/Flash chip drivers
+#
+# CONFIG_MTD_CFI is not set
+# CONFIG_MTD_JEDECPROBE is not set
+CONFIG_MTD_MAP_BANK_WIDTH_1=y
+CONFIG_MTD_MAP_BANK_WIDTH_2=y
+CONFIG_MTD_MAP_BANK_WIDTH_4=y
+# CONFIG_MTD_MAP_BANK_WIDTH_8 is not set
+# CONFIG_MTD_MAP_BANK_WIDTH_16 is not set
+# CONFIG_MTD_MAP_BANK_WIDTH_32 is not set
+CONFIG_MTD_CFI_I1=y
+CONFIG_MTD_CFI_I2=y
+# CONFIG_MTD_CFI_I4 is not set
+# CONFIG_MTD_CFI_I8 is not set
+# CONFIG_MTD_RAM is not set
+# CONFIG_MTD_ROM is not set
+# CONFIG_MTD_ABSENT is not set
+
+#
+# Mapping drivers for chip access
+#
+# CONFIG_MTD_COMPLEX_MAPPINGS is not set
+# CONFIG_MTD_PLATRAM is not set
+
+#
+# Self-contained MTD device drivers
+#
+# CONFIG_MTD_DATAFLASH is not set
+# CONFIG_MTD_SST25L is not set
+CONFIG_MTD_AK_SPIFLASH=y
+# CONFIG_MTD_SLRAM is not set
+# CONFIG_MTD_PHRAM is not set
+# CONFIG_MTD_MTDRAM is not set
+# CONFIG_MTD_BLOCK2MTD is not set
+
+#
+# Disk-On-Chip Device Drivers
+#
+# CONFIG_MTD_DOCG3 is not set
+CONFIG_MTD_AK_SPINAND=y
+# CONFIG_MTD_NAND is not set
+# CONFIG_MTD_ONENAND is not set
+
+#
+# LPDDR & LPDDR2 PCM memory drivers
+#
+# CONFIG_MTD_LPDDR is not set
+# CONFIG_MTD_LPDDR2_NVM is not set
+# CONFIG_MTD_SPI_NOR is not set
+# CONFIG_MTD_UBI is not set
+CONFIG_DTC=y
+CONFIG_OF=y
+# CONFIG_OF_UNITTEST is not set
+CONFIG_OF_FLATTREE=y
+CONFIG_OF_EARLY_FLATTREE=y
+CONFIG_OF_ADDRESS=y
+CONFIG_OF_IRQ=y
+CONFIG_OF_NET=y
+CONFIG_OF_MDIO=y
+CONFIG_OF_MTD=y
+CONFIG_OF_RESERVED_MEM=y
+# CONFIG_OF_OVERLAY is not set
+CONFIG_ARCH_MIGHT_HAVE_PC_PARPORT=y
+# CONFIG_PARPORT is not set
+CONFIG_BLK_DEV=y
+# CONFIG_BLK_DEV_NULL_BLK is not set
+# CONFIG_BLK_DEV_COW_COMMON is not set
+# CONFIG_BLK_DEV_LOOP is not set
+# CONFIG_BLK_DEV_DRBD is not set
+# CONFIG_BLK_DEV_NBD is not set
+# CONFIG_BLK_DEV_RAM is not set
+# CONFIG_CDROM_PKTCDVD is not set
+# CONFIG_ATA_OVER_ETH is not set
+# CONFIG_MG_DISK is not set
+# CONFIG_BLK_DEV_RBD is not set
+
+#
+# Misc devices
+#
+# CONFIG_DUMMY_IRQ is not set
+# CONFIG_ENCLOSURE_SERVICES is not set
+# CONFIG_HMC6352 is not set
+# CONFIG_SRAM is not set
+# CONFIG_C2PORT is not set
+
+#
+# EEPROM support
+#
+# CONFIG_EEPROM_93CX6 is not set
+
+#
+# Texas Instruments shared transport line discipline
+#
+
+#
+# Altera FPGA firmware download module
+#
+
+#
+# Intel MIC Bus Driver
+#
+
+#
+# SCIF Bus Driver
+#
+
+#
+# Intel MIC Host Driver
+#
+
+#
+# Intel MIC Card Driver
+#
+
+#
+# SCIF Driver
+#
+
+#
+# Intel MIC Coprocessor State Management (COSM) Drivers
+#
+# CONFIG_ECHO is not set
+# CONFIG_CXL_BASE is not set
+# CONFIG_CXL_KERNEL_API is not set
+# CONFIG_CXL_EEH is not set
+
+#
+# SCSI device support
+#
+CONFIG_SCSI_MOD=y
+# CONFIG_RAID_ATTRS is not set
+# CONFIG_SCSI is not set
+# CONFIG_SCSI_DMA is not set
+# CONFIG_SCSI_NETLINK is not set
+# CONFIG_ATA is not set
+# CONFIG_MD is not set
+
+CONFIG_NETDEVICES=y
+CONFIG_NET_CORE=y
+
+#
+# Distributed Switch Architecture drivers
+#
+# CONFIG_NET_DSA_MV88E6XXX is not set
+# CONFIG_NET_DSA_MV88E6XXX_NEED_PPU is not set
+CONFIG_ETHERNET=y
+# CONFIG_ALTERA_TSE is not set
+# CONFIG_NET_VENDOR_ARC is not set
+# CONFIG_NET_VENDOR_AURORA is not set
+# CONFIG_NET_CADENCE is not set
+# CONFIG_NET_VENDOR_BROADCOM is not set
+# CONFIG_NET_VENDOR_CIRRUS is not set
+# CONFIG_DM9000 is not set
+# CONFIG_DNET is not set
+# CONFIG_NET_VENDOR_EZCHIP is not set
+# CONFIG_NET_VENDOR_FARADAY is not set
+# CONFIG_NET_VENDOR_HISILICON is not set
+# CONFIG_NET_VENDOR_INTEL is not set
+# CONFIG_NET_VENDOR_MARVELL is not set
+# CONFIG_NET_VENDOR_MICREL is not set
+# CONFIG_NET_VENDOR_MICROCHIP is not set
+# CONFIG_NET_VENDOR_NATSEMI is not set
+# CONFIG_ETHOC is not set
+# CONFIG_NET_VENDOR_QUALCOMM is not set
+# CONFIG_NET_VENDOR_RENESAS is not set
+# CONFIG_NET_VENDOR_ROCKER is not set
+# CONFIG_NET_VENDOR_SAMSUNG is not set
+# CONFIG_NET_VENDOR_SEEQ is not set
+# CONFIG_NET_VENDOR_SMSC is not set
+# CONFIG_NET_VENDOR_STMICRO is not set
+# CONFIG_NET_VENDOR_SYNOPSYS is not set
+# CONFIG_NET_VENDOR_VIA is not set
+# CONFIG_NET_VENDOR_WIZNET is not set
+CONFIG_PHYLIB=y
+
+#
+# MII PHY device drivers
+#
+# CONFIG_USB_NET_DRIVERS is not set
+CONFIG_WLAN=y
+
+# CONFIG_RTL_CARDS is not set
+# CONFIG_RTL8XXXU is not set
+
+
+#
+# Enable WiMAX (Networking options) to see the WiMAX drivers
+#
+# CONFIG_WAN is not set
+# CONFIG_ISDN is not set
+# CONFIG_NVM is not set
+
+#
+# Input device support
+#
+CONFIG_INPUT=y
+CONFIG_INPUT_LEDS=y
+
+#
+# Userland interfaces
+#
+# CONFIG_INPUT_MOUSEDEV is not set
+# CONFIG_INPUT_JOYDEV is not set
+CONFIG_INPUT_EVDEV=y
+# CONFIG_INPUT_EVBUG is not set
+
+#
+# Input Device Drivers
+#
+# CONFIG_INPUT_KEYBOARD is not set
+# CONFIG_INPUT_MOUSE is not set
+# CONFIG_INPUT_JOYSTICK is not set
+# CONFIG_INPUT_TABLET is not set
+CONFIG_INPUT_TOUCHSCREEN=y
+CONFIG_TOUCHSCREEN_PROPERTIES=y
+CONFIG_INPUT_MISC=y
+
+#
+# Hardware I/O ports
+#
+# CONFIG_SERIO is not set
+# CONFIG_GAMEPORT is not set
+
+#
+# Character devices
+#
+CONFIG_TTY=y
+# CONFIG_VT is not set
+CONFIG_UNIX98_PTYS=y
+CONFIG_DEVPTS_MULTIPLE_INSTANCES=y
+# CONFIG_LEGACY_PTYS is not set
+# CONFIG_SERIAL_NONSTANDARD is not set
+# CONFIG_TRACE_SINK is not set
+CONFIG_DEVMEM=y
+# CONFIG_DEVKMEM is not set
+
+#
+# Serial drivers
+#
+# CONFIG_SERIAL_8250 is not set
+
+#
+# Non-8250 serial port support
+#
+CONFIG_SERIAL_CORE=y
+CONFIG_SERIAL_CORE_CONSOLE=y
+CONFIG_SERIAL_AK_UART=y
+CONFIG_SERIAL_AK_CONSOLE=y
+CONFIG_TTY_PRINTK=y
+# CONFIG_HW_RANDOM is not set
+
+#
+# I2C support
+#
+CONFIG_I2C=y
+CONFIG_I2C_BOARDINFO=y
+# CONFIG_I2C_COMPAT is not set
+CONFIG_I2C_CHARDEV=y
+CONFIG_I2C_MUX=y
+
+#
+# Multiplexer I2C Chip support
+#
+# CONFIG_I2C_ARB_GPIO_CHALLENGE is not set
+# CONFIG_I2C_MUX_GPIO is not set
+# CONFIG_I2C_MUX_PCA9541 is not set
+# CONFIG_I2C_MUX_PCA954x is not set
+# CONFIG_I2C_MUX_PINCTRL is not set
+# CONFIG_I2C_MUX_REG is not set
+# CONFIG_I2C_HELPER_AUTO is not set
+CONFIG_I2C_SMBUS=y
+
+#
+# I2C Algorithms
+#
+# CONFIG_I2C_ALGOBIT is not set
+# CONFIG_I2C_ALGOPCF is not set
+# CONFIG_I2C_ALGOPCA is not set
+
+#
+# I2C Hardware Bus support
+#
+
+#
+# I2C system bus drivers (mostly embedded / system-on-chip)
+#
+# CONFIG_I2C_CBUS_GPIO is not set
+# CONFIG_I2C_DESIGNWARE_PLATFORM is not set
+# CONFIG_I2C_EMEV2 is not set
+# CONFIG_I2C_GPIO is not set
+# CONFIG_I2C_OCORES is not set
+# CONFIG_I2C_PCA_PLATFORM is not set
+# CONFIG_I2C_PXA_PCI is not set
+# CONFIG_I2C_RK3X is not set
+# CONFIG_I2C_SIMTEC is not set
+# CONFIG_I2C_XILINX is not set
+
+#
+# External I2C/SMBus adapter drivers
+#
+# CONFIG_I2C_PARPORT_LIGHT is not set
+# CONFIG_I2C_TAOS_EVM is not set
+
+#
+# Other I2C/SMBus bus drivers
+#
+# CONFIG_I2C_STUB is not set
+# CONFIG_I2C_SLAVE is not set
+# CONFIG_I2C_DEBUG_CORE is not set
+# CONFIG_I2C_DEBUG_ALGO is not set
+# CONFIG_I2C_DEBUG_BUS is not set
+CONFIG_SPI=y
+# CONFIG_SPI_DEBUG is not set
+CONFIG_SPI_MASTER=y
+
+#
+# SPI Master Controller Drivers
+#
+# CONFIG_SPI_ALTERA is not set
+CONFIG_SPI_BITBANG=y
+# CONFIG_SPI_CADENCE is not set
+# CONFIG_SPI_GPIO is not set
+# CONFIG_SPI_FSL_SPI is not set
+# CONFIG_SPI_OC_TINY is not set
+# CONFIG_SPI_PXA2XX_PCI is not set
+# CONFIG_SPI_ROCKCHIP is not set
+# CONFIG_SPI_SC18IS602 is not set
+# CONFIG_SPI_XCOMM is not set
+# CONFIG_SPI_XILINX is not set
+# CONFIG_SPI_ZYNQMP_GQSPI is not set
+CONFIG_SPI_AK=y
+# CONFIG_SPI_DESIGNWARE is not set
+
+#
+# SPI Protocol Masters
+#
+# CONFIG_SPI_SPIDEV is not set
+# CONFIG_SPI_TLE62X0 is not set
+# CONFIG_SPMI is not set
+# CONFIG_HSI is not set
+
+#
+# PPS support
+#
+# CONFIG_PPS is not set
+
+#
+# PPS generators support
+#
+
+#
+# PTP clock support
+#
+
+#
+# Enable PHYLIB and NETWORK_PHY_TIMESTAMPING to see the additional clocks.
+#
+CONFIG_PINCTRL=y
+
+#
+# Pin controllers
+#
+CONFIG_PINMUX=y
+CONFIG_PINCONF=y
+CONFIG_DEBUG_PINCTRL=y
+# CONFIG_PINCTRL_AMD is not set
+# CONFIG_PINCTRL_SINGLE is not set
+CONFIG_PINCTRL_AK=y
+CONFIG_ARCH_HAVE_CUSTOM_GPIO_H=y
+CONFIG_ARCH_REQUIRE_GPIOLIB=y
+CONFIG_GPIOLIB=y
+CONFIG_GPIO_DEVRES=y
+CONFIG_OF_GPIO=y
+CONFIG_GPIOLIB_IRQCHIP=y
+CONFIG_DEBUG_GPIO=y
+CONFIG_GPIO_SYSFS=y
+
+#
+# Memory mapped GPIO drivers
+#
+# CONFIG_GPIO_74XX_MMIO is not set
+# CONFIG_GPIO_ALTERA is not set
+# CONFIG_GPIO_DWAPB is not set
+# CONFIG_GPIO_EM is not set
+# CONFIG_GPIO_GENERIC_PLATFORM is not set
+# CONFIG_GPIO_GRGPIO is not set
+# CONFIG_GPIO_XILINX is not set
+# CONFIG_GPIO_ZEVIO is not set
+# CONFIG_GPIO_ZX is not set
+
+#
+# I2C GPIO expanders
+#
+# CONFIG_GPIO_ADP5588 is not set
+# CONFIG_GPIO_ADNP is not set
+# CONFIG_GPIO_MAX7300 is not set
+# CONFIG_GPIO_MAX732X is not set
+# CONFIG_GPIO_PCA953X is not set
+# CONFIG_GPIO_PCF857X is not set
+# CONFIG_GPIO_SX150X is not set
+
+#
+# MFD GPIO expanders
+#
+
+#
+# SPI GPIO expanders
+#
+# CONFIG_GPIO_74X164 is not set
+# CONFIG_GPIO_MAX7301 is not set
+# CONFIG_GPIO_MC33880 is not set
+
+#
+# SPI or I2C GPIO expanders
+#
+# CONFIG_GPIO_MCP23S08 is not set
+
+#
+# USB GPIO expanders
+#
+# CONFIG_W1 is not set
+# CONFIG_POWER_SUPPLY is not set
+# CONFIG_POWER_AVS is not set
+# CONFIG_HWMON is not set
+# CONFIG_THERMAL is not set
+CONFIG_WATCHDOG=y
+CONFIG_WATCHDOG_CORE=y
+CONFIG_WATCHDOG_NOWAYOUT=y
+
+#
+# Watchdog Device Drivers
+#
+# CONFIG_SOFT_WATCHDOG is not set
+# CONFIG_GPIO_WATCHDOG is not set
+# CONFIG_XILINX_WATCHDOG is not set
+# CONFIG_CADENCE_WATCHDOG is not set
+# CONFIG_DW_WATCHDOG is not set
+CONFIG_AK_WATCHDOG_TOP=y
+# CONFIG_AK_WATCHDOG_NONE is not set
+# CONFIG_MAX63XX_WATCHDOG is not set
+# CONFIG_BCM7038_WDT is not set
+# CONFIG_MEN_A21_WDT is not set
+
+#
+# USB-based Watchdog Cards
+#
+# CONFIG_USBPCWATCHDOG is not set
+CONFIG_SSB_POSSIBLE=y
+
+#
+# Sonics Silicon Backplane
+#
+# CONFIG_SSB is not set
+CONFIG_BCMA_POSSIBLE=y
+
+#
+# Broadcom specific AMBA
+#
+# CONFIG_BCMA is not set
+
+#
+# Multifunction device drivers
+#
+# CONFIG_REGULATOR is not set
+CONFIG_MEDIA_SUPPORT=y
+
+#
+# Multimedia core support
+#
+CONFIG_MEDIA_CAMERA_SUPPORT=y
+# CONFIG_MEDIA_ANALOG_TV_SUPPORT is not set
+# CONFIG_MEDIA_DIGITAL_TV_SUPPORT is not set
+# CONFIG_MEDIA_RADIO_SUPPORT is not set
+# CONFIG_MEDIA_SDR_SUPPORT is not set
+# CONFIG_MEDIA_RC_SUPPORT is not set
+CONFIG_MEDIA_CONTROLLER=y
+CONFIG_VIDEO_DEV=y
+CONFIG_VIDEO_V4L2_SUBDEV_API=y
+CONFIG_VIDEO_V4L2=y
+CONFIG_VIDEO_ADV_DEBUG=y
+# CONFIG_VIDEO_FIXED_MINOR_RANGES is not set
+CONFIG_VIDEOBUF_GEN=y
+CONFIG_VIDEOBUF2_CORE=y
+CONFIG_VIDEOBUF2_MEMOPS=y
+CONFIG_VIDEOBUF2_DMA_CONTIG=y
+# CONFIG_TTPCI_EEPROM is not set
+
+#
+# Media drivers
+#
+# CONFIG_MEDIA_USB_SUPPORT is not set
+CONFIG_V4L_PLATFORM_DRIVERS=y
+CONFIG_SOC_CAMERA=y
+CONFIG_SOC_CAMERA_PLATFORM=y
+CONFIG_VIDEO_AK=y
+# CONFIG_VIDEO_XILINX is not set
+# CONFIG_V4L_MEM2MEM_DRIVERS is not set
+# CONFIG_V4L_TEST_DRIVERS is not set
+
+#
+# Supported MMC/SDIO adapters
+#
+
+#
+# Media ancillary drivers (tuners, sensors, i2c, frontends)
+#
+CONFIG_MEDIA_SUBDRV_AUTOSELECT=y
+
+#
+# Audio decoders, processors and mixers
+#
+
+#
+# RDS decoders
+#
+
+#
+# Video decoders
+#
+
+#
+# Video and audio decoders
+#
+
+#
+# Video encoders
+#
+
+#
+# Camera sensor devices
+#
+
+#
+# Flash devices
+#
+
+#
+# Video improvement chips
+#
+
+#
+# Audio/Video compression chips
+#
+
+#
+# Miscellaneous helper chips
+#
+
+#
+# Sensors used on soc_camera driver
+#
+
+#
+# Tools to develop new frontends
+#
+# CONFIG_DVB_DUMMY_FE is not set
+
+#
+# Graphics support
+#
+# CONFIG_DRM is not set
+
+#
+# Frame buffer Devices
+#
+CONFIG_FB=y
+# CONFIG_FIRMWARE_EDID is not set
+CONFIG_FB_CMDLINE=y
+# CONFIG_FB_DDC is not set
+# CONFIG_FB_BOOT_VESA_SUPPORT is not set
+# CONFIG_FB_CFB_FILLRECT is not set
+# CONFIG_FB_CFB_COPYAREA is not set
+# CONFIG_FB_CFB_IMAGEBLIT is not set
+
+#
+# Frame buffer hardware drivers
+#
+# CONFIG_FB_OPENCORES is not set
+# CONFIG_FB_S1D13XXX is not set
+# CONFIG_FB_SMSCUFX is not set
+# CONFIG_FB_UDL is not set
+# CONFIG_FB_IBM_GXT4500 is not set
+# CONFIG_FB_VIRTUAL is not set
+# CONFIG_FB_METRONOME is not set
+# CONFIG_FB_BROADSHEET is not set
+# CONFIG_FB_AUO_K190X is not set
+# CONFIG_FB_SIMPLE is not set
+# CONFIG_FB_SSD1307 is not set
+# CONFIG_BACKLIGHT_LCD_SUPPORT is not set
+# CONFIG_VGASTATE is not set
+# CONFIG_LOGO is not set
+# CONFIG_SOUND is not set
+
+#
+# HID support
+#
+# CONFIG_HID is not set
+
+#
+# USB HID support
+#
+# CONFIG_USB_HID is not set
+# CONFIG_HID_PID is not set
+
+#
+# USB HID Boot Protocol drivers
+#
+# CONFIG_USB_KBD is not set
+# CONFIG_USB_MOUSE is not set
+
+#
+# I2C HID support
+#
+# CONFIG_I2C_HID is not set
+CONFIG_USB_OHCI_LITTLE_ENDIAN=y
+CONFIG_USB_SUPPORT=y
+CONFIG_USB_COMMON=y
+CONFIG_USB_ARCH_HAS_HCD=y
+CONFIG_USB=y
+CONFIG_USB_ANNOUNCE_NEW_DEVICES=y
+
+#
+# Miscellaneous USB options
+#
+CONFIG_USB_DEFAULT_PERSIST=y
+
+#
+# USB Host Controller Drivers
+#
+
+#
+# USB Device Class drivers
+#
+# CONFIG_USB_ACM is not set
+# CONFIG_USB_PRINTER is not set
+CONFIG_USB_WDM=y
+# CONFIG_USB_TMC is not set
+
+CONFIG_USB_GADGET=y
+CONFIG_USB_LIBCOMPOSITE=m
+CONFIG_USB_F_MASS_STORAGE=m
+CONFIG_USB_MASS_STORAGE=m
+CONFIG_MMC=y
+# CONFIG_MMC_DEBUG is not set
+
+#
+# MMC/SD/SDIO Card Drivers
+#
+CONFIG_MMC_BLOCK=y
+CONFIG_MMC_BLOCK_MINORS=8
+CONFIG_MMC_BLOCK_BOUNCE=y
+# CONFIG_SDIO_UART is not set
+# CONFIG_MMC_TEST is not set
+
+#
+# MMC/SD/SDIO Host Controller Drivers
+#
+
+CONFIG_NEW_LEDS=y
+CONFIG_LEDS_CLASS=y
+# CONFIG_LEDS_CLASS_FLASH is not set
+
+#
+# LED drivers
+#
+
+#
+# LED Triggers
+#
+CONFIG_LEDS_TRIGGERS=y
+CONFIG_LEDS_TRIGGER_TIMER=y
+
+#
+# iptables trigger is under Netfilter config (LED target)
+#
+
+CONFIG_EDAC_ATOMIC_SCRUB=y
+CONFIG_EDAC_SUPPORT=y
+# CONFIG_EDAC is not set
+
+CONFIG_RTC_LIB=y
+CONFIG_RTC_CLASS=y
+CONFIG_RTC_HCTOSYS=y
+CONFIG_RTC_HCTOSYS_DEVICE="rtc0"
+CONFIG_RTC_SYSTOHC=y
+CONFIG_RTC_SYSTOHC_DEVICE="rtc0"
+# CONFIG_RTC_DEBUG is not set
+
+#
+# RTC interfaces
+#
+CONFIG_RTC_INTF_SYSFS=y
+CONFIG_RTC_INTF_PROC=y
+CONFIG_RTC_INTF_DEV=y
+# CONFIG_RTC_INTF_DEV_UIE_EMUL is not set
+# CONFIG_RTC_DRV_TEST is not set
+
+CONFIG_UIO=y
+# CONFIG_UIO_PDRV_GENIRQ is not set
+# CONFIG_UIO_DMEM_GENIRQ is not set
+# CONFIG_UIO_PRUSS is not set
+
+CONFIG_STAGING=y
+# CONFIG_PRISM2_USB is not set
+# CONFIG_COMEDI is not set
+# CONFIG_RTLLIB is not set
+# CONFIG_R8712U is not set
+CONFIG_R8188EU=m
+# CONFIG_88EU_AP_MODE is not set
+# CONFIG_VT6656 is not set
+
+#
+# Android
+#
+# CONFIG_ANDROID_TIMED_OUTPUT is not set
+# CONFIG_ANDROID_LOW_MEMORY_KILLER is not set
+# CONFIG_SYNC is not set
+CONFIG_ION=y
+# CONFIG_ION_TEST is not set
+# CONFIG_ION_DUMMY is not set
+# CONFIG_STAGING_BOARD is not set
+# CONFIG_DGAP is not set
+# CONFIG_GS_FPGABOOT is not set
+# CONFIG_COMMON_CLK_XLNX_CLKWZRD is not set
+# CONFIG_MOST is not set
+# CONFIG_CHROME_PLATFORMS is not set
+CONFIG_CLKDEV_LOOKUP=y
+CONFIG_HAVE_CLK_PREPARE=y
+CONFIG_COMMON_CLK=y
+
+#
+# Common Clock Framework
+#
+
+#
+# Hardware Spinlock drivers
+#
+
+#
+# Clock Source drivers
+#
+CONFIG_CLKSRC_OF=y
+CONFIG_CLKSRC_PROBE=y
+CONFIG_CLKSRC_MMIO=y
+CONFIG_ARM_TIMER_SP804=y
+CONFIG_IOMMU_SUPPORT=y
+
+#
+# Generic IOMMU Pagetable Support
+#
+# CONFIG_IOMMU_IO_PGTABLE_LPAE is not set
+# CONFIG_ARM_SMMU is not set
+
+#
+# Remoteproc drivers
+#
+# CONFIG_STE_MODEM_RPROC is not set
+
+#
+# Rpmsg drivers
+#
+
+#
+# SOC (System On Chip) specific Drivers
+#
+# CONFIG_SOC_BRCMSTB is not set
+# CONFIG_SUNXI_SRAM is not set
+# CONFIG_SOC_TI is not set
+# CONFIG_PM_DEVFREQ is not set
+# CONFIG_EXTCON is not set
+# CONFIG_MEMORY is not set
+CONFIG_IIO=y
+CONFIG_IIO_BUFFER=y
+CONFIG_IIO_TRIGGER=y
+CONFIG_IIO_CONSUMERS_PER_TRIGGER=2
+CONFIG_IIO_INTERRUPT_TRIGGER=y
+CONFIG_IIO_SYSFS_TRIGGER=y
+CONFIG_PWM=y
+CONFIG_IRQCHIP=y
+# CONFIG_IPACK_BUS is not set
+# CONFIG_RESET_CONTROLLER is not set
+# CONFIG_FMC is not set
+
+#
+# PHY Subsystem
+#
+# CONFIG_GENERIC_PHY is not set
+# CONFIG_PHY_PXA_28NM_HSIC is not set
+# CONFIG_PHY_PXA_28NM_USB2 is not set
+# CONFIG_BCM_KONA_USB2_PHY is not set
+# CONFIG_POWERCAP is not set
+# CONFIG_MCB is not set
+
+#
+# Performance monitor support
+#
+# CONFIG_RAS is not set
+
+#
+# Android
+#
+CONFIG_ANDROID=y
+# CONFIG_ANDROID_BINDER_IPC is not set
+# CONFIG_NVMEM is not set
+# CONFIG_STM is not set
+# CONFIG_STM_DUMMY is not set
+# CONFIG_STM_SOURCE_CONSOLE is not set
+# CONFIG_INTEL_TH is not set
+
+#
+# FPGA Configuration Support
+#
+# CONFIG_FPGA is not set
+
+#
+# Firmware Drivers
+#
+# CONFIG_FIRMWARE_MEMMAP is not set
+
+#
+# File systems
+#
+# CONFIG_EXT2_FS is not set
+# CONFIG_EXT3_FS is not set
+# CONFIG_EXT4_FS is not set
+# CONFIG_REISERFS_FS is not set
+# CONFIG_JFS_FS is not set
+# CONFIG_BTRFS_FS is not set
+# CONFIG_NILFS2_FS is not set
+# CONFIG_F2FS_FS is not set
+CONFIG_FS_POSIX_ACL=y
+CONFIG_FILE_LOCKING=y
+CONFIG_FSNOTIFY=y
+CONFIG_DNOTIFY=y
+CONFIG_INOTIFY_USER=y
+# CONFIG_FANOTIFY is not set
+# CONFIG_QUOTA is not set
+# CONFIG_QUOTACTL is not set
+# CONFIG_AUTOFS4_FS is not set
+# CONFIG_FUSE_FS is not set
+# CONFIG_OVERLAY_FS is not set
+
+#
+# Caches
+#
+# CONFIG_FSCACHE is not set
+
+#
+# CD-ROM/DVD Filesystems
+#
+# CONFIG_ISO9660_FS is not set
+# CONFIG_UDF_FS is not set
+
+#
+# DOS/FAT/NT Filesystems
+#
+CONFIG_FAT_FS=y
+CONFIG_MSDOS_FS=y
+CONFIG_VFAT_FS=y
+CONFIG_FAT_DEFAULT_CODEPAGE=437
+CONFIG_FAT_DEFAULT_IOCHARSET="iso8859-1"
+# CONFIG_NTFS_FS is not set
+
+#
+# Pseudo filesystems
+#
+CONFIG_PROC_FS=y
+CONFIG_PROC_SYSCTL=y
+CONFIG_PROC_PAGE_MONITOR=y
+# CONFIG_PROC_CHILDREN is not set
+CONFIG_KERNFS=y
+CONFIG_SYSFS=y
+CONFIG_TMPFS=y
+CONFIG_TMPFS_POSIX_ACL=y
+CONFIG_TMPFS_XATTR=y
+# CONFIG_HUGETLB_PAGE is not set
+CONFIG_CONFIGFS_FS=m
+CONFIG_MISC_FILESYSTEMS=y
+# CONFIG_ADFS_FS is not set
+# CONFIG_AFFS_FS is not set
+# CONFIG_HFS_FS is not set
+# CONFIG_HFSPLUS_FS is not set
+# CONFIG_BEFS_FS is not set
+# CONFIG_BFS_FS is not set
+# CONFIG_EFS_FS is not set
+CONFIG_JFFS2_FS=y
+CONFIG_JFFS2_FS_DEBUG=0
+# CONFIG_JFFS2_FS_WRITEBUFFER is not set
+# CONFIG_JFFS2_SUMMARY is not set
+# CONFIG_JFFS2_FS_XATTR is not set
+CONFIG_JFFS2_COMPRESSION_OPTIONS=y
+CONFIG_JFFS2_ZLIB=y
+# CONFIG_JFFS2_LZO is not set
+# CONFIG_JFFS2_RTIME is not set
+# CONFIG_JFFS2_RUBIN is not set
+CONFIG_JFFS2_CMODE_NONE=y
+# CONFIG_JFFS2_CMODE_PRIORITY is not set
+# CONFIG_JFFS2_CMODE_SIZE is not set
+# CONFIG_JFFS2_CMODE_FAVOURLZO is not set
+# CONFIG_LOGFS is not set
+# CONFIG_CRAMFS is not set
+CONFIG_SQUASHFS=y
+# CONFIG_SQUASHFS_FILE_CACHE is not set
+CONFIG_SQUASHFS_FILE_DIRECT=y
+# CONFIG_SQUASHFS_DECOMP_SINGLE is not set
+CONFIG_SQUASHFS_DECOMP_MULTI=y
+# CONFIG_SQUASHFS_DECOMP_MULTI_PERCPU is not set
+# CONFIG_SQUASHFS_XATTR is not set
+CONFIG_SQUASHFS_ZLIB=y
+# CONFIG_SQUASHFS_LZ4 is not set
+# CONFIG_SQUASHFS_LZO is not set
+CONFIG_SQUASHFS_XZ=y
+# CONFIG_SQUASHFS_4K_DEVBLK_SIZE is not set
+# CONFIG_SQUASHFS_EMBEDDED is not set
+CONFIG_SQUASHFS_FRAGMENT_CACHE_SIZE=3
+# CONFIG_VXFS_FS is not set
+# CONFIG_MINIX_FS is not set
+# CONFIG_OMFS_FS is not set
+# CONFIG_HPFS_FS is not set
+# CONFIG_QNX4FS_FS is not set
+# CONFIG_QNX6FS_FS is not set
+# CONFIG_ROMFS_FS is not set
+# CONFIG_PSTORE is not set
+# CONFIG_SYSV_FS is not set
+# CONFIG_UFS_FS is not set
+CONFIG_NETWORK_FILESYSTEMS=y
+CONFIG_NFS_FS=m
+CONFIG_NFS_V2=m
+CONFIG_NFS_V3=m
+# CONFIG_NFS_V3_ACL is not set
+# CONFIG_NFS_V4 is not set
+# CONFIG_NFS_SWAP is not set
+# CONFIG_NFSD is not set
+
+CONFIG_YAFFS_FS=y
+CONFIG_YAFFS_YAFFS1=y
+# CONFIG_YAFFS_9BYTE_TAGS is not set
+# CONFIG_YAFFS_DOES_ECC is not set
+CONFIG_YAFFS_YAFFS2=y
+CONFIG_YAFFS_AUTO_YAFFS2=y
+# CONFIG_YAFFS_DISABLE_TAGS_ECC is not set
+# CONFIG_YAFFS_ALWAYS_CHECK_CHUNK_ERASED is not set
+# CONFIG_YAFFS_EMPTY_LOST_AND_FOUND is not set
+# CONFIG_YAFFS_DISABLE_BLOCK_REFRESHING is not set
+# CONFIG_YAFFS_DISABLE_BACKGROUND is not set
+# CONFIG_YAFFS_DISABLE_BAD_BLOCK_MARKING is not set
+CONFIG_YAFFS_XATTR=y
+
+
+CONFIG_GRACE_PERIOD=m
+CONFIG_LOCKD=m
+CONFIG_LOCKD_V4=y
+CONFIG_NFS_COMMON=y
+CONFIG_SUNRPC=m
+# CONFIG_SUNRPC_DEBUG is not set
+# CONFIG_CEPH_FS is not set
+# CONFIG_CIFS is not set
+# CONFIG_NCP_FS is not set
+# CONFIG_CODA_FS is not set
+# CONFIG_AFS_FS is not set
+CONFIG_NLS=y
+CONFIG_NLS_DEFAULT="iso8859-1"
+CONFIG_NLS_CODEPAGE_437=y
+# CONFIG_NLS_CODEPAGE_737 is not set
+# CONFIG_NLS_CODEPAGE_775 is not set
+# CONFIG_NLS_CODEPAGE_850 is not set
+# CONFIG_NLS_CODEPAGE_852 is not set
+# CONFIG_NLS_CODEPAGE_855 is not set
+# CONFIG_NLS_CODEPAGE_857 is not set
+# CONFIG_NLS_CODEPAGE_860 is not set
+# CONFIG_NLS_CODEPAGE_861 is not set
+# CONFIG_NLS_CODEPAGE_862 is not set
+# CONFIG_NLS_CODEPAGE_863 is not set
+# CONFIG_NLS_CODEPAGE_864 is not set
+# CONFIG_NLS_CODEPAGE_865 is not set
+# CONFIG_NLS_CODEPAGE_866 is not set
+# CONFIG_NLS_CODEPAGE_869 is not set
+# CONFIG_NLS_CODEPAGE_936 is not set
+# CONFIG_NLS_CODEPAGE_950 is not set
+# CONFIG_NLS_CODEPAGE_932 is not set
+# CONFIG_NLS_CODEPAGE_949 is not set
+# CONFIG_NLS_CODEPAGE_874 is not set
+# CONFIG_NLS_ISO8859_8 is not set
+# CONFIG_NLS_CODEPAGE_1250 is not set
+# CONFIG_NLS_CODEPAGE_1251 is not set
+# CONFIG_NLS_ASCII is not set
+CONFIG_NLS_ISO8859_1=y
+# CONFIG_NLS_ISO8859_2 is not set
+# CONFIG_NLS_ISO8859_3 is not set
+# CONFIG_NLS_ISO8859_4 is not set
+# CONFIG_NLS_ISO8859_5 is not set
+# CONFIG_NLS_ISO8859_6 is not set
+# CONFIG_NLS_ISO8859_7 is not set
+# CONFIG_NLS_ISO8859_9 is not set
+# CONFIG_NLS_ISO8859_13 is not set
+# CONFIG_NLS_ISO8859_14 is not set
+# CONFIG_NLS_ISO8859_15 is not set
+# CONFIG_NLS_KOI8_R is not set
+# CONFIG_NLS_KOI8_U is not set
+# CONFIG_NLS_MAC_ROMAN is not set
+# CONFIG_NLS_MAC_CELTIC is not set
+# CONFIG_NLS_MAC_CENTEURO is not set
+# CONFIG_NLS_MAC_CROATIAN is not set
+# CONFIG_NLS_MAC_CYRILLIC is not set
+# CONFIG_NLS_MAC_GAELIC is not set
+# CONFIG_NLS_MAC_GREEK is not set
+# CONFIG_NLS_MAC_ICELAND is not set
+# CONFIG_NLS_MAC_INUIT is not set
+# CONFIG_NLS_MAC_ROMANIAN is not set
+# CONFIG_NLS_MAC_TURKISH is not set
+# CONFIG_NLS_UTF8 is not set
+
+#
+# Kernel hacking
+#
+
+#
+# printk and dmesg options
+#
+CONFIG_PRINTK_TIME=y
+CONFIG_MESSAGE_LOGLEVEL_DEFAULT=4
+# CONFIG_BOOT_PRINTK_DELAY is not set
+CONFIG_DYNAMIC_DEBUG=y
+
+#
+# Compile-time checks and compiler options
+#
+# CONFIG_DEBUG_INFO is not set
+# CONFIG_ENABLE_WARN_DEPRECATED is not set
+# CONFIG_ENABLE_MUST_CHECK is not set
+CONFIG_FRAME_WARN=4096
+# CONFIG_STRIP_ASM_SYMS is not set
+# CONFIG_READABLE_ASM is not set
+# CONFIG_UNUSED_SYMBOLS is not set
+# CONFIG_PAGE_OWNER is not set
+CONFIG_DEBUG_FS=y
+# CONFIG_HEADERS_CHECK is not set
+# CONFIG_DEBUG_SECTION_MISMATCH is not set
+# CONFIG_SECTION_MISMATCH_WARN_ONLY is not set
+CONFIG_FRAME_POINTER=y
+# CONFIG_DEBUG_FORCE_WEAK_PER_CPU is not set
+# CONFIG_MAGIC_SYSRQ is not set
+CONFIG_DEBUG_KERNEL=y
+
+#
+# Memory Debugging
+#
+# CONFIG_PAGE_EXTENSION is not set
+# CONFIG_DEBUG_PAGEALLOC is not set
+# CONFIG_DEBUG_OBJECTS is not set
+# CONFIG_SLUB_STATS is not set
+CONFIG_HAVE_DEBUG_KMEMLEAK=y
+# CONFIG_DEBUG_KMEMLEAK is not set
+# CONFIG_DEBUG_STACK_USAGE is not set
+# CONFIG_DEBUG_VM is not set
+# CONFIG_DEBUG_MEMORY_INIT is not set
+# CONFIG_DEBUG_SHIRQ is not set
+
+#
+# Debug Lockups and Hangs
+#
+# CONFIG_LOCKUP_DETECTOR is not set
+# CONFIG_DETECT_HUNG_TASK is not set
+# CONFIG_PANIC_ON_OOPS is not set
+CONFIG_PANIC_ON_OOPS_VALUE=0
+CONFIG_PANIC_TIMEOUT=0
+# CONFIG_SCHED_DEBUG is not set
+# CONFIG_SCHED_INFO is not set
+# CONFIG_SCHEDSTATS is not set
+# CONFIG_SCHED_STACK_END_CHECK is not set
+# CONFIG_DEBUG_TIMEKEEPING is not set
+# CONFIG_TIMER_STATS is not set
+CONFIG_DEBUG_PREEMPT=y
+
+#
+# Lock Debugging (spinlocks, mutexes, etc...)
+#
+# CONFIG_DEBUG_RT_MUTEXES is not set
+# CONFIG_DEBUG_SPINLOCK is not set
+# CONFIG_DEBUG_MUTEXES is not set
+# CONFIG_DEBUG_WW_MUTEX_SLOWPATH is not set
+# CONFIG_DEBUG_LOCK_ALLOC is not set
+# CONFIG_PROVE_LOCKING is not set
+# CONFIG_LOCK_STAT is not set
+# CONFIG_DEBUG_ATOMIC_SLEEP is not set
+# CONFIG_DEBUG_LOCKING_API_SELFTESTS is not set
+# CONFIG_LOCK_TORTURE_TEST is not set
+CONFIG_STACKTRACE=y
+# CONFIG_DEBUG_KOBJECT is not set
+CONFIG_DEBUG_BUGVERBOSE=y
+# CONFIG_DEBUG_LIST is not set
+# CONFIG_DEBUG_PI_LIST is not set
+# CONFIG_DEBUG_SG is not set
+# CONFIG_DEBUG_NOTIFIERS is not set
+# CONFIG_DEBUG_CREDENTIALS is not set
+
+#
+# RCU Debugging
+#
+# CONFIG_PROVE_RCU is not set
+# CONFIG_SPARSE_RCU_POINTER is not set
+# CONFIG_TORTURE_TEST is not set
+# CONFIG_RCU_TORTURE_TEST is not set
+CONFIG_RCU_CPU_STALL_TIMEOUT=21
+# CONFIG_RCU_TRACE is not set
+# CONFIG_RCU_EQS_DEBUG is not set
+# CONFIG_DEBUG_BLOCK_EXT_DEVT is not set
+# CONFIG_NOTIFIER_ERROR_INJECTION is not set
+# CONFIG_FAULT_INJECTION is not set
+# CONFIG_LATENCYTOP is not set
+CONFIG_NOP_TRACER=y
+CONFIG_HAVE_FUNCTION_TRACER=y
+CONFIG_HAVE_FUNCTION_GRAPH_TRACER=y
+CONFIG_HAVE_DYNAMIC_FTRACE=y
+CONFIG_HAVE_FTRACE_MCOUNT_RECORD=y
+CONFIG_HAVE_SYSCALL_TRACEPOINTS=y
+CONFIG_HAVE_C_RECORDMCOUNT=y
+CONFIG_TRACE_CLOCK=y
+CONFIG_RING_BUFFER=y
+CONFIG_EVENT_TRACING=y
+CONFIG_CONTEXT_SWITCH_TRACER=y
+CONFIG_TRACING=y
+CONFIG_GENERIC_TRACER=y
+CONFIG_TRACING_SUPPORT=y
+CONFIG_FTRACE=y
+CONFIG_FUNCTION_TRACER=y
+CONFIG_FUNCTION_GRAPH_TRACER=y
+# CONFIG_IRQSOFF_TRACER is not set
+# CONFIG_PREEMPT_TRACER is not set
+# CONFIG_SCHED_TRACER is not set
+# CONFIG_FTRACE_SYSCALLS is not set
+# CONFIG_TRACER_SNAPSHOT is not set
+CONFIG_BRANCH_PROFILE_NONE=y
+# CONFIG_PROFILE_ANNOTATED_BRANCHES is not set
+# CONFIG_PROFILE_ALL_BRANCHES is not set
+# CONFIG_STACK_TRACER is not set
+CONFIG_BLK_DEV_IO_TRACE=y
+# CONFIG_PROBE_EVENTS is not set
+CONFIG_DYNAMIC_FTRACE=y
+CONFIG_FUNCTION_PROFILER=y
+CONFIG_FTRACE_MCOUNT_RECORD=y
+# CONFIG_FTRACE_STARTUP_TEST is not set
+# CONFIG_TRACEPOINT_BENCHMARK is not set
+# CONFIG_RING_BUFFER_BENCHMARK is not set
+# CONFIG_RING_BUFFER_STARTUP_TEST is not set
+# CONFIG_TRACE_ENUM_MAP_FILE is not set
+CONFIG_TRACING_EVENTS_GPIO=y
+
+#
+# Runtime Testing
+#
+# CONFIG_LKDTM is not set
+# CONFIG_TEST_LIST_SORT is not set
+# CONFIG_BACKTRACE_SELF_TEST is not set
+# CONFIG_RBTREE_TEST is not set
+# CONFIG_INTERVAL_TREE_TEST is not set
+# CONFIG_PERCPU_TEST is not set
+# CONFIG_ATOMIC64_SELFTEST is not set
+# CONFIG_TEST_HEXDUMP is not set
+# CONFIG_TEST_STRING_HELPERS is not set
+# CONFIG_TEST_KSTRTOX is not set
+# CONFIG_TEST_PRINTF is not set
+# CONFIG_TEST_RHASHTABLE is not set
+# CONFIG_DMA_API_DEBUG is not set
+# CONFIG_TEST_LKM is not set
+# CONFIG_TEST_USER_COPY is not set
+# CONFIG_TEST_BPF is not set
+# CONFIG_TEST_UDELAY is not set
+# CONFIG_MEMTEST is not set
+# CONFIG_TEST_STATIC_KEYS is not set
+# CONFIG_SAMPLES is not set
+CONFIG_HAVE_ARCH_KGDB=y
+# CONFIG_KGDB is not set
+# CONFIG_ARM_PTDUMP is not set
+CONFIG_STRICT_DEVMEM=y
+# CONFIG_ARM_UNWIND is not set
+CONFIG_OLD_MCOUNT=y
+# CONFIG_DEBUG_USER is not set
+# CONFIG_DEBUG_LL is not set
+CONFIG_DEBUG_LL_INCLUDE="mach/debug-macro.S"
+# CONFIG_DEBUG_UART_8250 is not set
+CONFIG_UNCOMPRESS_INCLUDE="mach/uncompress.h"
+# CONFIG_DEBUG_SET_MODULE_RONX is not set
+# CONFIG_CORESIGHT is not set
+
+#
+# Security options
+#
+# CONFIG_KEYS is not set
+# CONFIG_SECURITY_DMESG_RESTRICT is not set
+# CONFIG_SECURITY is not set
+# CONFIG_SECURITYFS is not set
+CONFIG_DEFAULT_SECURITY_DAC=y
+CONFIG_DEFAULT_SECURITY=""
+CONFIG_CRYPTO=y
+
+#
+# Crypto core or helper
+#
+CONFIG_CRYPTO_ALGAPI=y
+CONFIG_CRYPTO_ALGAPI2=y
+CONFIG_CRYPTO_AEAD=y
+CONFIG_CRYPTO_AEAD2=y
+CONFIG_CRYPTO_BLKCIPHER=y
+CONFIG_CRYPTO_BLKCIPHER2=y
+CONFIG_CRYPTO_HASH=y
+CONFIG_CRYPTO_HASH2=y
+CONFIG_CRYPTO_RNG=y
+CONFIG_CRYPTO_RNG2=y
+CONFIG_CRYPTO_RNG_DEFAULT=y
+CONFIG_CRYPTO_PCOMP2=y
+CONFIG_CRYPTO_AKCIPHER2=y
+# CONFIG_CRYPTO_RSA is not set
+CONFIG_CRYPTO_MANAGER=y
+CONFIG_CRYPTO_MANAGER2=y
+# CONFIG_CRYPTO_USER is not set
+CONFIG_CRYPTO_MANAGER_DISABLE_TESTS=y
+CONFIG_CRYPTO_GF128MUL=y
+CONFIG_CRYPTO_NULL=y
+CONFIG_CRYPTO_NULL2=y
+CONFIG_CRYPTO_WORKQUEUE=y
+# CONFIG_CRYPTO_CRYPTD is not set
+# CONFIG_CRYPTO_MCRYPTD is not set
+# CONFIG_CRYPTO_AUTHENC is not set
+# CONFIG_CRYPTO_TEST is not set
+
+#
+# Authenticated Encryption with Associated Data
+#
+CONFIG_CRYPTO_CCM=y
+CONFIG_CRYPTO_GCM=y
+# CONFIG_CRYPTO_CHACHA20POLY1305 is not set
+CONFIG_CRYPTO_SEQIV=y
+# CONFIG_CRYPTO_ECHAINIV is not set
+
+#
+# Block modes
+#
+# CONFIG_CRYPTO_CBC is not set
+CONFIG_CRYPTO_CTR=y
+# CONFIG_CRYPTO_CTS is not set
+# CONFIG_CRYPTO_ECB is not set
+# CONFIG_CRYPTO_LRW is not set
+# CONFIG_CRYPTO_PCBC is not set
+# CONFIG_CRYPTO_XTS is not set
+# CONFIG_CRYPTO_KEYWRAP is not set
+
+#
+# Hash modes
+#
+# CONFIG_CRYPTO_CMAC is not set
+CONFIG_CRYPTO_HMAC=y
+# CONFIG_CRYPTO_XCBC is not set
+# CONFIG_CRYPTO_VMAC is not set
+
+#
+# Digest
+#
+CONFIG_CRYPTO_CRC32C=y
+# CONFIG_CRYPTO_CRC32 is not set
+# CONFIG_CRYPTO_CRCT10DIF is not set
+CONFIG_CRYPTO_GHASH=y
+# CONFIG_CRYPTO_POLY1305 is not set
+# CONFIG_CRYPTO_MD4 is not set
+CONFIG_CRYPTO_MD5=y
+# CONFIG_CRYPTO_MICHAEL_MIC is not set
+# CONFIG_CRYPTO_RMD128 is not set
+# CONFIG_CRYPTO_RMD160 is not set
+# CONFIG_CRYPTO_RMD256 is not set
+# CONFIG_CRYPTO_RMD320 is not set
+CONFIG_CRYPTO_SHA1=y
+CONFIG_CRYPTO_SHA256=y
+# CONFIG_CRYPTO_SHA512 is not set
+# CONFIG_CRYPTO_TGR192 is not set
+# CONFIG_CRYPTO_WP512 is not set
+
+#
+# Ciphers
+#
+CONFIG_CRYPTO_AES=y
+# CONFIG_CRYPTO_ANUBIS is not set
+CONFIG_CRYPTO_ARC4=y
+# CONFIG_CRYPTO_BLOWFISH is not set
+# CONFIG_CRYPTO_CAMELLIA is not set
+# CONFIG_CRYPTO_CAST5 is not set
+# CONFIG_CRYPTO_CAST6 is not set
+# CONFIG_CRYPTO_DES is not set
+# CONFIG_CRYPTO_FCRYPT is not set
+# CONFIG_CRYPTO_KHAZAD is not set
+# CONFIG_CRYPTO_SALSA20 is not set
+# CONFIG_CRYPTO_CHACHA20 is not set
+# CONFIG_CRYPTO_SEED is not set
+# CONFIG_CRYPTO_SERPENT is not set
+# CONFIG_CRYPTO_TEA is not set
+# CONFIG_CRYPTO_TWOFISH is not set
+
+#
+# Compression
+#
+# CONFIG_CRYPTO_DEFLATE is not set
+# CONFIG_CRYPTO_ZLIB is not set
+# CONFIG_CRYPTO_LZO is not set
+# CONFIG_CRYPTO_842 is not set
+# CONFIG_CRYPTO_LZ4 is not set
+# CONFIG_CRYPTO_LZ4HC is not set
+
+#
+# Random Number Generation
+#
+# CONFIG_CRYPTO_ANSI_CPRNG is not set
+CONFIG_CRYPTO_DRBG_MENU=y
+CONFIG_CRYPTO_DRBG_HMAC=y
+# CONFIG_CRYPTO_DRBG_HASH is not set
+# CONFIG_CRYPTO_DRBG_CTR is not set
+CONFIG_CRYPTO_DRBG=y
+CONFIG_CRYPTO_JITTERENTROPY=y
+# CONFIG_CRYPTO_USER_API_HASH is not set
+# CONFIG_CRYPTO_USER_API_SKCIPHER is not set
+# CONFIG_CRYPTO_USER_API_RNG is not set
+# CONFIG_CRYPTO_USER_API_AEAD is not set
+# CONFIG_CRYPTO_HW is not set
+
+#
+# Certificates for signature checking
+#
+# CONFIG_ARM_CRYPTO is not set
+CONFIG_BINARY_PRINTF=y
+
+#
+# Library routines
+#
+CONFIG_BITREVERSE=y
+# CONFIG_HAVE_ARCH_BITREVERSE is not set
+CONFIG_RATIONAL=y
+CONFIG_GENERIC_STRNCPY_FROM_USER=y
+CONFIG_GENERIC_STRNLEN_USER=y
+CONFIG_GENERIC_NET_UTILS=y
+CONFIG_GENERIC_PCI_IOMAP=y
+CONFIG_GENERIC_IO=y
+CONFIG_ARCH_USE_CMPXCHG_LOCKREF=y
+# CONFIG_CRC_CCITT is not set
+# CONFIG_CRC16 is not set
+# CONFIG_CRC_T10DIF is not set
+# CONFIG_CRC_ITU_T is not set
+CONFIG_CRC32=y
+# CONFIG_CRC32_SELFTEST is not set
+CONFIG_CRC32_SLICEBY8=y
+# CONFIG_CRC32_SLICEBY4 is not set
+# CONFIG_CRC32_SARWATE is not set
+# CONFIG_CRC32_BIT is not set
+# CONFIG_CRC7 is not set
+CONFIG_LIBCRC32C=y
+# CONFIG_CRC8 is not set
+# CONFIG_AUDIT_ARCH_COMPAT_GENERIC is not set
+# CONFIG_RANDOM32_SELFTEST is not set
+CONFIG_ZLIB_INFLATE=y
+CONFIG_ZLIB_DEFLATE=y
+CONFIG_XZ_DEC=y
+# CONFIG_XZ_DEC_X86 is not set
+# CONFIG_XZ_DEC_POWERPC is not set
+# CONFIG_XZ_DEC_IA64 is not set
+CONFIG_XZ_DEC_ARM=y
+CONFIG_XZ_DEC_ARMTHUMB=y
+# CONFIG_XZ_DEC_SPARC is not set
+CONFIG_XZ_DEC_BCJ=y
+# CONFIG_XZ_DEC_TEST is not set
+CONFIG_GENERIC_ALLOCATOR=y
+CONFIG_HAS_IOMEM=y
+CONFIG_HAS_IOPORT_MAP=y
+CONFIG_HAS_DMA=y
+CONFIG_DQL=y
+CONFIG_NLATTR=y
+CONFIG_GENERIC_ATOMIC64=y
+CONFIG_ARCH_HAS_ATOMIC64_DEC_IF_POSITIVE=y
+# CONFIG_CORDIC is not set
+# CONFIG_DDR is not set
+CONFIG_LIBFDT=y
+# CONFIG_SG_SPLIT is not set
+# CONFIG_ARCH_HAS_SG_CHAIN is not set
+# CONFIG_VIRTUALIZATION is not set
diff --git a/arch/arm/configs/anycloudv500_defconfig b/arch/arm/configs/anycloudv500_defconfig
new file mode 100755
index 0000000..7a8bf82
--- /dev/null
+++ b/arch/arm/configs/anycloudv500_defconfig
@@ -0,0 +1,1972 @@
+#
+# Automatically generated file; DO NOT EDIT.
+# Linux/arm 4.4.162 Kernel Configuration
+#
+CONFIG_ARM=y
+CONFIG_SYS_SUPPORTS_APM_EMULATION=y
+CONFIG_HAVE_PROC_CPU=y
+CONFIG_STACKTRACE_SUPPORT=y
+CONFIG_HAVE_LATENCYTOP_SUPPORT=y
+CONFIG_LOCKDEP_SUPPORT=y
+CONFIG_TRACE_IRQFLAGS_SUPPORT=y
+CONFIG_RWSEM_XCHGADD_ALGORITHM=y
+CONFIG_FIX_EARLYCON_MEM=y
+CONFIG_GENERIC_HWEIGHT=y
+CONFIG_GENERIC_CALIBRATE_DELAY=y
+CONFIG_NEED_DMA_MAP_STATE=y
+CONFIG_ARCH_SUPPORTS_UPROBES=y
+CONFIG_VECTORS_BASE=0xffff0000
+# CONFIG_ARM_PATCH_PHYS_VIRT is not set
+CONFIG_PHYS_OFFSET=0x80000000
+CONFIG_GENERIC_BUG=y
+CONFIG_PGTABLE_LEVELS=2
+CONFIG_DEFCONFIG_LIST="/lib/modules/$UNAME_RELEASE/.config"
+CONFIG_IRQ_WORK=y
+CONFIG_BUILDTIME_EXTABLE_SORT=y
+
+#
+# General setup
+#
+CONFIG_BROKEN_ON_SMP=y
+CONFIG_INIT_ENV_ARG_LIMIT=32
+CONFIG_CROSS_COMPILE=""
+# CONFIG_COMPILE_TEST is not set
+CONFIG_LOCALVERSION="V1.5"
+# CONFIG_LOCALVERSION_AUTO is not set
+CONFIG_HAVE_KERNEL_GZIP=y
+CONFIG_HAVE_KERNEL_LZMA=y
+CONFIG_HAVE_KERNEL_XZ=y
+CONFIG_HAVE_KERNEL_LZO=y
+CONFIG_HAVE_KERNEL_LZ4=y
+# CONFIG_KERNEL_GZIP is not set
+# CONFIG_KERNEL_LZMA is not set
+CONFIG_KERNEL_XZ=y
+# CONFIG_KERNEL_LZO is not set
+# CONFIG_KERNEL_LZ4 is not set
+CONFIG_DEFAULT_HOSTNAME="(none)"
+# CONFIG_SWAP is not set
+CONFIG_SYSVIPC=y
+CONFIG_SYSVIPC_SYSCTL=y
+# CONFIG_POSIX_MQUEUE is not set
+# CONFIG_CROSS_MEMORY_ATTACH is not set
+# CONFIG_FHANDLE is not set
+# CONFIG_USELIB is not set
+# CONFIG_AUDIT is not set
+CONFIG_HAVE_ARCH_AUDITSYSCALL=y
+
+#
+# IRQ subsystem
+#
+CONFIG_GENERIC_IRQ_PROBE=y
+CONFIG_GENERIC_IRQ_SHOW=y
+CONFIG_GENERIC_IRQ_SHOW_LEVEL=y
+CONFIG_HARDIRQS_SW_RESEND=y
+CONFIG_IRQ_DOMAIN=y
+CONFIG_HANDLE_DOMAIN_IRQ=y
+# CONFIG_IRQ_DOMAIN_DEBUG is not set
+CONFIG_IRQ_FORCED_THREADING=y
+CONFIG_GENERIC_CLOCKEVENTS=y
+
+#
+# Timers subsystem
+#
+CONFIG_TICK_ONESHOT=y
+CONFIG_NO_HZ_COMMON=y
+# CONFIG_HZ_PERIODIC is not set
+CONFIG_NO_HZ_IDLE=y
+CONFIG_NO_HZ=y
+CONFIG_HIGH_RES_TIMERS=y
+
+#
+# CPU/Task time and stats accounting
+#
+CONFIG_TICK_CPU_ACCOUNTING=y
+# CONFIG_VIRT_CPU_ACCOUNTING_GEN is not set
+# CONFIG_IRQ_TIME_ACCOUNTING is not set
+
+#
+# RCU Subsystem
+#
+CONFIG_TINY_RCU=y
+# CONFIG_RCU_EXPERT is not set
+CONFIG_SRCU=y
+# CONFIG_TASKS_RCU is not set
+# CONFIG_RCU_STALL_COMMON is not set
+# CONFIG_TREE_RCU_TRACE is not set
+# CONFIG_RCU_EXPEDITE_BOOT is not set
+# CONFIG_BUILD_BIN2C is not set
+# CONFIG_IKCONFIG is not set
+CONFIG_LOG_BUF_SHIFT=17
+CONFIG_GENERIC_SCHED_CLOCK=y
+# CONFIG_CGROUPS is not set
+# CONFIG_CHECKPOINT_RESTORE is not set
+# CONFIG_SCHED_AUTOGROUP is not set
+# CONFIG_SYSFS_DEPRECATED is not set
+CONFIG_RELAY=y
+# CONFIG_BLK_DEV_INITRD is not set
+CONFIG_CC_OPTIMIZE_FOR_PERFORMANCE=y
+# CONFIG_CC_OPTIMIZE_FOR_SIZE is not set
+CONFIG_SYSCTL=y
+CONFIG_ANON_INODES=y
+CONFIG_HAVE_UID16=y
+CONFIG_BPF=y
+CONFIG_EXPERT=y
+CONFIG_UID16=y
+CONFIG_MULTIUSER=y
+# CONFIG_SGETMASK_SYSCALL is not set
+# CONFIG_SYSFS_SYSCALL is not set
+# CONFIG_SYSCTL_SYSCALL is not set
+CONFIG_KALLSYMS=y
+# CONFIG_KALLSYMS_ALL is not set
+CONFIG_PRINTK=y
+CONFIG_BUG=y
+CONFIG_ELF_CORE=y
+CONFIG_BASE_FULL=y
+CONFIG_FUTEX=y
+CONFIG_EPOLL=y
+CONFIG_SIGNALFD=y
+CONFIG_TIMERFD=y
+CONFIG_EVENTFD=y
+# CONFIG_BPF_SYSCALL is not set
+CONFIG_SHMEM=y
+CONFIG_AIO=y
+CONFIG_ADVISE_SYSCALLS=y
+# CONFIG_USERFAULTFD is not set
+# CONFIG_MEMBARRIER is not set
+CONFIG_EMBEDDED=y
+CONFIG_HAVE_PERF_EVENTS=y
+CONFIG_PERF_USE_VMALLOC=y
+
+#
+# Kernel Performance Events And Counters
+#
+# CONFIG_PERF_EVENTS is not set
+# CONFIG_VM_EVENT_COUNTERS is not set
+# CONFIG_SLUB_DEBUG is not set
+# CONFIG_COMPAT_BRK is not set
+# CONFIG_SLAB is not set
+CONFIG_SLUB=y
+# CONFIG_SLOB is not set
+# CONFIG_SYSTEM_DATA_VERIFICATION is not set
+# CONFIG_PROFILING is not set
+CONFIG_HAVE_OPROFILE=y
+# CONFIG_KPROBES is not set
+CONFIG_JUMP_LABEL=y
+# CONFIG_STATIC_KEYS_SELFTEST is not set
+# CONFIG_UPROBES is not set
+# CONFIG_HAVE_64BIT_ALIGNED_ACCESS is not set
+CONFIG_ARCH_USE_BUILTIN_BSWAP=y
+CONFIG_HAVE_KPROBES=y
+CONFIG_HAVE_KRETPROBES=y
+CONFIG_HAVE_OPTPROBES=y
+CONFIG_HAVE_ARCH_TRACEHOOK=y
+CONFIG_HAVE_DMA_ATTRS=y
+CONFIG_HAVE_DMA_CONTIGUOUS=y
+CONFIG_GENERIC_SMP_IDLE_THREAD=y
+CONFIG_GENERIC_IDLE_POLL_SETUP=y
+CONFIG_HAVE_REGS_AND_STACK_ACCESS_API=y
+CONFIG_HAVE_CLK=y
+CONFIG_HAVE_DMA_API_DEBUG=y
+CONFIG_HAVE_PERF_REGS=y
+CONFIG_HAVE_PERF_USER_STACK_DUMP=y
+CONFIG_HAVE_ARCH_JUMP_LABEL=y
+CONFIG_ARCH_WANT_IPC_PARSE_VERSION=y
+CONFIG_HAVE_ARCH_SECCOMP_FILTER=y
+CONFIG_HAVE_CC_STACKPROTECTOR=y
+# CONFIG_CC_STACKPROTECTOR is not set
+CONFIG_CC_STACKPROTECTOR_NONE=y
+# CONFIG_CC_STACKPROTECTOR_REGULAR is not set
+# CONFIG_CC_STACKPROTECTOR_STRONG is not set
+CONFIG_HAVE_CONTEXT_TRACKING=y
+CONFIG_HAVE_VIRT_CPU_ACCOUNTING_GEN=y
+CONFIG_HAVE_IRQ_TIME_ACCOUNTING=y
+CONFIG_HAVE_MOD_ARCH_SPECIFIC=y
+CONFIG_MODULES_USE_ELF_REL=y
+CONFIG_ARCH_HAS_ELF_RANDOMIZE=y
+CONFIG_CLONE_BACKWARDS=y
+CONFIG_OLD_SIGSUSPEND3=y
+CONFIG_OLD_SIGACTION=y
+
+#
+# GCOV-based kernel profiling
+#
+# CONFIG_GCOV_KERNEL is not set
+CONFIG_ARCH_HAS_GCOV_PROFILE_ALL=y
+CONFIG_HAVE_GENERIC_DMA_COHERENT=y
+CONFIG_RT_MUTEXES=y
+CONFIG_BASE_SMALL=0
+CONFIG_MODULES=y
+# CONFIG_MODULE_FORCE_LOAD is not set
+CONFIG_MODULE_UNLOAD=y
+# CONFIG_MODULE_FORCE_UNLOAD is not set
+# CONFIG_MODVERSIONS is not set
+# CONFIG_MODULE_SRCVERSION_ALL is not set
+# CONFIG_MODULE_SIG is not set
+# CONFIG_MODULE_COMPRESS is not set
+CONFIG_BLOCK=y
+# CONFIG_LBDAF is not set
+# CONFIG_BLK_DEV_BSG is not set
+# CONFIG_BLK_DEV_BSGLIB is not set
+# CONFIG_BLK_DEV_INTEGRITY is not set
+# CONFIG_BLK_CMDLINE_PARSER is not set
+
+#
+# Partition Types
+#
+# CONFIG_PARTITION_ADVANCED is not set
+CONFIG_MSDOS_PARTITION=y
+CONFIG_EFI_PARTITION=y
+
+#
+# IO Schedulers
+#
+CONFIG_IOSCHED_NOOP=y
+# CONFIG_IOSCHED_DEADLINE is not set
+# CONFIG_IOSCHED_CFQ is not set
+CONFIG_DEFAULT_NOOP=y
+CONFIG_DEFAULT_IOSCHED="noop"
+CONFIG_INLINE_SPIN_UNLOCK_IRQ=y
+CONFIG_INLINE_READ_UNLOCK=y
+CONFIG_INLINE_READ_UNLOCK_IRQ=y
+CONFIG_INLINE_WRITE_UNLOCK=y
+CONFIG_INLINE_WRITE_UNLOCK_IRQ=y
+CONFIG_ARCH_SUPPORTS_ATOMIC_RMW=y
+# CONFIG_FREEZER is not set
+
+#
+# System Type
+#
+CONFIG_MMU=y
+CONFIG_ARCH_AK=y
+CONFIG_MACH_AK3790D=y
+
+#
+# Processor Type
+#
+CONFIG_CPU_ARM926T=y
+CONFIG_CPU_32v5=y
+CONFIG_CPU_ABRT_EV5TJ=y
+CONFIG_CPU_PABRT_LEGACY=y
+CONFIG_CPU_CACHE_VIVT=y
+CONFIG_CPU_COPY_V4WB=y
+CONFIG_CPU_TLB_V4WBI=y
+CONFIG_CPU_CP15=y
+CONFIG_CPU_CP15_MMU=y
+CONFIG_CPU_USE_DOMAINS=y
+
+#
+# Processor Features
+#
+# CONFIG_ARCH_PHYS_ADDR_T_64BIT is not set
+# CONFIG_ARM_THUMB is not set
+# CONFIG_CPU_ICACHE_DISABLE is not set
+# CONFIG_CPU_DCACHE_DISABLE is not set
+# CONFIG_CPU_DCACHE_WRITETHROUGH is not set
+# CONFIG_CPU_CACHE_ROUND_ROBIN is not set
+CONFIG_NEED_KUSER_HELPERS=y
+CONFIG_KUSER_HELPERS=y
+# CONFIG_CACHE_L2X0 is not set
+CONFIG_ARM_L1_CACHE_SHIFT=5
+# CONFIG_ARM_KERNMEM_PERMS is not set
+
+#
+# Bus support
+#
+# CONFIG_PCI_DOMAINS_GENERIC is not set
+# CONFIG_PCI_SYSCALL is not set
+# CONFIG_PCCARD is not set
+
+#
+# Kernel Features
+#
+CONFIG_VMSPLIT_3G=y
+# CONFIG_VMSPLIT_3G_OPT is not set
+# CONFIG_VMSPLIT_2G is not set
+# CONFIG_VMSPLIT_1G is not set
+CONFIG_PAGE_OFFSET=0xC0000000
+CONFIG_ARCH_NR_GPIO=0
+# CONFIG_PREEMPT_NONE is not set
+CONFIG_PREEMPT_VOLUNTARY=y
+# CONFIG_PREEMPT is not set
+CONFIG_HZ_FIXED=0
+CONFIG_HZ_100=y
+# CONFIG_HZ_200 is not set
+# CONFIG_HZ_250 is not set
+# CONFIG_HZ_300 is not set
+# CONFIG_HZ_500 is not set
+# CONFIG_HZ_1000 is not set
+CONFIG_HZ=100
+CONFIG_SCHED_HRTICK=y
+CONFIG_AEABI=y
+# CONFIG_OABI_COMPAT is not set
+# CONFIG_ARCH_SPARSEMEM_DEFAULT is not set
+# CONFIG_ARCH_SELECT_MEMORY_MODEL is not set
+CONFIG_HAVE_ARCH_PFN_VALID=y
+# CONFIG_HIGHMEM is not set
+CONFIG_CPU_SW_DOMAIN_PAN=y
+CONFIG_ARCH_WANT_GENERAL_HUGETLB=y
+# CONFIG_ARM_MODULE_PLTS is not set
+CONFIG_FLATMEM=y
+CONFIG_FLAT_NODE_MEM_MAP=y
+CONFIG_HAVE_MEMBLOCK=y
+CONFIG_NO_BOOTMEM=y
+CONFIG_MEMORY_ISOLATION=y
+# CONFIG_HAVE_BOOTMEM_INFO_NODE is not set
+CONFIG_SPLIT_PTLOCK_CPUS=999999
+CONFIG_COMPACTION=y
+CONFIG_MIGRATION=y
+# CONFIG_PHYS_ADDR_T_64BIT is not set
+CONFIG_ZONE_DMA_FLAG=0
+# CONFIG_KSM is not set
+CONFIG_DEFAULT_MMAP_MIN_ADDR=4096
+CONFIG_NEED_PER_CPU_KM=y
+# CONFIG_CLEANCACHE is not set
+CONFIG_CMA=y
+# CONFIG_CMA_DEBUG is not set
+# CONFIG_CMA_DEBUGFS is not set
+CONFIG_CMA_AREAS=7
+# CONFIG_CMA_AGGRESSIVE is not set
+# CONFIG_ZPOOL is not set
+# CONFIG_ZBUD is not set
+# CONFIG_ZSMALLOC is not set
+# CONFIG_IDLE_PAGE_TRACKING is not set
+CONFIG_FRAME_VECTOR=y
+CONFIG_FORCE_MAX_ZONEORDER=11
+CONFIG_ALIGNMENT_TRAP=y
+# CONFIG_UACCESS_WITH_MEMCPY is not set
+# CONFIG_SECCOMP is not set
+CONFIG_SWIOTLB=y
+CONFIG_IOMMU_HELPER=y
+
+#
+# Boot options
+#
+CONFIG_USE_OF=y
+# CONFIG_ATAGS is not set
+CONFIG_ZBOOT_ROM_TEXT=0
+CONFIG_ZBOOT_ROM_BSS=0
+# CONFIG_ARM_APPENDED_DTB is not set
+CONFIG_CMDLINE=""
+# CONFIG_XIP_KERNEL is not set
+# CONFIG_KEXEC is not set
+# CONFIG_CRASH_DUMP is not set
+# CONFIG_AUTO_ZRELADDR is not set
+
+#
+# CPU Power Management
+#
+
+#
+# CPU Frequency scaling
+#
+# CONFIG_CPU_FREQ is not set
+
+#
+# CPU Idle
+#
+# CONFIG_CPU_IDLE is not set
+# CONFIG_ARCH_NEEDS_CPU_IDLE_COUPLED is not set
+
+#
+# Floating point emulation
+#
+
+#
+# At least one emulation must be selected
+#
+# CONFIG_VFP is not set
+
+#
+# Userspace binary formats
+#
+CONFIG_BINFMT_ELF=y
+CONFIG_CORE_DUMP_DEFAULT_ELF_HEADERS=y
+# CONFIG_BINFMT_SCRIPT is not set
+# CONFIG_HAVE_AOUT is not set
+# CONFIG_BINFMT_MISC is not set
+CONFIG_COREDUMP=y
+
+#
+# Power management options
+#
+# CONFIG_SUSPEND is not set
+# CONFIG_PM is not set
+CONFIG_ARCH_SUSPEND_POSSIBLE=y
+# CONFIG_ARM_CPU_SUSPEND is not set
+CONFIG_ARCH_HIBERNATION_POSSIBLE=y
+CONFIG_NET=y
+CONFIG_NET_INGRESS=y
+
+#
+# Networking options
+#
+CONFIG_PACKET=y
+# CONFIG_PACKET_DIAG is not set
+CONFIG_UNIX=y
+CONFIG_UNIX_DIAG=y
+CONFIG_XFRM=y
+# CONFIG_XFRM_USER is not set
+# CONFIG_XFRM_SUB_POLICY is not set
+# CONFIG_XFRM_MIGRATE is not set
+# CONFIG_XFRM_STATISTICS is not set
+# CONFIG_NET_KEY is not set
+CONFIG_INET=y
+CONFIG_IP_MULTICAST=y
+# CONFIG_IP_ADVANCED_ROUTER is not set
+CONFIG_IP_PNP=y
+CONFIG_IP_PNP_DHCP=y
+CONFIG_IP_PNP_BOOTP=y
+CONFIG_IP_PNP_RARP=y
+# CONFIG_NET_IPIP is not set
+# CONFIG_NET_IPGRE_DEMUX is not set
+# CONFIG_NET_IP_TUNNEL is not set
+# CONFIG_IP_MROUTE is not set
+# CONFIG_SYN_COOKIES is not set
+# CONFIG_NET_IPVTI is not set
+# CONFIG_NET_UDP_TUNNEL is not set
+# CONFIG_NET_FOU is not set
+# CONFIG_INET_AH is not set
+# CONFIG_INET_ESP is not set
+# CONFIG_INET_IPCOMP is not set
+# CONFIG_INET_XFRM_TUNNEL is not set
+# CONFIG_INET_TUNNEL is not set
+CONFIG_INET_XFRM_MODE_TRANSPORT=y
+CONFIG_INET_XFRM_MODE_TUNNEL=y
+CONFIG_INET_XFRM_MODE_BEET=y
+CONFIG_INET_LRO=y
+CONFIG_INET_DIAG=y
+CONFIG_INET_TCP_DIAG=y
+CONFIG_INET_UDP_DIAG=y
+# CONFIG_TCP_CONG_ADVANCED is not set
+CONFIG_TCP_CONG_CUBIC=y
+CONFIG_DEFAULT_TCP_CONG="cubic"
+# CONFIG_TCP_MD5SIG is not set
+# CONFIG_IPV6 is not set
+CONFIG_NETWORK_SECMARK=y
+# CONFIG_NET_PTP_CLASSIFY is not set
+# CONFIG_NETWORK_PHY_TIMESTAMPING is not set
+CONFIG_NETFILTER=y
+# CONFIG_NETFILTER_DEBUG is not set
+CONFIG_NETFILTER_ADVANCED=y
+
+#
+# Core Netfilter Configuration
+#
+CONFIG_NETFILTER_INGRESS=y
+# CONFIG_NETFILTER_NETLINK_ACCT is not set
+# CONFIG_NETFILTER_NETLINK_QUEUE is not set
+# CONFIG_NETFILTER_NETLINK_LOG is not set
+# CONFIG_NF_CONNTRACK is not set
+# CONFIG_NF_TABLES is not set
+# CONFIG_NETFILTER_XTABLES is not set
+# CONFIG_IP_SET is not set
+# CONFIG_IP_VS is not set
+
+#
+# IP: Netfilter Configuration
+#
+# CONFIG_NF_DEFRAG_IPV4 is not set
+# CONFIG_NF_DUP_IPV4 is not set
+# CONFIG_NF_LOG_ARP is not set
+# CONFIG_NF_LOG_IPV4 is not set
+# CONFIG_NF_REJECT_IPV4 is not set
+# CONFIG_IP_NF_IPTABLES is not set
+# CONFIG_IP_NF_ARPTABLES is not set
+# CONFIG_IP_DCCP is not set
+CONFIG_IP_SCTP=y
+# CONFIG_SCTP_DBG_OBJCNT is not set
+CONFIG_SCTP_DEFAULT_COOKIE_HMAC_MD5=y
+# CONFIG_SCTP_DEFAULT_COOKIE_HMAC_SHA1 is not set
+# CONFIG_SCTP_DEFAULT_COOKIE_HMAC_NONE is not set
+CONFIG_SCTP_COOKIE_HMAC_MD5=y
+# CONFIG_SCTP_COOKIE_HMAC_SHA1 is not set
+# CONFIG_RDS is not set
+# CONFIG_TIPC is not set
+# CONFIG_ATM is not set
+# CONFIG_L2TP is not set
+# CONFIG_BRIDGE is not set
+CONFIG_HAVE_NET_DSA=y
+# CONFIG_NET_DSA is not set
+# CONFIG_VLAN_8021Q is not set
+# CONFIG_DECNET is not set
+# CONFIG_LLC2 is not set
+# CONFIG_IPX is not set
+# CONFIG_ATALK is not set
+# CONFIG_X25 is not set
+# CONFIG_LAPB is not set
+# CONFIG_PHONET is not set
+# CONFIG_IEEE802154 is not set
+# CONFIG_NET_SCHED is not set
+# CONFIG_DCB is not set
+# CONFIG_BATMAN_ADV is not set
+# CONFIG_OPENVSWITCH is not set
+# CONFIG_VSOCKETS is not set
+# CONFIG_NETLINK_DIAG is not set
+# CONFIG_MPLS is not set
+# CONFIG_HSR is not set
+# CONFIG_NET_SWITCHDEV is not set
+# CONFIG_NET_L3_MASTER_DEV is not set
+CONFIG_NET_RX_BUSY_POLL=y
+CONFIG_BQL=y
+# CONFIG_BPF_JIT is not set
+
+#
+# Network testing
+#
+# CONFIG_NET_PKTGEN is not set
+# CONFIG_HAMRADIO is not set
+# CONFIG_CAN is not set
+# CONFIG_IRDA is not set
+# CONFIG_BT is not set
+# CONFIG_AF_RXRPC is not set
+CONFIG_WIRELESS=y
+CONFIG_WIRELESS_EXT=y
+CONFIG_WEXT_CORE=y
+CONFIG_WEXT_PROC=y
+CONFIG_WEXT_PRIV=y
+CONFIG_CFG80211=m
+# CONFIG_NL80211_TESTMODE is not set
+# CONFIG_CFG80211_DEVELOPER_WARNINGS is not set
+# CONFIG_CFG80211_REG_DEBUG is not set
+# CONFIG_CFG80211_CERTIFICATION_ONUS is not set
+CONFIG_CFG80211_DEFAULT_PS=y
+# CONFIG_CFG80211_DEBUGFS is not set
+# CONFIG_CFG80211_INTERNAL_REGDB is not set
+CONFIG_CFG80211_CRDA_SUPPORT=y
+CONFIG_CFG80211_WEXT=y
+# CONFIG_LIB80211 is not set
+CONFIG_MAC80211=m
+CONFIG_MAC80211_HAS_RC=y
+CONFIG_MAC80211_RC_MINSTREL=y
+CONFIG_MAC80211_RC_MINSTREL_HT=y
+# CONFIG_MAC80211_RC_MINSTREL_VHT is not set
+CONFIG_MAC80211_RC_DEFAULT_MINSTREL=y
+CONFIG_MAC80211_RC_DEFAULT="minstrel_ht"
+# CONFIG_MAC80211_MESH is not set
+# CONFIG_MAC80211_LEDS is not set
+# CONFIG_MAC80211_DEBUGFS is not set
+# CONFIG_MAC80211_MESSAGE_TRACING is not set
+# CONFIG_MAC80211_DEBUG_MENU is not set
+CONFIG_MAC80211_STA_HASH_MAX_SIZE=0
+# CONFIG_WIMAX is not set
+# CONFIG_RFKILL is not set
+# CONFIG_NET_9P is not set
+# CONFIG_CAIF is not set
+# CONFIG_CEPH_LIB is not set
+# CONFIG_NFC is not set
+# CONFIG_LWTUNNEL is not set
+# CONFIG_DST_CACHE is not set
+CONFIG_HAVE_BPF_JIT=y
+
+#
+# Device Drivers
+#
+
+#
+# Generic Driver Options
+#
+CONFIG_UEVENT_HELPER=y
+CONFIG_UEVENT_HELPER_PATH="/sbin/hotplug"
+CONFIG_DEVTMPFS=y
+CONFIG_DEVTMPFS_MOUNT=y
+# CONFIG_STANDALONE is not set
+# CONFIG_PREVENT_FIRMWARE_BUILD is not set
+# CONFIG_FW_LOADER is not set
+# CONFIG_ALLOW_DEV_COREDUMP is not set
+# CONFIG_DEBUG_DRIVER is not set
+# CONFIG_DEBUG_DEVRES is not set
+# CONFIG_SYS_HYPERVISOR is not set
+# CONFIG_GENERIC_CPU_DEVICES is not set
+CONFIG_DMA_SHARED_BUFFER=y
+# CONFIG_FENCE_TRACE is not set
+CONFIG_DMA_CMA=y
+
+#
+# Default contiguous memory area size:
+#
+CONFIG_CMA_SIZE_MBYTES=30
+CONFIG_CMA_SIZE_SEL_MBYTES=y
+# CONFIG_CMA_SIZE_SEL_PERCENTAGE is not set
+# CONFIG_CMA_SIZE_SEL_MIN is not set
+# CONFIG_CMA_SIZE_SEL_MAX is not set
+CONFIG_CMA_ALIGNMENT=8
+
+#
+# Bus devices
+#
+# CONFIG_BRCMSTB_GISB_ARB is not set
+# CONFIG_VEXPRESS_CONFIG is not set
+# CONFIG_CONNECTOR is not set
+
+CONFIG_MTD=y
+# CONFIG_MTD_TESTS is not set
+# CONFIG_MTD_REDBOOT_PARTS is not set
+# CONFIG_MTD_CMDLINE_PARTS is not set
+# CONFIG_MTD_AFS_PARTS is not set
+# CONFIG_MTD_OF_PARTS is not set
+# CONFIG_MTD_AR7_PARTS is not set
+
+#
+# User Modules And Translation Layers
+#
+CONFIG_MTD_BLKDEVS=y
+CONFIG_MTD_BLOCK=y
+# CONFIG_FTL is not set
+# CONFIG_NFTL is not set
+# CONFIG_INFTL is not set
+# CONFIG_RFD_FTL is not set
+# CONFIG_SSFDC is not set
+# CONFIG_SM_FTL is not set
+# CONFIG_MTD_OOPS is not set
+# CONFIG_MTD_PARTITIONED_MASTER is not set
+
+#
+# RAM/ROM/Flash chip drivers
+#
+# CONFIG_MTD_CFI is not set
+# CONFIG_MTD_JEDECPROBE is not set
+CONFIG_MTD_MAP_BANK_WIDTH_1=y
+CONFIG_MTD_MAP_BANK_WIDTH_2=y
+CONFIG_MTD_MAP_BANK_WIDTH_4=y
+# CONFIG_MTD_MAP_BANK_WIDTH_8 is not set
+# CONFIG_MTD_MAP_BANK_WIDTH_16 is not set
+# CONFIG_MTD_MAP_BANK_WIDTH_32 is not set
+CONFIG_MTD_CFI_I1=y
+CONFIG_MTD_CFI_I2=y
+# CONFIG_MTD_CFI_I4 is not set
+# CONFIG_MTD_CFI_I8 is not set
+# CONFIG_MTD_RAM is not set
+# CONFIG_MTD_ROM is not set
+# CONFIG_MTD_ABSENT is not set
+
+#
+# Mapping drivers for chip access
+#
+# CONFIG_MTD_COMPLEX_MAPPINGS is not set
+# CONFIG_MTD_PLATRAM is not set
+
+#
+# Self-contained MTD device drivers
+#
+# CONFIG_MTD_DATAFLASH is not set
+# CONFIG_MTD_SST25L is not set
+CONFIG_MTD_AK_SPIFLASH=y
+# CONFIG_MTD_SLRAM is not set
+# CONFIG_MTD_PHRAM is not set
+# CONFIG_MTD_MTDRAM is not set
+# CONFIG_MTD_BLOCK2MTD is not set
+
+#
+# Disk-On-Chip Device Drivers
+#
+# CONFIG_MTD_DOCG3 is not set
+CONFIG_MTD_AK_SPINAND=y
+# CONFIG_MTD_NAND is not set
+# CONFIG_MTD_ONENAND is not set
+
+#
+# LPDDR & LPDDR2 PCM memory drivers
+#
+# CONFIG_MTD_LPDDR is not set
+# CONFIG_MTD_LPDDR2_NVM is not set
+# CONFIG_MTD_SPI_NOR is not set
+# CONFIG_MTD_UBI is not set
+CONFIG_DTC=y
+CONFIG_OF=y
+# CONFIG_OF_UNITTEST is not set
+CONFIG_OF_FLATTREE=y
+CONFIG_OF_EARLY_FLATTREE=y
+CONFIG_OF_ADDRESS=y
+CONFIG_OF_IRQ=y
+CONFIG_OF_NET=y
+CONFIG_OF_MDIO=y
+CONFIG_OF_MTD=y
+CONFIG_OF_RESERVED_MEM=y
+# CONFIG_OF_OVERLAY is not set
+CONFIG_ARCH_MIGHT_HAVE_PC_PARPORT=y
+# CONFIG_PARPORT is not set
+CONFIG_BLK_DEV=y
+# CONFIG_BLK_DEV_NULL_BLK is not set
+# CONFIG_BLK_DEV_COW_COMMON is not set
+CONFIG_BLK_DEV_LOOP=y
+CONFIG_BLK_DEV_LOOP_MIN_COUNT=8
+# CONFIG_BLK_DEV_CRYPTOLOOP is not set
+# CONFIG_BLK_DEV_DRBD is not set
+# CONFIG_BLK_DEV_NBD is not set
+# CONFIG_BLK_DEV_RAM is not set
+# CONFIG_CDROM_PKTCDVD is not set
+# CONFIG_ATA_OVER_ETH is not set
+# CONFIG_MG_DISK is not set
+# CONFIG_BLK_DEV_RBD is not set
+
+#
+# Misc devices
+#
+# CONFIG_DUMMY_IRQ is not set
+# CONFIG_ENCLOSURE_SERVICES is not set
+# CONFIG_HMC6352 is not set
+# CONFIG_SRAM is not set
+# CONFIG_C2PORT is not set
+
+#
+# EEPROM support
+#
+# CONFIG_EEPROM_93CX6 is not set
+
+#
+# Texas Instruments shared transport line discipline
+#
+
+#
+# Altera FPGA firmware download module
+#
+
+#
+# Intel MIC Bus Driver
+#
+
+#
+# SCIF Bus Driver
+#
+
+#
+# Intel MIC Host Driver
+#
+
+#
+# Intel MIC Card Driver
+#
+
+#
+# SCIF Driver
+#
+
+#
+# Intel MIC Coprocessor State Management (COSM) Drivers
+#
+# CONFIG_ECHO is not set
+# CONFIG_CXL_BASE is not set
+# CONFIG_CXL_KERNEL_API is not set
+# CONFIG_CXL_EEH is not set
+
+#
+# SCSI device support
+#
+CONFIG_SCSI_MOD=y
+# CONFIG_RAID_ATTRS is not set
+# CONFIG_SCSI is not set
+# CONFIG_SCSI_DMA is not set
+# CONFIG_SCSI_NETLINK is not set
+# CONFIG_ATA is not set
+# CONFIG_MD is not set
+
+CONFIG_NETDEVICES=y
+CONFIG_NET_CORE=y
+
+#
+# Distributed Switch Architecture drivers
+#
+# CONFIG_NET_DSA_MV88E6XXX is not set
+# CONFIG_NET_DSA_MV88E6XXX_NEED_PPU is not set
+CONFIG_ETHERNET=y
+# CONFIG_ALTERA_TSE is not set
+# CONFIG_NET_VENDOR_ARC is not set
+# CONFIG_NET_VENDOR_AURORA is not set
+# CONFIG_NET_CADENCE is not set
+# CONFIG_NET_VENDOR_BROADCOM is not set
+# CONFIG_NET_VENDOR_CIRRUS is not set
+# CONFIG_DM9000 is not set
+# CONFIG_DNET is not set
+# CONFIG_NET_VENDOR_EZCHIP is not set
+# CONFIG_NET_VENDOR_FARADAY is not set
+# CONFIG_NET_VENDOR_HISILICON is not set
+# CONFIG_NET_VENDOR_INTEL is not set
+# CONFIG_NET_VENDOR_MARVELL is not set
+# CONFIG_NET_VENDOR_MICREL is not set
+# CONFIG_NET_VENDOR_MICROCHIP is not set
+# CONFIG_NET_VENDOR_NATSEMI is not set
+# CONFIG_ETHOC is not set
+# CONFIG_NET_VENDOR_QUALCOMM is not set
+# CONFIG_NET_VENDOR_RENESAS is not set
+# CONFIG_NET_VENDOR_ROCKER is not set
+# CONFIG_NET_VENDOR_SAMSUNG is not set
+# CONFIG_NET_VENDOR_SEEQ is not set
+# CONFIG_NET_VENDOR_SMSC is not set
+# CONFIG_NET_VENDOR_STMICRO is not set
+# CONFIG_NET_VENDOR_SYNOPSYS is not set
+# CONFIG_NET_VENDOR_VIA is not set
+# CONFIG_NET_VENDOR_WIZNET is not set
+CONFIG_PHYLIB=y
+
+#
+# MII PHY device drivers
+#
+# CONFIG_USB_NET_DRIVERS is not set
+CONFIG_WLAN=y
+
+# CONFIG_RTL_CARDS is not set
+# CONFIG_RTL8XXXU is not set
+
+
+#
+# Enable WiMAX (Networking options) to see the WiMAX drivers
+#
+# CONFIG_WAN is not set
+# CONFIG_ISDN is not set
+# CONFIG_NVM is not set
+
+#
+# Input device support
+#
+CONFIG_INPUT=y
+CONFIG_INPUT_LEDS=y
+
+#
+# Userland interfaces
+#
+# CONFIG_INPUT_MOUSEDEV is not set
+# CONFIG_INPUT_JOYDEV is not set
+CONFIG_INPUT_EVDEV=y
+# CONFIG_INPUT_EVBUG is not set
+
+#
+# Input Device Drivers
+#
+# CONFIG_INPUT_KEYBOARD is not set
+# CONFIG_INPUT_MOUSE is not set
+# CONFIG_INPUT_JOYSTICK is not set
+# CONFIG_INPUT_TABLET is not set
+CONFIG_INPUT_TOUCHSCREEN=y
+CONFIG_TOUCHSCREEN_PROPERTIES=y
+CONFIG_INPUT_MISC=y
+
+#
+# Hardware I/O ports
+#
+# CONFIG_SERIO is not set
+# CONFIG_GAMEPORT is not set
+
+#
+# Character devices
+#
+CONFIG_TTY=y
+# CONFIG_VT is not set
+CONFIG_UNIX98_PTYS=y
+CONFIG_DEVPTS_MULTIPLE_INSTANCES=y
+# CONFIG_LEGACY_PTYS is not set
+# CONFIG_SERIAL_NONSTANDARD is not set
+# CONFIG_TRACE_SINK is not set
+CONFIG_DEVMEM=y
+# CONFIG_DEVKMEM is not set
+
+#
+# Serial drivers
+#
+# CONFIG_SERIAL_8250 is not set
+
+#
+# Non-8250 serial port support
+#
+CONFIG_SERIAL_CORE=y
+CONFIG_SERIAL_CORE_CONSOLE=y
+CONFIG_SERIAL_AK_UART=y
+CONFIG_SERIAL_AK_CONSOLE=y
+CONFIG_TTY_PRINTK=y
+# CONFIG_HW_RANDOM is not set
+
+#
+# I2C support
+#
+CONFIG_I2C=y
+CONFIG_I2C_BOARDINFO=y
+# CONFIG_I2C_COMPAT is not set
+CONFIG_I2C_CHARDEV=y
+CONFIG_I2C_MUX=y
+
+#
+# Multiplexer I2C Chip support
+#
+# CONFIG_I2C_ARB_GPIO_CHALLENGE is not set
+# CONFIG_I2C_MUX_GPIO is not set
+# CONFIG_I2C_MUX_PCA9541 is not set
+# CONFIG_I2C_MUX_PCA954x is not set
+# CONFIG_I2C_MUX_PINCTRL is not set
+# CONFIG_I2C_MUX_REG is not set
+# CONFIG_I2C_HELPER_AUTO is not set
+CONFIG_I2C_SMBUS=y
+
+#
+# I2C Algorithms
+#
+# CONFIG_I2C_ALGOBIT is not set
+# CONFIG_I2C_ALGOPCF is not set
+# CONFIG_I2C_ALGOPCA is not set
+
+#
+# I2C Hardware Bus support
+#
+
+#
+# I2C system bus drivers (mostly embedded / system-on-chip)
+#
+# CONFIG_I2C_CBUS_GPIO is not set
+# CONFIG_I2C_DESIGNWARE_PLATFORM is not set
+# CONFIG_I2C_EMEV2 is not set
+# CONFIG_I2C_GPIO is not set
+# CONFIG_I2C_OCORES is not set
+# CONFIG_I2C_PCA_PLATFORM is not set
+# CONFIG_I2C_PXA_PCI is not set
+# CONFIG_I2C_RK3X is not set
+# CONFIG_I2C_SIMTEC is not set
+# CONFIG_I2C_XILINX is not set
+
+#
+# External I2C/SMBus adapter drivers
+#
+# CONFIG_I2C_PARPORT_LIGHT is not set
+# CONFIG_I2C_TAOS_EVM is not set
+
+#
+# Other I2C/SMBus bus drivers
+#
+# CONFIG_I2C_STUB is not set
+# CONFIG_I2C_SLAVE is not set
+# CONFIG_I2C_DEBUG_CORE is not set
+# CONFIG_I2C_DEBUG_ALGO is not set
+# CONFIG_I2C_DEBUG_BUS is not set
+CONFIG_SPI=y
+# CONFIG_SPI_DEBUG is not set
+CONFIG_SPI_MASTER=y
+
+#
+# SPI Master Controller Drivers
+#
+# CONFIG_SPI_ALTERA is not set
+CONFIG_SPI_BITBANG=y
+# CONFIG_SPI_CADENCE is not set
+# CONFIG_SPI_GPIO is not set
+# CONFIG_SPI_FSL_SPI is not set
+# CONFIG_SPI_OC_TINY is not set
+# CONFIG_SPI_PXA2XX_PCI is not set
+# CONFIG_SPI_ROCKCHIP is not set
+# CONFIG_SPI_SC18IS602 is not set
+# CONFIG_SPI_XCOMM is not set
+# CONFIG_SPI_XILINX is not set
+# CONFIG_SPI_ZYNQMP_GQSPI is not set
+CONFIG_SPI_AK=y
+# CONFIG_SPI_DESIGNWARE is not set
+
+#
+# SPI Protocol Masters
+#
+# CONFIG_SPI_SPIDEV is not set
+# CONFIG_SPI_TLE62X0 is not set
+# CONFIG_SPMI is not set
+# CONFIG_HSI is not set
+
+#
+# PPS support
+#
+# CONFIG_PPS is not set
+
+#
+# PPS generators support
+#
+
+#
+# PTP clock support
+#
+
+#
+# Enable PHYLIB and NETWORK_PHY_TIMESTAMPING to see the additional clocks.
+#
+CONFIG_PINCTRL=y
+
+#
+# Pin controllers
+#
+CONFIG_PINMUX=y
+CONFIG_PINCONF=y
+# CONFIG_DEBUG_PINCTRL=y
+# CONFIG_PINCTRL_AMD is not set
+# CONFIG_PINCTRL_SINGLE is not set
+CONFIG_PINCTRL_AK=y
+CONFIG_ARCH_HAVE_CUSTOM_GPIO_H=y
+CONFIG_ARCH_REQUIRE_GPIOLIB=y
+CONFIG_GPIOLIB=y
+CONFIG_GPIO_DEVRES=y
+CONFIG_OF_GPIO=y
+CONFIG_GPIOLIB_IRQCHIP=y
+CONFIG_DEBUG_GPIO=y
+CONFIG_GPIO_SYSFS=y
+
+#
+# Memory mapped GPIO drivers
+#
+# CONFIG_GPIO_74XX_MMIO is not set
+# CONFIG_GPIO_ALTERA is not set
+# CONFIG_GPIO_DWAPB is not set
+# CONFIG_GPIO_EM is not set
+# CONFIG_GPIO_GENERIC_PLATFORM is not set
+# CONFIG_GPIO_GRGPIO is not set
+# CONFIG_GPIO_XILINX is not set
+# CONFIG_GPIO_ZEVIO is not set
+# CONFIG_GPIO_ZX is not set
+
+#
+# I2C GPIO expanders
+#
+# CONFIG_GPIO_ADP5588 is not set
+# CONFIG_GPIO_ADNP is not set
+# CONFIG_GPIO_MAX7300 is not set
+# CONFIG_GPIO_MAX732X is not set
+# CONFIG_GPIO_PCA953X is not set
+# CONFIG_GPIO_PCF857X is not set
+# CONFIG_GPIO_SX150X is not set
+
+#
+# MFD GPIO expanders
+#
+
+#
+# SPI GPIO expanders
+#
+# CONFIG_GPIO_74X164 is not set
+# CONFIG_GPIO_MAX7301 is not set
+# CONFIG_GPIO_MC33880 is not set
+
+#
+# SPI or I2C GPIO expanders
+#
+# CONFIG_GPIO_MCP23S08 is not set
+
+#
+# USB GPIO expanders
+#
+# CONFIG_W1 is not set
+# CONFIG_POWER_SUPPLY is not set
+# CONFIG_POWER_AVS is not set
+# CONFIG_HWMON is not set
+# CONFIG_THERMAL is not set
+CONFIG_WATCHDOG=y
+CONFIG_WATCHDOG_CORE=y
+CONFIG_WATCHDOG_NOWAYOUT=y
+
+#
+# Watchdog Device Drivers
+#
+# CONFIG_SOFT_WATCHDOG is not set
+# CONFIG_GPIO_WATCHDOG is not set
+# CONFIG_XILINX_WATCHDOG is not set
+# CONFIG_CADENCE_WATCHDOG is not set
+# CONFIG_DW_WATCHDOG is not set
+CONFIG_AK_WATCHDOG_TOP=y
+# CONFIG_AK_WATCHDOG_NONE is not set
+# CONFIG_MAX63XX_WATCHDOG is not set
+# CONFIG_BCM7038_WDT is not set
+# CONFIG_MEN_A21_WDT is not set
+
+#
+# USB-based Watchdog Cards
+#
+# CONFIG_USBPCWATCHDOG is not set
+CONFIG_SSB_POSSIBLE=y
+
+#
+# Sonics Silicon Backplane
+#
+# CONFIG_SSB is not set
+CONFIG_BCMA_POSSIBLE=y
+
+#
+# Broadcom specific AMBA
+#
+# CONFIG_BCMA is not set
+
+#
+# Multifunction device drivers
+#
+# CONFIG_REGULATOR is not set
+CONFIG_MEDIA_SUPPORT=y
+
+#
+# Multimedia core support
+#
+CONFIG_MEDIA_CAMERA_SUPPORT=y
+# CONFIG_MEDIA_ANALOG_TV_SUPPORT is not set
+# CONFIG_MEDIA_DIGITAL_TV_SUPPORT is not set
+# CONFIG_MEDIA_RADIO_SUPPORT is not set
+# CONFIG_MEDIA_SDR_SUPPORT is not set
+# CONFIG_MEDIA_RC_SUPPORT is not set
+CONFIG_MEDIA_CONTROLLER=y
+CONFIG_VIDEO_DEV=y
+CONFIG_VIDEO_V4L2_SUBDEV_API=y
+CONFIG_VIDEO_V4L2=y
+CONFIG_VIDEO_ADV_DEBUG=y
+# CONFIG_VIDEO_FIXED_MINOR_RANGES is not set
+CONFIG_VIDEOBUF_GEN=y
+CONFIG_VIDEOBUF2_CORE=y
+CONFIG_VIDEOBUF2_MEMOPS=y
+CONFIG_VIDEOBUF2_DMA_CONTIG=y
+# CONFIG_TTPCI_EEPROM is not set
+
+#
+# Media drivers
+#
+# CONFIG_MEDIA_USB_SUPPORT is not set
+CONFIG_V4L_PLATFORM_DRIVERS=y
+CONFIG_SOC_CAMERA=y
+CONFIG_SOC_CAMERA_PLATFORM=y
+CONFIG_VIDEO_AK=y
+# CONFIG_VIDEO_XILINX is not set
+# CONFIG_V4L_MEM2MEM_DRIVERS is not set
+# CONFIG_V4L_TEST_DRIVERS is not set
+
+#
+# Supported MMC/SDIO adapters
+#
+
+#
+# Media ancillary drivers (tuners, sensors, i2c, frontends)
+#
+CONFIG_MEDIA_SUBDRV_AUTOSELECT=y
+
+#
+# Audio decoders, processors and mixers
+#
+
+#
+# RDS decoders
+#
+
+#
+# Video decoders
+#
+
+#
+# Video and audio decoders
+#
+
+#
+# Video encoders
+#
+
+#
+# Camera sensor devices
+#
+
+#
+# Flash devices
+#
+
+#
+# Video improvement chips
+#
+
+#
+# Audio/Video compression chips
+#
+
+#
+# Miscellaneous helper chips
+#
+
+#
+# Sensors used on soc_camera driver
+#
+
+#
+# Tools to develop new frontends
+#
+# CONFIG_DVB_DUMMY_FE is not set
+
+#
+# Graphics support
+#
+# CONFIG_DRM is not set
+
+#
+# Frame buffer Devices
+#
+CONFIG_FB=y
+# CONFIG_FIRMWARE_EDID is not set
+CONFIG_FB_CMDLINE=y
+# CONFIG_FB_DDC is not set
+# CONFIG_FB_BOOT_VESA_SUPPORT is not set
+# CONFIG_FB_CFB_FILLRECT is not set
+# CONFIG_FB_CFB_COPYAREA is not set
+# CONFIG_FB_CFB_IMAGEBLIT is not set
+
+#
+# Frame buffer hardware drivers
+#
+# CONFIG_FB_OPENCORES is not set
+# CONFIG_FB_S1D13XXX is not set
+# CONFIG_FB_SMSCUFX is not set
+# CONFIG_FB_UDL is not set
+# CONFIG_FB_IBM_GXT4500 is not set
+# CONFIG_FB_VIRTUAL is not set
+# CONFIG_FB_METRONOME is not set
+# CONFIG_FB_BROADSHEET is not set
+# CONFIG_FB_AUO_K190X is not set
+# CONFIG_FB_SIMPLE is not set
+# CONFIG_FB_SSD1307 is not set
+# CONFIG_BACKLIGHT_LCD_SUPPORT is not set
+# CONFIG_VGASTATE is not set
+# CONFIG_LOGO is not set
+# CONFIG_SOUND is not set
+
+#
+# HID support
+#
+# CONFIG_HID is not set
+
+#
+# USB HID support
+#
+# CONFIG_USB_HID is not set
+# CONFIG_HID_PID is not set
+
+#
+# USB HID Boot Protocol drivers
+#
+# CONFIG_USB_KBD is not set
+# CONFIG_USB_MOUSE is not set
+
+#
+# I2C HID support
+#
+# CONFIG_I2C_HID is not set
+CONFIG_USB_OHCI_LITTLE_ENDIAN=y
+CONFIG_USB_SUPPORT=y
+CONFIG_USB_COMMON=y
+CONFIG_USB_ARCH_HAS_HCD=y
+CONFIG_USB=y
+CONFIG_USB_ANNOUNCE_NEW_DEVICES=y
+
+#
+# Miscellaneous USB options
+#
+CONFIG_USB_DEFAULT_PERSIST=y
+
+#
+# USB Host Controller Drivers
+#
+
+#
+# USB Device Class drivers
+#
+# CONFIG_USB_ACM is not set
+# CONFIG_USB_PRINTER is not set
+CONFIG_USB_WDM=y
+# CONFIG_USB_TMC is not set
+
+CONFIG_USB_GADGET=y
+CONFIG_USB_LIBCOMPOSITE=m
+CONFIG_USB_F_MASS_STORAGE=m
+CONFIG_USB_MASS_STORAGE=m
+CONFIG_MMC=y
+# CONFIG_MMC_DEBUG is not set
+
+#
+# MMC/SD/SDIO Card Drivers
+#
+CONFIG_MMC_BLOCK=y
+CONFIG_MMC_BLOCK_MINORS=8
+CONFIG_MMC_BLOCK_BOUNCE=y
+# CONFIG_SDIO_UART is not set
+# CONFIG_MMC_TEST is not set
+
+#
+# MMC/SD/SDIO Host Controller Drivers
+#
+
+CONFIG_NEW_LEDS=y
+CONFIG_LEDS_CLASS=y
+# CONFIG_LEDS_CLASS_FLASH is not set
+
+#
+# LED drivers
+#
+
+#
+# LED Triggers
+#
+CONFIG_LEDS_TRIGGERS=y
+CONFIG_LEDS_TRIGGER_TIMER=y
+
+#
+# iptables trigger is under Netfilter config (LED target)
+#
+
+CONFIG_EDAC_ATOMIC_SCRUB=y
+CONFIG_EDAC_SUPPORT=y
+# CONFIG_EDAC is not set
+
+CONFIG_RTC_LIB=y
+CONFIG_RTC_CLASS=y
+# CONFIG_RTC_HCTOSYS is not set
+CONFIG_RTC_SYSTOHC=y
+CONFIG_RTC_SYSTOHC_DEVICE="rtc0"
+# CONFIG_RTC_DEBUG is not set
+
+#
+# RTC interfaces
+#
+CONFIG_RTC_INTF_SYSFS=y
+CONFIG_RTC_INTF_PROC=y
+CONFIG_RTC_INTF_DEV=y
+# CONFIG_RTC_INTF_DEV_UIE_EMUL is not set
+# CONFIG_RTC_DRV_TEST is not set
+
+CONFIG_UIO=y
+# CONFIG_UIO_PDRV_GENIRQ is not set
+# CONFIG_UIO_DMEM_GENIRQ is not set
+# CONFIG_UIO_PRUSS is not set
+
+CONFIG_STAGING=y
+# CONFIG_PRISM2_USB is not set
+# CONFIG_COMEDI is not set
+# CONFIG_RTLLIB is not set
+# CONFIG_R8712U is not set
+CONFIG_R8188EU=m
+# CONFIG_88EU_AP_MODE is not set
+# CONFIG_VT6656 is not set
+
+#
+# Android
+#
+# CONFIG_ANDROID_TIMED_OUTPUT is not set
+# CONFIG_ANDROID_LOW_MEMORY_KILLER is not set
+# CONFIG_SYNC is not set
+CONFIG_ION=y
+# CONFIG_ION_TEST is not set
+# CONFIG_ION_DUMMY is not set
+# CONFIG_STAGING_BOARD is not set
+# CONFIG_DGAP is not set
+# CONFIG_GS_FPGABOOT is not set
+# CONFIG_COMMON_CLK_XLNX_CLKWZRD is not set
+# CONFIG_MOST is not set
+# CONFIG_CHROME_PLATFORMS is not set
+CONFIG_CLKDEV_LOOKUP=y
+CONFIG_HAVE_CLK_PREPARE=y
+CONFIG_COMMON_CLK=y
+
+#
+# Common Clock Framework
+#
+
+#
+# Hardware Spinlock drivers
+#
+
+#
+# Clock Source drivers
+#
+CONFIG_CLKSRC_OF=y
+CONFIG_CLKSRC_PROBE=y
+CONFIG_CLKSRC_MMIO=y
+CONFIG_ARM_TIMER_SP804=y
+CONFIG_IOMMU_SUPPORT=y
+
+#
+# Generic IOMMU Pagetable Support
+#
+# CONFIG_IOMMU_IO_PGTABLE_LPAE is not set
+# CONFIG_ARM_SMMU is not set
+
+#
+# Remoteproc drivers
+#
+# CONFIG_STE_MODEM_RPROC is not set
+
+#
+# Rpmsg drivers
+#
+
+#
+# SOC (System On Chip) specific Drivers
+#
+# CONFIG_SOC_BRCMSTB is not set
+# CONFIG_SUNXI_SRAM is not set
+# CONFIG_SOC_TI is not set
+# CONFIG_PM_DEVFREQ is not set
+# CONFIG_EXTCON is not set
+# CONFIG_MEMORY is not set
+CONFIG_IIO=y
+CONFIG_IIO_BUFFER=y
+CONFIG_IIO_TRIGGER=y
+CONFIG_IIO_CONSUMERS_PER_TRIGGER=2
+CONFIG_IIO_INTERRUPT_TRIGGER=y
+CONFIG_IIO_SYSFS_TRIGGER=y
+CONFIG_PWM=y
+CONFIG_IRQCHIP=y
+# CONFIG_IPACK_BUS is not set
+# CONFIG_RESET_CONTROLLER is not set
+# CONFIG_FMC is not set
+
+#
+# PHY Subsystem
+#
+# CONFIG_GENERIC_PHY is not set
+# CONFIG_PHY_PXA_28NM_HSIC is not set
+# CONFIG_PHY_PXA_28NM_USB2 is not set
+# CONFIG_BCM_KONA_USB2_PHY is not set
+# CONFIG_POWERCAP is not set
+# CONFIG_MCB is not set
+
+#
+# Performance monitor support
+#
+# CONFIG_RAS is not set
+
+#
+# Android
+#
+CONFIG_ANDROID=y
+# CONFIG_ANDROID_BINDER_IPC is not set
+# CONFIG_NVMEM is not set
+# CONFIG_STM is not set
+# CONFIG_STM_DUMMY is not set
+# CONFIG_STM_SOURCE_CONSOLE is not set
+# CONFIG_INTEL_TH is not set
+
+#
+# FPGA Configuration Support
+#
+# CONFIG_FPGA is not set
+
+#
+# Firmware Drivers
+#
+# CONFIG_FIRMWARE_MEMMAP is not set
+
+#
+# File systems
+#
+# CONFIG_EXT2_FS is not set
+# CONFIG_EXT3_FS is not set
+# CONFIG_EXT4_FS is not set
+# CONFIG_REISERFS_FS is not set
+# CONFIG_JFS_FS is not set
+# CONFIG_BTRFS_FS is not set
+# CONFIG_NILFS2_FS is not set
+# CONFIG_F2FS_FS is not set
+CONFIG_FS_POSIX_ACL=y
+CONFIG_FILE_LOCKING=y
+CONFIG_FSNOTIFY=y
+CONFIG_DNOTIFY=y
+CONFIG_INOTIFY_USER=y
+# CONFIG_FANOTIFY is not set
+# CONFIG_QUOTA is not set
+# CONFIG_QUOTACTL is not set
+# CONFIG_AUTOFS4_FS is not set
+# CONFIG_FUSE_FS is not set
+# CONFIG_OVERLAY_FS is not set
+
+#
+# Caches
+#
+# CONFIG_FSCACHE is not set
+
+#
+# CD-ROM/DVD Filesystems
+#
+# CONFIG_ISO9660_FS is not set
+# CONFIG_UDF_FS is not set
+
+#
+# DOS/FAT/NT Filesystems
+#
+CONFIG_FAT_FS=y
+CONFIG_MSDOS_FS=y
+CONFIG_VFAT_FS=y
+CONFIG_FAT_DEFAULT_CODEPAGE=437
+CONFIG_FAT_DEFAULT_IOCHARSET="iso8859-1"
+# CONFIG_NTFS_FS is not set
+
+#
+# Pseudo filesystems
+#
+CONFIG_PROC_FS=y
+CONFIG_PROC_SYSCTL=y
+CONFIG_PROC_PAGE_MONITOR=y
+# CONFIG_PROC_CHILDREN is not set
+CONFIG_KERNFS=y
+CONFIG_SYSFS=y
+CONFIG_TMPFS=y
+CONFIG_TMPFS_POSIX_ACL=y
+CONFIG_TMPFS_XATTR=y
+# CONFIG_HUGETLB_PAGE is not set
+CONFIG_CONFIGFS_FS=m
+CONFIG_MISC_FILESYSTEMS=y
+# CONFIG_ADFS_FS is not set
+# CONFIG_AFFS_FS is not set
+# CONFIG_HFS_FS is not set
+# CONFIG_HFSPLUS_FS is not set
+# CONFIG_BEFS_FS is not set
+# CONFIG_BFS_FS is not set
+# CONFIG_EFS_FS is not set
+CONFIG_JFFS2_FS=y
+CONFIG_JFFS2_FS_DEBUG=0
+# CONFIG_JFFS2_FS_WRITEBUFFER is not set
+# CONFIG_JFFS2_SUMMARY is not set
+# CONFIG_JFFS2_FS_XATTR is not set
+CONFIG_JFFS2_COMPRESSION_OPTIONS=y
+CONFIG_JFFS2_ZLIB=y
+# CONFIG_JFFS2_LZO is not set
+# CONFIG_JFFS2_RTIME is not set
+# CONFIG_JFFS2_RUBIN is not set
+CONFIG_JFFS2_CMODE_NONE=y
+# CONFIG_JFFS2_CMODE_PRIORITY is not set
+# CONFIG_JFFS2_CMODE_SIZE is not set
+# CONFIG_JFFS2_CMODE_FAVOURLZO is not set
+# CONFIG_LOGFS is not set
+# CONFIG_CRAMFS is not set
+CONFIG_SQUASHFS=y
+# CONFIG_SQUASHFS_FILE_CACHE is not set
+CONFIG_SQUASHFS_FILE_DIRECT=y
+# CONFIG_SQUASHFS_DECOMP_SINGLE is not set
+CONFIG_SQUASHFS_DECOMP_MULTI=y
+# CONFIG_SQUASHFS_DECOMP_MULTI_PERCPU is not set
+# CONFIG_SQUASHFS_XATTR is not set
+CONFIG_SQUASHFS_ZLIB=y
+# CONFIG_SQUASHFS_LZ4 is not set
+# CONFIG_SQUASHFS_LZO is not set
+CONFIG_SQUASHFS_XZ=y
+# CONFIG_SQUASHFS_4K_DEVBLK_SIZE is not set
+# CONFIG_SQUASHFS_EMBEDDED is not set
+CONFIG_SQUASHFS_FRAGMENT_CACHE_SIZE=3
+# CONFIG_VXFS_FS is not set
+# CONFIG_MINIX_FS is not set
+# CONFIG_OMFS_FS is not set
+# CONFIG_HPFS_FS is not set
+# CONFIG_QNX4FS_FS is not set
+# CONFIG_QNX6FS_FS is not set
+# CONFIG_ROMFS_FS is not set
+# CONFIG_PSTORE is not set
+# CONFIG_SYSV_FS is not set
+# CONFIG_UFS_FS is not set
+CONFIG_NETWORK_FILESYSTEMS=y
+CONFIG_NFS_FS=m
+CONFIG_NFS_V2=m
+CONFIG_NFS_V3=m
+# CONFIG_NFS_V3_ACL is not set
+# CONFIG_NFS_V4 is not set
+# CONFIG_NFS_SWAP is not set
+# CONFIG_NFSD is not set
+
+CONFIG_YAFFS_FS=y
+CONFIG_YAFFS_YAFFS1=y
+# CONFIG_YAFFS_9BYTE_TAGS is not set
+# CONFIG_YAFFS_DOES_ECC is not set
+CONFIG_YAFFS_YAFFS2=y
+CONFIG_YAFFS_AUTO_YAFFS2=y
+# CONFIG_YAFFS_DISABLE_TAGS_ECC is not set
+# CONFIG_YAFFS_ALWAYS_CHECK_CHUNK_ERASED is not set
+# CONFIG_YAFFS_EMPTY_LOST_AND_FOUND is not set
+# CONFIG_YAFFS_DISABLE_BLOCK_REFRESHING is not set
+# CONFIG_YAFFS_DISABLE_BACKGROUND is not set
+# CONFIG_YAFFS_DISABLE_BAD_BLOCK_MARKING is not set
+CONFIG_YAFFS_XATTR=y
+
+
+CONFIG_GRACE_PERIOD=m
+CONFIG_LOCKD=m
+CONFIG_LOCKD_V4=y
+CONFIG_NFS_COMMON=y
+CONFIG_SUNRPC=m
+# CONFIG_SUNRPC_DEBUG is not set
+# CONFIG_CEPH_FS is not set
+# CONFIG_CIFS is not set
+# CONFIG_NCP_FS is not set
+# CONFIG_CODA_FS is not set
+# CONFIG_AFS_FS is not set
+CONFIG_NLS=y
+CONFIG_NLS_DEFAULT="iso8859-1"
+CONFIG_NLS_CODEPAGE_437=y
+# CONFIG_NLS_CODEPAGE_737 is not set
+# CONFIG_NLS_CODEPAGE_775 is not set
+# CONFIG_NLS_CODEPAGE_850 is not set
+# CONFIG_NLS_CODEPAGE_852 is not set
+# CONFIG_NLS_CODEPAGE_855 is not set
+# CONFIG_NLS_CODEPAGE_857 is not set
+# CONFIG_NLS_CODEPAGE_860 is not set
+# CONFIG_NLS_CODEPAGE_861 is not set
+# CONFIG_NLS_CODEPAGE_862 is not set
+# CONFIG_NLS_CODEPAGE_863 is not set
+# CONFIG_NLS_CODEPAGE_864 is not set
+# CONFIG_NLS_CODEPAGE_865 is not set
+# CONFIG_NLS_CODEPAGE_866 is not set
+# CONFIG_NLS_CODEPAGE_869 is not set
+# CONFIG_NLS_CODEPAGE_936 is not set
+# CONFIG_NLS_CODEPAGE_950 is not set
+# CONFIG_NLS_CODEPAGE_932 is not set
+# CONFIG_NLS_CODEPAGE_949 is not set
+# CONFIG_NLS_CODEPAGE_874 is not set
+# CONFIG_NLS_ISO8859_8 is not set
+# CONFIG_NLS_CODEPAGE_1250 is not set
+# CONFIG_NLS_CODEPAGE_1251 is not set
+# CONFIG_NLS_ASCII is not set
+CONFIG_NLS_ISO8859_1=y
+# CONFIG_NLS_ISO8859_2 is not set
+# CONFIG_NLS_ISO8859_3 is not set
+# CONFIG_NLS_ISO8859_4 is not set
+# CONFIG_NLS_ISO8859_5 is not set
+# CONFIG_NLS_ISO8859_6 is not set
+# CONFIG_NLS_ISO8859_7 is not set
+# CONFIG_NLS_ISO8859_9 is not set
+# CONFIG_NLS_ISO8859_13 is not set
+# CONFIG_NLS_ISO8859_14 is not set
+# CONFIG_NLS_ISO8859_15 is not set
+# CONFIG_NLS_KOI8_R is not set
+# CONFIG_NLS_KOI8_U is not set
+# CONFIG_NLS_MAC_ROMAN is not set
+# CONFIG_NLS_MAC_CELTIC is not set
+# CONFIG_NLS_MAC_CENTEURO is not set
+# CONFIG_NLS_MAC_CROATIAN is not set
+# CONFIG_NLS_MAC_CYRILLIC is not set
+# CONFIG_NLS_MAC_GAELIC is not set
+# CONFIG_NLS_MAC_GREEK is not set
+# CONFIG_NLS_MAC_ICELAND is not set
+# CONFIG_NLS_MAC_INUIT is not set
+# CONFIG_NLS_MAC_ROMANIAN is not set
+# CONFIG_NLS_MAC_TURKISH is not set
+# CONFIG_NLS_UTF8 is not set
+
+#
+# Kernel hacking
+#
+
+#
+# printk and dmesg options
+#
+# CONFIG_PRINTK_TIME is not set
+CONFIG_MESSAGE_LOGLEVEL_DEFAULT=4
+# CONFIG_BOOT_PRINTK_DELAY is not set
+CONFIG_DYNAMIC_DEBUG=y
+
+#
+# Compile-time checks and compiler options
+#
+# CONFIG_DEBUG_INFO is not set
+# CONFIG_ENABLE_WARN_DEPRECATED is not set
+# CONFIG_ENABLE_MUST_CHECK is not set
+CONFIG_FRAME_WARN=4096
+# CONFIG_STRIP_ASM_SYMS is not set
+# CONFIG_READABLE_ASM is not set
+# CONFIG_UNUSED_SYMBOLS is not set
+# CONFIG_PAGE_OWNER is not set
+CONFIG_DEBUG_FS=y
+# CONFIG_HEADERS_CHECK is not set
+# CONFIG_DEBUG_SECTION_MISMATCH is not set
+# CONFIG_SECTION_MISMATCH_WARN_ONLY is not set
+CONFIG_FRAME_POINTER=y
+# CONFIG_DEBUG_FORCE_WEAK_PER_CPU is not set
+# CONFIG_MAGIC_SYSRQ is not set
+CONFIG_DEBUG_KERNEL=y
+
+#
+# Memory Debugging
+#
+# CONFIG_PAGE_EXTENSION is not set
+# CONFIG_DEBUG_PAGEALLOC is not set
+# CONFIG_DEBUG_OBJECTS is not set
+# CONFIG_SLUB_STATS is not set
+CONFIG_HAVE_DEBUG_KMEMLEAK=y
+# CONFIG_DEBUG_KMEMLEAK is not set
+# CONFIG_DEBUG_STACK_USAGE is not set
+# CONFIG_DEBUG_VM is not set
+# CONFIG_DEBUG_MEMORY_INIT is not set
+# CONFIG_DEBUG_SHIRQ is not set
+
+#
+# Debug Lockups and Hangs
+#
+# CONFIG_LOCKUP_DETECTOR is not set
+# CONFIG_DETECT_HUNG_TASK is not set
+# CONFIG_PANIC_ON_OOPS is not set
+CONFIG_PANIC_ON_OOPS_VALUE=0
+CONFIG_PANIC_TIMEOUT=0
+# CONFIG_SCHED_DEBUG is not set
+# CONFIG_SCHED_INFO is not set
+# CONFIG_SCHEDSTATS is not set
+# CONFIG_SCHED_STACK_END_CHECK is not set
+# CONFIG_DEBUG_TIMEKEEPING is not set
+# CONFIG_TIMER_STATS is not set
+
+#
+# Lock Debugging (spinlocks, mutexes, etc...)
+#
+# CONFIG_DEBUG_RT_MUTEXES is not set
+# CONFIG_DEBUG_SPINLOCK is not set
+# CONFIG_DEBUG_MUTEXES is not set
+# CONFIG_DEBUG_WW_MUTEX_SLOWPATH is not set
+# CONFIG_DEBUG_LOCK_ALLOC is not set
+# CONFIG_PROVE_LOCKING is not set
+# CONFIG_LOCK_STAT is not set
+# CONFIG_DEBUG_ATOMIC_SLEEP is not set
+# CONFIG_DEBUG_LOCKING_API_SELFTESTS is not set
+# CONFIG_LOCK_TORTURE_TEST is not set
+CONFIG_STACKTRACE=y
+# CONFIG_DEBUG_KOBJECT is not set
+CONFIG_DEBUG_BUGVERBOSE=y
+# CONFIG_DEBUG_LIST is not set
+# CONFIG_DEBUG_PI_LIST is not set
+# CONFIG_DEBUG_SG is not set
+# CONFIG_DEBUG_NOTIFIERS is not set
+# CONFIG_DEBUG_CREDENTIALS is not set
+
+#
+# RCU Debugging
+#
+# CONFIG_PROVE_RCU is not set
+# CONFIG_SPARSE_RCU_POINTER is not set
+# CONFIG_TORTURE_TEST is not set
+# CONFIG_RCU_TORTURE_TEST is not set
+# CONFIG_RCU_TRACE is not set
+# CONFIG_RCU_EQS_DEBUG is not set
+# CONFIG_DEBUG_BLOCK_EXT_DEVT is not set
+# CONFIG_NOTIFIER_ERROR_INJECTION is not set
+# CONFIG_FAULT_INJECTION is not set
+# CONFIG_LATENCYTOP is not set
+CONFIG_HAVE_FUNCTION_TRACER=y
+CONFIG_HAVE_FUNCTION_GRAPH_TRACER=y
+CONFIG_HAVE_DYNAMIC_FTRACE=y
+CONFIG_HAVE_FTRACE_MCOUNT_RECORD=y
+CONFIG_HAVE_SYSCALL_TRACEPOINTS=y
+CONFIG_HAVE_C_RECORDMCOUNT=y
+CONFIG_TRACING_SUPPORT=y
+# CONFIG_FTRACE is not set
+
+#
+# Runtime Testing
+#
+# CONFIG_LKDTM is not set
+# CONFIG_TEST_LIST_SORT is not set
+# CONFIG_BACKTRACE_SELF_TEST is not set
+# CONFIG_RBTREE_TEST is not set
+# CONFIG_INTERVAL_TREE_TEST is not set
+# CONFIG_PERCPU_TEST is not set
+# CONFIG_ATOMIC64_SELFTEST is not set
+# CONFIG_TEST_HEXDUMP is not set
+# CONFIG_TEST_STRING_HELPERS is not set
+# CONFIG_TEST_KSTRTOX is not set
+# CONFIG_TEST_PRINTF is not set
+# CONFIG_TEST_RHASHTABLE is not set
+# CONFIG_DMA_API_DEBUG is not set
+# CONFIG_TEST_LKM is not set
+# CONFIG_TEST_USER_COPY is not set
+# CONFIG_TEST_BPF is not set
+# CONFIG_TEST_UDELAY is not set
+# CONFIG_MEMTEST is not set
+# CONFIG_TEST_STATIC_KEYS is not set
+# CONFIG_SAMPLES is not set
+CONFIG_HAVE_ARCH_KGDB=y
+# CONFIG_KGDB is not set
+# CONFIG_ARM_PTDUMP is not set
+CONFIG_STRICT_DEVMEM=y
+# CONFIG_ARM_UNWIND is not set
+# CONFIG_DEBUG_USER is not set
+# CONFIG_DEBUG_LL is not set
+CONFIG_DEBUG_LL_INCLUDE="mach/debug-macro.S"
+# CONFIG_DEBUG_UART_8250 is not set
+CONFIG_UNCOMPRESS_INCLUDE="mach/uncompress.h"
+# CONFIG_DEBUG_SET_MODULE_RONX is not set
+# CONFIG_CORESIGHT is not set
+
+#
+# Security options
+#
+# CONFIG_KEYS is not set
+# CONFIG_SECURITY_DMESG_RESTRICT is not set
+# CONFIG_SECURITY is not set
+# CONFIG_SECURITYFS is not set
+CONFIG_DEFAULT_SECURITY_DAC=y
+CONFIG_DEFAULT_SECURITY=""
+CONFIG_CRYPTO=y
+
+#
+# Crypto core or helper
+#
+CONFIG_CRYPTO_ALGAPI=y
+CONFIG_CRYPTO_ALGAPI2=y
+CONFIG_CRYPTO_AEAD=y
+CONFIG_CRYPTO_AEAD2=y
+CONFIG_CRYPTO_BLKCIPHER=y
+CONFIG_CRYPTO_BLKCIPHER2=y
+CONFIG_CRYPTO_HASH=y
+CONFIG_CRYPTO_HASH2=y
+CONFIG_CRYPTO_RNG=y
+CONFIG_CRYPTO_RNG2=y
+CONFIG_CRYPTO_RNG_DEFAULT=y
+CONFIG_CRYPTO_PCOMP2=y
+CONFIG_CRYPTO_AKCIPHER2=y
+# CONFIG_CRYPTO_RSA is not set
+CONFIG_CRYPTO_MANAGER=y
+CONFIG_CRYPTO_MANAGER2=y
+# CONFIG_CRYPTO_USER is not set
+CONFIG_CRYPTO_MANAGER_DISABLE_TESTS=y
+CONFIG_CRYPTO_GF128MUL=y
+CONFIG_CRYPTO_NULL=y
+CONFIG_CRYPTO_NULL2=y
+CONFIG_CRYPTO_WORKQUEUE=y
+# CONFIG_CRYPTO_CRYPTD is not set
+# CONFIG_CRYPTO_MCRYPTD is not set
+# CONFIG_CRYPTO_AUTHENC is not set
+# CONFIG_CRYPTO_TEST is not set
+
+#
+# Authenticated Encryption with Associated Data
+#
+CONFIG_CRYPTO_CCM=y
+CONFIG_CRYPTO_GCM=y
+# CONFIG_CRYPTO_CHACHA20POLY1305 is not set
+CONFIG_CRYPTO_SEQIV=y
+# CONFIG_CRYPTO_ECHAINIV is not set
+
+#
+# Block modes
+#
+# CONFIG_CRYPTO_CBC is not set
+CONFIG_CRYPTO_CTR=y
+# CONFIG_CRYPTO_CTS is not set
+# CONFIG_CRYPTO_ECB is not set
+# CONFIG_CRYPTO_LRW is not set
+# CONFIG_CRYPTO_PCBC is not set
+# CONFIG_CRYPTO_XTS is not set
+# CONFIG_CRYPTO_KEYWRAP is not set
+
+#
+# Hash modes
+#
+# CONFIG_CRYPTO_CMAC is not set
+CONFIG_CRYPTO_HMAC=y
+# CONFIG_CRYPTO_XCBC is not set
+# CONFIG_CRYPTO_VMAC is not set
+
+#
+# Digest
+#
+CONFIG_CRYPTO_CRC32C=y
+# CONFIG_CRYPTO_CRC32 is not set
+# CONFIG_CRYPTO_CRCT10DIF is not set
+CONFIG_CRYPTO_GHASH=y
+# CONFIG_CRYPTO_POLY1305 is not set
+# CONFIG_CRYPTO_MD4 is not set
+CONFIG_CRYPTO_MD5=y
+# CONFIG_CRYPTO_MICHAEL_MIC is not set
+# CONFIG_CRYPTO_RMD128 is not set
+# CONFIG_CRYPTO_RMD160 is not set
+# CONFIG_CRYPTO_RMD256 is not set
+# CONFIG_CRYPTO_RMD320 is not set
+CONFIG_CRYPTO_SHA1=y
+CONFIG_CRYPTO_SHA256=y
+# CONFIG_CRYPTO_SHA512 is not set
+# CONFIG_CRYPTO_TGR192 is not set
+# CONFIG_CRYPTO_WP512 is not set
+
+#
+# Ciphers
+#
+CONFIG_CRYPTO_AES=y
+# CONFIG_CRYPTO_ANUBIS is not set
+CONFIG_CRYPTO_ARC4=y
+# CONFIG_CRYPTO_BLOWFISH is not set
+# CONFIG_CRYPTO_CAMELLIA is not set
+# CONFIG_CRYPTO_CAST5 is not set
+# CONFIG_CRYPTO_CAST6 is not set
+# CONFIG_CRYPTO_DES is not set
+# CONFIG_CRYPTO_FCRYPT is not set
+# CONFIG_CRYPTO_KHAZAD is not set
+# CONFIG_CRYPTO_SALSA20 is not set
+# CONFIG_CRYPTO_CHACHA20 is not set
+# CONFIG_CRYPTO_SEED is not set
+# CONFIG_CRYPTO_SERPENT is not set
+# CONFIG_CRYPTO_TEA is not set
+# CONFIG_CRYPTO_TWOFISH is not set
+
+#
+# Compression
+#
+# CONFIG_CRYPTO_DEFLATE is not set
+# CONFIG_CRYPTO_ZLIB is not set
+# CONFIG_CRYPTO_LZO is not set
+# CONFIG_CRYPTO_842 is not set
+# CONFIG_CRYPTO_LZ4 is not set
+# CONFIG_CRYPTO_LZ4HC is not set
+
+#
+# Random Number Generation
+#
+# CONFIG_CRYPTO_ANSI_CPRNG is not set
+CONFIG_CRYPTO_DRBG_MENU=y
+CONFIG_CRYPTO_DRBG_HMAC=y
+# CONFIG_CRYPTO_DRBG_HASH is not set
+# CONFIG_CRYPTO_DRBG_CTR is not set
+CONFIG_CRYPTO_DRBG=y
+CONFIG_CRYPTO_JITTERENTROPY=y
+# CONFIG_CRYPTO_USER_API_HASH is not set
+# CONFIG_CRYPTO_USER_API_SKCIPHER is not set
+# CONFIG_CRYPTO_USER_API_RNG is not set
+# CONFIG_CRYPTO_USER_API_AEAD is not set
+# CONFIG_CRYPTO_HW is not set
+
+#
+# Certificates for signature checking
+#
+# CONFIG_ARM_CRYPTO is not set
+# CONFIG_BINARY_PRINTF is not set
+
+#
+# Library routines
+#
+CONFIG_BITREVERSE=y
+# CONFIG_HAVE_ARCH_BITREVERSE is not set
+CONFIG_RATIONAL=y
+CONFIG_GENERIC_STRNCPY_FROM_USER=y
+CONFIG_GENERIC_STRNLEN_USER=y
+CONFIG_GENERIC_NET_UTILS=y
+CONFIG_GENERIC_PCI_IOMAP=y
+CONFIG_GENERIC_IO=y
+CONFIG_ARCH_USE_CMPXCHG_LOCKREF=y
+# CONFIG_CRC_CCITT is not set
+# CONFIG_CRC16 is not set
+# CONFIG_CRC_T10DIF is not set
+# CONFIG_CRC_ITU_T is not set
+CONFIG_CRC32=y
+# CONFIG_CRC32_SELFTEST is not set
+CONFIG_CRC32_SLICEBY8=y
+# CONFIG_CRC32_SLICEBY4 is not set
+# CONFIG_CRC32_SARWATE is not set
+# CONFIG_CRC32_BIT is not set
+# CONFIG_CRC7 is not set
+CONFIG_LIBCRC32C=y
+# CONFIG_CRC8 is not set
+# CONFIG_AUDIT_ARCH_COMPAT_GENERIC is not set
+# CONFIG_RANDOM32_SELFTEST is not set
+CONFIG_ZLIB_INFLATE=y
+CONFIG_ZLIB_DEFLATE=y
+CONFIG_XZ_DEC=y
+# CONFIG_XZ_DEC_X86 is not set
+# CONFIG_XZ_DEC_POWERPC is not set
+# CONFIG_XZ_DEC_IA64 is not set
+CONFIG_XZ_DEC_ARM=y
+CONFIG_XZ_DEC_ARMTHUMB=y
+# CONFIG_XZ_DEC_SPARC is not set
+CONFIG_XZ_DEC_BCJ=y
+# CONFIG_XZ_DEC_TEST is not set
+CONFIG_GENERIC_ALLOCATOR=y
+CONFIG_HAS_IOMEM=y
+CONFIG_HAS_IOPORT_MAP=y
+CONFIG_HAS_DMA=y
+CONFIG_DQL=y
+CONFIG_NLATTR=y
+CONFIG_GENERIC_ATOMIC64=y
+CONFIG_ARCH_HAS_ATOMIC64_DEC_IF_POSITIVE=y
+# CONFIG_CORDIC is not set
+# CONFIG_DDR is not set
+CONFIG_LIBFDT=y
+# CONFIG_SG_SPLIT is not set
+# CONFIG_ARCH_HAS_SG_CHAIN is not set
+# CONFIG_VIRTUALIZATION is not set
diff --git a/arch/arm/mach-anycloudv500/Kconfig b/arch/arm/mach-anycloudv500/Kconfig
new file mode 100755
index 0000000..029a95a
--- /dev/null
+++ b/arch/arm/mach-anycloudv500/Kconfig
@@ -0,0 +1,13 @@
+# linux/arch/arm/mach-anycloudv500/Kconfig
+#
+# Copyright 2018 Anyka Microelectronics
+#
+# Licensed under GPLv2
+
+# Machine support
+
+config MACH_AK3790D
+	bool "ANYCLOUDV500 Socs support"
+	depends on ARCH_AK
+	help
+	  Support for AK3790D
diff --git a/arch/arm/mach-anycloudv500/Makefile b/arch/arm/mach-anycloudv500/Makefile
new file mode 100755
index 0000000..73f6925
--- /dev/null
+++ b/arch/arm/mach-anycloudv500/Makefile
@@ -0,0 +1,11 @@
+#linux/arch/arm/mach-ak39/Makefile
+#
+# Copyright 2013 Anyka Microelectronics
+#
+# Licensed under GPLv2
+
+# Core support for all Anyka SoCs
+obj-y		    += ak_l2.o
+
+# Machin support
+obj-$(CONFIG_MACH_AK3790D)	   += anycloudv500.o
diff --git a/arch/arm/mach-anycloudv500/Makefile.boot b/arch/arm/mach-anycloudv500/Makefile.boot
new file mode 100755
index 0000000..bef051b
--- /dev/null
+++ b/arch/arm/mach-anycloudv500/Makefile.boot
@@ -0,0 +1,2 @@
+   zreladdr-y	:= 0x80008000
+params_phys-y	:= 0x80000100
diff --git a/arch/arm/mach-anycloudv500/ak_l2.c b/arch/arm/mach-anycloudv500/ak_l2.c
new file mode 100755
index 0000000..868ca8a
--- /dev/null
+++ b/arch/arm/mach-anycloudv500/ak_l2.c
@@ -0,0 +1,1289 @@
+/*
+ * /linux/arch/arm/mach-ak39/l2.c
+ *
+ * Copyright (C) 2018 Anyka(Guangzhou) Microelectronics Technology Co., Ltd.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+
+#include <linux/module.h>
+#include <linux/ioport.h>
+#include <linux/delay.h>
+#include <linux/interrupt.h>
+#include <linux/dma-mapping.h>
+#include <linux/clk.h>
+#include <linux/err.h>
+#include <linux/stddef.h>
+#include <linux/irq.h>
+#include <linux/sched.h>
+ 
+#include <asm/dma.h>
+#include <asm/sizes.h>
+
+#include <mach/ak_l2.h>
+
+#define L2_DEBUG		1
+//#undef L2_DEBUG
+extern struct raw_notifier_head netdev_chain;
+
+#define vL2DMA_ADDRBUF0         (AK_VA_L2CTRL + 0x00)
+#define vL2DMA_CONBUF0          (AK_VA_L2CTRL + 0x40)
+
+#define L2_DMA_ADDR				(AK_VA_L2CTRL + 0x00)
+#define L2_DMA_CON				(AK_VA_L2CTRL + 0x40)
+#define L2_DMAREQ				(AK_VA_L2CTRL + 0x80)
+#define L2_FRACDMAADDR			(AK_VA_L2CTRL + 0x84)
+#define L2_CONBUF0_7			(AK_VA_L2CTRL + 0x88)  
+#define L2_CONBUF8_15			(AK_VA_L2CTRL + 0x8C) 
+#define L2_BUFASSIGN1			(AK_VA_L2CTRL + 0x90) 
+#define L2_BUFASSIGN2			(AK_VA_L2CTRL + 0x94) 
+#define L2_LDMACON				(AK_VA_L2CTRL + 0x98) 
+#define L2_BUFINTEN				(AK_VA_L2CTRL + 0x9C) 
+#define L2_BUFSTAT1				(AK_VA_L2CTRL + 0xA0) 
+#define L2_BUFSTAT2				(AK_VA_L2CTRL + 0xA8) 
+
+/*************************** L2 MEMORY CONTROL *********************/
+#define rL2_DMAREQ              (AK_VA_L2CTRL + 0x80)
+#define rL2_FRACDMAADDR         (AK_VA_L2CTRL + 0x84)
+#define rL2_CONBUF0_7           (AK_VA_L2CTRL + 0x88)  
+#define rL2_CONBUF8_15          (AK_VA_L2CTRL + 0x8C) 
+#define rL2_BUFASSIGN1          (AK_VA_L2CTRL + 0x90) 
+#define rL2_BUFASSIGN2          (AK_VA_L2CTRL + 0x94) 
+#define rL2_LDMACON             (AK_VA_L2CTRL + 0x98) 
+#define rL2_BUFINTEN            (AK_VA_L2CTRL + 0x9C) 
+#define rL2_BUFSTAT1            (AK_VA_L2CTRL + 0xA0) 
+#define rL2_BUFSTAT2			(AK_VA_L2CTRL + 0xA8) 
+
+/*************************** L2 MEMORY BUFFER **********************/
+#define rL2_ADDRBUF0            (AK_VA_L2MEM + 0x0000)
+#define rL2_ADDRBUF1            (AK_VA_L2MEM + 0x0200)
+#define rL2_ADDRBUF2            (AK_VA_L2MEM + 0x0400)
+#define rL2_ADDRBUF3            (AK_VA_L2MEM + 0x0600)
+#define rL2_ADDRBUF4            (AK_VA_L2MEM + 0x0800)
+#define rL2_ADDRBUF5            (AK_VA_L2MEM + 0x0A00)
+#define rL2_ADDRBUF6            (AK_VA_L2MEM + 0x0C00)
+#define rL2_ADDRBUF7            (AK_VA_L2MEM + 0x0E00)
+
+#define rL2_ADDRTX1_BUF8        (AK_VA_L2MEM + 0x1000)
+#define rL2_ADDRRX1_BUF9        (AK_VA_L2MEM + 0x1080)
+#define rL2_ADDRTX2_BUF10       (AK_VA_L2MEM + 0x1100)
+#define rL2_ADDRRX2_BUF11       (AK_VA_L2MEM + 0x1180)
+
+#define	write_ramb(v, p)		(*(volatile unsigned char *)(p) = (v))
+#define write_ramw(v, p)		(*(volatile unsigned short *)(p) = (v))
+#define write_raml(v, p)		(*(volatile unsigned long *)(p) = (v))
+
+#define read_ramb(p)			(*(volatile unsigned char *)(p))
+#define read_ramw(p)			(*(volatile unsigned short *)(p))
+#define read_raml(p)			(*(volatile unsigned long *)(p))
+
+
+static l2_buffer_info_t l2_buffer_info[L2_COMMON_BUFFER_NUM];
+static l2_dma_info_t l2_dma_info[L2_COMMON_BUFFER_NUM + L2_UART_BUFFER_NUM];
+static bool l2_frac_started = false;	/* L2 fraction DMA start flag */
+
+static l2_device_info_t l2_device_info[] = {
+	{ ADDR_USB_EP1,		BUF_NULL },
+	{ ADDR_USB_EP2,		BUF_NULL },
+	{ ADDR_USB_EP3,		BUF_NULL },
+	{ ADDR_RESERVED,	BUF_NULL },
+	{ ADDR_MMC0,		BUF_NULL },
+	{ ADDR_MMC1,		BUF_NULL },
+	{ ADDR_MMC2,		BUF_NULL },
+	//{ ADDR_RESERVED,	BUF_NULL },
+	{ ADDR_SPI1_RX,		BUF_NULL },
+	{ ADDR_SPI1_TX,		BUF_NULL },
+	{ ADDR_DAC,			BUF_NULL },
+	{ ADDR_SPI2_RX,		BUF_NULL },
+	{ ADDR_SPI2_TX,		BUF_NULL },
+	{ ADDR_GPS,			BUF_NULL },
+	{ ADDR_PCM_TX,		BUF_NULL },
+	{ ADDR_ADC,			BUF_NULL },
+	{ ADDR_USB_EP4, 	BUF_NULL },
+	{ ADDR_RESERVED, 	BUF_NULL },
+};
+
+static int l2_wait = 0;
+static wait_queue_head_t l2_wq;
+
+static void l2_combuf_ctrl(u8 id, bool enable);
+static void l2_select_combuf(l2_device_t device, u8 id);
+static void l2_assert_combuf_id(u8 id);
+static void l2_assert_buf_id(u8 id);
+static void l2_clear_dma(u8 id);
+static void l2_frac_dma(unsigned long ram_addr, u8 id, u8 frac_offset,
+	unsigned int bytes, l2_dma_transfer_direction_t direction, bool intr_enable);
+static void l2_get_addr(u8 id, void __iomem ** bufaddr);
+static bool l2_get_dma_param(unsigned int bytes, unsigned int *low, unsigned int *high);
+static void l2_dma(unsigned long ram_addr, u8 id, unsigned int bytes,
+		l2_dma_transfer_direction_t direction, bool intr_enable);
+static bool l2_wait_dma_finish(u8 id);
+static void l2_cpu(unsigned long ram_addr, u8 id,
+	unsigned long buf_offset, unsigned int bytes, l2_dma_transfer_direction_t direction);
+static irqreturn_t l2_interrupt_handler(int irq, void *dev_id);
+
+#ifdef L2_DEBUG
+#define L2_PRINT_FUNCLINES() do { printk("%s(): line: %d\n", __func__, __LINE__); } while (0)
+
+//static inline void l2_dump_registers(void)
+void l2_dump_registers(void)
+{
+	printk("ANYKA L2 Register Dumping Begin:\n");
+	printk("  rL2_DMAREQ(C080)        = 0x%08X, rL2_FRACDMAADDR(C084)     = 0x%0X\n",__raw_readl(rL2_DMAREQ), __raw_readl(rL2_FRACDMAADDR));
+	printk("  rL2_CONBUF0_7(C088) = 0x%08X, rL2_CONBUF8_15(C08C) = 0x%0X\n",__raw_readl(rL2_CONBUF0_7), __raw_readl(rL2_CONBUF8_15));
+	printk("  rL2_BUFASSIGN1(C090)    = 0x%08X, rL2_BUFINTEN(C09C)  = 0x%0X\n",__raw_readl(rL2_BUFASSIGN1), __raw_readl(rL2_BUFINTEN));
+	printk("  rL2_BUFSTAT1(C0A0)      = 0x%08X, rL2_BUFSTAT2(C0A8)    = 0x%0X\n",__raw_readl(rL2_BUFSTAT1), __raw_readl(rL2_BUFSTAT2));
+	printk("ANYKA L2 Register Dumping End.\n");
+}
+
+static inline void l2_print_array(const char *name, unsigned char *array, int len)
+{
+	int i;
+
+	printk("%s[%d] = {\n ", name, len);
+	for (i = 0; i < len; i++) {
+		printk(" 0x%02X,", array[i]);
+		if (i % 16 == 15)
+			printk("\n ");
+	}
+	printk("};\n");
+
+}
+
+#else
+#define L2_PRINT_FUNCLINES() do { } while (0)
+
+static inline void l2_dump_registers(void)
+{
+}
+static inline void l2_print_array(const char *name, unsigned int *array, int len)
+{
+}
+#endif
+
+/**
+ * l2_assert_buf_id - Assert a L2 buffer ID is valid
+ *  @id:		L2 buffer ID
+ *
+ *  NOTE: Assert only L2 common buffer and UART buffer, USB buffer is not checked.
+ *            Since this function is called internally by other L2 API, invalid id will cause
+ *            linux kernel to oops for bug tracking.
+ */
+static void l2_assert_buf_id(u8 id)
+{
+	if (id >= L2_COMMON_BUFFER_NUM + L2_UART_BUFFER_NUM)
+		BUG();
+}
+
+/**
+ * l2_assert_combuf_id - Assert a L2 common buffer ID is valid
+ *  @id:		L2 buffer ID
+ *
+ *  NOTE: Assert only L2 common buffer, UART & USB buffer is not checked.
+ *            Since this function is called internally by other L2 API, invalid id will cause
+ *            linux kernel to oops for bug tracking.
+ */
+static void l2_assert_combuf_id(u8 id)
+{
+	if (id >= L2_COMMON_BUFFER_NUM)
+		BUG();
+}
+
+/**
+ * l2_combuf_ctrl - L2 buffer enable/disable
+ *  @id:		L2 buffer ID
+ *  @enable:	true to enable L2 buffer, false to disable L2 buffer 
+ */
+static void l2_combuf_ctrl(u8 id, bool enable)
+{
+	unsigned long regval;
+	unsigned long flags;
+
+	l2_assert_buf_id(id);
+
+	local_irq_save(flags);
+	
+	regval = __raw_readl(rL2_CONBUF0_7);
+	if (enable) {
+		/* Enable L2 buffer & L2 Buffer DMA */
+		regval |= (1 << (id + L2_COMMON_BUF_CFG_BUF_DMA_VLD_START)) |
+			(1 << (id + L2_COMMON_BUF_CFG_BUF_VLD_START));
+	} else {
+		/* Disable L2 buffer & L2 Buffer DMA */
+		regval &= ~((1 << (id + L2_COMMON_BUF_CFG_BUF_DMA_VLD_START)) |
+			(1 << (id + L2_COMMON_BUF_CFG_BUF_VLD_START)));
+	}
+	//rL2_CONBUF0_7 = regval;
+	__raw_writel(regval, rL2_CONBUF0_7);
+
+	local_irq_restore(flags);
+
+}
+
+/**
+ * l2_select_combuf - Select a L2 buffer for given device
+ *  @device:	Device which need to assign a L2 buffer
+ *  @id:		L2 buffer ID
+ */
+static void l2_select_combuf(l2_device_t device, u8 id)
+{
+	unsigned long regval;
+	unsigned long bits_offset;
+	
+	l2_assert_combuf_id(id);
+
+	if ((u8)device < 10) {
+		/*
+		 * USB Bulkout ~ DAC (Device 0 ~ 9) is controlled by Buffer Assignment Register 1
+		 */
+		regval = __raw_readl(rL2_BUFASSIGN1);
+		bits_offset = (u8)device * 3;
+		regval &= ~(0x7 << bits_offset);
+		regval |= ((id & 0x7) << bits_offset);
+		//rL2_BUFASSIGN1 = regval;
+		__raw_writel(regval, rL2_BUFASSIGN1);
+		
+	} else {
+		/*
+		 * SPI2 Rx ~ ADC (Device 10 ~ 14) is controlled by Buffer Assignment Register 2
+		 */
+		regval = __raw_readl(rL2_BUFASSIGN2);
+		bits_offset = ((u8)device - 10) * 3;
+		regval &= ~(0x7 << bits_offset);
+		regval |= ((id & 0x7) << bits_offset);
+		//rL2_BUFASSIGN2 = regval;
+		__raw_writel(regval, rL2_BUFASSIGN2);
+	}
+
+}
+
+
+/**
+ * l2_deselect_combuf - deselect a L2 buffer for given device
+ *  @device:	Device which need to assign a L2 buffer
+ *  @id:		L2 buffer ID
+ *
+ * note: buffer 0 is reserved for softuse, no hardware is assigned
+ *          so when free a l2 buffer, select to this device use buffer 0 as deselect
+ */
+static void l2_deselect_combuf(l2_device_t device, u8 id)
+{
+	unsigned long regval;
+	unsigned long bits_offset;
+	
+	l2_assert_combuf_id(id);
+
+	if ((u8)device < 10) {
+		/*
+		 * USB Bulkout ~ DAC (Device 0 ~ 9) is controlled by Buffer Assignment Register 1
+		 */
+		regval = __raw_readl(rL2_BUFASSIGN1);
+		bits_offset = (u8)device * 3;
+		regval &= ~(0x7 << bits_offset);
+		//rL2_BUFASSIGN1 = regval;
+		__raw_writel(regval, rL2_BUFASSIGN1);
+	} else {
+		/*
+		 * SPI2 Rx ~ ADC (Device 10 ~ 14) is controlled by Buffer Assignment Register 2
+		 */
+		regval = __raw_readl(rL2_BUFASSIGN2);
+		bits_offset = ((u8)device - 10) * 3;
+		regval &= ~(0x7 << bits_offset);
+		//rL2_BUFASSIGN2 = regval;
+		__raw_writel(regval, rL2_BUFASSIGN2);
+	}
+
+}
+
+/**
+ * l2_clear_dma - Clear L2 buffer DMA status
+ *  @id:		L2 buffer ID which need to clear DMA status
+ */
+static void l2_clear_dma(u8 id)
+{
+	bool dmapending;
+	u8 status;
+
+	dmapending = __raw_readl(rL2_DMAREQ) & (1 << (id + L2_DMA_REQ_BUF_START));
+	status = l2_get_status(id);
+
+	if (status == 0) {
+		return ;	/* NO DMA request, so do nothing */
+	}
+	
+	if(l2_dma_info[id].direction == BUF2MEM) {
+		pr_err("#hd#l2r:[%d]..", id); 
+		while (dmapending) {
+			l2_set_status(id, 8);
+			dmapending = __raw_readl(rL2_DMAREQ) & (1 << (id + L2_DMA_REQ_BUF_START));
+		}
+		pr_err("done\n");
+	} else {
+		/*
+		 * Wait until DMA request of this L2 buffer is finished.
+		 */
+		pr_info("l2t:[%d]..", id);
+		while (dmapending) {
+			l2_clr_status(id);
+			dmapending = __raw_readl(rL2_DMAREQ) & (1 << (id + L2_DMA_REQ_BUF_START));
+		}
+		pr_info("done\n");
+	}
+}
+
+/**
+ * l2_frac_dma - Start data tranferring between memory and l2 common buffer in fraction DMA mode
+ *  @ram_addr:		External RAM address(Physical)
+ *  @id:		L2 buffer ID involved in DMA transfer
+ *  @frac_offset:	The region offset between buffer start address and transfer start address
+ *  @bytes:		Data transfer size
+ *  @direction:		Data transfer direction between L2 memory and external RAM 
+ *  @intr_enable:	Open interrupt for this L2 buffer or not
+ *
+ *  NOTE: Data transfer size should be 1~64Bytes, frac_offset should be 0~7 (*64Bytes)
+ */
+static void l2_frac_dma(unsigned long ram_addr, u8 id, u8 frac_offset,
+	unsigned int bytes, l2_dma_transfer_direction_t direction,	bool intr_enable)
+{
+	u32 bufaddr;
+	u32 highaddr;
+	unsigned long regval;
+	unsigned long flags;
+
+#if 0
+	pr_info("%s(): ram_addr=0x%08X, l2 buffer id=%d, frac_offset=%d, bytes=%d, direction=%s, intr_enable=%d.\n",
+		__func__, (unsigned int)ram_addr, id, frac_offset, bytes, (direction == BUF2MEM)?"BUF2MEM":"MEM2BUF", intr_enable);
+#endif
+
+	if (bytes == 0) {
+		pr_err("l2: no need to start fraction dma transfer: bytes=0.\n");
+		return ;
+	}
+
+	local_irq_save(flags);
+
+	/*
+	 * Set fraction external RAM address.
+	 */
+	highaddr = (ram_addr << 2) & 0xC0000000;
+	 
+	regval = __raw_readl(rL2_FRACDMAADDR);
+	regval &= ~(L2_FRAC_DMA_LOW_ADDR_MASK | (3<<30)); //modified by anyka chenyingyu
+	regval |= (ram_addr & L2_FRAC_DMA_LOW_ADDR_MASK) | highaddr;
+	//rL2_FRACDMAADDR = regval;
+	__raw_writel(regval, rL2_FRACDMAADDR);
+
+	/* Set fraction DMA address */
+	bufaddr = (id < L2_COMMON_BUFFER_NUM) ? ((id & 0x7) << 3) | (frac_offset & 0x7) :
+		(0x40 + ((id - L2_COMMON_BUFFER_NUM) << 1)) | (frac_offset & 0x1);
+
+	/* Clear other fraction DMA request and info */
+	regval = __raw_readl(rL2_DMAREQ);
+	regval &= ~(L2_DMA_REQ_FRAC_DMA_LEN_MASK | L2_DMA_REQ_FRAC_DMA_L2_ADDR_MASK |
+		L2_DMA_REQ_FRAC_DMA_REQ | L2_DMA_REQ_BUF_REQ_MASK);
+
+	switch (direction) {
+	case MEM2BUF:
+		if (bytes & 0x1)
+			bytes = bytes + 1;	/* Round to even number when read data from external ram */
+		regval |= L2_DMA_REQ_FRAC_DMA_REQ | L2_DMA_REQ_FRAC_DMA_DIR_WR |
+			(bufaddr << L2_DMA_REQ_FRAC_DMA_L2_ADDR_START) |
+			((bytes - 1) << L2_DMA_REQ_FRAC_DMA_LEN_START);
+		//rL2_DMAREQ = regval;
+		__raw_writel(regval, rL2_DMAREQ);
+		break;
+	case BUF2MEM:
+		regval &= ~(L2_DMA_REQ_FRAC_DMA_DIR_WR);
+		regval |= L2_DMA_REQ_FRAC_DMA_REQ |
+			(bufaddr << L2_DMA_REQ_FRAC_DMA_L2_ADDR_START) |
+			((bytes - 1) << L2_DMA_REQ_FRAC_DMA_LEN_START);
+		//rL2_DMAREQ = regval;
+		__raw_writel(regval, rL2_DMAREQ);
+		break;
+	default:
+		BUG();
+	}
+
+	if (intr_enable) {
+		regval = __raw_readl(rL2_BUFINTEN);
+		regval |= L2_DMA_INTR_ENABLE_FRAC_INTR_EN;
+		//rL2_BUFINTEN = regval;
+		__raw_writel(regval, rL2_BUFINTEN);
+	}
+
+	local_irq_restore(flags);
+}
+
+/**
+ * l2_get_addr - Get L2 memory start address for given L2 buffer
+ *  @id:		L2 buffer ID
+ *  Return L2 memory start address(Logical/Virtual) (NOT physical address)
+ */
+static void l2_get_addr(u8 id, void __iomem ** bufaddr)
+{
+	if (id < L2_UART_BUFFER_INDEX) {	/* L2 common buffer */
+		*bufaddr = AK_VA_L2MEM + L2_COMMON_BUFFER_OFFSET +
+			id * L2_COMMON_BUFFER_LEN;
+
+	} else if (id < L2_USB_HOST_BUFFER_INDEX) {	/* UART L2 buffer */
+		*bufaddr = AK_VA_L2MEM + L2_UART_BUFFER_OFFSET + 
+			(id - L2_COMMON_BUFFER_NUM) * L2_UART_BUFFER_LEN;
+	} else {
+		pr_err("l2: invalid buffer id %d.\n", (int)id);
+	}
+}
+/**
+ * l2_get_dma_param - Calculate l2 buffer big loop/small loop counter value
+ *  @bytes:		L2 buffer ID
+ *  @low:			CNT_cfg (bit[7:0] of DMA Operation Times Configuration Register)
+ *  @high:		CNT_cfg_H (bit[23:16] of DMA Operation Times Configuration Register)
+ *  Return true when correct counter value (high/low) is found, else return false.
+ *
+ *  NOTE: Use a simplified calculation method for L2 buffer 0~7 and 8~15 for bytes > 8KB
+ */
+static bool l2_get_dma_param(unsigned int bytes, unsigned int *low, unsigned int *high)
+{
+	unsigned int factor;
+	unsigned int dma_times = bytes / DMA_ONE_SHOT_LEN;
+
+	if (bytes <= 8 * 1024) {
+		*low = dma_times;
+		*high = 0;
+
+		return true;
+	} else if (dma_times & 0x7) {
+		pr_err("l2: Invalid L2 DMA buffer size(%u).\n", bytes);
+		return false;
+	}
+
+	factor = 16 * 8;
+
+	while (factor > 0) {
+		if ((dma_times % factor) == 0) {
+			*low = factor;
+			*high = dma_times / factor - 1;
+
+			return (*high < 0xFF) ? true : false;
+		}
+
+		factor -= 8;
+	}
+	
+	return false;
+}
+
+
+/**
+ * l2_dma - Start data tranferring between memory and l2 buffer in DMA mode
+ *  @ram_addr:		External RAM address(Physical)
+ *  @id:		L2 buffer ID involved in DMA transfer
+ *  @bytes:		Data transfer size
+ *  @direction:		Data transfer direction between L2 memory and external RAM 
+ *  @intr_enable:	Open interrupt for this L2 buffer or not
+ */
+static void l2_dma(unsigned long ram_addr, u8 id, unsigned int bytes,
+	l2_dma_transfer_direction_t direction, bool intr_enable)
+{
+	//unsigned long regid;
+	unsigned long regval;
+	unsigned long flags;
+	unsigned int cnt_low;
+	unsigned int cnt_high;
+
+#if 0
+	pr_info("%s(): ram_addr=0x%0X, id=%d, bytes=%d, direction=%d, intr_enable=%d.\n",
+		__func__, (unsigned int)ram_addr, id, bytes, direction, intr_enable);
+#endif
+	if (bytes == 0) {
+		pr_err("l2: no need to start dma transfer: bytes=0.\n");
+		return ;
+	}
+
+	if (!l2_get_dma_param(bytes, &cnt_low, &cnt_high)) {
+		pr_err("l2: L2 DMA buffer size error: bytes=%d.\n", bytes);
+		return ;
+	}
+	
+	if (l2_dma_info[id].dma_start || l2_dma_info[id].dma_frac_start) {
+		pr_err("l2: unable to start dma, dma NOT finished, buf id=%d.\n", (int)id);
+		return ;
+	}
+
+	l2_dma_info[id].dma_op_times = bytes / DMA_ONE_SHOT_LEN;
+	l2_dma_info[id].dma_frac_data_len = bytes % DMA_ONE_SHOT_LEN;
+	l2_dma_info[id].dma_addr = (void *)ram_addr;
+	l2_dma_info[id].direction = direction;
+	l2_dma_info[id].intr_enable = intr_enable;
+	l2_dma_info[id].need_frac = false;
+
+	if (l2_dma_info[id].dma_frac_data_len > 0) {
+		l2_dma_info[id].need_frac = true;
+		l2_dma_info[id].dma_frac_addr = (void *)(u8 *)l2_dma_info[id].dma_addr +
+			l2_dma_info[id].dma_op_times* DMA_ONE_SHOT_LEN;
+		l2_dma_info[id].dma_frac_offset = l2_dma_info[id].dma_op_times;
+	}
+
+	if (l2_dma_info[id].dma_op_times== 0) {
+		/*
+		 * If DMA transfer size < 64, we start fraction DMA immediately.
+		 */
+		 
+		l2_dma_info[id].dma_start = false;
+		l2_dma_info[id].dma_frac_start = true;
+
+		l2_frac_dma((unsigned long)l2_dma_info[id].dma_frac_addr, id,
+			l2_dma_info[id].dma_frac_offset, l2_dma_info[id].dma_frac_data_len,
+			l2_dma_info[id].direction, intr_enable);
+		return ;
+	}
+	l2_dma_info[id].dma_start = true;
+
+	local_irq_save(flags);
+
+	asm("MMU_Clean_Invalidate_Dcache:\n" "mrc  p15,0,r15,c7,c14,3\n" "bne MMU_Clean_Invalidate_Dcache"); 
+
+	/*
+	 * Set address of external RAM
+	 */
+	regval = (unsigned long)l2_dma_info[id].dma_addr;
+	//regid = vL2DMA_ADDRBUF0 + id * 4;
+	__raw_writel(regval, vL2DMA_ADDRBUF0 + id * 4);
+
+	/*
+	 * Set DMA operation times
+	 */
+	//regid = (unsigned long);
+	regval = (cnt_high << 16) | (cnt_low & 0xFF);
+	__raw_writel(regval, vL2DMA_CONBUF0 + id * 4);
+
+	/*
+	 * Set DMA direction for L2 common buffer
+	 */
+	if (id < L2_COMMON_BUFFER_NUM) {
+		regval = __raw_readl(rL2_CONBUF0_7);
+		
+		if (l2_dma_info[id].direction == MEM2BUF) {
+			regval |= (1 << (id + L2_COMMON_BUF_CFG_BUF_DIR_START));;
+		} else {
+			regval &= ~(1 << (id + L2_COMMON_BUF_CFG_BUF_DIR_START)); 
+		}
+		//rL2_CONBUF0_7 = regval;
+		__raw_writel(regval, rL2_CONBUF0_7);
+	}
+
+	
+	/*
+	 * Start buffer DMA request
+	 */
+	regval = __raw_readl(rL2_DMAREQ);	
+	regval &= ~(L2_DMA_REQ_FRAC_DMA_REQ | L2_DMA_REQ_BUF_REQ_MASK);
+	if (id < L2_COMMON_BUFFER_NUM) {
+		regval |= (1 << (id + L2_DMA_REQ_BUF_START));
+	} else {
+		regval |= (1 << ((id - L2_UART_BUF_START_ID + L2_UART_BUF_CFG_BUF_START)));
+	}
+	//rL2_DMAREQ = regval;
+	__raw_writel(regval, rL2_DMAREQ);
+
+	
+	/*
+	 * Enable DMA interrupt now
+	 */
+	if (intr_enable) {
+		regval = __raw_readl(rL2_BUFINTEN);
+		if (id < L2_COMMON_BUFFER_NUM) {
+			regval |= 1 << (id + L2_DMA_INTR_ENABLE_BUF_START);
+		} else {
+			regval |= 1 << (id - L2_COMMON_BUFFER_NUM + L2_DMA_INTR_ENABLE_UART_BUF_START);
+		}
+		//rL2_BUFINTEN = regval;
+		__raw_writel(regval, rL2_BUFINTEN);
+	}
+
+	local_irq_restore(flags);
+}
+
+/**
+ * l2_wait_dma_finish - Wait for L2 DMA to finish
+ *  @id:	L2 buffer ID involved in DMA transfer
+ *  Return true: DMA transfer finished successfully.
+ *            false: DMA transfer failed.
+ *  NOTE: DMA transfer is started by l2_dma.
+ */
+static bool l2_wait_dma_finish(u8 id)
+{
+	unsigned int timeout;
+	unsigned long dmareq;
+	unsigned long dma_bit;
+	const unsigned int max_wait_time = L2_MAX_DMA_WAIT_TIME;
+
+	timeout = 0;
+	if (l2_dma_info[id].dma_start) {
+		dma_bit = (id < L2_COMMON_BUFFER_NUM) ? (1 << (id + L2_DMA_REQ_BUF_START)) :
+			(1 << (id - L2_COMMON_BUFFER_NUM + L2_DMA_REQ_UART_BUF_REQ_START));
+		do {
+			dmareq = __raw_readl(rL2_DMAREQ);
+		} while((dmareq & dma_bit) && timeout++ < max_wait_time);
+
+		l2_dma_info[id].dma_start = false;
+		pr_debug("l2: dma_bit=%lx,buf id=%d, status=%d\n", dma_bit, id, l2_get_status(id));
+		if (timeout >= max_wait_time) {
+			pr_err("l2: wait dma timeout, buf id=%d, status=%d.\n", id, l2_get_status(id));
+			l2_clear_dma(id);
+			__raw_writel(0x0, vL2DMA_CONBUF0 + id * 4);
+			return false;
+		}
+
+		/*
+		 * If fraction DMA  is NOT need, then everything is done.
+		 */
+		if (!l2_dma_info[id].need_frac) {
+			return true;
+		}	
+
+
+		/*
+		 * Start fraction DMA here for remain bytes transfer (<64Bytes).
+		 */
+		l2_dma_info[id].dma_frac_start = true;
+		l2_frac_dma((unsigned long)l2_dma_info[id].dma_frac_addr, id,
+			l2_dma_info[id].dma_frac_offset, l2_dma_info[id].dma_frac_data_len,
+			l2_dma_info[id].direction, false);
+
+	}
+
+	/*
+	 * Fraction DMA handling starts here.
+	 */
+	if (l2_dma_info[id].dma_frac_start) {
+		timeout = 0;
+		do {
+			dmareq = __raw_readl(rL2_DMAREQ);
+		} while((dmareq & L2_DMA_REQ_FRAC_DMA_REQ) && (timeout++ < max_wait_time));
+
+		l2_dma_info[id].dma_frac_start = false;
+
+		if (timeout >= max_wait_time) {
+			pr_err("l2:wait frac dma timeout, buf id=%d, status=%d.\n", id, l2_get_status(id));
+			return false;
+		}
+
+		if ((l2_dma_info[id].direction == MEM2BUF) && 
+			(l2_dma_info[id].dma_frac_data_len < 60)) {
+
+			void __iomem * bufaddr;
+
+			l2_get_addr(id, &bufaddr);
+			__raw_writel(0, bufaddr + (l2_dma_info[id].dma_frac_offset & 0x1FF) + 60);
+		}
+	}
+
+	return true;
+}
+
+/**
+ * l2_interrupt_handler - L2 memory interrupt handler
+ *  @irq:	IRQ number for L2 memory (Must be IRQ_L2MEM)
+ *  @dev_id:	Device specific information used by interrupt handler
+ *
+ *  NOTE: Only shared IRQ need to check @irq & @dev_id.
+ *            No need to check them here since L2 memory IRQ is NOT shared IRQ.
+ */
+static irqreturn_t l2_interrupt_handler(int irq, void *dev_id)
+{
+	unsigned long regval;
+	int i = 0;
+	//printk("enter %s\n", __FUNCTION__);
+	regval = __raw_readl(rL2_DMAREQ);
+
+	for (i = 0; i < L2_COMMON_BUFFER_NUM; i++) {
+		unsigned long dmapending = regval & (1 << ( i + L2_DMA_REQ_BUF_START));
+
+		if (l2_dma_info[i].dma_start && !dmapending) {
+			if (!l2_frac_started && l2_dma_info[i].need_frac) {
+				l2_dma_info[i].dma_frac_start = true;
+				l2_dma_info[i].dma_start = false;
+
+				l2_frac_dma((unsigned long)l2_dma_info[i].dma_frac_addr, i,
+					l2_dma_info[i].dma_frac_offset, l2_dma_info[i].dma_frac_data_len,
+					l2_dma_info[i].direction, true);
+
+				l2_frac_started = true;
+			} else {
+				/* DMA has finished */
+				unsigned long regval;
+
+				regval = __raw_readl(rL2_BUFINTEN);
+				regval &= ~(1 << (i + L2_DMA_INTR_ENABLE_BUF_START));
+				//rL2_BUFINTEN = regval;
+				__raw_writel(regval, rL2_BUFINTEN);
+
+				l2_dma_info[i].dma_start = false;
+
+				if (l2_dma_info[i].callback_func != NULL)
+					l2_dma_info[i].callback_func(l2_dma_info[i].data);
+				
+			}
+		}
+
+		if (l2_dma_info[i].dma_frac_start) {
+			unsigned long frac_dmapending = regval & L2_DMA_REQ_FRAC_DMA_REQ;
+			if (l2_frac_started && !frac_dmapending) {
+				l2_frac_started = false;
+
+				switch (l2_dma_info[i].direction) {
+				case MEM2BUF:
+					if (l2_dma_info[i].dma_frac_data_len <= 60)
+						__raw_writel(0x0, AK_VA_L2MEM + i * 512 + 0x1FC);
+					break;
+				case BUF2MEM:
+					if (l2_dma_info[i].dma_frac_data_len <= 512 - 4)
+						l2_clear_dma(i);
+					break;
+				default:
+					BUG();
+				}
+				l2_dma_info[i].dma_frac_start = false;
+
+				if (l2_dma_info[i].callback_func != NULL)
+					l2_dma_info[i].callback_func(l2_dma_info[i].data);
+				
+			}
+		}
+		
+	}
+
+	return IRQ_HANDLED;
+}
+
+/**
+ * l2_cpu - Transfer data between memory and l2 buffer in CPU mode
+ *  @ram_addr:		External RAM address(Physical)
+ *  @id:		L2 buffer ID
+ *  @buf_offset:	The buffer offset
+ *  @bytes:		Data transfer size
+ *  @direction:		Data transfer direction between L2 memory and external RAM 
+ */
+static void l2_cpu(unsigned long ram_addr, u8 id,
+	unsigned long buf_offset, unsigned int bytes, l2_dma_transfer_direction_t direction)
+{
+	int i;
+	int j;
+	unsigned long trans_no;
+	unsigned long frac_no;
+	unsigned long buf_count;
+	unsigned long buf_remain;
+	unsigned long temp_ram;
+	unsigned long temp_buf;
+	void __iomem * bufaddr;
+	
+	/*
+	 * L2 buffer caller MUST guarantee L2 buffer offset is 4-byte aligned
+	 */
+	if (unlikely(buf_offset % 4))
+		BUG();
+	l2_get_addr(id, &bufaddr);
+	if (bufaddr == NULL) {
+		return ;
+	}
+	bufaddr += buf_offset;
+	trans_no = bytes / 4;
+	frac_no = bytes % 4;
+	
+	buf_count = (buf_offset + bytes) / L2_BUF_STATUS_MULTIPLY_RATIO;
+	buf_remain = (buf_offset + bytes) % L2_BUF_STATUS_MULTIPLY_RATIO;
+
+	switch (direction) {
+	case MEM2BUF:
+		if (ram_addr % 4) {
+			for (i = 0; i < trans_no; i++) {
+				temp_ram = 0;
+				for (j = 0; j < 4; j++)
+					temp_ram |= ((read_ramb(ram_addr + i*4 + j))<<(j*8));
+				__raw_writel(temp_ram, (bufaddr + i * 4));
+			}
+			if (frac_no) {
+				temp_ram = 0;
+				for (j = 0; j < frac_no; j++)
+					temp_ram |= ((read_ramb(ram_addr + trans_no*4 + j))<<(j*8));
+				__raw_writel(temp_ram, (bufaddr + trans_no * 4));
+			}
+		} else {
+			for (i = 0; i < trans_no; i++)
+				__raw_writel(read_raml(ram_addr + i*4), (bufaddr + i*4));
+			if (frac_no)
+				__raw_writel(read_raml(ram_addr + trans_no*4), (bufaddr + trans_no*4));
+		}
+		
+		/*
+		 * If we do NOT write data to L2 in multiple of 64Bytes, we must write something to the 4Bytes in 64Bytes-
+		 * boundary so that CPU knows writing ends..
+		 */
+		if ((buf_remain > 0) && (buf_remain <= L2_BUF_STATUS_MULTIPLY_RATIO - 4))
+			__raw_writel(0, (bufaddr - buf_offset + buf_count*L2_BUF_STATUS_MULTIPLY_RATIO + L2_BUF_STATUS_MULTIPLY_RATIO - 4));
+		break;
+	case BUF2MEM:
+		if (ram_addr % 4) {
+			for (i = 0; i < trans_no; i++) {
+				temp_buf = __raw_readl(bufaddr + i * 4);	
+				for (j = 0; j < 4; j++)
+					write_ramb((u8)((temp_buf>>j*8) & 0xFF), (ram_addr + i*4 + j));
+			}
+			if (frac_no) {
+				temp_buf = __raw_readl(bufaddr+trans_no*4);
+				for (j = 0; j < frac_no; j++)
+					write_ramb((u8)((temp_buf>>j*8) & 0xFF), (ram_addr + trans_no*4 + j));
+			}
+		} else {
+			for (i = 0; i < trans_no; i++)
+			{
+				write_raml(__raw_readl(bufaddr+i*4), (ram_addr+i*4));
+			}
+			
+			if (frac_no) {
+				temp_buf = __raw_readl(bufaddr+trans_no*4);
+				temp_ram = read_raml(ram_addr+trans_no*4);
+				temp_buf &= ((1<<(frac_no*8+1))-1);
+				temp_ram &= ~((1<<(frac_no*8+1))-1);
+				temp_ram |= temp_buf;
+				write_raml(temp_ram, (ram_addr+trans_no*4));
+			}
+		}
+		
+		/*
+		 * If we do NOT read data from L2 in multiple of 64Bytes, we must read the 4Bytes in 64Bytes-
+		 * boundary so that CPU knows reading ends..
+		 */
+		if ((buf_remain > 0) && (buf_remain <= L2_BUF_STATUS_MULTIPLY_RATIO - 4))
+			temp_buf = __raw_readl(bufaddr-buf_offset+buf_count*L2_BUF_STATUS_MULTIPLY_RATIO+L2_BUF_STATUS_MULTIPLY_RATIO - 4);
+		break;
+	default:
+		BUG();
+	}
+
+}
+
+/**
+ * l2_init - Initialize linux kernel L2 memory support
+ */
+void __init l2_init(void)
+{
+	int i;
+	int retval;
+
+	/*
+	 * Enable L2 controller working clock
+	 */
+	l2_enable_clock(true);
+
+	/*
+	 * Initialize all L2 common buffer status to IDLE(could be allocated)
+	 */
+	for (i = 0; i < L2_COMMON_BUFFER_NUM; i++) {
+		l2_buffer_info[i].id = (u8)i;
+		l2_buffer_info[i].usable = L2_STAT_IDLE;
+		l2_buffer_info[i].used_time = 0;
+	}
+
+	/* L2 Memory Register initializations */
+	//rL2_DMAREQ = L2_DMA_REQ_EN;
+	__raw_writel(L2_DMA_REQ_EN, rL2_DMAREQ);
+	__raw_writel(L2_FRAC_DMA_AHB_FLAG_EN | L2_FRAC_DMA_LDMA_FLAG_EN, rL2_FRACDMAADDR);
+	__raw_writel(0x0, rL2_CONBUF0_7);
+	__raw_writel(L2_UART_BUF_CFG_UART_EN_MASK | L2_UART_BUF_CFG_UART_CLR_MASK, rL2_CONBUF8_15);
+	__raw_writel(0x0,rL2_BUFASSIGN1);
+	__raw_writel(0x0,rL2_BUFASSIGN2);
+
+	/* Initialize L2 DMA information status */
+	memset(l2_dma_info, 0, ARRAY_SIZE(l2_dma_info));
+
+	/* Initialize global L2 fraction DMA start flag */
+	l2_frac_started = false;
+
+	init_waitqueue_head(&l2_wq);
+
+	/* L2 Memory Interrupt handler registered */
+	if ((retval = request_irq(IRQ_L2MEM, &l2_interrupt_handler, 0/*IRQF_DISABLED*/, "l2", NULL)) < 0)
+		pr_err("l2: failed to request_irq, irq number: %d, retval=%d.\n", IRQ_L2MEM, retval);
+
+	pr_info("On-chip L2 memory initialized\n");
+}
+
+/**
+ * __l2_alloc - Allocate a common L2 buffer for given device
+ *  @device:	Device ID which need common L2 buffer
+ *  Return L2 buffer ID (0 ~ 7)
+ *
+ *  Only common L2 buffers(ID 0 ~ 7) could be allocated by __l2_alloc.
+ *  Other L2 buffers (UART/USB used) is handled by corresponding devices directly.
+ */
+static u8 __l2_alloc(l2_device_t device, bool need_wait)
+{
+	int i;
+	u16 used_times = MAX_L2_BUFFER_USED_TIMES;
+	u8 id = BUF_NULL;
+	u8 first_id = BUF_NULL;
+	unsigned long flags;
+	bool l2_allocated = false;
+	if (unlikely(device == ADDR_RESERVED)) {
+		pr_err("l2: unable to allocate l2 buffer for reserved device.\n");
+		
+		return BUF_NULL;
+	}
+
+	if (unlikely(l2_device_info[(u8)device].id != BUF_NULL)) {
+		pr_err("l2: device %d already have a l2 buffer %d\n",
+			(int)(u8)device, (int)(u8)l2_device_info[(u8)device].id);
+		
+		return l2_device_info[(u8)device].id;
+	}
+
+	do {
+		local_irq_save(flags);
+
+		l2_allocated = false;
+
+		for (i = 1; i < L2_COMMON_BUFFER_NUM; i++) {
+			if (l2_buffer_info[i].usable == L2_STAT_IDLE) {
+				if (first_id == BUF_NULL) {
+					first_id = l2_buffer_info[i].id;
+					used_times = l2_buffer_info[i].used_time;
+					id = first_id;
+				}
+				if (l2_buffer_info[i].used_time < used_times) {
+					used_times = l2_buffer_info[i].used_time;
+					id = l2_buffer_info[i].id;
+				}
+			}
+		}
+
+		if (unlikely(first_id == BUF_NULL)) {
+			if(!need_wait) {
+				local_irq_restore(flags);
+				return BUF_NULL;
+			}
+			local_irq_restore(flags);
+			l2_wait = 0;
+			wait_event(l2_wq, l2_wait);
+		} else {
+			l2_allocated = true;
+		}
+	} while (!l2_allocated);
+
+	/*
+	 * Got a L2 buffer successfully...
+	 */
+	l2_buffer_info[id].usable = L2_STAT_USED;
+	l2_buffer_info[id].used_time++;
+	if (l2_buffer_info[id].used_time == 0) {
+		/*
+		 * In case when the new allocated L2 buffer has been used MAX_L2_BUFFER_USED_TIMES,
+		 * we just clear all L2 buffer used times as a simpfied method of balancing 8 L2 buffer usage.
+		 */
+		for (i = 0; i < L2_COMMON_BUFFER_NUM; i++)
+			l2_buffer_info[i].used_time = 0;
+	}
+
+	/* Enable L2 buffer */
+	l2_combuf_ctrl(id, true);
+
+	/* Change device info */
+	l2_device_info[device].id = id;
+
+	/* Select L2 common buffer for device */
+	l2_select_combuf(device, id);
+
+	local_irq_restore(flags);
+
+	/* Clear L2 buffer status */
+	l2_clr_status(id);
+	return id;
+}
+
+u8 l2_alloc(l2_device_t device)
+{
+		return __l2_alloc(device, true);
+}
+EXPORT_SYMBOL(l2_alloc);
+
+u8 l2_alloc_nowait(l2_device_t device)
+{
+		return __l2_alloc(device, false);
+}
+EXPORT_SYMBOL(l2_alloc_nowait);
+
+/**
+ * l2_free - Free L2 common buffer for given device
+ *  @device:	Device ID which need common L2 buffer
+ *  Return L2 buffer ID (0 ~ 7)
+ *
+ *  Only common L2 buffers(ID 0 ~ 7) could be allocated by l2_alloc.
+ *  Other L2 buffers (UART/USB used) is handled by corresponding devices directly.
+ *  NOTE: Return the previous L2 buffer ID if a L2 buffer has been allocated to the device.
+ *            This means one device could get only one L2 buffer maximum.
+ */
+void l2_free(l2_device_t device)
+{
+	u8 id;
+	unsigned long regval;
+	unsigned long flags;
+	//printk("enter %s\n", __FUNCTION__);
+	id = l2_device_info[(u8)device].id;
+	if (unlikely(id == BUF_NULL)) {
+		pr_err("l2: trying to free invalid buffer id %d\n", (int)id);
+		return ;
+	}
+	
+	l2_clear_dma(id);
+
+	local_irq_save(flags);
+
+	/*
+	 * Disable DMA interrupt of this L2 buffer.
+	 */
+	regval = __raw_readl(rL2_BUFINTEN);
+	regval &= ~(1 << (id + L2_DMA_INTR_ENABLE_BUF_START));
+	//rL2_BUFINTEN = regval;
+	__raw_writel(regval, rL2_BUFINTEN);
+
+	/* Set DMA count to 0 */
+	__raw_writel(0x0, vL2DMA_CONBUF0 + id * 4);
+
+	/* Disable this L2 buffer */
+	l2_combuf_ctrl(id, false);
+	l2_deselect_combuf(device, id);
+
+	/* Clear DMA & DMA fraction flags */
+	if (l2_dma_info[id].dma_start || l2_dma_info[id].dma_frac_start) {
+		l2_dma_info[id].dma_start = false;
+		l2_dma_info[id].dma_frac_start = false;
+	}
+
+	l2_dma_info[id].callback_func = NULL;
+	l2_dma_info[id].data = 0;
+
+	l2_device_info[(u8)device].id = BUF_NULL;
+	l2_buffer_info[id].usable = L2_STAT_IDLE;
+
+	l2_wait = 1;
+	wake_up(&l2_wq);
+
+	local_irq_restore(flags);
+
+}
+EXPORT_SYMBOL(l2_free);
+
+/**
+ * l2_set_dma_callback - Set callback function when L2 DMA/fraction DMA interrupt handler is done
+ *  @id:	L2 buffer ID
+ *  @func:	Callback function
+ *  Return true(Always)
+ *  
+ *  NOTE: Caller MUST guarantee that L2 buffer ID is valid. And since the callback function is called
+ *  in interrupt handler, it MUST NOT call any functions which may sleep.
+ */
+bool l2_set_dma_callback(u8 id, l2_callback_func_t func, unsigned long data)
+{
+	if (unlikely(id >= L2_COMMON_BUFFER_NUM)) {
+		pr_err("l2: Set dma callback, invalid buf id[%d].\n", id);
+		return false;
+	}
+
+	if (unlikely(l2_dma_info[id].dma_start || l2_dma_info[id].dma_frac_start)) {
+		pr_err("l2: Set dma callback, dma not finished.\n");
+		return false;
+	}
+
+	l2_dma_info[id].callback_func = func;
+	l2_dma_info[id].data = data;
+
+	return true;
+}
+EXPORT_SYMBOL(l2_set_dma_callback);
+
+/**
+ * l2_combuf_dma - Start data tranferring between memory and l2 common buffer in DMA mode
+ *  @ram_addr:		External RAM address(Physical)
+ *  @id:		L2 buffer ID involved in DMA transfer
+ *  @bytes:		Data transfer size
+ *  @direction:		Data transfer direction between L2 memory and external RAM 
+ *  @intr_enable:	Open interrupt for this L2 buffer or not
+ */
+void l2_combuf_dma(unsigned long ram_addr, u8 id, unsigned int bytes, l2_dma_transfer_direction_t direction, bool intr_enable)
+{
+	if (unlikely(id >= L2_COMMON_BUFFER_NUM)) {
+		pr_err("l2: begin common buffer dma, error buf id=[%d].\n", id);
+		return ;
+	}
+
+	l2_dma(ram_addr, id, bytes, direction, intr_enable);
+}
+EXPORT_SYMBOL(l2_combuf_dma);
+
+/**
+ * l2_combuf_wait_dma_finish - Wait for L2 DMA to finish
+ *  @id:	L2 buffer ID involved in DMA transfer
+ *  Return true: DMA transfer finished successfully.
+ *            false: DMA transfer failed.
+ *  NOTE: DMA transfer is started by l2_combuf_dma.
+ */
+bool l2_combuf_wait_dma_finish(u8 id)
+{
+	if (unlikely(id >= L2_COMMON_BUFFER_NUM)) {
+		pr_err("l2: begin common buffer dma, error buf id=[%d].\n", id);
+		return false;
+	}
+	return l2_wait_dma_finish(id);
+}
+EXPORT_SYMBOL(l2_combuf_wait_dma_finish);
+
+/**
+ * l2_combuf_cpu - Transfer data between memory and l2 common buffer in CPU mode
+ *  @ram_addr:	External RAM address(Physical)
+ *  @id:	L2 buffer ID
+ *  @bytes:	Data transfer size
+ *  @direction:	Data transfer direction between L2 memory and external RAM
+ *
+ *  NOTE: According to XuChang, if one transfer data from Peripheral --> L2 Buffer --> RAM, 
+ *            special care need to be taken when data size is NOT multiple of 64Bytes.
+ *            Pheripheral driver must check hardware signals to confirm data has been transfer from
+ *            peripheral to L2 buffer since L2 do NOT provide some mechanism to confirm data has
+ *            been in L2 Buffer. Driver can and only can call l2_combuf_cpu() to copy data from L2
+ *            Buffer --> RAM after checking hardware signals.
+ *            As to 64Bytes * n size data, L2 could check Buffer Status Status Counter to confirm that
+ *            Data has been transfer from peripheral to L2 buffer, so no hardware signals checking needed.
+ */
+void l2_combuf_cpu(unsigned long ram_addr, u8 id,
+	unsigned int bytes, l2_dma_transfer_direction_t direction)
+{
+	int i;
+	int loop;
+	int remain;
+
+	loop = bytes / L2_BUF_STATUS_MULTIPLY_RATIO;
+	remain = bytes % L2_BUF_STATUS_MULTIPLY_RATIO;
+
+	switch (direction) {
+	case MEM2BUF:
+		for (i = 0; i < loop; i++) {
+			
+			while (l2_get_status(id) == (L2_BUFFER_SIZE / L2_BUF_STATUS_MULTIPLY_RATIO))
+				;	/* Waiting for L2 buffer to NOT full(means writable) */
+			
+			l2_cpu(ram_addr + i * L2_BUF_STATUS_MULTIPLY_RATIO, id,
+				(i % 8) * L2_BUF_STATUS_MULTIPLY_RATIO, L2_BUF_STATUS_MULTIPLY_RATIO, direction);
+		}
+		if (remain > 0) {
+			while (l2_get_status(id) > 0)
+				;	/* Waiting for L2 buffer to empty */
+
+			l2_cpu(ram_addr + loop * L2_BUF_STATUS_MULTIPLY_RATIO, id,
+				(loop % 8) * L2_BUF_STATUS_MULTIPLY_RATIO, remain, direction);
+		}
+		break;
+	case BUF2MEM:
+		for (i = 0; i < loop; i++) {
+			while (l2_get_status(id) == 0)
+				;	/* Waiting for L2 buffer to be not empty (means readable) */
+			
+			l2_cpu(ram_addr + i * L2_BUF_STATUS_MULTIPLY_RATIO, id,
+				(i % 8) * L2_BUF_STATUS_MULTIPLY_RATIO, L2_BUF_STATUS_MULTIPLY_RATIO, direction);
+			
+		}
+		if (remain > 0) {
+			l2_cpu(ram_addr + loop * L2_BUF_STATUS_MULTIPLY_RATIO, id,
+				(loop % 8) * L2_BUF_STATUS_MULTIPLY_RATIO, remain, direction);
+		}
+		break;
+	default:
+		BUG();
+	}
+}
+EXPORT_SYMBOL(l2_combuf_cpu);
+
+/**
+ * l2_get_status - Get L2 buffer status
+ *  @id:	L2 buffer ID
+ */
+u8 l2_get_status(u8 id)
+{
+	l2_assert_buf_id(id);
+
+	return (id < L2_COMMON_BUFFER_NUM) ? (__raw_readl(rL2_BUFSTAT1) >> (id * 4)) & 0xF :
+		(__raw_readl(rL2_BUFSTAT2) >> ((id - L2_UART_BUF_START_ID) << 1)) & 0x3;
+}
+EXPORT_SYMBOL(l2_get_status);
+
+/**
+ * l2_clr_status - Clear L2 buffer status
+ *  @id:	L2 buffer ID
+ */
+void l2_clr_status(u8 id)
+{
+	unsigned long flags;
+
+	l2_assert_buf_id(id);
+	
+	local_irq_save(flags);
+
+	if (id < L2_COMMON_BUFFER_NUM) {
+		__raw_writel(__raw_readl(rL2_CONBUF0_7) | (1 << (id + L2_COMMON_BUF_CFG_BUF_CLR_START)), rL2_CONBUF0_7);
+	} else {
+		__raw_writel(__raw_readl(rL2_CONBUF8_15) | (1 << (id - L2_UART_BUF_START_ID + L2_UART_BUF_CFG_BUF_START)), rL2_CONBUF8_15);
+	}
+
+	local_irq_restore(flags);
+
+}
+EXPORT_SYMBOL(l2_clr_status);
+
+/**
+ * l2_set_status - Clear L2 buffer status
+ *  @id:	L2 buffer ID
+ *  @status:	Status to be set (0 ~ 8)
+ */
+void l2_set_status(u8 id, u8 status)
+{
+	unsigned long regval;
+	unsigned long flags;
+	
+	l2_assert_buf_id(id);
+
+	if ((id >= L2_COMMON_BUFFER_NUM) || status > MAX_L2_DMA_STATUS_VALUE)
+		BUG();
+
+	local_irq_save(flags);
+
+	/*
+	 * Enable CPU-controlled buffer function and set L2 buffer `id' status
+	 * status = current number of data in the CPU controlled buffer.
+	 */
+	regval = __raw_readl(rL2_CONBUF8_15);
+	regval &= ~(L2_UART_BUF_CFG_CPU_BUF_NUM_MASK | L2_UART_BUF_CFG_CPU_BUF_SEL_EN |
+		L2_UART_BUF_CFG_CPU_BUF_SEL_MASK);
+	regval |= (id << L2_UART_BUF_CFG_CPU_BUF_SEL_START) | L2_UART_BUF_CFG_CPU_BUF_SEL_EN |
+		(status << L2_UART_BUF_CFG_CPU_BUF_NUM_START);
+	//rL2_CONBUF8_15 = regval;
+	__raw_writel(regval, rL2_CONBUF8_15);
+
+	/*
+	* Disable CPU-controlled buffer function
+	*/
+	regval = __raw_readl(rL2_CONBUF8_15);
+	regval &= ~(L2_UART_BUF_CFG_CPU_BUF_NUM_MASK | L2_UART_BUF_CFG_CPU_BUF_SEL_EN |
+		L2_UART_BUF_CFG_CPU_BUF_SEL_MASK);
+	__raw_writel(regval, rL2_CONBUF8_15);
+
+	local_irq_restore(flags);
+
+}
+EXPORT_SYMBOL(l2_set_status);
diff --git a/arch/arm/mach-anycloudv500/anycloudv500.c b/arch/arm/mach-anycloudv500/anycloudv500.c
new file mode 100755
index 0000000..3c8df3b
--- /dev/null
+++ b/arch/arm/mach-anycloudv500/anycloudv500.c
@@ -0,0 +1,124 @@
+/*
+ * /linux/arch/arm/mach-ak37d/ak37dxxev300.c
+ *
+ * Copyright (C) 2018 Anyka(Guangzhou) Microelectronics Technology Co., Ltd.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include <linux/platform_device.h>
+#include <linux/irq.h>
+#include <linux/of_platform.h>
+
+#include <asm/mach/arch.h>
+#include <asm/mach/map.h>
+#include <asm/mach-types.h>
+#include <asm/irq.h>
+#include <asm/sizes.h>
+
+#include <mach/ak_l2.h>
+#include <mach/map.h>
+
+#include <linux/input.h>
+#include <linux/irqchip.h>
+
+#define AK_CPU_ID			(AK_VA_SYSCTRL + 0x00)
+
+#define AKCPU_VALUE			0x20170200
+#define AKCPU_TYPE			"AK37XXD"
+
+#define IODESC_ENT(x) 							\
+{												\
+	.virtual = (unsigned long)AK_VA_##x,		\
+	.pfn	 = __phys_to_pfn(AK_PA_##x),		\
+	.length	 = AK_SZ_##x,						\
+	.type	 = MT_DEVICE						\
+}
+
+static struct map_desc ak37d_iodesc[] __initdata = {
+	IODESC_ENT(SYSCTRL),
+	IODESC_ENT(CAMERA),
+	IODESC_ENT(LCD),
+	IODESC_ENT(ROTATION),
+	IODESC_ENT(VENCODE),
+	IODESC_ENT(VDECODE),
+	IODESC_ENT(GUI),
+	IODESC_ENT(SUBCTRL),
+	IODESC_ENT(MAC),
+	IODESC_ENT(MIPI1),
+	IODESC_ENT(MIPI2),
+	IODESC_ENT(DSI),
+	IODESC_ENT(REGRAM),
+	IODESC_ENT(L2MEM),
+	IODESC_ENT(RESERVED_MEM),
+};
+
+void __init ak37d_map_io(void)
+{
+	unsigned long regval = 0x0;
+    
+	/* initialise the io descriptors we need for initialisation */
+	iotable_init(ak37d_iodesc, ARRAY_SIZE(ak37d_iodesc));
+
+	regval = __raw_readl(AK_CPU_ID);
+	if (regval == AKCPU_VALUE) 
+		pr_info("ANYKA CPU %s (ID 0x%lx)\n", AKCPU_TYPE, regval);
+	else
+		pr_info("Unknown ANYKA CPU ID: 0x%lx\n", regval);
+		
+}
+
+void wdt_enable(void);
+void wdt_keepalive(unsigned int heartbeat);
+
+static void ak37d_restart(enum reboot_mode mode, const char *cmd)
+{
+#if defined CONFIG_AK_WATCHDOG_TOP
+	wdt_enable();
+	wdt_keepalive(2);
+#endif
+}
+
+static void __init ak37d_init(void)
+{	
+    int ret;
+	l2_init();
+
+	ret = of_platform_populate(NULL, of_default_bus_match_table, NULL,
+				   NULL);
+	if (ret) {
+		pr_err("of_platform_populate failed: %d\n", ret);
+		BUG();
+	}    
+	
+	return;
+}
+
+
+static const char * const ak37d_dt_compat[] = {
+    "anyka,ak3750d",
+	"anyka,ak3760d",
+	"anyka,ak3780d",
+	"anyka,ak3790d",
+    "anyka,ak3918ev500",
+	NULL
+};
+
+DT_MACHINE_START(AK37xxD, "AK3790D")
+/* Maintainer: Anyka(Guangzhou) Microelectronics Technology Co., Ltd */
+	.dt_compat	= ak37d_dt_compat,
+	.map_io = ak37d_map_io,
+	.init_time = NULL,
+	.init_machine = ak37d_init,
+	.init_early = NULL,
+	.reserve = NULL,
+    .restart = ak37d_restart,
+MACHINE_END
diff --git a/arch/arm/mach-anycloudv500/include/mach/ak_l2.h b/arch/arm/mach-anycloudv500/include/mach/ak_l2.h
new file mode 100755
index 0000000..2372886
--- /dev/null
+++ b/arch/arm/mach-anycloudv500/include/mach/ak_l2.h
@@ -0,0 +1,335 @@
+/*
+ * linux/arch/arm/mach-ak39/include/mach/ak_l2.h
+ *
+ * Copyright (C) 2018 Anyka(Guangzhou) Microelectronics Technology Co., Ltd.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+
+#ifndef __ASM_ARCH_L2_H
+#define __ASM_ARCH_L2_H
+
+#include <mach/map.h>
+
+#undef REG32
+#define REG32(_reg)		(*(volatile unsigned long *)(_reg))
+
+#undef REG16 
+#define REG16(_reg)		(*(volatile unsigned short *)(_reg))
+
+/*
+ * ANYKA L2 Control Register List and Bit map definition
+ * TODO: Add all register bit maps and move all to map.h in the future.
+*/
+#define L2_DMA_REQ_BUF_START			24
+#define L2_DMA_REQ_BUF_REQ_MASK			(0xFFFF << 16)
+#define L2_DMA_REQ_UART_BUF_REQ_START	16
+#define L2_DMA_REQ_FRAC_DMA_LEN_START	10
+#define L2_DMA_REQ_FRAC_DMA_LEN_MASK	(0x3F << L2_DMA_REQ_FRAC_DMA_LEN_START)
+#define L2_DMA_REQ_FRAC_DMA_REQ			(1 << 9)
+#define L2_DMA_REQ_FRAC_DMA_DIR_WR		(1 << 8)
+#define L2_DMA_REQ_FRAC_DMA_L2_ADDR_START	1
+#define L2_DMA_REQ_FRAC_DMA_L2_ADDR_MASK	(0x7F << L2_DMA_REQ_FRAC_DMA_L2_ADDR_START)
+#define L2_DMA_REQ_EN					(1 << 0)
+
+#define L2_FRAC_DMA_AHB_FLAG_EN			(1 << 29)
+#define L2_FRAC_DMA_LDMA_FLAG_EN		(1 << 28)
+
+#define L2_FRAC_DMA_LOW_ADDR_MASK		(0xFFFFFFF << 0)
+
+#define L2_COMMON_BUF_CFG_BUF7_CLR		(1 << 31)
+#define L2_COMMON_BUF_CFG_BUF6_CLR		(1 << 30)
+#define L2_COMMON_BUF_CFG_BUF5_CLR		(1 << 29)
+#define L2_COMMON_BUF_CFG_BUF4_CLR		(1 << 28)
+#define L2_COMMON_BUF_CFG_BUF3_CLR		(1 << 27)
+#define L2_COMMON_BUF_CFG_BUF2_CLR		(1 << 26)
+#define L2_COMMON_BUF_CFG_BUF1_CLR		(1 << 25)
+#define L2_COMMON_BUF_CFG_BUF0_CLR		(1 << 24)
+#define L2_COMMON_BUF_CFG_BUF_CLR_START	24
+#define L2_COMMON_BUF_CFG_BUF0_7_CLR_MASK	(0xFF << L2_COMMON_BUF_CFG_BUF_START)
+#define L2_COMMON_BUF_CFG_BUF_VLD_START	16
+#define L2_COMMON_BUF_CFG_BUF0_7_VLD_MASK	(0xFF << L2_COMMON_BUF_CFG_BUF_VLD_START
+#define L2_COMMON_BUF_CFG_BUF_DMA_VLD_START	0
+#define L2_COMMON_BUF_CFG_BUF_DIR_START	8
+
+#define L2_UART_BUF_CFG_BUF_START		16
+
+#define L2_UART_BUF_CFG_UART_EN_MASK	(0xF << 28)
+#define L2_UART_BUF_CFG_UART_CLR_MASK	(0xFF << 16)
+#define L2_UART_BUF_CFG_CPU_BUF_SEL_EN	(1 << 3)
+#define L2_UART_BUF_CFG_CPU_BUF_NUM_START	4
+#define L2_UART_BUF_CFG_CPU_BUF_NUM_MASK	(0xF << L2_UART_BUF_CFG_CPU_BUF_NUM_START)
+#define L2_UART_BUF_CFG_CPU_BUF_SEL_START	0
+#define L2_UART_BUF_CFG_CPU_BUF_SEL_MASK	(0x7 << L2_UART_BUF_CFG_CPU_BUF_SEL_START)
+
+#define L2_DMA_INTR_ENABLE_BUF_START	9
+#define L2_DMA_INTR_ENABLE_UART_BUF_START	1
+#define L2_DMA_INTR_ENABLE_FRAC_INTR_EN	(1 << 0)
+
+/*
+ * ANYKA L2 buffer size(buffer 0 to buffer 7), all 512Bytes.
+ * NOTE: L2 buffer 8 to 15 dedicate to UART 1 to 4 &  USB 2.0 Controller, 
+ *           and the corresponding L2 buffer size could be 64, 128 and 256 Bytes.
+ * See ANYKA Programmer's Guide for details (ANYKA preferably).
+ */
+#define L2_BUFFER_SIZE			512
+
+/*
+  * ANYKA L2 DMA waiting times in loop
+  * TODO: Must be change to waiting time based on CPU frequency when frequency APIs are done.
+  */
+#define L2_MAX_DMA_WAIT_TIME	50 * 1000000UL
+
+/*
+ * ANYKA DMA size in bytes per transfer (Always 64Bytes)
+ * L2 DMA transfer follows this definition.
+ */
+#define DMA_ONE_SHOT_LEN		64
+
+/*
+ * ANYKA L2 Buffer Status Multiply Ratio(64)
+ * Buffer Status Register 1 & 2: The number of data = Bufn_sta * L2_BUF_STATUS_MULTIPLY_RATIO
+ */
+#define L2_BUF_STATUS_MULTIPLY_RATIO	64
+
+/*
+ * L2 Buffer ID Assignment:
+ * 0 - 7: L2 common buffer, could be used by different peripherals
+ * 8 - 15: Dedicate L2 buffer for UART
+ * 16 - 18: Dedicate L2 buffer for USB
+ */
+#define L2_COMMON_BUFFER_NUM	8
+#define L2_UART_BUFFER_NUM		4
+
+#define L2_UART_BUFFER_INDEX	L2_COMMON_BUFFER_NUM
+#define L2_USB_HOST_BUFFER_INDEX	(L2_UART_BUFFER_INDEX + L2_UART_BUFFER_NUM)
+
+
+#define L2_COMMON_BUFFER_LEN	512
+#define L2_UART_BUFFER_LEN		128
+
+#define L2_COMMON_BUFFER_OFFSET		0
+#define L2_UART_BUFFER_OFFSET		(L2_COMMON_BUFFER_LEN * L2_COMMON_BUFFER_NUM)
+
+/*
+ * L2 controller working clock define
+ */
+#define L2_CLOCK_EN				(0x1 << 9)
+#define L2_CLOCK_REG			(AK_VA_SYSCTRL + 0x1C)
+
+/*
+ * L2 device list which may use L2 memory.
+ * The devices are defined according to L2 Buffer Assignement 1 & 2 register bit sequence.
+ */
+typedef enum {
+	ADDR_USB_EP1 = 0,		/* USB 2.0 HS Controller: Endpoint 1 */
+	ADDR_USB_EP2,			/* USB 2.0 HS Controller: Endpoint 2 */
+	ADDR_USB_EP3,			/* USB 2.0 HS Controller: Endpoint 3 */
+	ADDR_RESERVED,			/* Reserved */
+	ADDR_MMC0,				/* MMC0 interface */
+	ADDR_MMC1,				/* MMC1 interface */
+	ADDR_MMC2,				/* MMC2 interface */
+	ADDR_SPI1_RX = 7,		/* Rx buffer of SPI1 Controller */
+	ADDR_SPI1_TX,			/* Tx buffer of SPI1 Controller */
+	ADDR_DAC,				/* DAC control module */	
+	ADDR_SPI2_RX,			/* Rx buffer of SPI2 Controller */
+	ADDR_SPI2_TX,			/* Tx buffer of SPI2 Controller */
+	ADDR_GPS,				/* GPS interface */
+	ADDR_PCM_TX,			/* Tx buffer of PCM Controller */
+	ADDR_ADC,				/* ADC2 */
+	ADDR_USB_EP4,			/* USB 2.0 HS Controller: Endpoint 4 */
+} l2_device_t;
+
+
+#define BUF_NULL					0xFF	/* Invalid L2 buffer ID */
+#define L2_UART_BUF_START_ID		L2_COMMON_BUFFER_NUM	/* UART used buffer ID from 8 */
+
+/*
+ * Maximum L2 DMA status value (The value in CPU-Controlled Buffer and Buffer8 ~ Buffer15 Configuration Register)
+ * The maximum DMA transfer bytes = MAX_L2_DMA_STATUS_VALUE * 64
+ */
+#define MAX_L2_DMA_STATUS_VALUE		0x8
+#define MAX_L2_BUFFER_USED_TIMES	0xFFFF
+
+/*
+ * Data transfer direction between L2 memory and external RAM
+ */
+typedef enum {
+	BUF2MEM = 0,	/* Data transfer from L2 buffer to external RAM */
+	MEM2BUF,	/* Data transfer from external RAM to L2 buffer */
+} l2_dma_transfer_direction_t;
+
+/*
+ * Callback function when L2 DMA/fraction DMA interrupt handler is done
+ */
+typedef void (*l2_callback_func_t)(unsigned long data);
+
+/*
+ * L2 buffer status
+ */
+typedef enum {
+	L2_STAT_USED = 0,	/* Current L2 buffer is used by some device */
+	L2_STAT_IDLE,		/* Current L2 buffer is NOT used by some device, thus could be allocated */
+} l2_buffer_status_t;
+
+/*
+ * L2 buffer information
+ */
+typedef struct {
+	u8 id;				/* L2 buffer ID (0~17) */
+	l2_buffer_status_t usable;	/* L2 buffer status(used or idle) */
+	u16 used_time;			/* Counter on L2 buffer used times */
+} l2_buffer_info_t;
+
+/*
+ * Information on device which use L2 memory
+ */
+typedef struct {
+	l2_device_t device;	/* Device ID */
+	u8 id;				/* TODO: Remove id in the future since array index already represent buffer id */
+} l2_device_info_t;
+
+/*
+ * L2 DMA usage information (including DMA/fraction DMA/external RAM/Callback function)
+ */
+typedef struct {
+	bool dma_start;
+	bool intr_enable;
+	l2_dma_transfer_direction_t direction;
+	void *dma_addr;
+	u32  dma_op_times;
+	bool need_frac;
+	bool dma_frac_start;
+	void *dma_frac_addr;
+	u32  dma_frac_offset;
+	u32  dma_frac_data_len;
+	l2_callback_func_t callback_func;
+	unsigned long data;
+} l2_dma_info_t;
+
+/**
+ * l2_init - Initialize linux kernel L2 memory support
+ */
+void __init l2_init(void);
+
+/**
+ * l2_alloc - Allocate a common L2 buffer for given device
+ *  @device:	Device ID which need common L2 buffer
+ *  Return L2 buffer ID (0 ~ 7)
+ *
+ *  Only common L2 buffers(ID 0 ~ 7) could be allocated by l2_alloc.
+ *  Other L2 buffers (UART/USB used) is handled by corresponding devices directly.
+ */
+u8 l2_alloc(l2_device_t device);
+
+/**
+ * l2_alloc_nowait - Allocate a common L2 buffer for given device
+ *  @device:	Device ID which need common L2 buffer
+ *  Return L2 buffer ID (0 ~ 7)
+ *
+ *  Only common L2 buffers(ID 0 ~ 7) could be allocated by l2_alloc_nowait.
+ *  Other L2 buffers (UART/USB used) is handled by corresponding devices directly.
+ *  return BUF_NULL immediately if no buf was alloc .
+ */
+u8 l2_alloc_nowait(l2_device_t device);
+
+/**
+ * l2_free - Free L2 common buffer for given device
+ *  @device:	Device ID which need common L2 buffer
+ *  Return L2 buffer ID (0 ~ 7)
+ *
+ *  Only common L2 buffers(ID 0 ~ 7) could be allocated by l2_alloc.
+ *  Other L2 buffers (UART/USB used) is handled by corresponding devices directly.
+ *  NOTE: Return the previous L2 buffer ID if a L2 buffer has been allocated to the device.
+ *            This means one device could get only one L2 buffer maximum.
+ */
+void l2_free(l2_device_t device);
+
+/**
+ * l2_set_dma_callback - Set callback function when L2 DMA/fraction DMA interrupt handler is done
+ *  @id:		L2 buffer ID
+ *  @func:	Callback function
+ *  @data:	Arguments used by callback function
+ *  Return true(Always)
+ *  
+ *  NOTE: Caller MUST guarantee that L2 buffer ID is valid. And since the callback function is called
+ *  in interrupt handler, it MUST NOT call any functions which may sleep.
+ */
+bool l2_set_dma_callback(u8 id, l2_callback_func_t func, unsigned long data);
+
+/**
+ * l2_combuf_dma - Start data tranferring between memory and l2 common buffer in DMA mode
+ *  @ram_addr:		External RAM address(Physical)
+ *  @id:			L2 buffer ID involved in DMA transfer
+ *  @bytes:		Data transfer size
+ *  @direction:		Data transfer direction between L2 memory and external RAM 
+ *  @intr_enable:		Open interrupt for this L2 buffer or not
+ */
+void l2_combuf_dma(unsigned long ram_addr, u8 id, unsigned int bytes, l2_dma_transfer_direction_t direction, bool intr_enable);
+
+/**
+ * l2_combuf_wait_dma_finish - Wait for L2 DMA finish
+ *  @id:	L2 buffer ID involved in DMA transfer
+ *  Return true: DMA transfer finished successfully.
+ *            false: DMA transfer failed.
+ *  NOTE: DMA transfer is started by l2_combuf_dma.
+ */
+bool l2_combuf_wait_dma_finish(u8 id);
+
+/**
+ * l2_combuf_cpu - Transfer data between memory and l2 common buffer in CPU mode
+ *  @ram_addr:	External RAM address(Physical)
+ *  @id:	L2 buffer ID
+ *  @bytes:	Data transfer size
+ *  @direction:	Data transfer direction between L2 memory and external RAM
+ *
+ *  NOTE: According to XuChang, if one transfer data from Peripheral --> L2 Buffer --> RAM, 
+ *            special care need to be taken when data size is NOT multiple of 64Bytes.
+ *            Pheripheral driver must check hardware signals to confirm data has been transfer from
+ *            peripheral to L2 buffer since L2 do NOT provide some mechanism to confirm data has
+ *            been in L2 Buffer. Driver can and only can call l2_combuf_cpu() to copy data from L2
+ *            Buffer --> RAM after checking hardware signals.
+ *            As to 64Bytes * n size data, L2 could check Buffer Status Status Counter to confirm that
+ *            Data has been transfer from peripheral to L2 buffer, so no hardware signals checking needed.
+ */
+void l2_combuf_cpu(unsigned long ram_addr, u8 id, unsigned int bytes, l2_dma_transfer_direction_t direction);
+
+/**
+ * l2_get_status - Get L2 buffer status
+ *  @id:	L2 buffer ID
+ */
+u8 l2_get_status(u8 id);
+
+/**
+ * l2_clr_status - Clear L2 buffer status
+ *  @id:	L2 buffer ID
+ */
+void l2_clr_status(u8 id);
+
+/**
+ * l2_set_status - Clear L2 buffer status
+ *  @id:	L2 buffer ID
+ *  @status:	Status to be set (0 ~ 8)
+ */
+void l2_set_status(u8 id, u8 status);
+
+static inline void l2_enable_clock(int enable)
+{
+	if (enable)
+		REG32(L2_CLOCK_REG) &= ~L2_CLOCK_EN;
+	else
+		REG32(L2_CLOCK_REG) |= L2_CLOCK_EN;
+	return;
+}
+
+#endif	/* __ASM_ARCH_L2_H */
+
diff --git a/arch/arm/mach-anycloudv500/include/mach/anyka_types.h b/arch/arm/mach-anycloudv500/include/mach/anyka_types.h
new file mode 100755
index 0000000..3500502
--- /dev/null
+++ b/arch/arm/mach-anycloudv500/include/mach/anyka_types.h
@@ -0,0 +1,71 @@
+/** @file
+ * @brief Define the register operator for system
+ *
+ * Copyright (C) 2006 Anyka (GuangZhou) Software Technology Co., Ltd.
+ * @author 
+ * @date 2006-01-16
+ * @version 1.0
+ */
+
+#ifndef _ANYKA_TYPES_H_
+#define _ANYKA_TYPES_H_
+
+/** @defgroup ANYKA_CPU  
+ *    @ingroup M3PLATFORM
+ */
+/*@{*/
+
+/* preliminary type definition for global area */
+typedef    unsigned char          T_U8;       /* unsigned 8 bit integer */
+typedef    unsigned short         T_U16;      /* unsigned 16 bit integer */
+typedef    unsigned long          T_U32;      /* unsigned 32 bit integer */
+typedef    signed char            T_S8;       /* signed 8 bit integer */
+typedef    signed short           T_S16;      /* signed 16 bit integer */
+typedef    signed long            T_S32;      /* signed 32 bit integer */
+typedef    void                   T_VOID;     /* void */
+typedef    unsigned long long     T_U64;       //64bit
+
+#define    T_U8_MAX             ((T_U8)0xff)                 // maximum T_U8 value
+#define    T_U16_MAX            ((T_U16)0xffff)              // maximum T_U16 value
+#define    T_U32_MAX            ((T_U32)0xffffffff)          // maximum T_U32 value
+#define    T_S8_MIN             ((T_S8)(-127-1))             // minimum T_S8 value
+#define    T_S8_MAX             ((T_S8)127)                  // maximum T_S8 value
+#define    T_S16_MIN            ((T_S16)(-32767L-1L))        // minimum T_S16 value
+#define    T_S16_MAX            ((T_S16)(32767L))            // maximum T_S16 value
+#define    T_S32_MIN            ((T_S32)(-2147483647L-1L))   // minimum T_S32 value
+#define    T_S32_MAX            ((T_S32)(2147483647L))       // maximum T_S32 value
+
+/* basal type definition for global area */
+typedef T_S8                    T_CHR;      /* char */
+typedef T_U8                    T_BOOL;     /* BOOL type */
+
+typedef T_VOID *                T_pVOID;    /* pointer of void data */
+typedef const T_VOID *          T_pCVOID;   /* const pointer of void data */
+
+typedef T_S8 *                  T_pSTR;     /* pointer of string */
+typedef const T_S8 *            T_pCSTR;    /* const pointer of string */
+
+
+typedef T_U16                   T_WCHR;     /**< unicode char */
+typedef T_U16 *                 T_pWSTR;    /* pointer of unicode string */
+typedef const T_U16 *           T_pCWSTR;   /* const pointer of unicode string */
+
+
+typedef T_U8 *                  T_pDATA;    /* pointer of data */
+typedef const T_U8 *            T_pCDATA;   /* const pointer of data */
+
+typedef T_U32                   T_COLOR;    /* color value */
+
+typedef T_U32                   T_HANDLE;   /* a handle */
+
+#define        AK_FALSE            0
+#define        AK_TRUE             1
+#undef AK_NULL
+#define        AK_NULL             ((T_pVOID)(0))
+
+#define        AK_EMPTY
+/*@}*/
+
+
+#endif    //  _ANYKA_TYPES_H_
+
diff --git a/arch/arm/mach-anycloudv500/include/mach/entry-macro.S b/arch/arm/mach-anycloudv500/include/mach/entry-macro.S
new file mode 100755
index 0000000..5c170fe
--- /dev/null
+++ b/arch/arm/mach-anycloudv500/include/mach/entry-macro.S
@@ -0,0 +1,208 @@
+/*
+ * linux/arch/arm/mach-ak39/include/mach/entry-macro.S
+ *
+ * Low-level IRQ helper macros for AK39-based platforms
+ *
+ * Copyright (C) 2018 Anyka(Guangzhou) Microelectronics Technology Co., Ltd.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+
+#include <mach/map.h>
+#include <asm/irq.h>
+
+#define	AK39_IRQ_INTMASK		(AK_VA_SYSCTRL + 0x24)
+#define	AK39_FIQ_INTMASK		(AK_VA_SYSCTRL + 0x28)
+#define	AK39_INT_STATUS			(AK_VA_SYSCTRL + 0x4C)
+
+	.macro  get_irqnr_preamble, base, tmp
+	.endm
+
+	.macro  arch_ret_to_user, tmp1, tmp2
+	.endm
+
+	.macro	get_irqnr_and_base, irqnr, irqstat, base, tmp
+	
+		ldr	\base, =AK39_INT_STATUS
+		ldr	\irqstat, [\base]		@ get interrupts status
+		teq	\irqstat, #0x0
+		beq	1002f
+
+		ldr	\base, =AK39_IRQ_INTMASK	@ get interrupts mask
+		ldr	\base, [\base]
+		and	\irqstat, \irqstat, \base
+
+		tst	\irqstat, #(1<<IRQ_CAMERA)
+		bicne	\irqstat, \irqstat, #(1<<IRQ_CAMERA)
+		movne	\irqnr, #IRQ_CAMERA
+		bne	1001f
+
+		tst	\irqstat, #(1<<IRQ_VIDEO_ENCODER)
+		bicne	\irqstat, \irqstat, #(1<<IRQ_VIDEO_ENCODER)
+		movne	\irqnr, #IRQ_VIDEO_ENCODER
+		bne	1001f
+
+		tst	\irqstat, #(1<<IRQ_SYSCTRL)
+		bicne	\irqstat, \irqstat, #(1<<IRQ_SYSCTRL)
+		movne	\irqnr, #IRQ_SYSCTRL
+		bne	1001f
+
+		tst	\irqstat, #(1<<IRQ_MCI0)
+		bicne	\irqstat, \irqstat, #(1<<IRQ_MCI0)
+		movne	\irqnr, #IRQ_MCI0
+		bne	1001f
+
+		tst	\irqstat, #(1<<IRQ_MCI1)
+		bicne	\irqstat, \irqstat, #(1<<IRQ_MCI1)
+		movne	\irqnr, #IRQ_MCI1
+		bne	1001f
+
+		tst	\irqstat, #(1<<IRQ_ADC2)
+		bicne	\irqstat, \irqstat, #(1<<IRQ_ADC2)
+		movne	\irqnr, #IRQ_ADC2
+		bne	1001f
+
+		tst	\irqstat, #(1<<IRQ_DAC)
+		bicne	\irqstat, \irqstat, #(1<<IRQ_DAC)
+		movne	\irqnr, #IRQ_DAC
+		bne	1001f
+
+		tst	\irqstat, #(1<<IRQ_SPI1)
+		bicne	\irqstat, \irqstat, #(1<<IRQ_SPI1)
+		movne	\irqnr, #IRQ_SPI1
+		bne	1001f
+
+		tst	\irqstat, #(1<<IRQ_SPI2)
+		bicne	\irqstat, \irqstat, #(1<<IRQ_SPI2)
+		movne	\irqnr, #IRQ_SPI2
+		bne	1001f
+
+		tst	\irqstat, #(1<<IRQ_UART0)
+		bicne	\irqstat, \irqstat, #(1<<IRQ_UART0)
+		movne	\irqnr, #IRQ_UART0
+		bne	1001f
+
+		tst	\irqstat, #(1<<IRQ_UART1)
+		bicne	\irqstat, \irqstat, #(1<<IRQ_UART1)
+		movne	\irqnr, #IRQ_UART1
+		bne	1001f
+
+		tst	\irqstat, #(1<<IRQ_L2MEM)
+		bicne	\irqstat, \irqstat, #(1<<IRQ_L2MEM)
+		movne	\irqnr, #IRQ_L2MEM
+		bne	1001f
+
+		tst	\irqstat, #(1<<IRQ_I2C)
+		bicne	\irqstat, \irqstat, #(1<<IRQ_I2C)
+		movne	\irqnr, #IRQ_I2C
+		bne	1001f
+
+		tst	\irqstat, #(1<<IRQ_IRDA)
+		bicne	\irqstat, \irqstat, #(1<<IRQ_IRDA)
+		movne	\irqnr, #IRQ_IRDA
+		bne	1001f
+
+		tst	\irqstat, #(1<<IRQ_GPIO)
+		bicne	\irqstat, \irqstat, #(1<<IRQ_GPIO)
+		movne	\irqnr, #IRQ_GPIO
+		bne	1001f
+
+		tst	\irqstat, #(1<<IRQ_MAC)
+		bicne	\irqstat, \irqstat, #(1<<IRQ_MAC)
+		movne	\irqnr, #IRQ_MAC
+		bne	1001f
+
+		tst	\irqstat, #(1<<IRQ_ENCRYTION)
+		bicne	\irqstat, \irqstat, #(1<<IRQ_ENCRYTION)
+		movne	\irqnr, #IRQ_ENCRYTION
+		bne	1001f
+
+		tst	\irqstat, #(1<<IRQ_USBOTG_MCU)
+		bicne	\irqstat, \irqstat, #(1<<IRQ_USBOTG_MCU)
+		movne	\irqnr, #IRQ_USBOTG_MCU
+		bne	1001f
+
+		tst	\irqstat, #(1<<IRQ_USBOTG_DMA)
+		bicne	\irqstat, \irqstat, #(1<<IRQ_USBOTG_DMA)
+		movne	\irqnr, #IRQ_USBOTG_DMA
+		bne	1001f
+
+		tst	\irqstat, #(1<<IRQ_TWI2)
+		bicne	\irqstat, \irqstat, #(1<<IRQ_TWI2)
+		movne	\irqnr, #IRQ_TWI2
+		bne	1001f
+		
+		tst	\irqstat, #(1<<IRQ_UART3)
+		bicne	\irqstat, \irqstat, #(1<<IRQ_UART3)
+		movne	\irqnr, #IRQ_UART3
+		bne	1001f
+
+		tst	\irqstat, #(1<<IRQ_UART4)
+		bicne	\irqstat, \irqstat, #(1<<IRQ_UART4)
+		movne	\irqnr, #IRQ_UART4
+		bne	1001f
+
+		tst	\irqstat, #(1<<IRQ_VIDEO_DECODER)
+		bicne	\irqstat, \irqstat, #(1<<IRQ_VIDEO_DECODER)
+		movne	\irqnr, #IRQ_VIDEO_DECODER
+		bne	1001f		
+
+		tst	\irqstat, #(1<<IRQ_GUI)
+		bicne	\irqstat, \irqstat, #(1<<IRQ_GUI)
+		movne	\irqnr, #IRQ_GUI
+		bne	1001f
+
+		tst	\irqstat, #(1<<IRQ_LCD)
+		bicne	\irqstat, \irqstat, #(1<<IRQ_LCD)
+		movne	\irqnr, #IRQ_LCD
+		bne	1001f
+
+		tst	\irqstat, #(1<<IRQ_NULL1)
+		bicne	\irqstat, \irqstat, #(1<<IRQ_NULL1)
+		movne	\irqnr, #IRQ_NULL1
+		bne	1001f
+
+		tst	\irqstat, #(1<<IRQ_MCI2)
+		bicne	\irqstat, \irqstat, #(1<<IRQ_MCI2)
+		movne	\irqnr, #IRQ_MCI2
+		bne	1001f
+
+		tst	\irqstat, #(1<<IRQ_SD_PLUGIN)
+		bicne	\irqstat, \irqstat, #(1<<IRQ_SD_PLUGIN)
+		movne	\irqnr, #IRQ_SD_PLUGIN
+		bne	1001f
+
+		tst	\irqstat, #(1<<IRQ_TWI3)
+		bicne	\irqstat, \irqstat, #(1<<IRQ_TWI3)
+		movne	\irqnr, #IRQ_TWI3
+		bne	1001f
+
+		tst	\irqstat, #(1<<IRQ_TWI4)
+		bicne	\irqstat, \irqstat, #(1<<IRQ_TWI4)
+		movne	\irqnr, #IRQ_TWI4
+		bne	1001f
+		
+		tst	\irqstat, #(1<<IRQ_NULL2)
+		bicne	\irqstat, \irqstat, #(1<<IRQ_NULL2)
+		movne	\irqnr, #IRQ_NULL2
+		bne	1001f
+		
+	1001:
+		@ got irqnr
+	1002:
+		@ exit here
+	.endm
+
+	/* currently don't need an disable_fiq macro */
+	.macro	disable_fiq
+	.endm
+	
diff --git a/arch/arm/mach-anycloudv500/include/mach/irqs.h b/arch/arm/mach-anycloudv500/include/mach/irqs.h
new file mode 100755
index 0000000..9bc4965
--- /dev/null
+++ b/arch/arm/mach-anycloudv500/include/mach/irqs.h
@@ -0,0 +1,90 @@
+/*
+ * linux/arch/arm/mach-ak37d/include/mach/irqs.h
+ *
+ * Copyright (C) 2018 Anyka(Guangzhou) Microelectronics Technology Co., Ltd.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+
+#ifndef __ASM_ARCH_IRQS_H_
+#define __ASM_ARCH_IRQS_H_
+
+#define	AK39_IRQ(x)				(x)
+/*
+ * Main CPU Interrupts
+ */
+#define	IRQ_MEM					AK39_IRQ(0)
+#define	IRQ_CAMERA				AK39_IRQ(1)
+#define	IRQ_VIDEO_ENCODER		AK39_IRQ(2)
+#define	IRQ_SYSCTRL				AK39_IRQ(3)
+#define	IRQ_MCI0				AK39_IRQ(4)
+#define	IRQ_MCI1				AK39_IRQ(5)
+#define	IRQ_ADC2				AK39_IRQ(6)
+#define	IRQ_DAC					AK39_IRQ(7)
+#define	IRQ_SPI1				AK39_IRQ(8)
+#define	IRQ_SPI2				AK39_IRQ(9)
+#define	IRQ_UART0				AK39_IRQ(10)
+#define	IRQ_UART1				AK39_IRQ(11)
+#define	IRQ_L2MEM				AK39_IRQ(12)
+#define	IRQ_I2C					AK39_IRQ(13)
+#define	IRQ_IRDA				AK39_IRQ(14)
+#define	IRQ_GPIO				AK39_IRQ(15)
+#define	IRQ_MAC					AK39_IRQ(16)
+#define	IRQ_ENCRYTION			AK39_IRQ(17)
+#define	IRQ_USBOTG_MCU			AK39_IRQ(18)
+#define	IRQ_USBOTG_DMA			AK39_IRQ(19)
+#define	IRQ_TWI2				AK39_IRQ(20)
+#define	IRQ_UART3				AK39_IRQ(21)
+#define	IRQ_UART4				AK39_IRQ(22)
+#define	IRQ_VIDEO_DECODER		AK39_IRQ(23)
+#define	IRQ_GUI					AK39_IRQ(24)
+#define	IRQ_LCD					AK39_IRQ(25)
+#define	IRQ_NULL1				AK39_IRQ(26)
+#define	IRQ_MCI2				AK39_IRQ(27)
+#define	IRQ_SD_PLUGIN			AK39_IRQ(28)
+#define	IRQ_TWI3				AK39_IRQ(29)
+#define	IRQ_TWI4				AK39_IRQ(30)
+#define	IRQ_NULL2				AK39_IRQ(31)
+
+/*
+ * System Control Module Sub-IRQs
+ */
+#define IRQ_SYSCTRL_START		(IRQ_NULL2 + 1)
+#define	AK39_SYSCTRL_IRQ(x)		(IRQ_SYSCTRL_START + (x))
+
+#define IRQ_SARADC				AK39_SYSCTRL_IRQ(0)
+#define	IRQ_TIMER5				AK39_SYSCTRL_IRQ(1)
+#define	IRQ_TIMER4				AK39_SYSCTRL_IRQ(2)
+#define	IRQ_TIMER3				AK39_SYSCTRL_IRQ(3)
+#define	IRQ_TIMER2				AK39_SYSCTRL_IRQ(4)
+#define	IRQ_TIMER1				AK39_SYSCTRL_IRQ(5)
+#define IRQ_WAKEUP				AK39_SYSCTRL_IRQ(6)
+#define	IRQ_RTC_RDY				AK39_SYSCTRL_IRQ(7)
+#define	IRQ_RTC_ALARM			AK39_SYSCTRL_IRQ(8)
+#define IRQ_RTC_TIMER			AK39_SYSCTRL_IRQ(9)
+#define IRQ_RTC_WATCHDOG		AK39_SYSCTRL_IRQ(10)
+#define IRQ_GPI0_AO				AK39_SYSCTRL_IRQ(11)
+#define IRQ_GPI1_AO				AK39_SYSCTRL_IRQ(12)
+#define IRQ_GPI2_AO				AK39_SYSCTRL_IRQ(13)
+#define IRQ_GPI3_AO				AK39_SYSCTRL_IRQ(14)
+#define IRQ_GPI4_AO				AK39_SYSCTRL_IRQ(15)
+#define IRQ_BVD_LOW_PWR			AK39_SYSCTRL_IRQ(16)
+#define IRQ_PMU_RDY				AK39_SYSCTRL_IRQ(17)
+#define	IRQ_TIMER7				AK39_SYSCTRL_IRQ(18)
+#define	IRQ_TIMER6				AK39_SYSCTRL_IRQ(19)
+
+/* total irq number */
+//#define NR_IRQS     	(IRQ_TIMER6 + 109 + 1)   /* AK37D has 109 gpio irqs */
+#define NR_IRQS     	(IRQ_TIMER6 + 123 + 1)   /* AK37D has 123 gpio irqs */
+
+#endif  /* __ASM_ARCH_IRQS_H_ */
+
diff --git a/arch/arm/mach-anycloudv500/include/mach/map.h b/arch/arm/mach-anycloudv500/include/mach/map.h
new file mode 100755
index 0000000..e33941f
--- /dev/null
+++ b/arch/arm/mach-anycloudv500/include/mach/map.h
@@ -0,0 +1,152 @@
+/*
+ * linux/arch/arm/mach-ak39/include/mach/map.h
+ *
+ * Copyright (C) 2018 Anyka(Guangzhou) Microelectronics Technology Co., Ltd.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+
+#ifndef __ASM_ARCH_MAP_H
+#define __ASM_ARCH_MAP_H
+
+#ifndef __ASSEMBLY__
+#define AK39_ADDR(x)		((void __iomem *)0xF0000000 + (x))
+#else
+#define AK39_ADDR(x)		(0xF0000000 + (x))
+#endif
+
+#define AK_VA_SYSCTRL		AK39_ADDR(0x00008000)
+#define AK_PA_SYSCTRL		(0x08000000)
+#define AK_SZ_SYSCTRL		SZ_32K		/* 32KB */
+
+#define AK_VA_CAMERA		AK39_ADDR(0x00010000)
+#define AK_PA_CAMERA		(0x20000000)
+#define AK_SZ_CAMERA		SZ_64K		/* 64KB */
+
+#define AK_VA_LCD			AK39_ADDR(0x00020000)
+#define AK_PA_LCD			(0x20010000)
+#define AK_SZ_LCD			SZ_32K		/* 32KB */
+
+#define AK_VA_ROTATION		AK39_ADDR(0x00028000)
+#define AK_PA_ROTATION		(0x20018000)
+#define AK_SZ_ROTATION		SZ_32K		/* 32KB */
+
+#define AK_VA_VENCODE		AK39_ADDR(0x00030000)
+#define AK_PA_VENCODE		(0x20020000)
+#define AK_SZ_VENCODE		SZ_64K		/* 64KB */
+
+#define AK_VA_VDECODE		AK39_ADDR(0x00040000)
+#define AK_PA_VDECODE		(0x20030000)
+#define AK_SZ_VDECODE		SZ_64K		/* 64KB */
+
+#define AK_VA_GUI			AK39_ADDR(0x00050000)
+#define AK_PA_GUI			(0x20040000)
+#define AK_SZ_GUI			SZ_64K		/* 64KB */
+
+/* some sub system control register */
+#define AK_VA_SUBCTRL		AK39_ADDR(0x00060000)
+#define AK_PA_SUBCTRL		(0x20100000)
+#define AK_SZ_SUBCTRL		SZ_2M		/* 2MB */
+
+#define AK_VA_MAC			AK39_ADDR(0x00260000)
+#define AK_PA_MAC			(0x20300000)
+#define AK_SZ_MAC			SZ_8K		/* 8KB */
+
+#define AK_VA_MIPI1			AK39_ADDR(0x00262000)
+#define AK_PA_MIPI1			(0x20400000)
+#define AK_SZ_MIPI1			SZ_64K		/* 64KB */
+
+#define AK_VA_MIPI2			AK39_ADDR(0x00272000)
+#define AK_PA_MIPI2			(0x20480000)
+#define AK_SZ_MIPI2			SZ_64K		/* 64KB */
+
+#define AK_VA_DSI			AK39_ADDR(0x00282000)
+#define AK_PA_DSI			(0x20500000)
+#define AK_SZ_DSI			SZ_64K		/* 64KB */
+
+#define AK_VA_REGRAM		AK39_ADDR(0x00292000)
+#define AK_PA_REGRAM		(0x21000000)
+#define AK_SZ_REGRAM		SZ_8K		/* 8KB */
+
+#define AK_VA_L2MEM			AK39_ADDR(0x00294000)
+#define AK_PA_L2MEM			(0x48000000)
+#define AK_SZ_L2MEM			SZ_8K 		/* 8KB */
+
+#define AK_VA_RESERVED_MEM	AK39_ADDR(0x00296000)
+#define AK_PA_RESERVED_MEM	(0x81400000)
+#define AK_SZ_RESERVED_MEM	(0x2000000)
+
+/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */
+#define AK_VA_MCI			(AK_VA_SUBCTRL + 0x0000)
+#define AK_PA_MCI			(AK_PA_SUBCTRL + 0x0000)
+
+#define AK_VA_SDIO			(AK_VA_SUBCTRL + 0x8000)
+#define AK_PA_SDIO			(AK_PA_SUBCTRL + 0x8000)
+
+#define AK_VA_DAC			(AK_VA_SUBCTRL + 0x10000)
+#define AK_PA_DAC			(AK_PA_SUBCTRL + 0x10000)
+
+#define AK_VA_ADC			(AK_VA_SUBCTRL + 0x18000)
+#define AK_PA_ADC			(AK_PA_SUBCTRL + 0x18000)
+
+#define AK_VA_SPI1			(AK_VA_SUBCTRL + 0x20000)
+#define AK_PA_SPI1			(AK_PA_SUBCTRL + 0x20000)
+
+#define AK_VA_SPI2			(AK_VA_SUBCTRL + 0x28000)
+#define AK_PA_SPI2			(AK_PA_SUBCTRL + 0x28000)
+
+#define AK_VA_UART			(AK_VA_SUBCTRL + 0x30000)
+#define AK_PA_UART			(AK_PA_SUBCTRL + 0x30000)
+
+#define AK_VA_UART2			(AK_VA_SUBCTRL + 0x38000)
+#define AK_PA_UART2			(AK_PA_SUBCTRL + 0x38000)
+
+#define AK_VA_L2CTRL		(AK_VA_SUBCTRL + 0x40000)
+#define AK_PA_L2CTRL		(AK_PA_SUBCTRL + 0x40000)
+
+#define AK_VA_I2C1			(AK_VA_SUBCTRL + 0x50000)
+#define AK_PA_I2C1			(AK_PA_SUBCTRL + 0x50000)
+
+#define AK_VA_IRDA			(AK_VA_SUBCTRL + 0x60000)
+#define AK_PA_IRDA			(AK_PA_SUBCTRL + 0x60000)
+
+#define AK_VA_GPIO			(AK_VA_SUBCTRL + 0x70000)
+#define AK_PA_GPIO			(AK_PA_SUBCTRL + 0x70000)
+
+/* encryption register */
+#define AK_VA_ENCRY			(AK_VA_SUBCTRL + 0x80000)
+#define AK_PA_ENCRY			(AK_PA_SUBCTRL + 0x80000)
+
+#define AK_VA_I2C2			(AK_VA_SUBCTRL + 0x90000)
+#define AK_PA_I2C2			(AK_PA_SUBCTRL + 0x90000)
+
+#define AK_VA_UART3			(AK_VA_SUBCTRL + 0xA0000)
+#define AK_PA_UART3			(AK_PA_SUBCTRL + 0xA0000)
+
+#define AK_VA_UART4			(AK_VA_SUBCTRL + 0xA8000)
+#define AK_PA_UART4			(AK_PA_SUBCTRL + 0xA8000)
+
+#define AK_VA_MCI3			(AK_VA_SUBCTRL + 0xB0000)
+#define AK_PA_MCI3			(AK_PA_SUBCTRL + 0xB0000)
+
+#define AK_VA_I2C3			(AK_VA_SUBCTRL + 0xB8000)
+#define AK_PA_I2C3			(AK_PA_SUBCTRL + 0xB8000)
+
+#define AK_VA_I2C4			(AK_VA_SUBCTRL + 0xC0000)
+#define AK_PA_I2C4			(AK_PA_SUBCTRL + 0xC0000)
+
+/* usb register */
+#define AK_VA_USB			(AK_VA_SUBCTRL + 0x100000)
+#define AK_PA_USB			(AK_PA_SUBCTRL + 0x100000)
+
+#endif  /* __ASM_ARCH_MAP_H */
+
diff --git a/arch/arm/mach-anycloudv500/include/mach/uncompress.h b/arch/arm/mach-anycloudv500/include/mach/uncompress.h
new file mode 100755
index 0000000..11fe9c3
--- /dev/null
+++ b/arch/arm/mach-anycloudv500/include/mach/uncompress.h
@@ -0,0 +1,221 @@
+/*
+ * linux/arch/arm/mach-ak39/include/mach/uncompress.h
+ *
+ * Copyright (C) 2018 Anyka(Guangzhou) Microelectronics Technology Co., Ltd.
+ *
+ * Author: Feilong Dong <dong_feilong@anyka.com>
+ *         Donghua Cao  <cao_donghua@anyka.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+
+#ifndef __UNCOMPRESS_H_
+#define __UNCOMPRESS_H_
+
+#include <asm/sizes.h>
+#include <mach/map.h>
+
+#if defined(CONFIG_CPU_AK3750D) || defined(CONFIG_CPU_AK3918EV500)|| defined(CONFIG_CPU_AK3790D)
+#define CONFIG_UART0_INIT
+#endif
+
+#define BAUD_RATE  					115200
+#define ENDDING_OFFSET				60
+
+#undef REG32
+#define REG32(_reg)             	(*(volatile unsigned long *)(_reg))
+
+#define CLK_ASIC_PLL_CTRL			(AK_PA_SYSCTRL + 0x08)
+
+/* L2 buffer address */
+#define UART0_TXBUF_ADDR			(0x48000000 + 0x1000) //0x48001000
+#define UART0_RXBUF_ADDR        	(0x48000000 + 0x1080)
+
+/* L2 buffer control register */
+#define L2BUF_CONF2_REG         	REG32(0x20140000 + 0x008C) //0x2014008c
+#define UART0_TXBUF_CLR_BIT     	16
+#define UART0_RXBUF_CLR_BIT     	17
+
+/* pullup/pulldown configure registers */
+#define PPU_PPD1_REG           	REG32(AK_PA_SYSCTRL + 0x194) //0x08000080  
+#define TXD0_PU_BIT             1
+#define RXD0_PU_BIT             0
+
+/* Clock control register */
+#define CLK_CTRL_REG1			REG32(AK_PA_SYSCTRL + 0x1C) //0x0800000C
+#define UART0_CLKEN_BIT			7	//0x0800,001C
+
+/*********** Shared pin control reigsters ********/
+#define SRDPIN_CTRL1_REG     	REG32(AK_PA_SYSCTRL + 0x178) //0x08000074
+
+#define UART0_RXD				0
+#define UART0_TXD				2
+
+/** ************ UART registers *****************************/
+#define UART0_CONF1_REG			REG32(0x20130000 + 0x00) //0x20130000
+#define UART0_CONF2_REG			REG32(0x20130000 + 0x04)
+#define UART0_DATA_CONF_REG		REG32(0x20130000 + 0x08)
+#define UART0_BUF_THRE_REG		REG32(0x20130000 + 0x0C)
+#define UART0_BUF_RX_REG		REG32(0x20130000 + 0x10)
+#define UART0_BUF_RX_BACKUP_REG	REG32(0x20130000 + 0x14)
+#define UART0_BUF_STOPBIT_REG	REG32(0x20130000 + 0x18)
+
+/* bit define of UARTx_CONF1_REG */
+#define CTS_SEL_BIT             18
+#define RTS_SEL_BIT             19
+#define PORT_ENABLE_BIT         21  //0: disable, 1:enable
+#define TX_STATUS_CLR_BIT       28
+#define RX_STATUS_CLR_BIT       29
+
+/* bit define of UARTx_CONF2_REG */
+#define TX_COUNT_BIT            4
+#define TX_COUNT_VALID_BIT      16
+#define TX_END_BIT              19
+#define TX_END_MASK             (1 << TX_END_BIT)
+	
+#define UART_TXBUF_CLR_BIT      UART0_TXBUF_CLR_BIT 
+#define SRDPIN_UART_RXTX_BIT    ((1 << UART0_RXD)|(1 << UART0_TXD)) // GPIO 1&2, 0x0800,0074 bit[1]&bit[2] == 1&1
+#define RXD_PU_BIT              RXD0_PU_BIT
+#define TXD_PU_BIT              TXD0_PU_BIT
+#define UART_CLKEN_BIT			UART0_CLKEN_BIT
+#define UART_TXBUF_ADDR         UART0_TXBUF_ADDR
+#define UART_CONF1_REG          UART0_CONF1_REG
+#define UART_CONF2_REG          UART0_CONF2_REG
+#define UART_DATA_CONF_REG      UART0_DATA_CONF_REG
+#define UART_BUF_STOPBIT_REG	UART0_BUF_STOPBIT_REG
+
+static unsigned int __uidiv(unsigned int num, unsigned int den)
+{
+	unsigned int i;
+
+	if (den == 1)
+		return num;
+
+	i = 1;
+	while (den * i < num)
+		i++;
+
+	return i-1;
+}
+
+static unsigned long __get_asic_pll_clk(void)
+{
+	unsigned long pll_m, pll_n, pll_od;
+	unsigned long asic_pll_clk;
+	unsigned long regval;
+
+	regval = REG32(CLK_ASIC_PLL_CTRL);
+	pll_od = (regval & (0x3 << 12)) >> 12;
+	pll_n = (regval & (0xf << 8)) >> 8;
+	pll_m = regval & 0xff;
+
+	asic_pll_clk = (12 * pll_m)/(pll_n * (1 << pll_od)); // clk unit: MHz
+
+	if ((pll_od >= 1) && ((pll_n >= 2) && (pll_n <= 6)) 
+		 && ((pll_m >= 84) && (pll_m <= 254)))
+		return asic_pll_clk;
+	return 0;
+}
+
+static unsigned long __get_vclk(void)
+{
+	unsigned long regval;
+	unsigned long div;
+	
+	regval = REG32(CLK_ASIC_PLL_CTRL);
+	div = (regval & (0x7 << 17)) >> 17;
+	if (div == 0)
+		return __get_asic_pll_clk() >> 1;
+	
+	return __get_asic_pll_clk() >> div;
+}
+
+static unsigned long __get_asic_clk(void)
+{
+	unsigned long regval;
+	unsigned long div;
+	
+	regval = REG32(CLK_ASIC_PLL_CTRL);
+	div = regval & (1 << 24);
+	if (div == 0) 
+		return __get_vclk();
+	
+	return __get_vclk() >> 1;
+}
+
+static void uart_init(void)
+{
+	unsigned int asic_clk, clk_div;
+
+	/* adjust DMA priority */
+	//REG32(0x21000018) = 0x00FFFFFF;
+
+	/* enable uart clock control */
+	CLK_CTRL_REG1 &= ~(0x1 << UART_CLKEN_BIT);
+
+	/* configuration shared pins to UART0  */
+	SRDPIN_CTRL1_REG |= SRDPIN_UART_RXTX_BIT;
+
+	/* configuration uart pin pullup disable */
+	PPU_PPD1_REG |= (0x1 << RXD_PU_BIT) | (0x1 << TXD_PU_BIT);
+
+	// set uart baud rate
+	asic_clk = __get_asic_clk()*1000000;
+	clk_div = __uidiv(asic_clk, BAUD_RATE) - 1;
+	UART_CONF1_REG &= ~((0x1 << TX_STATUS_CLR_BIT) | (0x1 << RX_STATUS_CLR_BIT) | 0xFF);
+	UART_CONF1_REG |= (0x1 << TX_STATUS_CLR_BIT) | (0x1 << RX_STATUS_CLR_BIT) | clk_div; 
+	
+#ifdef CONFIG_UART1_INIT
+	/* Disable flow control */
+	UART_CONF1_REG |= (0x1 << CTS_SEL_BIT) | (0x1 << RTS_SEL_BIT);
+#endif
+	UART_BUF_STOPBIT_REG = (0x1F << 16) | (0x1 << 0);
+
+	/* enable uart port */
+	UART_CONF1_REG |= (0x1 << PORT_ENABLE_BIT);
+}
+
+
+/* print a char to uart */
+void putc(char c)
+{
+	/* Clear uart tx buffer */
+	L2BUF_CONF2_REG   |= (0x1 << UART_TXBUF_CLR_BIT);
+
+	/* write char to uart buffer */
+	REG32(UART_TXBUF_ADDR) = (unsigned long)c;
+	REG32(UART_TXBUF_ADDR + ENDDING_OFFSET) = (unsigned long)'\0';
+	
+	/* Clear uart tx count register */
+	UART_CONF1_REG |= (0x1 << TX_STATUS_CLR_BIT);
+
+	/* Send buffer, each time only send 1 byte */
+	UART_CONF2_REG |= (1 << TX_COUNT_BIT) | (0x1 << TX_COUNT_VALID_BIT);
+
+	/* Wait for finish */
+	while((UART_CONF2_REG & TX_END_MASK) == 0) {
+	}
+}
+
+static inline void flush(void)
+{
+}
+
+static inline void arch_decomp_setup(void)
+{
+	uart_init();
+}
+
+/* nothing to do */
+#define arch_decomp_wdog()
+
+#endif   /* __UNCOMPRESS_H_ */
diff --git a/arch/arm/tools/mach-types b/arch/arm/tools/mach-types
old mode 100644
new mode 100755
index 2ed1b8a..6f783ac
--- a/arch/arm/tools/mach-types
+++ b/arch/arm/tools/mach-types
@@ -1006,3 +1006,5 @@ eco5_bx2		MACH_ECO5_BX2		ECO5_BX2		4572
 eukrea_cpuimx28sd	MACH_EUKREA_CPUIMX28SD	EUKREA_CPUIMX28SD	4573
 domotab			MACH_DOMOTAB		DOMOTAB			4574
 pfla03			MACH_PFLA03		PFLA03			4575
+anyka_ak39xx	MACH_AK39XX		AK39XX			3892
+anyka_ak		MACH_AK			AK37XX			3893
diff --git a/drivers/clk/Makefile b/drivers/clk/Makefile
old mode 100644
new mode 100755
index af9e9af..c89bc0b
--- a/drivers/clk/Makefile
+++ b/drivers/clk/Makefile
@@ -49,6 +49,7 @@ obj-$(CONFIG_COMMON_CLK_WM831X)		+= clk-wm831x.o
 obj-$(CONFIG_COMMON_CLK_XGENE)		+= clk-xgene.o
 obj-$(CONFIG_COMMON_CLK_PWM)		+= clk-pwm.o
 obj-$(CONFIG_COMMON_CLK_AT91)		+= at91/
+obj-y			        += anyka/
 obj-y					+= bcm/
 obj-$(CONFIG_ARCH_BERLIN)		+= berlin/
 obj-$(CONFIG_ARCH_HISI)			+= hisilicon/
diff --git a/drivers/clk/anyka/Makefile b/drivers/clk/anyka/Makefile
new file mode 100755
index 0000000..bff46b6
--- /dev/null
+++ b/drivers/clk/anyka/Makefile
@@ -0,0 +1,6 @@
+#
+# Anyka Clock specific Makefile
+#
+
+obj-$(CONFIG_ARCH_AK39)	+= ak39_clk.o
+obj-$(CONFIG_ARCH_AK) += ak_clk.o
diff --git a/drivers/clk/anyka/ak39_clk.c b/drivers/clk/anyka/ak39_clk.c
new file mode 100755
index 0000000..e72e972
--- /dev/null
+++ b/drivers/clk/anyka/ak39_clk.c
@@ -0,0 +1,707 @@
+/*
+ * AK39XX clk driver
+ *
+ * Copyright (C) 2018 Anyka(Guangzhou) Microelectronics Technology Co., Ltd.
+ *
+ * Author: Feilong Dong <dong_feilong@anyka.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+/**
+ * DOC: AK39XX (clock resource manager)
+ *
+ * The clock tree on the Ak39XX has several levels.  There's a root
+ * oscillator running at 12Mhz. After the oscillator there are 3
+ * PLLs, roughly divided as "CPU_PLL", "ASIC_PLL" and "PERI_PLL".  
+ * Those 3 PLLs each can divide their output to produce several channels.
+ * Finally, there is the level of clocks to be consumed by other hardware
+ * components (like "isp" or "nethernet"), which divide off of some subset
+ * of the PLL channels.
+ *
+ * All of the clocks in the tree are exposed in the DT, because the DT
+ * may want to make assignments of the final layer of clocks to the
+ * PLL channels, and some components of the hardware will actually
+ * skip layers of the tree (for example, the sar_adc clock comes
+ * directly from the root oscillator without using a clock divider 
+ * from PLL).
+ */
+
+#define pr_fmt(fmt) KBUILD_MODNAME ": " fmt
+
+#include <linux/clk-provider.h>
+#include <linux/clkdev.h>
+#include <linux/clk.h>
+//#include <linux/clk/ak_clk.h>
+#include <linux/debugfs.h>
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/of_address.h>
+#include <linux/platform_device.h>
+#include <linux/slab.h>
+#include <linux/delay.h>
+
+//#include <dt-bindings/clock/ak_clk.h>
+#include <mach/map.h>
+
+/* clock register offset */
+#define CLOCK_CPU_PLL_CTRL			(0x04)
+#define CLOCK_ASIC_PLL_CTRL			(0x08)
+#define CLOCK_ADC2_DAC_CTRL			(0x0C)
+#define CLOCK_ADC2_DAC_HS_CTRL		(0x10)
+#define CLOCK_PERI_PLL_CTRL1		(0x14)
+#define CLOCK_PERI_PLL_CTRL2		(0x18)
+#define CLOCK_GATE_CTRL1			(0x1C)
+#define CLOCK_SOFT_RESET			(0x20)
+#define CLOCK_USB_I2S_CTRL			(0x58)
+
+/* clock gate control register bit */
+#define AK_GATE_MCLK_DPHY			(1 << 25)
+#define AK_GATE_MCLK_DRAM			(1 << 24)
+#define AK_GATE_VCLK2_VIDEO			(1 << 20)
+#define AK_GATE_VCLK1_CAMERA		(1 << 19)
+#define AK_GATE_ASICCLK_I2C1		(1 << 17)
+#define AK_GATE_ASICCLK_MIPI		(1 << 16)
+#define AK_GATE_ASICCLK_USB			(1 << 15)
+#define AK_GATE_ASICCLK_ENCRYPT		(1 << 14)
+#define AK_GATE_ASICCLK_MAC			(1 << 13)
+#define AK_GATE_ASICCLK_GPIO		(1 << 12)
+#define AK_GATE_ASICCLK_IRDA		(1 << 11)
+#define AK_GATE_ASICCLK_I2C0		(1 << 10)
+#define AK_GATE_ASICCLK_L2MEM		(1 << 9)
+#define AK_GATE_ASICCLK_UART1		(1 << 8)
+#define AK_GATE_ASICCLK_UART0		(1 << 7)
+#define AK_GATE_ASICCLK_SPI1		(1 << 6)
+#define AK_GATE_ASICCLK_SPI0		(1 << 5)
+#define AK_GATE_ASICCLK_DAC			(1 << 4)
+#define AK_GATE_ASICCLK_ADC2		(1 << 3)
+#define AK_GATE_ASICCLK_MCI1		(1 << 2)
+#define AK_GATE_ASICCLK_MCI0		(1 << 1)
+
+/* clock reset control register bit */
+#define AK_RESET_ADC1				(1 << 30)
+#define AK_RESET_HSADC2				(1 << 29) | (1 << 27)
+#define AK_RESET_HSDAC				(1 << 28) | (1 << 26)
+#define AK_RESET_DPHY				(1 << 25)
+#define AK_RESET_DRAM				(1 << 24)
+#define AK_RESET_VIDEO				(1 << 20)
+#define AK_RESET_CAMERA				(1 << 19)
+#define AK_RESET_I2C1				(1 << 17)
+#define AK_RESET_MIPI				(1 << 16)
+#define AK_RESET_USB				(1 << 15)
+#define AK_RESET_ENCRYPT			(1 << 14)
+#define AK_RESET_MAC				(1 << 13)
+#define AK_RESET_GPIO				(1 << 12)
+#define AK_RESET_IRDA				(1 << 11)
+#define AK_RESET_I2C0				(1 << 10)
+#define AK_RESET_L2MEM				(1 << 9)
+#define AK_RESET_UART1				(1 << 8)
+#define AK_RESET_UART0				(1 << 7)
+#define AK_RESET_SPI1				(1 << 6)
+#define AK_RESET_SPIO				(1 << 5)
+#define AK_RESET_DAC				(1 << 4)
+#define AK_RESET_ADC2				(1 << 3)
+#define AK_RESET_MCI1				(1 << 2)
+#define AK_RESET_MCI0				(1 << 1)
+
+
+/* ADC2/DAC clock control register */
+#define AK_CLKCON_CLK_DAC			(1 << 28)
+#define AK_CLKCON_CLK_ADC1			(1 << 3)
+
+/* ADC2/DAC high speed clock control register */
+#define AK_CLKCON_HCLK_ADC2			(1 << 28)
+#define AK_CLKCON_HCLK_DAC			(1 << 18)
+#define AK_CLKCON_CLK_ADC2			(1 << 8)
+
+
+/* PERI PLL channel clock control register1 */
+//1: peri pll 	0: external 12MHz
+#define AK_CLKCON_CLK_PHY_SEL		(1 << 19)
+//1: peri pll	0: external 25MHz
+#define AK_CLKCON_CLK_MAC_SEL		(1 << 18)
+#define AK_CLKCON_CLK_12M			(1 << 17)
+#define AK_CLKCON_CLK_25M			(1 << 16)
+#define AK_CLKCON_CLK_25M_IN		(1 << 14)
+
+/* PERI PLL channel clock control register2 */
+/* 1: positive clk	0: negative clk */
+#define AK_CLKCON_PCLK_CIS			(1 << 20)		//camera
+#define AK_CLKCON_SCLK_CIS			(1 << 18)		//sensor
+#define AK_CLKCON_CLK_OPCLK			(1 << 8)		//MAC
+
+#define AK39_CLK_CPU2X_MODE		(1 << 24)
+#define AK39_CLK_MEM2X_MODE		(1 << 30) // CDH:H3 ADD DPHYCLK2X
+
+#define MHz	1000000UL
+
+struct ak_fixed_clk {
+	int id;
+	struct clk_hw hw;
+	void __iomem *reg;
+	unsigned long fixed_rate;
+};
+
+struct ak_factor_clk {
+	int id;
+	struct clk_hw hw;
+	void __iomem *reg;
+	int m;
+	int n;
+};
+
+struct ak_mux_clk {
+	int id;
+	struct clk_hw hw;
+	void __iomem *reg;
+	int select_index;
+};
+
+struct ak_gate_clk {
+	int id;
+	struct clk_hw hw;
+	void __iomem *reg;
+	int ctrlbit;
+};
+
+#define to_clk_ak_fixed(_hw) container_of(_hw, struct ak_fixed_clk, hw)
+#define to_clk_ak_factor(_hw) container_of(_hw, struct ak_factor_clk, hw)
+#define to_clk_ak_mux(_hw) container_of(_hw, struct ak_mux_clk, hw)
+#define to_clk_ak_gate(_hw) container_of(_hw, struct ak_gate_clk, hw)
+
+static unsigned long ak_get_cpu_pll_clk(void __iomem *reg)
+{
+	unsigned long pll_m, pll_n, pll_od;
+	unsigned long cpu_pll_clk;
+	unsigned long regval;
+
+	regval = __raw_readl(reg + CLOCK_CPU_PLL_CTRL);
+	pll_od = (regval & (0x3 << 12)) >> 12;
+	pll_n = (regval & (0xf << 8)) >> 8;
+	pll_m = regval & 0xff;
+
+	cpu_pll_clk = 12 * pll_m /(pll_n * (1 << pll_od)); // clk unit: MHz
+	if ((pll_od >= 1) && ((pll_n >= 1) && (pll_n <= 12)) 
+		 && ((pll_m >= 84) && (pll_m <= 254)))
+		return cpu_pll_clk * MHz;
+	
+	panic("cpu pll clk: %ld(Mhz) is unusable\n", cpu_pll_clk);
+}
+
+static unsigned long ak_fixed_clk_recalc_rate(struct clk_hw *hw, unsigned long parent_rate)
+{
+    unsigned long regval;
+	//get fixed clk rate from dts
+	//set regs
+	struct ak_fixed_clk *fixed_clk = to_clk_ak_fixed(hw);
+	
+	switch(fixed_clk->id) {
+		case 0:	//CPU
+			regval = __raw_readl(fixed_clk->reg + CLOCK_CPU_PLL_CTRL);
+			if (regval & AK39_CLK_CPU2X_MODE)
+				fixed_clk->fixed_rate = ak_get_cpu_pll_clk(fixed_clk->reg);
+			else
+				fixed_clk->fixed_rate = ak_get_cpu_pll_clk(fixed_clk->reg) >> 1;		
+			break;
+		case 1: //AHB
+				fixed_clk->fixed_rate = ak_get_cpu_pll_clk(fixed_clk->reg) >> 1;				
+			break;
+		case 2: //MEM
+			fixed_clk->fixed_rate = ak_get_cpu_pll_clk(fixed_clk->reg) >> 1;		
+			break;
+		case 3: //DPHY
+			regval = __raw_readl(fixed_clk->reg + CLOCK_CPU_PLL_CTRL);
+			if (regval & AK39_CLK_MEM2X_MODE)
+				fixed_clk->fixed_rate = ak_get_cpu_pll_clk(fixed_clk->reg);
+			else
+				fixed_clk->fixed_rate = ak_get_cpu_pll_clk(fixed_clk->reg) >> 1;
+			break;
+		case 4: //ASIC_PLL set in init func, just return
+		case 5: //PERI_PLL set in init func, just return
+			break;
+
+		default:
+			pr_err("No this clk config in dts.\n");
+			break;
+	}
+	
+	return fixed_clk->fixed_rate;
+}
+
+const struct clk_ops ak_fixed_clk_ops = {
+	.recalc_rate = ak_fixed_clk_recalc_rate,
+};
+
+static long ak_factor_clk_round_rate(struct clk_hw *hw, unsigned long rate,
+					unsigned long *parent_rate)
+{
+	//struct ak_client_clk *client_clk = to_clk_ak_factor(hw);
+	/*to do*/
+	return 0;
+}
+
+static int ak_factor_clk_set_rate(struct clk_hw *hw, 
+	unsigned long rate, unsigned long parent_rate)
+{
+	//struct ak_client_clk *client_clk = to_clk_ak_factor(hw);
+	/*to do*/
+	return 0;
+}
+
+static unsigned long ak_factor_clk_recalc_rate(struct clk_hw *hw,
+					unsigned long parent_rate)
+{
+	//struct ak_client_clk *client_clk = to_clk_ak_factor(hw);
+	/* to do */
+	return 0;
+}
+
+const struct clk_ops ak_factor_clk_ops = {
+	.round_rate = ak_factor_clk_round_rate,
+	.set_rate = ak_factor_clk_set_rate,
+	.recalc_rate = ak_factor_clk_recalc_rate,
+};
+
+static int ak_mux_clk_set_parent(struct clk_hw *hw, u8 index)
+{
+	//struct ak_client_clk *client_clk = to_clk_ak_mux(hw);
+	/* to do */
+	return 0;
+}
+
+static u8 ak_mux_clk_get_parent(struct clk_hw *hw)
+{
+	//struct ak_client_clk *client_clk = to_clk_ak_mux(hw);
+	/* to do */
+	return 0;
+}
+
+
+const struct clk_ops ak_mux_clk_ops = {
+    .set_parent = ak_mux_clk_set_parent,
+    .get_parent = ak_mux_clk_get_parent,
+    //.determine_rate = __clk_mux_determine_rate,
+};
+
+static int ak_gc_enable(struct clk_hw *hw)
+{
+	struct ak_gate_clk *gate_clk = to_clk_ak_gate(hw);
+	u32 con;
+	
+	con = __raw_readl(gate_clk->reg + CLOCK_GATE_CTRL1);
+	con &= ~(1<<gate_clk->ctrlbit);
+	__raw_writel(con, gate_clk->reg + CLOCK_GATE_CTRL1);
+
+	con = __raw_readl(gate_clk->reg + CLOCK_SOFT_RESET);
+	con |= (0x1 << gate_clk->ctrlbit);
+	__raw_writel(con, gate_clk->reg + CLOCK_SOFT_RESET);
+	mdelay(5);
+	con = __raw_readl(gate_clk->reg + CLOCK_SOFT_RESET);
+	con &= ~(0x1 << gate_clk->ctrlbit);
+	__raw_writel(con, gate_clk->reg + CLOCK_SOFT_RESET);
+	return 0;
+}
+
+static void ak_gc_disable(struct clk_hw *hw)
+{
+	struct ak_gate_clk *gate_clk = to_clk_ak_gate(hw);
+	u32 con;
+	
+	con = __raw_readl(gate_clk->reg + CLOCK_GATE_CTRL1);
+	con |= (1<<gate_clk->ctrlbit);
+	__raw_writel(con, gate_clk->reg + CLOCK_GATE_CTRL1);
+}
+
+static unsigned long ak_gc_recalc_rate(struct clk_hw *hw,
+					unsigned long parent_rate)
+{
+	struct ak_gate_clk *gate_clk = to_clk_ak_gate(hw);
+	unsigned long rate;
+	u32 regval = __raw_readl(gate_clk->reg + CLOCK_ASIC_PLL_CTRL);
+
+	regval = ((regval >> 17) && 0x7);
+	if (regval == 0)
+		regval = 1;
+	
+	if (gate_clk->id > 18)
+		rate = parent_rate>>1;
+	else
+		rate = parent_rate>>(1+regval);
+	
+	return rate;
+}
+
+const struct clk_ops ak_gate_clk_ops = {
+	.enable		= ak_gc_enable,
+	.disable	= ak_gc_disable,
+	.recalc_rate = ak_gc_recalc_rate,
+};
+
+struct clk * __init ak_register_fixed_clk(
+		const char *name,
+		const char *parent_name,
+		void __iomem *res_reg,
+		u32 fixed_rate,
+		int id,
+		const struct clk_ops *ops)
+{
+	struct ak_fixed_clk *fixed_clk;
+	struct clk *clk;
+	struct clk_init_data init = {};
+
+	fixed_clk = kzalloc(sizeof(*fixed_clk), GFP_KERNEL);
+	if (!fixed_clk)
+		return ERR_PTR(-ENOMEM);
+
+	init.name = name;
+	init.flags = CLK_IS_BASIC;
+	init.parent_names = parent_name ? &parent_name : NULL;
+	init.num_parents = parent_name ? 1 : 0;
+	init.ops = ops;
+
+	fixed_clk->reg = res_reg;
+	fixed_clk->fixed_rate = fixed_rate;
+	fixed_clk->id = id;
+
+	fixed_clk->hw.init = &init;
+
+	clk = clk_register(NULL, &fixed_clk->hw);
+	if (IS_ERR(clk))
+		kfree(fixed_clk);
+
+	return clk;
+}
+
+struct clk * __init ak_register_factor_clk(
+		const char *name,
+		const char *parent_name,
+		void __iomem *res_reg,
+		int id,
+		const struct clk_ops *ops)
+{
+	struct ak_factor_clk *factor_clk;
+	struct clk *clk;
+	struct clk_init_data init = {};
+
+	factor_clk = kzalloc(sizeof(*factor_clk), GFP_KERNEL);
+	if (!factor_clk)
+		return ERR_PTR(-ENOMEM);
+
+	init.name = name;
+	init.flags = CLK_IGNORE_UNUSED;
+	init.parent_names = parent_name ? &parent_name : NULL;
+	init.num_parents = 1;
+	init.ops = ops;
+
+	factor_clk->reg = res_reg;
+	factor_clk->id = id;
+	factor_clk->hw.init = &init;
+
+	clk = clk_register(NULL, &factor_clk->hw);
+	if (IS_ERR(clk))
+		kfree(factor_clk);
+
+	return clk;
+}
+
+struct clk * __init ak_register_mux_clk(
+		const char *name,
+		const char * const *parent_names,
+		int num_parents,
+		void __iomem *res_reg,
+		int id,
+		const struct clk_ops *ops)
+{
+	struct ak_mux_clk *mux_clk;
+	struct clk *clk;
+	struct clk_init_data init = {};
+
+	mux_clk = kzalloc(sizeof(*mux_clk), GFP_KERNEL);
+	if (!mux_clk)
+		return ERR_PTR(-ENOMEM);
+
+	init.name = name;
+	init.flags = CLK_SET_RATE_PARENT;
+	init.parent_names = parent_names;
+	init.num_parents = num_parents;
+	init.ops = ops;
+
+	mux_clk->id = id;
+	mux_clk->reg = res_reg;
+	mux_clk->hw.init = &init;
+
+	clk = clk_register(NULL, &mux_clk->hw);
+	if (IS_ERR(clk))
+		kfree(mux_clk);
+
+	return clk;
+}
+
+
+struct clk * __init ak_clk_register_gate(
+		const char *name,
+		const char *parent_name,
+		void __iomem *res_reg,
+		u8 ctrlbit,
+		const struct clk_ops *ops)
+{
+	struct ak_gate_clk *gate_clk;
+	struct clk *clk;
+	struct clk_init_data init = {};
+
+	gate_clk = kzalloc(sizeof(*gate_clk), GFP_KERNEL);
+	if (!gate_clk)
+		return ERR_PTR(-ENOMEM);
+
+	init.name = name;
+	init.flags = CLK_SET_RATE_PARENT;
+	init.parent_names = parent_name ? &parent_name : NULL;
+	init.num_parents = parent_name ? 1 : 0;
+	init.ops = ops;
+
+	gate_clk->reg = res_reg;
+	gate_clk->ctrlbit = ctrlbit;
+
+	gate_clk->hw.init = &init;
+
+	clk = clk_register(NULL, &gate_clk->hw);
+	if (IS_ERR(clk))
+		kfree(gate_clk);
+	//printk("RRRR###################%s_%d, gate_clk =%p, clk=%p\n", __FUNCTION__, __LINE__, gate_clk,clk);
+	return clk;
+}
+
+void aisc_pll_init(void __iomem *reg, u32 asic_pll, u32 div_od, u32 div_n)
+{
+	u32 div_m;
+	u32 asicclk;
+	u32 uartdiv;
+	u32 regval;
+
+	if ((div_n < 2) || (div_n > 6)
+		|| (div_od < 1) || (div_od > 3))
+		panic("Asic frequency parameter Error");
+
+	/* asic_pll = 480M=2vclk = 240M=4asic=120M */
+	asicclk = asic_pll >> 2;
+	div_m = ((asic_pll/MHz)*(div_n * (1 << div_od)))/12;
+	uartdiv = asicclk/115200-1;
+	/* set asic pll frequency */
+	regval = ((1 << 24)|(1 << 23)|(1 <<17)|(div_od << 12)|(div_n << 8)|(div_m));
+	__raw_writel(regval, reg + CLOCK_ASIC_PLL_CTRL);
+
+	/* enable asic pll freq change valid */
+	regval = __raw_readl(reg + CLOCK_CPU_PLL_CTRL);
+	regval |= (1 << 28);
+	__raw_writel(regval, reg + CLOCK_CPU_PLL_CTRL);	
+
+	/* set uart baud rate */
+	/*regval = __raw_readl(AK_VA_UART + 0x00);
+	regval &= ~((0x1 << 28) | (0x1 << 29) | 0xFF);
+	regval |= (0x1 << 28) | (0x1 << 29) | uartdiv;
+	__raw_writel(regval, AK_VA_UART + 0x00);*/
+}
+
+void peri_pll_init(void __iomem *reg, u32 peri_pll, u32 div_od, u32 div_n)
+{
+	u32 div_m;
+	u32 regval;
+
+	if ((div_n < 2) || (div_n > 6)
+		|| (div_od < 1) || (div_od > 3))
+		panic("Asic frequency parameter Error");
+
+	/* peri_pll = 600M */
+	div_m = ((peri_pll/MHz)*(div_n * (1 << div_od)))/12;
+	/* set peri pll frequency */
+	regval = __raw_readl(reg + CLOCK_PERI_PLL_CTRL1);
+    regval &= ~((0x3<<12)|(0xf<<8)|0xff);
+    regval |= ((div_od << 12)|(div_n << 8)|(div_m));
+    __raw_writel(regval, reg + CLOCK_PERI_PLL_CTRL1);
+	
+	/* enable peri pll freq change valid */
+	regval = __raw_readl(reg + CLOCK_CPU_PLL_CTRL);
+	regval |= (1 << 29);
+	__raw_writel(regval, reg + CLOCK_CPU_PLL_CTRL);
+}
+
+static void __init of_ak_fixed_clk_init(struct device_node *np)
+{
+	struct clk_onecell_data *clk_data;
+	const char *clk_name = np->name;
+	const char *parent_name = of_clk_get_parent_name(np, 0);
+	void __iomem *res_reg = AK_VA_SYSCTRL;
+	u32 rate, div_od, div_n;
+	int id, index, number;
+
+	clk_data = kmalloc(sizeof(struct clk_onecell_data), GFP_KERNEL);
+	if (!clk_data)
+		return;
+
+	number = of_property_count_u32_elems(np, "clock-id");
+	clk_data->clks = kcalloc(number, sizeof(struct clk *), GFP_KERNEL);
+	if (!clk_data->clks)
+		goto err_free_data;
+
+	of_property_read_u32(np, "clock-frequency", &rate);
+	of_property_read_u32(np, "clock-div-od", &div_od);
+	of_property_read_u32(np, "clock-div-n", &div_n);
+
+	if (!strcmp(clk_name, "asic_pll")){	
+		aisc_pll_init(res_reg, rate, div_od, div_n);
+	}
+	if (!strcmp(clk_name, "peri_pll")){
+		peri_pll_init(res_reg, rate, div_od, div_n);
+	}
+
+	for (index = 0; index < number; index++) {
+		of_property_read_string_index(np, "clock-output-names",
+					      index, &clk_name);
+		of_property_read_u32_index(np, "clock-id", index, &id);
+		//pr_err("of_ak_fixed_clk_init %s %s %d %d\n", clk_name, parent_name, rate, id);
+		clk_data->clks[index] = ak_register_fixed_clk(clk_name, parent_name,
+						res_reg, rate, id, &ak_fixed_clk_ops);
+		if (IS_ERR(clk_data->clks[index])) {
+			pr_err("ak39_fixed_clk register fixed clk failed: clk_name:%s, index = %d\n", clk_name, index);
+			WARN_ON(true);
+			continue;
+		}
+	}
+
+	clk_data->clk_num = number;
+	if (number == 1)
+		of_clk_add_provider(np, of_clk_src_simple_get, clk_data->clks[0]);
+	else
+		of_clk_add_provider(np, of_clk_src_onecell_get, clk_data);
+
+	return;
+
+err_free_data:
+	kfree(clk_data);
+}
+
+static void __init of_ak_factor_clk_init(struct device_node *np)
+{
+	struct clk_onecell_data *clk_data;
+	const char *clk_name = np->name;
+	const char *parent_name = of_clk_get_parent_name(np, 0);
+	void __iomem *res_reg = AK_VA_SYSCTRL;
+	//u32 div_n, div_m;
+	int id, index, number;
+
+	clk_data = kmalloc(sizeof(struct clk_onecell_data), GFP_KERNEL);
+	if (!clk_data)
+		return;
+
+	number = of_property_count_u32_elems(np, "clock-id");
+	clk_data->clks = kcalloc(number, sizeof(struct clk *), GFP_KERNEL);
+	if (!clk_data->clks)
+		goto err_free_data;
+
+	//of_property_read_u32(np, "clock-div-n", &div_n);
+	//of_property_read_u32(np, "clock-div-m", &div_m);
+
+	for (index = 0; index < number; index++) {
+		of_property_read_string_index(np, "clock-output-names",
+					      index, &clk_name);
+		of_property_read_u32_index(np, "clock-id", index, &id);
+		//pr_err(KERN_ERR"of_ak_factor_clk_init %s %s %d %d\n", clk_name, parent_name, id, index);
+		clk_data->clks[index] = ak_register_factor_clk(clk_name, parent_name,
+						res_reg, id, &ak_factor_clk_ops);
+		if (IS_ERR(clk_data->clks[index])) {
+			pr_err("ak39_factor_clk register gate clk failed: clk_name:%s, err = %s\n", clk_name, (char *)PTR_ERR(clk_data->clks[index]));
+			WARN_ON(true);
+			continue;
+		}
+	}
+
+	clk_data->clk_num = number;
+	if (number == 1)
+		of_clk_add_provider(np, of_clk_src_simple_get, clk_data->clks[0]);
+	else
+		of_clk_add_provider(np, of_clk_src_onecell_get, clk_data);
+
+	return;
+	
+err_free_data:
+	kfree(clk_data);
+}
+
+static void __init of_ak_mux_clk_init(struct device_node *np)
+{
+	struct clk *clk = NULL;
+	const char *clk_name = np->name;
+	const char *parent_name[2];
+	void __iomem *res_reg = AK_VA_SYSCTRL;
+	int id, number;
+
+	number = of_clk_parent_fill(np, parent_name, 2);
+	of_property_read_string(np, "clock-output-names", &clk_name);
+	of_property_read_u32(np, "clock-id", &id);
+
+	//pr_err("of_ak_mux_clk_init %s %s %s %d\n", clk_name, parent_name[0], parent_name[1], id);
+	clk = ak_register_mux_clk(clk_name, parent_name, number,
+						res_reg, id, &ak_mux_clk_ops);
+
+	if (!IS_ERR(clk)) {
+		of_clk_add_provider(np, of_clk_src_simple_get, clk);
+	} else
+		pr_err("ak39_mux_clk register mux clk failed: clk_name:%s %s \n", clk_name, (char *)PTR_ERR(clk));
+}
+
+static void __init of_ak_gate_clk_init(struct device_node *np)
+{
+	struct clk_onecell_data *clk_data;
+	const char *clk_name = np->name;
+	const char *parent_name = of_clk_get_parent_name(np, 0);
+	void __iomem *reg = AK_VA_SYSCTRL;
+	u32 ctrlbit;
+	int number, index;
+
+	clk_data = kmalloc(sizeof(struct clk_onecell_data), GFP_KERNEL);
+	if (!clk_data)
+		return;
+	//printk("#########################%s_%d, clk_data =%p\n", __FUNCTION__, __LINE__, clk_data);
+	number = of_property_count_u32_elems(np, "clock-ctrlbit");
+	clk_data->clks = kcalloc(number, sizeof(struct clk *), GFP_KERNEL);
+	if (!clk_data->clks)
+		goto err_free_data;
+
+	for (index = 0; index < number; index++) {
+		of_property_read_string_index(np, "clock-output-names",
+					      index, &clk_name);
+		of_property_read_u32_index(np, "clock-ctrlbit", index, &ctrlbit);
+
+		pr_debug("of_ak_gate_clk_init %s %s %d\n", clk_name, parent_name, ctrlbit);
+		clk_data->clks[index] = ak_clk_register_gate(clk_name, parent_name, 
+						  reg, ctrlbit, &ak_gate_clk_ops);
+
+		if (IS_ERR(clk_data->clks[index])) {
+			pr_err("ak39_gate_clk register gate clk failed: clk_name:%s, index = %d\n", clk_name, index);
+			WARN_ON(true);
+			continue;
+		}
+		//printk("22222###################%s_%d,clk=%p\n", __FUNCTION__, __LINE__, clk_data->clks[index]);
+	}
+	
+	clk_data->clk_num = number;
+	of_clk_add_provider(np, of_clk_src_onecell_get, clk_data);
+
+	return;
+
+err_free_data:
+	kfree(clk_data);
+}
+
+CLK_OF_DECLARE(ak39_asic_fixed_clk, "anyka,ak39-fixed-clk", of_ak_fixed_clk_init);
+CLK_OF_DECLARE(ak39_factor_clk, "anyka,ak39-factor-clk", of_ak_factor_clk_init);
+CLK_OF_DECLARE(ak39_asic_mux_clk, "anyka,ak39-mux-clk", of_ak_mux_clk_init);
+CLK_OF_DECLARE(ak39_asic_gate_clk, "anyka,ak39-gate-clk", of_ak_gate_clk_init);
diff --git a/drivers/clk/anyka/ak_clk.c b/drivers/clk/anyka/ak_clk.c
new file mode 100755
index 0000000..304c5af
--- /dev/null
+++ b/drivers/clk/anyka/ak_clk.c
@@ -0,0 +1,1558 @@
+/*
+ * AK39XX clk driver
+ *
+ * Copyright (C) 2018 Anyka(Guangzhou) Microelectronics Technology Co., Ltd.
+ *
+ * Author: Feilong Dong <dong_feilong@anyka.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+/**
+ * DOC: AK39XX (clock resource manager)
+ *
+ * The clock tree on the Ak39XX has several levels.  There's a root
+ * oscillator running at 12Mhz. After the oscillator there are 3
+ * PLLs, roughly divided as "CPU_PLL", "ASIC_PLL" and "PERI_PLL".  
+ * Those 3 PLLs each can divide their output to produce several channels.
+ * Finally, there is the level of clocks to be consumed by other hardware
+ * components (like "isp" or "nethernet"), which divide off of some subset
+ * of the PLL channels.
+ *
+ * All of the clocks in the tree are exposed in the DT, because the DT
+ * may want to make assignments of the final layer of clocks to the
+ * PLL channels, and some components of the hardware will actually
+ * skip layers of the tree (for example, the sar_adc clock comes
+ * directly from the root oscillator without using a clock divider 
+ * from PLL).
+ */
+
+#define pr_fmt(fmt) KBUILD_MODNAME ": " fmt
+
+#include <linux/clk-provider.h>
+#include <linux/clkdev.h>
+#include <linux/clk.h>
+#include <linux/debugfs.h>
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/of_address.h>
+#include <linux/platform_device.h>
+#include <linux/slab.h>
+#include <linux/delay.h>
+
+#include <mach/map.h>
+
+/* clock register offset */
+#define CLOCK_CPU_PLL_CTRL			(0x04)
+#define CLOCK_ASIC_PLL_CTRL			(0x08)
+#define CLOCK_ADC2_DAC_CTRL			(0x0C)
+#define CLOCK_ADC2_DAC_HS_CTRL		(0x10)
+#define CLOCK_PERI_PLL_CTRL1		(0x14)
+#define CLOCK_PERI_PLL_CTRL2		(0x18)
+#define CLOCK_GATE_CTRL1			(0x1C)
+#define CLOCK_SOFT_RESET			(0x20)
+#define CLOCK_USB_I2S_CTRL			(0x58)
+#define CLOCK_DAC_FADEOUT_CTRL		(0x70)
+#define ANALOG_CTRL_REG3			(0xA4)
+#define CLOCK_SPI_HIGH_SPEED_CTRL	(0x100)
+#define CLOCK_AUDIO_PLL_CTRL		(0x1B8)
+#define CLOCK_SD_ADC_DAC_CTRL		(0x1BC)
+
+#define CLOCK_GATE_RESET_CTRL2		(0xFC)
+
+/* ADC2/DAC clock control register */
+#define AK_CLKCON_CLK_DAC			(1 << 28)
+#define AK_CLKCON_CLK_ADC1			(1 << 3)
+
+/* ADC2/DAC high speed clock control register */
+#define AK_CLKCON_HCLK_ADC2			(1 << 28)
+#define AK_CLKCON_HCLK_DAC			(1 << 18)
+#define AK_CLKCON_CLK_ADC2			(1 << 8)
+
+
+/* PERI PLL channel clock control register1 */
+//1: peri pll 	0: external 12MHz
+#define AK_CLKCON_CLK_PHY_SEL		(1 << 19)
+//1: peri pll	0: external 25MHz
+#define AK_CLKCON_CLK_MAC_SEL		(1 << 18)
+#define AK_CLKCON_CLK_12M			(1 << 17)
+#define AK_CLKCON_CLK_25M			(1 << 16)
+#define AK_CLKCON_CLK_25M_IN		(1 << 14)
+
+/* PERI PLL channel clock control register2 */
+/* 1: positive clk	0: negative clk */
+#define AK_CLKCON_PCLK_CIS			(1 << 20)		//camera
+#define AK_CLKCON_SCLK_CIS			(1 << 18)		//sensor
+#define AK_CLKCON_CLK_OPCLK			(1 << 8)		//MAC
+
+
+#define AK37D_CLK_CPU2X4X_MODE		(1 << 24)
+#define AK37D_CLK_CPU_DPHY_OPP_EN	(1 << 26)
+#define AK37D_CLK_DPHY1X2X_MODE		(1 << 30)
+
+#define MHz	1000000UL
+
+struct ak_fixed_clk {
+	int id;
+	struct clk_hw hw;
+	void __iomem *reg;
+	unsigned long fixed_rate;
+};
+
+struct ak_factor_clk {
+	int id;
+	struct clk_hw hw;
+	void __iomem *reg;
+	int m;
+	int n;
+};
+
+struct ak_mux_clk {
+	int id;
+	struct clk_hw hw;
+	void __iomem *reg;
+	int select_index;
+};
+
+struct ak_gate_clk {
+	int id;
+	struct clk_hw hw;
+	void __iomem *reg;
+	int ctrlbit;
+};
+
+#define to_clk_ak_fixed(_hw) container_of(_hw, struct ak_fixed_clk, hw)
+#define to_clk_ak_factor(_hw) container_of(_hw, struct ak_factor_clk, hw)
+#define to_clk_ak_mux(_hw) container_of(_hw, struct ak_mux_clk, hw)
+#define to_clk_ak_gate(_hw) container_of(_hw, struct ak_gate_clk, hw)
+
+/*
+	pll（160mhz-320mhz）		1	1	0	0
+采样率	PLL（HZ）	PLL_M		PLL_N	DIV	OSR	spr_compute	error(%)
+	8k	184320000	24			95		90	256	8000.000000 	0
+	11.025k	282240000 24    	146		100	256	11025.000000 	0
+	12k	168960000	24			87		55	256	12000.000000 	0	note：MCLK要为12.288mhz，则pll要为184320000
+	16k	184320000	24			95		45	256	16000.000000 	0
+	22.05k	282240000	24		146		50	256	22050.000000 	0
+	24k	184320000	24			95		30	256	24000.000000 	0
+	32k	204800000	14			63		25	256	32000.000000 	0	note：MCLK要为12.288mhz，则pll要为245760000，DIV为30
+	44.1k	282240000	24		146		25	256	44100.000000 	0
+	48k	184320000	24			95		15	256	48000.000000 	0
+	88.2k	293538461	25		158		13	256	88202.662560 	0.0030187	note:可以使用（pll）282240000／（osr）128
+	96k	245760000	24			127		10	256	96000.000000 	0
+*/
+
+static unsigned long pll4[] = {	184320000, 282240000, 168960000, 184320000, 282240000, 184320000,
+	204800000, 282240000, 184320000, 293538461, 245760000};
+static unsigned char pll4_m[] = {24, 24, 24, 24, 24, 24,
+	14, 24, 24, 25, 24};	/*width:5bits*/
+static unsigned short pll4_n[] = {95, 146, 87, 95, 146, 95,
+	63, 146, 95, 158, 127};	/*width:9bits*/
+static unsigned short sddac_DIV[] = {90, 100, 55, 45, 50, 30,
+	25, 25, 15, 13, 10};
+static unsigned short sdadc_DIV[] = {90, 100, 55, 45, 50, 30,
+	25, 25, 15, 13, 10};
+static unsigned short sddac_OSR[] = {256, 256, 256, 256, 256, 256,
+	256, 256, 256, 256, 256};
+static unsigned short sdadc_OSR[] = {256, 256, 256, 256, 256, 256,
+	256, 256, 256, 256, 256};
+static unsigned int sample_rate[] = {8000, 11025, 12000, 16000, 22050, 24000,
+	32000, 44100, 48000, 88202, 96000};
+
+static unsigned long ak_get_cpu_pll_clk(void __iomem *reg)
+{
+	u32 pll_m, pll_n, pll_od;
+	u32 cpu_pll_clk;
+	u32 regval;
+
+	regval = __raw_readl(reg + CLOCK_CPU_PLL_CTRL);
+	pll_od = (regval & (0x3 << 12)) >> 12;
+	pll_n = (regval & (0xf << 8)) >> 8;
+	pll_m = regval & 0xff;
+
+	cpu_pll_clk = 12 * pll_m /(pll_n * (1 << pll_od)); // clk unit: MHz
+	if ((pll_od >= 1) && ((pll_n >= 1) && (pll_n <= 12)) 
+		 && (pll_m >= 2))
+		return cpu_pll_clk * MHz;
+	
+	pr_err("cpu pll clk: %d(Mhz) pll_od %d pll_n %d pll_m %d \n", cpu_pll_clk, pll_od, pll_n, pll_m);
+	return 0;
+}
+
+static long ak_fixed_clk_round_rate(struct clk_hw *hw, unsigned long rate,
+					unsigned long *parent_rate)
+{
+	struct ak_fixed_clk *fixed_clk = to_clk_ak_fixed(hw);
+
+	pr_debug("%s %d id:%d, rate:%lu, parent_rate:%lu\n",
+			__func__, __LINE__, fixed_clk->id, rate, *parent_rate);
+	return rate;
+}
+
+static int ak_fixed_clk_set_rate(struct clk_hw *hw,
+	unsigned long rate, unsigned long parent_rate)
+{
+	int i;
+	int num;
+	int timeout;
+	u32 regval;
+	struct ak_fixed_clk *fixed_clk = to_clk_ak_fixed(hw);
+
+	pr_debug("%s %d id:%d, rate:%lu, parent_rate:%lu\n",
+			__func__, __LINE__, fixed_clk->id, rate, parent_rate);
+
+	if (fixed_clk->id == 12) {
+		num = sizeof(pll4) / sizeof(pll4[0]);
+
+		for (i = 0; i < num; i++) {
+			if (rate == pll4[i]) {
+				break;
+			}
+		}
+
+		if (i >= num) {
+			pr_err("%s %d id:%d set rate:%lu failed\n",
+					__func__, __LINE__, fixed_clk->id, rate);
+			return -1;
+		}
+
+		/*open audio pll*/
+		regval = __raw_readl(fixed_clk->reg + CLOCK_AUDIO_PLL_CTRL);
+		regval &= ~(0x1<<15);
+		regval |= 0x1<<16;
+		__raw_writel(regval, fixed_clk->reg + CLOCK_AUDIO_PLL_CTRL);
+
+		/*set audio pll frequence*/
+		regval = __raw_readl(fixed_clk->reg + CLOCK_AUDIO_PLL_CTRL);
+		regval &= ~(0x1f<<0);
+		regval &= ~(0x1ff<<5);
+		regval |= (pll4_m[i] & 0x1f)<<0;
+		regval |= (pll4_n[i] & 0x1ff)<<5;
+		regval |= 1 << 14;
+		__raw_writel(regval, fixed_clk->reg + CLOCK_AUDIO_PLL_CTRL);
+
+		/*wait pll adjust finish*/
+		timeout = 100000;
+		do {
+			timeout--;
+			regval = __raw_readl(fixed_clk->reg + CLOCK_AUDIO_PLL_CTRL) & (0x1 << 14);
+		} while (regval & (timeout > 0));
+		if (timeout <= 0) {
+			pr_err("%s %d id:%d set rate:%lu timeout\n",
+					__func__, __LINE__, fixed_clk->id, rate);
+			return -1;
+		}
+	}
+
+	return 0;
+}
+
+static unsigned long ak_fixed_clk_recalc_rate(struct clk_hw *hw, unsigned long parent_rate)
+{
+	u32 regval;
+	int div_j, div_d, div_phy;
+	//get fixed clk rate from dts
+	struct ak_fixed_clk *fixed_clk = to_clk_ak_fixed(hw);
+
+	if (fixed_clk->id == 12) {
+		int pll4_m, pll4_n;
+		unsigned long pll4_clk;
+
+		regval = __raw_readl(fixed_clk->reg + CLOCK_AUDIO_PLL_CTRL);
+		pll4_m = regval & 0x1f;
+		pll4_n = (regval >> 5) & 0x1ff;
+
+		pll4_clk = 48000000 / (pll4_m + 1) * (pll4_n + 1);
+
+		pr_debug("%s %d id:%d parent rate:%lu,"
+				"regval:0x%08x, pll4_clk:%lu, m:%d, n:%d\n",
+				__func__, __LINE__, fixed_clk->id, parent_rate,
+				regval, pll4_clk, pll4_m, pll4_n);
+
+		return pll4_clk;
+	}
+
+	regval = __raw_readl(fixed_clk->reg + CLOCK_CPU_PLL_CTRL);
+	if (regval & AK37D_CLK_CPU_DPHY_OPP_EN)
+	{
+		div_j = 0;
+		div_d = 1;
+		div_phy = 0;
+	} else {
+		if (regval & AK37D_CLK_CPU2X4X_MODE) {
+			div_j = 1;
+			div_d = 2;
+		} else {
+			div_j = 0;
+			div_d = 2;
+		}
+		if (regval & AK37D_CLK_DPHY1X2X_MODE)
+			div_phy = 1;
+		else
+			div_phy = 2;
+	}
+	
+	switch(fixed_clk->id) {
+		case 0:	//JCLK
+			fixed_clk->fixed_rate = ak_get_cpu_pll_clk(fixed_clk->reg) >> div_j;
+			pr_err("CPU(JCLK): %lu(Mhz) \n", fixed_clk->fixed_rate/MHz);
+			break;
+		case 1: //HCLK/DCLK
+			fixed_clk->fixed_rate = ak_get_cpu_pll_clk(fixed_clk->reg) >> div_d;
+			//pr_err("MEMCTRL(HCLK/DCLK): %lu(Mhz) \n", fixed_clk->fixed_rate/MHz);
+			break;
+		case 2: //DPHY
+			fixed_clk->fixed_rate = ak_get_cpu_pll_clk(fixed_clk->reg) >> div_phy;
+			pr_err("MEMDDR2(DPHY): %lu(Mhz) \n", fixed_clk->fixed_rate/MHz);
+			break;
+		case 3: //ASIC_PLL set in init func, just return
+		case 4: //PERI_PLL set in init func, just return
+			break;
+		default:
+			pr_err("No this clk config in dts.\n");
+			break;
+	}
+
+	return fixed_clk->fixed_rate;
+}
+
+const struct clk_ops ak_fixed_clk_ops = {
+	.round_rate = ak_fixed_clk_round_rate,
+	.set_rate = ak_fixed_clk_set_rate,
+	.recalc_rate = ak_fixed_clk_recalc_rate,
+};
+
+static int sdadc_sddac_calc_div_osr(int is_sdadc, unsigned long rate, unsigned long *parent_rate, int *div, int *osr)
+{
+	int i;
+	int num;
+
+	pr_debug("%s %d %s rate:%lu, parent_rate:%lu\n",
+			__func__, __LINE__, is_sdadc ? "sdadc":"sddac",rate, *parent_rate);
+
+	num = sizeof(pll4) / sizeof(pll4[0]);
+
+	for (i = 0; i < num; i++) {
+		if (rate == sample_rate[i]) {
+			break;
+		}
+	}
+
+	if (i >= num) {
+		pr_err("%s %d rate:%lu failed\n", __func__, __LINE__, rate);
+		return -1;
+	}
+
+	*parent_rate = pll4[i];
+	if (is_sdadc) {
+		*div = sdadc_DIV[i];
+		*osr = sdadc_OSR[i];
+	} else {
+		*div = sddac_DIV[i];
+		*osr = sddac_OSR[i];
+	}
+
+	return 0;
+}
+
+static int sdadc_set_div_osr(struct ak_factor_clk *factor_clk,
+		unsigned long rate, unsigned long *parent_rate)
+{
+	int div, osr, map_osr;
+	int timeout;
+	u32 regval;
+
+	if (sdadc_sddac_calc_div_osr(1, rate, parent_rate, &div, &osr)) {
+		return -1;
+	}
+
+	if (osr == 512)
+		map_osr = 0x0;
+	else if (osr == 256)
+		map_osr = 0x1;
+	else {
+		pr_err("%s %d rate:%lu failed, div:%d, osr:%d\n",
+				__func__, __LINE__, rate, div, osr);
+		return -1;
+	}
+
+	/*set adc_clk generated from audio_pll_clk*/
+	regval = __raw_readl(factor_clk->reg + CLOCK_SD_ADC_DAC_CTRL);
+	regval |= 1<<20;
+	__raw_writel(regval,factor_clk->reg + CLOCK_SD_ADC_DAC_CTRL);
+
+	/*reset adc from adc clk*/
+	regval = __raw_readl(factor_clk->reg + CLOCK_SOFT_RESET);
+	regval &= ~(1<<27);
+	__raw_writel(regval,factor_clk->reg + CLOCK_SOFT_RESET);
+
+	/*close adc fillter clk gate*/
+	regval = __raw_readl(factor_clk->reg + CLOCK_SD_ADC_DAC_CTRL);
+	regval &= ~(1<<8);
+	__raw_writel(regval,factor_clk->reg + CLOCK_SD_ADC_DAC_CTRL);
+
+	/*change the div val*/
+	regval = __raw_readl(factor_clk->reg + CLOCK_SD_ADC_DAC_CTRL);
+	regval &= ~(0xff<<0);
+	regval |= ((0xFF& (div - 1))<<0);
+	__raw_writel(regval,factor_clk->reg + CLOCK_SD_ADC_DAC_CTRL);
+
+	/*set sdadc_div_vld_cfg*/
+	regval = __raw_readl(factor_clk->reg + CLOCK_SD_ADC_DAC_CTRL);
+	regval |= (1<<9);
+	__raw_writel(regval,factor_clk->reg + CLOCK_SD_ADC_DAC_CTRL);
+
+	/*wait the sddac_div_vld_cfg clear*/
+	timeout = 100000;
+	do {
+		timeout--;
+		regval = __raw_readl(factor_clk->reg + CLOCK_SD_ADC_DAC_CTRL) & (1<<9);
+	} while (regval & (timeout > 0));
+	if (timeout <= 0) {
+		pr_err("%s %d wait sddac_div timeout\n", __func__, __LINE__);
+	}
+
+	/*open adc fillter clk gate*/
+	regval = __raw_readl(factor_clk->reg + CLOCK_SD_ADC_DAC_CTRL);
+	regval |= (1<<8);
+	__raw_writel(regval,factor_clk->reg + CLOCK_SD_ADC_DAC_CTRL);
+
+	/*release the reset adc from adc clk*/
+	regval = __raw_readl(factor_clk->reg + CLOCK_SOFT_RESET);
+	regval |= (1<<27);
+	__raw_writel(regval,factor_clk->reg + CLOCK_SOFT_RESET);
+
+	/*set osr*/
+	regval = __raw_readl(factor_clk->reg + CLOCK_DAC_FADEOUT_CTRL);
+	regval &= ~(0x1<<31);
+	regval |= ((map_osr & 0x1)<<31);
+	__raw_writel(regval,factor_clk->reg + CLOCK_DAC_FADEOUT_CTRL);
+
+	return 0;
+}
+
+static int sddac_set_div_osr(struct ak_factor_clk *factor_clk, unsigned long rate, unsigned long *parent_rate)
+{
+	int div, osr, map_osr;
+	int timeout;
+	u32 regval;
+
+	if (sdadc_sddac_calc_div_osr(0, rate, parent_rate, &div, &osr)) {
+		return -1;
+	}
+
+	/*map osr*/
+	switch (osr) {
+		case 256:
+			map_osr = 0x0;
+			break;
+
+		case 272:
+			map_osr = 0x1;
+			break;
+
+		case 264:
+			map_osr = 0x2;
+			break;
+
+		case 248:
+			map_osr = 0x3;
+			break;
+
+		case 240:
+			map_osr = 0x4;
+			break;
+
+		case 136:
+			map_osr = 0x5;
+			break;
+
+		case 128:
+			map_osr = 0x6;
+			break;
+
+		case 120:
+			map_osr = 0x7;
+			break;
+
+		default:
+			pr_err("%s %d rate:%lu failed, set osr fail. div:%d, osr:%d\n",
+					__func__, __LINE__, rate, div, osr);
+			return -1;
+			break;
+	}
+
+	/*sele audio_pll generated dac_clk*/
+	regval = __raw_readl(factor_clk->reg + CLOCK_SD_ADC_DAC_CTRL);
+	regval |= 1<<21;
+	__raw_writel(regval,factor_clk->reg + CLOCK_SD_ADC_DAC_CTRL);
+
+	/*close the dac_filter_en_cfg*/
+	regval = __raw_readl(factor_clk->reg + CLOCK_DAC_FADEOUT_CTRL);
+	regval &= ~(1<<3);
+	__raw_writel(regval,factor_clk->reg + CLOCK_DAC_FADEOUT_CTRL);
+
+	/*reset dac from dac clk*/
+	regval = __raw_readl(factor_clk->reg + CLOCK_SOFT_RESET);
+	regval &= ~(1<<26);
+	__raw_writel(regval,factor_clk->reg + CLOCK_SOFT_RESET);
+
+	/*disable the sd_dac_clk*/
+	regval = __raw_readl(factor_clk->reg + CLOCK_SD_ADC_DAC_CTRL);
+	regval &= ~(1<<18);
+	__raw_writel(regval,factor_clk->reg + CLOCK_SD_ADC_DAC_CTRL);
+
+	/*change the div val*/
+	regval = __raw_readl(factor_clk->reg + CLOCK_SD_ADC_DAC_CTRL);
+	regval &= ~(0xFF<<10);
+	regval |= ((0xFF & (div - 1))<<10);
+	__raw_writel(regval,factor_clk->reg + CLOCK_SD_ADC_DAC_CTRL);
+
+	/*set sddac_div_vld_cfg*/
+	regval = __raw_readl(factor_clk->reg + CLOCK_SD_ADC_DAC_CTRL);
+	regval |= (1<<19);
+	__raw_writel(regval,factor_clk->reg + CLOCK_SD_ADC_DAC_CTRL);
+
+	/*wait the sddac_div_vld_cfg  clear*/
+	timeout = 100000;
+	do {
+		timeout--;
+		regval = __raw_readl(factor_clk->reg + CLOCK_SD_ADC_DAC_CTRL) & (1<<19);
+	} while (regval & (timeout > 0));
+	if (timeout <= 0) {
+		pr_err("%s %d wait sddac_div timeout\n", __func__, __LINE__);
+	}
+
+	/*enable the sd_dac_clk*/
+	regval = __raw_readl(factor_clk->reg + CLOCK_SD_ADC_DAC_CTRL);
+	regval |= (1<<18);
+	__raw_writel(regval,factor_clk->reg + CLOCK_SD_ADC_DAC_CTRL);
+
+	/*release the reset dac from dac clk*/
+	regval = __raw_readl(factor_clk->reg + CLOCK_SOFT_RESET);
+	regval |= (1<<26);
+	__raw_writel(regval,factor_clk->reg + CLOCK_SOFT_RESET);
+
+	/*set osr*/
+	regval = __raw_readl(factor_clk->reg + CLOCK_DAC_FADEOUT_CTRL);
+	regval &= ~(0x7);
+	regval |= map_osr & 0x7;
+	__raw_writel(regval,factor_clk->reg + CLOCK_DAC_FADEOUT_CTRL);
+
+	return 0;
+}
+
+static int adchs_set_div(struct ak_factor_clk *factor_clk, int factor)
+{
+	int timeout;
+	u32 regval;
+
+	/*reset adc from adc hsclk*/
+	regval = __raw_readl(factor_clk->reg + CLOCK_SOFT_RESET);
+	regval &= ~(1<<29);
+	__raw_writel(regval,factor_clk->reg + CLOCK_SOFT_RESET);
+
+	/*wait the sdadc_hsdiv_vld_cfg  clear*/
+	timeout = 100000;
+	do {
+		timeout--;
+		regval = __raw_readl(factor_clk->reg + CLOCK_ADC2_DAC_HS_CTRL) & (1<<29);
+	} while (regval & (timeout > 0));
+	if (timeout <= 0) {
+		pr_err("%s %d wait sdadc hsdiv timeout\n", __func__, __LINE__);
+	}
+
+	/*disable the sd_adc_hsclk*/
+	regval = __raw_readl(factor_clk->reg + CLOCK_ADC2_DAC_HS_CTRL);
+	regval &= ~(1<<28);
+	__raw_writel(regval,factor_clk->reg + CLOCK_ADC2_DAC_HS_CTRL);
+
+	/*change the div val*/
+	regval = __raw_readl(factor_clk->reg + CLOCK_ADC2_DAC_HS_CTRL);
+	regval &= ~(0xff<<20);
+	regval |= ((0xff&factor)<<20);
+	__raw_writel(regval,factor_clk->reg + CLOCK_ADC2_DAC_HS_CTRL);
+
+	/*set sddac_hsdiv_vld_cfg*/
+	regval = __raw_readl(factor_clk->reg + CLOCK_ADC2_DAC_HS_CTRL);
+	regval |= (1<<29);
+	__raw_writel(regval,factor_clk->reg + CLOCK_ADC2_DAC_HS_CTRL);
+
+	/*wait the sdadc_div_vld_cfg clear*/
+	timeout = 100000;
+	do {
+		timeout--;
+		regval = __raw_readl(factor_clk->reg + CLOCK_ADC2_DAC_HS_CTRL) & (1<<29);
+	} while (regval & (timeout > 0));
+	if (timeout <= 0) {
+		pr_err("%s %d wait sdadc div timeout\n", __func__, __LINE__);
+	}
+
+	/*enable the sd_adc_hsclk*/
+	regval = __raw_readl(factor_clk->reg + CLOCK_ADC2_DAC_HS_CTRL);
+	regval |= (1<<28);
+	__raw_writel(regval,factor_clk->reg + CLOCK_ADC2_DAC_HS_CTRL);
+
+	/*release adc from adc hsclk*/
+	regval = __raw_readl(factor_clk->reg + CLOCK_SOFT_RESET);
+	regval |= (1<<29);
+	__raw_writel(regval,factor_clk->reg + CLOCK_SOFT_RESET);
+
+	return 0;
+}
+
+static int dachs_set_div(struct ak_factor_clk *factor_clk, int factor)
+{
+	int timeout;
+	u32 regval;
+
+	/*close the dac_filter_en_cfg*/
+	regval = __raw_readl(factor_clk->reg + CLOCK_DAC_FADEOUT_CTRL);
+	regval &= ~(1<<3);
+	__raw_writel(regval,factor_clk->reg + CLOCK_DAC_FADEOUT_CTRL);
+
+	/*reset dac from dac hsclk*/
+	regval = __raw_readl(factor_clk->reg + CLOCK_SOFT_RESET);
+	regval &= ~(1<<28);
+	__raw_writel(regval,factor_clk->reg + CLOCK_SOFT_RESET);
+
+	/*wait the sddac_hsdiv_vld_cfg  clear*/
+	timeout = 100000;
+	do {
+		timeout--;
+		regval = __raw_readl(factor_clk->reg + CLOCK_ADC2_DAC_HS_CTRL) & (1<<19);
+	} while (regval & (timeout > 0));
+	if (timeout <= 0) {
+		pr_err("%s %d wait sddac hsdiv timeout\n", __func__, __LINE__);
+	}
+
+	/*disable the sd_dac_hsclk*/
+	regval = __raw_readl(factor_clk->reg + CLOCK_ADC2_DAC_HS_CTRL);
+	regval &= ~(1<<18);
+	__raw_writel(regval,factor_clk->reg + CLOCK_ADC2_DAC_HS_CTRL);
+
+	/*change the div val*/
+	regval = __raw_readl(factor_clk->reg + CLOCK_ADC2_DAC_HS_CTRL);
+	regval &= ~(0xff<<10);
+	regval |= ((0xff&factor)<<10);
+	__raw_writel(regval,factor_clk->reg + CLOCK_ADC2_DAC_HS_CTRL);
+
+	/*set sddac_hsdiv_vld_cfg*/
+	regval = __raw_readl(factor_clk->reg + CLOCK_ADC2_DAC_HS_CTRL);
+	regval |= (1<<19);
+	__raw_writel(regval,factor_clk->reg + CLOCK_ADC2_DAC_HS_CTRL);
+
+	/*wait the sddac_div_vld_cfg clear*/
+	timeout = 100000;
+	do {
+		timeout--;
+		regval = __raw_readl(factor_clk->reg + CLOCK_ADC2_DAC_HS_CTRL) & (1<<19);
+	} while (regval & (timeout > 0));
+	if (timeout <= 0) {
+		pr_err("%s %d wait sddac div timeout\n", __func__, __LINE__);
+	}
+
+	/*enable the sd_dac_hsclk*/
+	regval = __raw_readl(factor_clk->reg + CLOCK_ADC2_DAC_HS_CTRL);
+	regval |= (1<<18);
+	__raw_writel(regval,factor_clk->reg + CLOCK_ADC2_DAC_HS_CTRL);
+
+	/*release dac from dac hsclk*/
+	regval = __raw_readl(factor_clk->reg + CLOCK_SOFT_RESET);
+	regval |= (1<<28);
+	__raw_writel(regval,factor_clk->reg + CLOCK_SOFT_RESET);
+
+	return 0;
+}
+
+static long ak_factor_clk_round_rate(struct clk_hw *hw, unsigned long rate,
+					unsigned long *parent_rate)
+{
+	struct ak_factor_clk *factor_clk = to_clk_ak_factor(hw);
+
+	long ret = 0;
+	u32 factor;
+	u32 regval;
+	unsigned long flags;
+
+	pr_debug("%s %d id:%d\n", __func__, __LINE__, factor_clk->id);
+	
+	local_irq_save(flags);
+
+	factor = (*parent_rate)/rate - 1;
+	/* calculate the factor value, and set the proper reg bits */
+	switch(factor_clk->id) {
+		case 0:	//adchs
+			adchs_set_div(factor_clk, factor);
+			break;
+		case 1: //dachs
+			dachs_set_div(factor_clk, factor);
+			break;
+		case 2: //spi0_clk
+		    /* spi hsclk = 2* spi_bus_clock(80M) = 160M*/
+		    factor = (*parent_rate)/(rate*2) - 1;
+            
+            /* hsclk must be disable,before adjustment clock divider parameter. */
+			regval = __raw_readl(factor_clk->reg + CLOCK_SPI_HIGH_SPEED_CTRL);
+            regval &= ~(0x1<<8);
+			__raw_writel(regval, factor_clk->reg + CLOCK_SPI_HIGH_SPEED_CTRL);
+
+            regval = __raw_readl(factor_clk->reg + CLOCK_SPI_HIGH_SPEED_CTRL);
+			regval &= ~(0xFF);
+			regval |= (0xFF&factor);
+			__raw_writel(regval, factor_clk->reg + CLOCK_SPI_HIGH_SPEED_CTRL);
+			break;
+		case 3: //sclk0
+            /* hsclk must be disable,before adjustment clock divider parameter. */
+			regval = __raw_readl(factor_clk->reg + CLOCK_PERI_PLL_CTRL2);
+            regval &= ~(0x1<<18);
+			__raw_writel(regval, factor_clk->reg + CLOCK_PERI_PLL_CTRL2);
+			regval = __raw_readl(factor_clk->reg + CLOCK_PERI_PLL_CTRL2);
+			regval &= ~(0x3F<<10);
+			regval |= ((0xFF&factor)<<10);
+			__raw_writel(regval, factor_clk->reg + CLOCK_PERI_PLL_CTRL2);
+			break;
+		case 4: //sclk1
+            /* hsclk must be disable,before adjustment clock divider parameter. */
+			regval = __raw_readl(factor_clk->reg + CLOCK_SPI_HIGH_SPEED_CTRL);
+            regval &= ~(0x1<<18);
+			__raw_writel(regval, factor_clk->reg + CLOCK_SPI_HIGH_SPEED_CTRL);
+			regval = __raw_readl(factor_clk->reg + CLOCK_SPI_HIGH_SPEED_CTRL);
+			regval &= ~(0x3F<<10);
+			regval |= ((0xFF&factor)<<10);
+			__raw_writel(regval, factor_clk->reg + CLOCK_SPI_HIGH_SPEED_CTRL);
+			break;
+		case 5: //csi_pclk
+		    /* hsclk must be disable,before adjustment clock divider parameter. */
+			regval = __raw_readl(factor_clk->reg + CLOCK_PERI_PLL_CTRL2);
+            regval &= ~(0x1<<28);
+			__raw_writel(regval, factor_clk->reg + CLOCK_PERI_PLL_CTRL2);
+
+			regval = __raw_readl(factor_clk->reg + CLOCK_PERI_PLL_CTRL2);
+			regval &= ~(0x3F<<20);
+			regval |= ((0x3F&factor)<<20);
+			__raw_writel(regval, factor_clk->reg + CLOCK_PERI_PLL_CTRL2);			
+			break;
+		case 6: //dsi_pclk
+			/* config LCD PCLK in LCD driver, this function no use here */
+			/* refer to 0x200100BC */
+			break;
+		case 7: //opclk
+			/*opclk clk is fixed to 50MHz*/			
+			break;
+		case 8: //usb_phy
+			/* usb phy clk fixed to 12MHz */
+			
+			break;
+		case 9: //sdadc
+			/* audio pll division setting */
+			if (sdadc_set_div_osr(factor_clk, rate, parent_rate))
+				ret = -1;
+
+			break;
+		case 10: //sddac
+			/* audio pll division setting */
+			if (sddac_set_div_osr(factor_clk, rate, parent_rate))
+				ret = -1;
+
+			break;
+		case 11: //adc0
+			/* hsclk must be disable,before adjustment clock divider parameter. */
+			regval = __raw_readl(factor_clk->reg + CLOCK_ADC2_DAC_CTRL);
+            regval &= ~(0x1<<8);
+			__raw_writel(regval, factor_clk->reg + CLOCK_ADC2_DAC_CTRL);
+
+			regval = __raw_readl(factor_clk->reg + CLOCK_ADC2_DAC_CTRL);
+			regval &= ~(0x7);
+			regval |= (0x7&factor);
+			__raw_writel(regval, factor_clk->reg + CLOCK_ADC2_DAC_CTRL);
+			break;
+
+		default:
+			pr_err("No this factor clk config in dts.\n");
+			break;
+	}
+	local_irq_restore(flags);
+	
+	return ret;
+}
+
+static int ak_factor_clk_set_rate(struct clk_hw *hw, 
+	unsigned long rate, unsigned long parent_rate)
+{
+	struct ak_factor_clk *factor_clk = to_clk_ak_factor(hw);
+	u32 regval;
+	unsigned long flags;
+
+	pr_debug("%s %d id:%d, rate:%lu\n", __func__, __LINE__, factor_clk->id, rate);
+
+	local_irq_save(flags);
+	/* set the enable and valid config reg bits to enable the clk */
+	switch(factor_clk->id) {
+		case 0:	//adchs
+			break;
+		case 1: //dachs
+			break;
+		case 2: //spi0_clk
+			regval = __raw_readl(factor_clk->reg + CLOCK_SPI_HIGH_SPEED_CTRL);
+			regval |= (0x1<<9);
+			__raw_writel(regval, factor_clk->reg + CLOCK_SPI_HIGH_SPEED_CTRL);
+			regval |= (0x1<<8);
+			__raw_writel(regval, factor_clk->reg + CLOCK_SPI_HIGH_SPEED_CTRL);
+			break;
+		case 3: //sclk0
+			regval = __raw_readl(factor_clk->reg + CLOCK_PERI_PLL_CTRL2);
+			regval |= (0x1<<19);
+			__raw_writel(regval, factor_clk->reg + CLOCK_PERI_PLL_CTRL2);
+			regval |= (0x1<<18);
+			__raw_writel(regval, factor_clk->reg + CLOCK_PERI_PLL_CTRL2);
+			break;
+		case 4: //sclk1
+			regval = __raw_readl(factor_clk->reg + CLOCK_SPI_HIGH_SPEED_CTRL);
+			regval |= (0x1<<19);
+			__raw_writel(regval, factor_clk->reg + CLOCK_SPI_HIGH_SPEED_CTRL);
+			regval |= (0x1<<18);
+			__raw_writel(regval, factor_clk->reg + CLOCK_SPI_HIGH_SPEED_CTRL);
+			break;
+		case 5: //csi_pclk
+			regval = __raw_readl(factor_clk->reg + CLOCK_PERI_PLL_CTRL2);
+			regval |= (0x1<<29);
+			__raw_writel(regval, factor_clk->reg + CLOCK_PERI_PLL_CTRL2);
+			regval |= (0x1<<28);
+			__raw_writel(regval, factor_clk->reg + CLOCK_PERI_PLL_CTRL2);
+			break;
+		case 6: //dsi_pclk
+			/*config enable in LCD driver */
+			break;
+		case 7: //opclk
+			/* config as fixed 50MHz */
+			regval = __raw_readl(factor_clk->reg + CLOCK_PERI_PLL_CTRL1);
+			regval &= ~(0x1<<22);  //first set mac interface select Rmii
+			__raw_writel(regval, factor_clk->reg + CLOCK_PERI_PLL_CTRL1);
+			regval |= (0x1<<23);  //mac_speed_cfg=1(100m)
+			__raw_writel(regval, factor_clk->reg + CLOCK_PERI_PLL_CTRL1);
+			regval |= (0x1<<21);  //set bit[21],enable generate 50m
+			__raw_writel(regval, factor_clk->reg + CLOCK_PERI_PLL_CTRL1);
+			regval |= (0x1<<18|0x1<<28);  //set bit[28],enable generate 50m, bit[18], select 25m clock of mac from pll div
+			__raw_writel(regval, factor_clk->reg + CLOCK_PERI_PLL_CTRL1);
+			break;
+		case 8: //usb_phy
+			/* config fixed to 12MHz */
+			break;
+		case 9: //sdadc
+		
+			break;
+		case 10: //sddac
+		
+			break;
+		case 11: //adc0
+			regval = __raw_readl(factor_clk->reg + CLOCK_ADC2_DAC_CTRL);
+			regval |= (0x1<<9);
+			__raw_writel(regval, factor_clk->reg + CLOCK_ADC2_DAC_CTRL);
+			regval |= (0x1<<8);
+			__raw_writel(regval, factor_clk->reg + CLOCK_ADC2_DAC_CTRL);			
+			break;
+
+		default:
+			pr_err("No this factor clk config in dts.\n");
+			break;
+	}
+	local_irq_restore(flags);
+
+	return 0;
+}
+
+static unsigned long sdadc_get_clk(struct ak_factor_clk *factor_clk,
+		unsigned long parent_rate)
+{
+	int div, osr;
+	unsigned int regval_div, regval_osr;
+	unsigned long sdadc_clk;
+
+	regval_div = __raw_readl(factor_clk->reg + CLOCK_SD_ADC_DAC_CTRL);
+	div = (regval_div & 0xFF) + 1;
+
+	regval_osr = __raw_readl(factor_clk->reg + CLOCK_DAC_FADEOUT_CTRL);
+	osr = (regval_osr & (1<< 31)) ? 256:512;
+
+	sdadc_clk = parent_rate / div / osr;
+
+	pr_debug("%s %d id:%d, parent_rate:%lu,"
+			"regval_div:%x, regval_osr:%x, sddca_clk:%lu\n",
+			__func__, __LINE__, factor_clk->id, parent_rate,
+			regval_div, regval_osr, sdadc_clk);
+	return  sdadc_clk;
+}
+
+static int sddac_get_clk(struct ak_factor_clk *factor_clk, unsigned long parent_rate)
+{
+	int div, osr;
+	unsigned int regval_div, regval_osr;
+	unsigned long sddac_clk;
+
+	regval_div = __raw_readl(factor_clk->reg + CLOCK_SD_ADC_DAC_CTRL);
+	div = ((regval_div >> 10) & 0xff) + 1;
+
+	regval_osr = __raw_readl(factor_clk->reg + CLOCK_DAC_FADEOUT_CTRL);
+	switch (regval_osr & 0x7) {
+		case 0x0:
+			osr = 256;
+			break;
+
+		case 0x1:
+			osr = 272;
+			break;
+
+		case 0x2:
+			osr = 264;
+			break;
+
+		case 0x3:
+			osr = 248;
+			break;
+
+		case 0x4:
+			osr = 240;
+			break;
+
+		case 0x5:
+			osr = 136;
+			break;
+
+		case 0x6:
+			osr = 128;
+			break;
+
+		case 0x7:
+			osr = 120;
+			break;
+
+		default:
+			osr = 256;
+			break;
+	}
+
+	sddac_clk = parent_rate / div / osr;
+
+	pr_debug("%s %d id:%d, parent_rate:%lu,"
+			"regval_div:%x, regval_osr:%x, sddac_clk:%lu\n",
+			__func__, __LINE__, factor_clk->id, parent_rate,
+			regval_div, regval_osr, sddac_clk);
+	return  sddac_clk;
+}
+
+static unsigned long ak_factor_clk_recalc_rate(struct clk_hw *hw,
+					unsigned long parent_rate)
+{
+	struct ak_factor_clk *factor_clk = to_clk_ak_factor(hw);
+	u32 regval;
+	u32 factor;
+
+	pr_debug("%s %d id:%d, parent_rate:%lu\n",
+			__func__, __LINE__, factor_clk->id, parent_rate);
+	/* return the actural clk rate of the clk from the related reg bits */
+	switch(factor_clk->id) {
+		case 0:	//adchs
+			regval = __raw_readl(factor_clk->reg + CLOCK_ADC2_DAC_HS_CTRL);
+			factor = (regval>>20)&0xFF;	
+			break;
+		case 1: //dachs
+			regval = __raw_readl(factor_clk->reg + CLOCK_ADC2_DAC_HS_CTRL);
+			factor = (regval>>10)&0xFF;	
+			break;
+		case 2: //spi0_clk
+			regval = __raw_readl(factor_clk->reg + CLOCK_SPI_HIGH_SPEED_CTRL);
+			factor = regval&0xFF;
+			break;
+		case 3: //sclk0
+			regval = __raw_readl(factor_clk->reg + CLOCK_PERI_PLL_CTRL2);
+			factor = (regval>>10)&0x3F;
+			break;
+		case 4: //sclk1
+			regval = __raw_readl(factor_clk->reg + CLOCK_SPI_HIGH_SPEED_CTRL);
+			factor = (regval>>10)&0x3F;
+			break;
+		case 5: //csi_pclk
+			regval = __raw_readl(factor_clk->reg + CLOCK_PERI_PLL_CTRL2);
+			factor = (regval>>20)&0x3F;
+			break;
+		case 6: //dsi_pclk
+			/*config enable in LCD driver */
+			break;
+		case 7: //opclk
+			/* fixed to 50MHz */
+			factor = 12 - 1;
+			break;
+		case 8: //usb_phy
+			/* fixed to 12MHz */
+			factor = 50 - 1;
+			break;
+		case 9: //sdadc
+			return sdadc_get_clk(factor_clk, parent_rate);
+			
+			break;
+		case 10: //sddac
+			return sddac_get_clk(factor_clk, parent_rate);
+						
+			break;
+		case 11: //adc0
+			
+			break;
+		default:
+			pr_err("No this factor clk config in dts.\n");
+			break;
+	}
+
+	return parent_rate/(factor + 1);
+}
+
+const struct clk_ops ak_factor_clk_ops = {
+	.round_rate = ak_factor_clk_round_rate,
+	.set_rate = ak_factor_clk_set_rate,
+	.recalc_rate = ak_factor_clk_recalc_rate,
+};
+
+static int ak_mux_clk_set_parent(struct clk_hw *hw, u8 index)
+{
+	//struct ak_client_clk *client_clk = to_clk_ak_mux(hw);
+	/* to do */
+	return 0;
+}
+
+static u8 ak_mux_clk_get_parent(struct clk_hw *hw)
+{
+	//struct ak_client_clk *client_clk = to_clk_ak_mux(hw);
+	/* to do */
+	return 0;
+}
+
+
+const struct clk_ops ak_mux_clk_ops = {
+    .set_parent = ak_mux_clk_set_parent,
+    .get_parent = ak_mux_clk_get_parent,
+    //.determine_rate = __clk_mux_determine_rate,
+};
+
+static int ak_gc_enable(struct clk_hw *hw)
+{
+	struct ak_gate_clk *gate_clk = to_clk_ak_gate(hw);
+	u32 con;
+	unsigned long flags;
+	
+	local_irq_save(flags);
+	if (gate_clk->reg == AK_VA_SYSCTRL) {
+		con = __raw_readl(gate_clk->reg + CLOCK_GATE_CTRL1);
+		con &= ~(1<<gate_clk->ctrlbit);
+		__raw_writel(con, gate_clk->reg + CLOCK_GATE_CTRL1);
+		
+		con = __raw_readl(gate_clk->reg + CLOCK_SOFT_RESET);
+		con |= (0x1 << gate_clk->ctrlbit);
+		__raw_writel(con, gate_clk->reg + CLOCK_SOFT_RESET);
+		mdelay(1);
+		con = __raw_readl(gate_clk->reg + CLOCK_SOFT_RESET);
+		con &= ~(0x1 << gate_clk->ctrlbit);
+		__raw_writel(con, gate_clk->reg + CLOCK_SOFT_RESET);
+	} else if (gate_clk->reg == AK_VA_SYSCTRL + CLOCK_GATE_RESET_CTRL2) {
+		con = __raw_readl(gate_clk->reg);
+		con &= ~(1<<gate_clk->ctrlbit);
+		__raw_writel(con, gate_clk->reg);
+		
+		con = __raw_readl(gate_clk->reg);
+		con |= (0x1 << (gate_clk->ctrlbit+16));
+		__raw_writel(con, gate_clk->reg);
+		mdelay(1);
+		con = __raw_readl(gate_clk->reg);
+		con &= ~(0x1 << (gate_clk->ctrlbit+16));
+		__raw_writel(con, gate_clk->reg);
+	}
+	local_irq_restore(flags);
+	
+	return 0;
+}
+
+static void ak_gc_disable(struct clk_hw *hw)
+{
+	struct ak_gate_clk *gate_clk = to_clk_ak_gate(hw);
+	u32 con;
+	unsigned long flags;
+	
+	local_irq_save(flags);
+	if (gate_clk->reg == AK_VA_SYSCTRL) {
+		con = __raw_readl(gate_clk->reg + CLOCK_GATE_CTRL1);
+		con |= (1<<gate_clk->ctrlbit);
+		__raw_writel(con, gate_clk->reg + CLOCK_GATE_CTRL1);
+	} else if (gate_clk->reg == AK_VA_SYSCTRL + CLOCK_GATE_RESET_CTRL2) {
+		con = __raw_readl(gate_clk->reg);
+		con |= (1<<gate_clk->ctrlbit);
+		__raw_writel(con, gate_clk->reg);
+	}
+	local_irq_restore(flags);
+}
+
+static unsigned long ak_gc_recalc_rate(struct clk_hw *hw,
+					unsigned long parent_rate)
+{
+	struct ak_gate_clk *gate_clk = to_clk_ak_gate(hw);
+	unsigned long rate;
+	u32 regval = __raw_readl(gate_clk->reg + CLOCK_ASIC_PLL_CTRL);
+
+	regval = ((regval >> 17) && 0x7);
+	if (regval == 0)
+		regval = 1;
+	
+	if (gate_clk->id > 18)
+		rate = parent_rate>>1;
+	else
+		rate = parent_rate>>(1+regval);
+	
+	return rate;
+}
+
+const struct clk_ops ak_gate_clk_ops = {
+	.enable		= ak_gc_enable,
+	.disable	= ak_gc_disable,
+	.recalc_rate = ak_gc_recalc_rate,
+};
+
+struct clk * __init ak_register_fixed_clk(
+		const char *name,
+		const char *parent_name,
+		void __iomem *res_reg,
+		u32 fixed_rate,
+		int id,
+		const struct clk_ops *ops)
+{
+	struct ak_fixed_clk *fixed_clk;
+	struct clk *clk;
+	struct clk_init_data init = {};
+
+	fixed_clk = kzalloc(sizeof(*fixed_clk), GFP_KERNEL);
+	if (!fixed_clk)
+		return ERR_PTR(-ENOMEM);
+
+	init.name = name;
+	init.flags = CLK_IS_BASIC;
+	init.parent_names = parent_name ? &parent_name : NULL;
+	init.num_parents = parent_name ? 1 : 0;
+	init.ops = ops;
+
+	fixed_clk->reg = res_reg;
+	fixed_clk->fixed_rate = fixed_rate;
+	fixed_clk->id = id;
+
+	fixed_clk->hw.init = &init;
+	
+	clk = clk_register(NULL, &fixed_clk->hw);
+	if (IS_ERR(clk))
+		kfree(fixed_clk);
+
+	return clk;
+}
+
+struct clk * __init ak_register_factor_clk(
+		const char *name,
+		const char *parent_name,
+		void __iomem *res_reg,
+		int id,
+		const struct clk_ops *ops)
+{
+	struct ak_factor_clk *factor_clk;
+	struct clk *clk;
+	struct clk_init_data init = {};
+
+	factor_clk = kzalloc(sizeof(*factor_clk), GFP_KERNEL);
+	if (!factor_clk)
+		return ERR_PTR(-ENOMEM);
+
+	init.name = name;
+	if (!strcmp(name, "clk_sdadc") || !strcmp(name, "clk_sddac"))
+		init.flags = CLK_SET_RATE_PARENT;
+	else
+		init.flags = CLK_IGNORE_UNUSED;
+	init.parent_names = parent_name ? &parent_name : NULL;
+	init.num_parents = 1;
+	init.ops = ops;
+
+	factor_clk->reg = res_reg;
+	factor_clk->id = id;
+	factor_clk->hw.init = &init;
+
+	clk = clk_register(NULL, &factor_clk->hw);
+	if (IS_ERR(clk))
+		kfree(factor_clk);
+
+	return clk;
+}
+
+struct clk * __init ak_register_mux_clk(
+		const char *name,
+		const char * const *parent_names,
+		int num_parents,
+		void __iomem *res_reg,
+		int id,
+		const struct clk_ops *ops)
+{
+	struct ak_mux_clk *mux_clk;
+	struct clk *clk;
+	struct clk_init_data init = {};
+
+	mux_clk = kzalloc(sizeof(*mux_clk), GFP_KERNEL);
+	if (!mux_clk)
+		return ERR_PTR(-ENOMEM);
+
+	init.name = name;
+	init.flags = CLK_SET_RATE_PARENT;
+	init.parent_names = parent_names;
+	init.num_parents = num_parents;
+	init.ops = ops;
+
+	mux_clk->id = id;
+	mux_clk->reg = res_reg;
+	mux_clk->hw.init = &init;
+
+	clk = clk_register(NULL, &mux_clk->hw);
+	if (IS_ERR(clk))
+		kfree(mux_clk);
+
+	return clk;
+}
+
+
+struct clk * __init ak_clk_register_gate(
+		const char *name,
+		const char *parent_name,
+		void __iomem *res_reg,
+		u8 ctrlbit,
+		const struct clk_ops *ops)
+{
+	struct ak_gate_clk *gate_clk;
+	struct clk *clk;
+	struct clk_init_data init = {};
+
+	gate_clk = kzalloc(sizeof(*gate_clk), GFP_KERNEL);
+	if (!gate_clk)
+		return ERR_PTR(-ENOMEM);
+
+	init.name = name;
+	init.flags = CLK_SET_RATE_PARENT;
+	init.parent_names = parent_name ? &parent_name : NULL;
+	init.num_parents = parent_name ? 1 : 0;
+	init.ops = ops;
+
+	gate_clk->id = ctrlbit;
+	gate_clk->reg = res_reg;
+	gate_clk->ctrlbit = ctrlbit;
+
+	gate_clk->hw.init = &init;
+
+	clk = clk_register(NULL, &gate_clk->hw);
+	if (IS_ERR(clk))
+		kfree(gate_clk);
+
+	return clk;
+}
+
+void aisc_pll_init(void __iomem *reg, u32 asic_pll, u32 div_od, u32 div_n)
+{
+	u32 div_m;
+	u32 rd_div_m;
+	u32 rd_div_n;
+	u32 rd_div_od;
+	u32 regval;
+
+	if ((div_n < 2) || (div_n > 6)
+		|| (div_od < 1) || (div_od > 3))
+		panic("Asic frequency parameter Error");
+
+	regval = __raw_readl(reg + CLOCK_ASIC_PLL_CTRL);
+	rd_div_m = (regval&0xff);
+	rd_div_n = (regval>>8)&0xf;
+	rd_div_od = (regval>>12)&0x3;
+	if((rd_div_m!= 0xa0)&&(rd_div_n!= 0x2)&&(rd_div_od!= 0x3)){
+		printk(KERN_ERR"asic pll has inited!\n");
+		return;
+	}
+
+	/* asic_pll = 480M=2vclk = 240M=4asic=120M */
+	div_m = ((asic_pll/MHz)*(div_n * (1 << div_od)))/12;
+	/* set asic pll frequency */
+	regval = ((1 << 24)|(1 << 23)|(1 <<17)|(div_od << 12)|(div_n << 8)|(div_m));
+	__raw_writel(regval, reg + CLOCK_ASIC_PLL_CTRL);
+
+	/* enable asic pll freq change valid */
+	regval = __raw_readl(reg + CLOCK_CPU_PLL_CTRL);
+	regval |= (1 << 28);
+	__raw_writel(regval, reg + CLOCK_CPU_PLL_CTRL);	
+
+}
+
+void peri_pll_init(void __iomem *reg, u32 peri_pll, u32 div_od, u32 div_n)
+{
+	u32 div_m;
+	u32 regval;
+	u32 rd_div_m;
+	u32 rd_div_n;
+	u32 rd_div_od;
+
+	if ((div_n < 2) || (div_n > 6)
+		|| (div_od < 1) || (div_od > 3))
+		panic("Asic frequency parameter Error");
+
+	regval = __raw_readl(reg + CLOCK_PERI_PLL_CTRL1);
+	rd_div_m = (regval&0xff);
+	rd_div_n = (regval>>8)&0xf;
+	rd_div_od = (regval>>12)&0x3;
+	if((rd_div_m == 0xc8)&&(rd_div_n == 0x2)&&(rd_div_od == 0x1)){
+		printk(KERN_ERR"peril pll has inited!\n");
+		return;
+	}
+	/* peri_pll = 600M */
+	div_m = ((peri_pll/MHz)*(div_n * (1 << div_od)))/12;
+	/* set peri pll frequency */
+	regval = __raw_readl(reg + CLOCK_PERI_PLL_CTRL1);
+    regval &= ~((0x3<<12)|(0xf<<8)|0xff);
+    regval |= ((div_od << 12)|(div_n << 8)|(div_m));
+    __raw_writel(regval, reg + CLOCK_PERI_PLL_CTRL1);
+	
+	/* enable peri pll freq change valid */
+	regval = __raw_readl(reg + CLOCK_CPU_PLL_CTRL);
+	regval |= (1 << 29);
+	__raw_writel(regval, reg + CLOCK_CPU_PLL_CTRL);
+}
+
+static void __init of_ak_fixed_clk_init(struct device_node *np)
+{
+	struct clk_onecell_data *clk_data;
+	const char *clk_name = np->name;
+	const char *parent_name = of_clk_get_parent_name(np, 0);
+	void __iomem *res_reg = AK_VA_SYSCTRL;
+	u32 rate, div_od, div_n;
+	int id, index, number;
+
+	clk_data = kmalloc(sizeof(struct clk_onecell_data), GFP_KERNEL);
+	if (!clk_data)
+		return;
+
+	number = of_property_count_u32_elems(np, "clock-id");
+	clk_data->clks = kcalloc(number, sizeof(struct clk *), GFP_KERNEL);
+	if (!clk_data->clks)
+		goto err_free_data;
+
+	of_property_read_u32(np, "clock-frequency", &rate);
+	of_property_read_u32(np, "clock-div-od", &div_od);
+	of_property_read_u32(np, "clock-div-n", &div_n);
+
+	if (!strcmp(clk_name, "asic_pll")){	
+		aisc_pll_init(res_reg, rate, div_od, div_n);
+	}
+	if (!strcmp(clk_name, "peri_pll")){
+		peri_pll_init(res_reg, rate, div_od, div_n);
+	}
+
+	for (index = 0; index < number; index++) {
+		of_property_read_string_index(np, "clock-output-names",
+					      index, &clk_name);
+		of_property_read_u32_index(np, "clock-id", index, &id);
+		pr_debug("of_ak_fixed_clk_init %s %s %d %d\n", clk_name, parent_name, rate, id);
+		clk_data->clks[index] = ak_register_fixed_clk(clk_name, parent_name,
+						res_reg, rate, id, &ak_fixed_clk_ops);
+		if (IS_ERR(clk_data->clks[index])) {
+			pr_err("ak39_fixed_clk register fixed clk failed: clk_name:%s, index = %d\n",
+					clk_name, index);
+			WARN_ON(true);
+			continue;
+		}
+		clk_register_clkdev(clk_data->clks[index], clk_name, NULL);
+	}
+
+	clk_data->clk_num = number;
+	if (number == 1)
+		of_clk_add_provider(np, of_clk_src_simple_get, clk_data->clks[0]);
+	else
+		of_clk_add_provider(np, of_clk_src_onecell_get, clk_data);
+
+	return;
+
+err_free_data:
+	kfree(clk_data);
+}
+
+static void __init of_ak_factor_clk_init(struct device_node *np)
+{
+	struct clk_onecell_data *clk_data;
+	const char *clk_name = np->name;
+	const char *parent_name = of_clk_get_parent_name(np, 0);
+	void __iomem *res_reg = AK_VA_SYSCTRL;
+	//u32 div_n, div_m;
+	int id, index, number;
+
+	clk_data = kmalloc(sizeof(struct clk_onecell_data), GFP_KERNEL);
+	if (!clk_data)
+		return;
+
+	number = of_property_count_u32_elems(np, "clock-id");
+	clk_data->clks = kcalloc(number, sizeof(struct clk *), GFP_KERNEL);
+	if (!clk_data->clks)
+		goto err_free_data;
+
+	//of_property_read_u32(np, "clock-div-n", &div_n);
+	//of_property_read_u32(np, "clock-div-m", &div_m);
+
+	for (index = 0; index < number; index++) {
+		of_property_read_string_index(np, "clock-output-names",
+					      index, &clk_name);
+		of_property_read_u32_index(np, "clock-id", index, &id);
+		pr_debug("of_ak_factor_clk_init %s %s %d %d\n", clk_name, parent_name, id, index);
+		clk_data->clks[index] = ak_register_factor_clk(clk_name, parent_name,
+						res_reg, id, &ak_factor_clk_ops);
+		if (IS_ERR(clk_data->clks[index])) {
+			pr_err("ak39_factor_clk register gate clk failed: clk_name:%s, err = %s\n",
+					clk_name, (char *)PTR_ERR(clk_data->clks[index]));
+			WARN_ON(true);
+			continue;
+		}
+		//clk_register_clkdev(clk_data->clks[index], clk_name, NULL);
+	}
+
+	clk_data->clk_num = number;
+	if (number == 1)
+		of_clk_add_provider(np, of_clk_src_simple_get, clk_data->clks[0]);
+	else
+		of_clk_add_provider(np, of_clk_src_onecell_get, clk_data);
+
+	return;
+	
+err_free_data:
+	kfree(clk_data);
+}
+
+static void __init of_ak_mux_clk_init(struct device_node *np)
+{
+	struct clk *clk = NULL;
+	const char *clk_name = np->name;
+	const char *parent_name[2];
+	void __iomem *res_reg = AK_VA_SYSCTRL;
+	int id, number;
+
+	number = of_clk_parent_fill(np, parent_name, 2);
+	of_property_read_string(np, "clock-output-names", &clk_name);
+	of_property_read_u32(np, "clock-id", &id);
+
+	//pr_err("of_ak_mux_clk_init %s %s %s %d\n", clk_name, parent_name[0], parent_name[1], id);
+	clk = ak_register_mux_clk(clk_name, parent_name, number,
+						res_reg, id, &ak_mux_clk_ops);
+	if (!IS_ERR(clk)) {
+		of_clk_add_provider(np, of_clk_src_simple_get, clk);
+	} else
+		pr_err("ak39_mux_clk register mux clk failed: clk_name:%s %s \n",
+				clk_name, (char *)PTR_ERR(clk));
+}
+
+static void __init of_ak_gate_clk_init(struct device_node *np)
+{
+	struct clk_onecell_data *clk_data;
+	const char *clk_name = np->name;
+	const char *parent_name = of_clk_get_parent_name(np, 0);
+	void __iomem *reg = AK_VA_SYSCTRL;
+	u32 ctrlbit;
+	int number, index;
+
+	clk_data = kmalloc(sizeof(struct clk_onecell_data), GFP_KERNEL);
+	if (!clk_data)
+		return;
+	
+	number = of_property_count_u32_elems(np, "clock-ctrlbit");
+
+	clk_data->clks = kcalloc(number, sizeof(struct clk *), GFP_KERNEL);
+	if (!clk_data->clks)
+		goto err_free_data;
+
+	for (index = 0; index < number; index++) {
+		of_property_read_string_index(np, "clock-output-names",
+					      index, &clk_name);
+		of_property_read_u32_index(np, "clock-ctrlbit", index, &ctrlbit);
+		if (ctrlbit >= 32) {
+			ctrlbit %= 32;
+			reg = AK_VA_SYSCTRL + CLOCK_GATE_RESET_CTRL2;
+		}
+
+		pr_debug("of_ak_gate_clk_init %s %s %d\n", clk_name, parent_name, ctrlbit);
+		clk_data->clks[index] = ak_clk_register_gate(clk_name, parent_name, 
+						  reg, ctrlbit, &ak_gate_clk_ops);
+		if (IS_ERR(clk_data->clks[index])) {
+			pr_err("ak39_gate_clk register gate clk failed: clk_name:%s, index = %d\n",
+					clk_name, index);
+			WARN_ON(true);
+			continue;
+		}
+	}
+
+	clk_data->clk_num = number;
+	of_clk_add_provider(np, of_clk_src_onecell_get, clk_data);
+
+	return;
+
+err_free_data:
+	kfree(clk_data);
+}
+
+static void __init of_ak_uv_det_pd(struct device_node *np)
+{
+	int ret;
+	u32 regval;
+	unsigned int enable = 0;
+	unsigned int threshold = 0;
+	void __iomem *reg = AK_VA_SYSCTRL;
+
+	ret = of_property_read_u32(np, "enable", &enable);
+	if (ret < 0) {
+		pr_err("Could not read enable property of_uv_det_pd\n");
+		return;
+	}
+
+	ret = of_property_read_u32(np, "threshold", &threshold);
+	if (ret < 0) {
+		pr_err("Could not read threshold property of_uv_det_pd\n");
+		return;
+	}
+
+	switch (threshold) {
+		case 0:
+			threshold = 0B11;
+			break;
+
+		case 1:
+			threshold = 0B01;
+			break;
+
+		case 2:
+			threshold = 0B00;
+			break;
+
+		default:
+			threshold = 0B11;
+			break;
+	}
+	regval = __raw_readl(reg + ANALOG_CTRL_REG3);
+	regval &= ~(0x3 << 20);
+	regval |= threshold << 20;
+	if (enable)
+		regval &= ~(1 << 30);
+	else
+		regval |= 1 << 30;
+	__raw_writel(regval, reg + ANALOG_CTRL_REG3);
+}
+
+CLK_OF_DECLARE(ak37d_asic_fixed_clk, "anyka,ak3790d-fixed-clk", of_ak_fixed_clk_init);
+CLK_OF_DECLARE(ak37d_factor_clk, "anyka,ak3790d-factor-clk", of_ak_factor_clk_init);
+CLK_OF_DECLARE(ak37d_asic_mux_clk, "anyka,ak3790d-mux-clk", of_ak_mux_clk_init);
+CLK_OF_DECLARE(ak37d_asic_gate_clk, "anyka,ak3790d-gate-clk", of_ak_gate_clk_init);
+CLK_OF_DECLARE(ak37d_uv_det_pd, "anyka,ak3790d-uv_det_pd", of_ak_uv_det_pd);
diff --git a/drivers/clocksource/Makefile b/drivers/clocksource/Makefile
old mode 100644
new mode 100755
index 56bd16e..18fe993
--- a/drivers/clocksource/Makefile
+++ b/drivers/clocksource/Makefile
@@ -20,6 +20,8 @@ obj-$(CONFIG_CLKSRC_DBX500_PRCMU)	+= clksrc-dbx500-prcmu.o
 obj-$(CONFIG_ARMADA_370_XP_TIMER)	+= time-armada-370-xp.o
 obj-$(CONFIG_ORION_TIMER)	+= time-orion.o
 obj-$(CONFIG_ARCH_BCM2835)	+= bcm2835_timer.o
+obj-$(CONFIG_ARCH_AK39)		+= ak39_timer.o
+obj-$(CONFIG_ARCH_AK)	    += ak_timer.o
 obj-$(CONFIG_ARCH_CLPS711X)	+= clps711x-timer.o
 obj-$(CONFIG_ARCH_ATLAS7)	+= timer-atlas7.o
 obj-$(CONFIG_ARCH_MOXART)	+= moxart_timer.o
@@ -65,3 +67,4 @@ obj-$(CONFIG_H8300_TMR16)		+= h8300_timer16.o
 obj-$(CONFIG_H8300_TPU)			+= h8300_tpu.o
 obj-$(CONFIG_CLKSRC_ST_LPC)		+= clksrc_st_lpc.o
 obj-$(CONFIG_X86_NUMACHIP)		+= numachip.o
+obj-y    += ak_hardware_timer.o 
diff --git a/drivers/clocksource/ak_hardware_timer.c b/drivers/clocksource/ak_hardware_timer.c
new file mode 100755
index 0000000..9bf8cfc
--- /dev/null
+++ b/drivers/clocksource/ak_hardware_timer.c
@@ -0,0 +1,226 @@
+/* 
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/init.h>
+#include <linux/interrupt.h>
+#include <linux/irq.h>
+#include <linux/err.h>
+#include <linux/clk.h>
+#include <linux/slab.h>
+#include <linux/export.h>
+
+#include <asm/io.h>
+#include <asm/mach/time.h>
+
+#include <mach/map.h>
+
+#include <linux/delay.h>
+
+
+#define AK_TIMER2_CTRL1		(AK_VA_SYSCTRL + 0xBC)
+#define AK_TIMER2_CTRL2		(AK_VA_SYSCTRL + 0xC0)
+#define AK_TIMER3_CTRL1		(AK_VA_SYSCTRL + 0xC4)
+#define AK_TIMER3_CTRL2		(AK_VA_SYSCTRL + 0xC8)
+#define AK_TIMER4_CTRL1		(AK_VA_SYSCTRL + 0xCC)
+#define AK_TIMER4_CTRL2		(AK_VA_SYSCTRL + 0xD0)
+
+#define TIMER_CNT				(12000000/HZ)
+#define TIMER_USEC_SHIFT		16
+#define TIMER_CNT_MASK			(0x3F<<26)
+
+
+#define TIMER_CLEAR_BIT			(1<<30)
+#define TIMER_FEED_BIT			(1<<29)
+#define TIMER_ENABLE_BIT		(1<<28)
+#define TIMER_STATUS_BIT		(1<<27)
+#define TIMER_READ_SEL_BIT		(1<<26)
+
+
+#define MODE_AUTO_RELOAD_TIMER	0x0
+#define MODE_ONE_SHOT_TIMER		0x1
+#define MODE_PWM				0x2   
+
+typedef int (*timer_handler) (void *data);
+
+struct aktimer {
+	volatile unsigned int __force *ctrl1;
+	volatile unsigned int __force *ctrl2;
+
+	int timer_bit;
+	int irq;
+	timer_handler handler;
+	void *data;
+};
+static unsigned long flags;
+
+/* copy from plat-s3c/time.c
+ *
+ *  timer_mask_usec_ticks
+ *
+ * given a clock and divisor, make the value to pass into timer_ticks_to_usec
+ * to scale the ticks into usecs
+*/
+static inline unsigned long
+timer_mask_usec_ticks(unsigned long scaler, unsigned long pclk)
+{
+	unsigned long den = pclk / 1000;
+
+	return ((1000 << TIMER_USEC_SHIFT) * scaler + (den >> 1)) / den;
+}
+
+static inline void ak_timer_setup(struct aktimer *ptimer)
+{
+	unsigned long regval;
+
+	/* clear timeout puls, reload */
+    regval = __raw_readl(ptimer->ctrl2);
+    __raw_writel(regval | TIMER_CLEAR_BIT, ptimer->ctrl2);
+}
+
+
+int ak_timer_stop(void *priv)
+{
+	struct aktimer *ptimer = priv;
+
+	__raw_writel(~TIMER_ENABLE_BIT, ptimer->ctrl2);
+	clear_bit(ptimer->timer_bit, &flags);
+
+	return 0;
+}
+EXPORT_SYMBOL(ak_timer_stop);
+
+
+/*
+ * IRQ handler for the timer
+ */
+static irqreturn_t ak_timer_interrupt(int irq, void *dev_id)
+{
+	struct aktimer *ptimer = dev_id;
+
+	if (__raw_readl(ptimer->ctrl2) & TIMER_STATUS_BIT) {
+
+		ptimer->handler(ptimer->data);
+
+		ak_timer_setup(ptimer);
+	}
+
+	return IRQ_HANDLED;
+}
+
+void * ak_timer_probe(int which_timer)
+{
+	int ret;
+	int timer_bit;
+	struct aktimer *ptimer;
+
+	ptimer = kmalloc(sizeof(struct aktimer), GFP_KERNEL);
+	if (ptimer == NULL) {
+		pr_debug("%s kmalloc failed.\n", __func__);
+		goto err1;
+	}
+
+	memset(ptimer, 0, sizeof(*ptimer));
+
+	switch (which_timer) {
+	case 2:
+		ptimer->ctrl1 = AK_TIMER2_CTRL1;
+		ptimer->ctrl2 = AK_TIMER2_CTRL2;
+		ptimer->irq = IRQ_TIMER2;
+		break;
+	case 3:
+		ptimer->ctrl1 = AK_TIMER3_CTRL1;
+		ptimer->ctrl2 = AK_TIMER3_CTRL2;
+		ptimer->irq = IRQ_TIMER3;
+		break;
+	case 4:
+		ptimer->ctrl1 = AK_TIMER4_CTRL1;
+		ptimer->ctrl2 = AK_TIMER4_CTRL2;
+		ptimer->irq = IRQ_TIMER4;
+		break;
+	default:
+		pr_debug("ak only support 3 normal timers(timer2timer3timer4).\n");
+		goto err2;
+		break;
+	}
+
+	timer_bit = 1<<(which_timer - 1);
+	ptimer->timer_bit = timer_bit;
+
+	/* setup irq handler for IRQ_TIMER */
+	ret = request_irq(ptimer->irq, ak_timer_interrupt, 0/*IRQF_DISABLED*/ | IRQF_TIMER | IRQF_IRQPOLL, "timer for ptz", ptimer);
+	if (ret) {
+		pr_debug("request irq for timer failed.\n");
+		goto err2;
+	}
+	return ptimer;
+
+err2:
+	kfree(ptimer);
+err1:
+	return NULL;
+}
+EXPORT_SYMBOL(ak_timer_probe);
+
+int ak_timer_remove(void *priv)
+{
+	struct aktimer *ptimer = priv;
+
+	ak_timer_stop(priv);
+	free_irq(ptimer->irq, ptimer);
+	kfree(ptimer);
+
+	return 0;
+}
+EXPORT_SYMBOL(ak_timer_remove);
+
+/*
+ *which_timer:	1~5, total five timers.
+ * */
+int ak_timer_start(timer_handler handler, void *data, void *priv, int hz)
+{
+	int ret = 0;
+	unsigned long timecnt = (12000000/hz) - 1;
+	struct aktimer *ptimer = priv;
+	int timer_bit = ptimer->timer_bit;
+
+	if (handler == NULL) {
+		pr_debug("%s handler NULL", __func__);
+		ret = -EINVAL;
+		goto err1;
+	}
+
+
+	if (test_bit(timer_bit, &flags)) {
+		pr_debug("The timer be used.\n");
+		ret = -EBUSY;
+		goto err1;
+	}
+
+	set_bit(timer_bit, &flags);
+
+	ptimer->handler = handler;
+	ptimer->data = data;
+
+	__raw_writel(timecnt, ptimer->ctrl1);
+	__raw_writel((TIMER_ENABLE_BIT | TIMER_FEED_BIT | (MODE_AUTO_RELOAD_TIMER << 24)), 
+		ptimer->ctrl2);
+
+err1:
+	return ret;
+}
+EXPORT_SYMBOL(ak_timer_start);
\ No newline at end of file
diff --git a/drivers/clocksource/ak_timer.c b/drivers/clocksource/ak_timer.c
new file mode 100755
index 0000000..94059b1
--- /dev/null
+++ b/drivers/clocksource/ak_timer.c
@@ -0,0 +1,247 @@
+/*
+ * AKXX hr_timer driver
+ *
+ * Copyright (C) 2018 Anyka(Guangzhou) Microelectronics Technology Co., Ltd.
+ *
+ * Author: Feilong Dong <dong_feilong@anyka.com>
+ * 		   Guohong Ye  <ye_guohong@anyka.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#define pr_fmt(fmt) "ak-timer: " fmt
+
+#include <linux/bitops.h>
+#include <linux/init.h>
+#include <linux/interrupt.h>
+#include <linux/irq.h>
+#include <linux/clocksource.h>
+#include <linux/clockchips.h>
+
+#include <linux/clocksource.h>
+#include <linux/interrupt.h>
+#include <linux/irqreturn.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/of_address.h>
+#include <linux/of_irq.h>
+#include <linux/of_platform.h>
+#include <linux/slab.h>
+#include <linux/string.h>
+#include <linux/sched_clock.h>
+
+#include <asm/irq.h>
+#include <mach/map.h>
+
+
+#define AK_TIMER1_CTRL1       (AK_VA_SYSCTRL + 0xB4)
+#define AK_TIMER1_CTRL2       (AK_VA_SYSCTRL + 0xB8)
+#define AK_TIMER2_CTRL1       (AK_VA_SYSCTRL + 0xBC)
+#define AK_TIMER2_CTRL2       (AK_VA_SYSCTRL + 0xC0)
+#define AK_TIMER3_CTRL1       (AK_VA_SYSCTRL + 0xC4)
+#define AK_TIMER3_CTRL2       (AK_VA_SYSCTRL + 0xC8)
+#define AK_TIMER4_CTRL1       (AK_VA_SYSCTRL + 0xCC)
+#define AK_TIMER4_CTRL2       (AK_VA_SYSCTRL + 0xD0)
+#define AK_TIMER5_CTRL1       (AK_VA_SYSCTRL + 0xD4)
+#define AK_TIMER5_CTRL2       (AK_VA_SYSCTRL + 0xD8)
+#define AK_TIMER6_CTRL1       (AK_VA_SYSCTRL + 0x1C0)
+#define AK_TIMER6_CTRL2       (AK_VA_SYSCTRL + 0x1C4)
+#define AK_TIMER7_CTRL1       (AK_VA_SYSCTRL + 0x1C8)
+#define AK_TIMER7_CTRL2       (AK_VA_SYSCTRL + 0x1CC)
+
+#define AK_CE_CTRL1       AK_TIMER6_CTRL1
+#define AK_CE_CTRL2       AK_TIMER6_CTRL2
+#define IRQ_TIMER           IRQ_TIMER6
+
+#define AK_CS_CTRL1       AK_TIMER7_CTRL1
+#define AK_CS_CTRL2       AK_TIMER7_CTRL2
+
+#define TIMER_CLK_INPUT     (12000000)
+#define TIMER_CNT           (TIMER_CLK_INPUT/HZ)
+#define TIMER_CNT_MASK			(0x3F<<26)
+
+/* define timer control register2 bits */
+#define TIMER_CLEAR_BIT         (1<<30)
+#define TIMER_FEED_BIT          (1<<29)
+#define TIMER_ENABLE            (1<<28)
+#define TIMER_STATUS_BIT        (1<<27)
+#define TIMER_READ_SEL_BIT      (1<<26)
+
+/* define working mode */
+#define MODE_AUTO_RELOAD_TIMER  (0x0<<24)
+#define MODE_ONE_SHOT_TIMER     (0x1<<24)
+#define MODE_PWM                (0x2<<24)   
+
+/* use ak timer as clocksource device */
+static cycle_t ak_timer7_read(struct clocksource *cs)
+{
+    u32 ctrl1, ctrl2;
+    unsigned long flags;
+
+    local_irq_save(flags);
+
+    /* select read current count mode */
+	ctrl2 = __raw_readl(AK_CS_CTRL2);
+	__raw_writel(ctrl2 | TIMER_READ_SEL_BIT, AK_CS_CTRL2);
+
+    ctrl1 = __raw_readl(AK_CS_CTRL1);
+
+    /* resume read mode */
+    ctrl2 = __raw_readl(AK_CS_CTRL2);
+	__raw_writel(ctrl2 & (~TIMER_READ_SEL_BIT), AK_CS_CTRL2);
+
+    local_irq_restore(flags);
+
+    return (cycle_t)~ctrl1;
+}
+
+static struct clocksource ak_cs = {
+    .name           = "ak_timer cs",
+    .rating         = 150,
+    .read           = ak_timer7_read,
+    .mask           = CLOCKSOURCE_MASK(32),
+    .flags          = CLOCK_SOURCE_IS_CONTINUOUS,
+};
+
+/* use ak timer1 as clock event device */
+static int ak_timer6_set_mode(int mode,
+    struct clock_event_device *evt)
+{
+	int ret = 0;
+
+	switch (mode) {
+		case 0://CLOCK_EVT_MODE_PERIODIC:
+			__raw_writel((TIMER_CNT-1), AK_CE_CTRL1);
+			__raw_writel((MODE_AUTO_RELOAD_TIMER | TIMER_ENABLE | TIMER_FEED_BIT ), AK_CE_CTRL2);
+			break;
+
+		case 1://CLOCK_EVT_MODE_ONESHOT:
+			__raw_writel(0xffffffff, AK_CE_CTRL1);
+			__raw_writel((MODE_ONE_SHOT_TIMER | TIMER_ENABLE | TIMER_FEED_BIT ), AK_CE_CTRL2);
+			break;
+
+		default:
+			ret = -1;
+			break;
+	}
+
+	return ret;
+}
+
+static int ak_timer6_set_periodic(struct clock_event_device *evt)
+{
+	return ak_timer6_set_mode(0, evt);
+}
+
+static int ak_timer6_set_oneshot(struct clock_event_device *evt)
+{
+	return ak_timer6_set_mode(1, evt);
+}
+
+static int ak_timer6_set_next_event(unsigned long next,
+    struct clock_event_device *evt)
+{
+    __raw_writel(next, AK_CE_CTRL1);
+    __raw_writel((TIMER_ENABLE | MODE_ONE_SHOT_TIMER| TIMER_FEED_BIT), AK_CE_CTRL2);
+
+    return 0;
+}
+
+static struct clock_event_device ak_ced = {
+    .name       = "ak_timer6 ce",
+    .features   = CLOCK_EVT_FEAT_PERIODIC | CLOCK_EVT_FEAT_ONESHOT,
+    .shift      = 32,
+    .rating     = 150,
+    .irq        = IRQ_TIMER,
+    .set_next_event = ak_timer6_set_next_event,
+	.set_state_periodic = ak_timer6_set_periodic,
+	.set_state_oneshot = ak_timer6_set_oneshot,
+};
+
+/* interrupt handler of ak timer1 */
+static irqreturn_t ak_timer6_interrupt(int irq, void *handle)
+{
+    struct clock_event_device   *dev = handle;
+    u32 ctrl2;
+
+    ctrl2 = __raw_readl(AK_CE_CTRL2);
+    if (ctrl2 & TIMER_STATUS_BIT) {
+        dev->event_handler(dev);
+        __raw_writel(ctrl2 | TIMER_CLEAR_BIT, AK_CE_CTRL2);
+        return IRQ_HANDLED;
+    }      
+
+    return IRQ_NONE;
+}
+
+static struct irqaction ak_timer6_irq = {
+    .name	= "ak_timer6 irq",
+    .flags	= IRQF_TIMER | IRQF_IRQPOLL,
+    .handler	= ak_timer6_interrupt,
+    .dev_id	= &ak_ced,
+};
+
+/* use ak timer7 as sched clock */
+static u64 ak_read_sched_clock(void)
+{
+    u32 ctrl1, ctrl2;
+    unsigned long flags;
+
+    local_irq_save(flags);
+
+    /* select read current count mode */
+	ctrl2 = __raw_readl(AK_CS_CTRL2);
+	__raw_writel(ctrl2 | TIMER_READ_SEL_BIT, AK_CS_CTRL2);
+
+    ctrl1 = __raw_readl(AK_CS_CTRL1);
+
+    /* resume read mode */
+    ctrl2 = __raw_readl(AK_CS_CTRL2);
+	__raw_writel(ctrl2 & (~TIMER_READ_SEL_BIT), AK_CS_CTRL2);
+
+    local_irq_restore(flags);
+
+    return ~ctrl1;
+}
+
+static void __init ak_timer_init(struct device_node *node)
+{
+	int irq;
+    pr_err("ak_timer_init\n");
+	irq = irq_of_parse_and_map(node, 5); /* index 0 - timer1, 6 - timer7 */
+	if (irq <= 0)
+		panic("Can't parse IRQ");
+
+	/* clock for timers*/
+
+	/* enable clocksource timer */
+    /* ak timer7 clocksource init */
+    __raw_writel(0xffffffff, AK_CS_CTRL1);
+    __raw_writel((TIMER_ENABLE | MODE_AUTO_RELOAD_TIMER| TIMER_FEED_BIT), 
+                  AK_CS_CTRL2);
+
+	/* register to clocksource framework */
+	if (clocksource_register_hz(&ak_cs, TIMER_CLK_INPUT))
+		pr_err("ak_sys_timer_init: clocksource_register failed for %s\n",
+					ak_cs.name);
+
+    /* register to clock event framework */
+    ak_ced.cpumask    = cpumask_of(0);
+    clockevents_config_and_register(&ak_ced, TIMER_CLK_INPUT, 0xf, 0xffffffff);
+
+    if (setup_irq(irq, &ak_timer6_irq))
+        pr_err("ak_sys_timer_init: irq register failed for %s\n",
+                    ak_timer6_irq.name);
+
+	/* register to 64bit general sched clock framework */
+    sched_clock_register(ak_read_sched_clock, 32, TIMER_CLK_INPUT);
+}
+CLOCKSOURCE_OF_DECLARE(ak_hrtimer, "anyka,ak3790d-system-timer", ak_timer_init);
diff --git a/drivers/gpio/gpiolib-sysfs.c b/drivers/gpio/gpiolib-sysfs.c
old mode 100644
new mode 100755
index b57ed8e..6ea4d6f
--- a/drivers/gpio/gpiolib-sysfs.c
+++ b/drivers/gpio/gpiolib-sysfs.c
@@ -139,6 +139,228 @@ static ssize_t value_store(struct device *dev,
 }
 static DEVICE_ATTR_RW(value);
 
+
+
+
+
+static ssize_t drive_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	struct gpiod_data *data = dev_get_drvdata(dev);
+	struct gpio_desc *desc = data->desc;
+	ssize_t			status;
+
+	mutex_lock(&data->mutex);
+
+	status = gpiod_get_drive(desc);
+	if (status >= 0) {
+		status = sprintf(buf, "%d\n", status);
+	} else {
+		status = sprintf(buf, "%s\n", "error");
+	}
+
+	mutex_unlock(&data->mutex);
+
+	return status;
+}
+
+static ssize_t drive_store(struct device *dev,
+		struct device_attribute *attr, const char *buf, size_t size)
+{
+	struct gpiod_data *data = dev_get_drvdata(dev);
+	struct gpio_desc *desc = data->desc;
+	ssize_t			status;
+	long strength;
+
+	mutex_lock(&data->mutex);
+
+	status = kstrtol(buf, 0, &strength);
+	if (status == 0) {
+		status = gpiod_set_drive(desc, strength);
+	}
+
+	mutex_unlock(&data->mutex);
+
+	return status ? : size;
+}
+static DEVICE_ATTR_RW(drive);
+
+static ssize_t pull_polarity_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	struct gpiod_data *data = dev_get_drvdata(dev);
+	struct gpio_desc *desc = data->desc;
+	ssize_t			status;
+
+	mutex_lock(&data->mutex);
+
+	status = gpiod_get_pull_polarity(desc);
+	if (status >= 0) {
+		status = sprintf(buf, "%s\n", status ? "pullup":"pulldown");
+	} else {
+		status = sprintf(buf, "%s\n", "error");
+	}
+
+	mutex_unlock(&data->mutex);
+
+	return status;
+}
+
+static ssize_t pull_polarity_store(struct device *dev,
+		struct device_attribute *attr, const char *buf, size_t size)
+{
+	struct gpiod_data *data = dev_get_drvdata(dev);
+	struct gpio_desc *desc = data->desc;
+	ssize_t			status;
+
+	mutex_lock(&data->mutex);
+
+	if (sysfs_streq(buf, "pullup"))
+		status = gpiod_set_pull_polarity(desc, 1);
+	else if (sysfs_streq(buf, "pulldown"))
+		status = gpiod_set_pull_polarity(desc, 0);
+	else
+		status = -EINVAL;
+
+	mutex_unlock(&data->mutex);
+
+	return status ? : size;
+}
+static DEVICE_ATTR_RW(pull_polarity);
+
+static ssize_t pull_enable_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	struct gpiod_data *data = dev_get_drvdata(dev);
+	struct gpio_desc *desc = data->desc;
+	ssize_t			status;
+
+	mutex_lock(&data->mutex);
+
+	status = gpiod_get_pull_enable(desc);
+	if (status >= 0) {
+		status = sprintf(buf, "%d\n", status ? 1:0);
+	} else {
+		status = sprintf(buf, "%s\n", "error");
+	}
+
+	mutex_unlock(&data->mutex);
+
+	return status;
+}
+
+static ssize_t pull_enable_store(struct device *dev,
+		struct device_attribute *attr, const char *buf, size_t size)
+{
+	struct gpiod_data *data = dev_get_drvdata(dev);
+	struct gpio_desc *desc = data->desc;
+	ssize_t			status;
+
+	mutex_lock(&data->mutex);
+
+	if (sysfs_streq(buf, "1"))
+		status = gpiod_set_pull_enable(desc, 1);
+	else if (sysfs_streq(buf, "0"))
+		status = gpiod_set_pull_enable(desc, 0);
+	else
+		status = -EINVAL;
+
+	mutex_unlock(&data->mutex);
+
+	return status ? : size;
+}
+static DEVICE_ATTR_RW(pull_enable);
+
+static ssize_t input_enable_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	struct gpiod_data *data = dev_get_drvdata(dev);
+	struct gpio_desc *desc = data->desc;
+	ssize_t			status;
+
+	mutex_lock(&data->mutex);
+
+	status = gpiod_get_input_enable(desc);
+	if (status >= 0) {
+		status = sprintf(buf, "%d\n", status ? 1:0);
+	} else {
+		status = sprintf(buf, "%s\n", "error");
+	}
+
+	mutex_unlock(&data->mutex);
+
+	return status;
+}
+
+static ssize_t input_enable_store(struct device *dev,
+		struct device_attribute *attr, const char *buf, size_t size)
+{
+	struct gpiod_data *data = dev_get_drvdata(dev);
+	struct gpio_desc *desc = data->desc;
+	ssize_t			status;
+
+	mutex_lock(&data->mutex);
+
+	if (sysfs_streq(buf, "1"))
+		status = gpiod_set_input_enable(desc, 1);
+	else if (sysfs_streq(buf, "0"))
+		status = gpiod_set_input_enable(desc, 0);
+	else
+		status = -EINVAL;
+
+	mutex_unlock(&data->mutex);
+
+	return status ? : size;
+}
+static DEVICE_ATTR_RW(input_enable);
+
+static ssize_t slew_rate_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	struct gpiod_data *data = dev_get_drvdata(dev);
+	struct gpio_desc *desc = data->desc;
+	ssize_t			status;
+
+	mutex_lock(&data->mutex);
+
+	status = gpiod_get_slew_rate(desc);
+	if (status >= 0) {
+		status = sprintf(buf, "%s\n", status ? "fast":"slow");
+	} else {
+		status = sprintf(buf, "%s\n", "error");
+	}
+
+	mutex_unlock(&data->mutex);
+
+	return status;
+}
+
+static ssize_t slew_rate_store(struct device *dev,
+		struct device_attribute *attr, const char *buf, size_t size)
+{
+	struct gpiod_data *data = dev_get_drvdata(dev);
+	struct gpio_desc *desc = data->desc;
+	ssize_t			status;
+
+	mutex_lock(&data->mutex);
+
+	if (sysfs_streq(buf, "fast"))
+		status = gpiod_set_slew_rate(desc, 1);
+	else if (sysfs_streq(buf, "slow"))
+		status = gpiod_set_slew_rate(desc, 0);
+	else
+		status = -EINVAL;
+
+	mutex_unlock(&data->mutex);
+
+	return status ? : size;
+}
+static DEVICE_ATTR_RW(slew_rate);
+
+
+
+
+
 static irqreturn_t gpio_sysfs_irq(int irq, void *priv)
 {
 	struct gpiod_data *data = priv;
@@ -377,6 +599,11 @@ static struct attribute *gpio_attrs[] = {
 	&dev_attr_edge.attr,
 	&dev_attr_value.attr,
 	&dev_attr_active_low.attr,
+	&dev_attr_drive.attr,
+	&dev_attr_pull_polarity.attr,
+	&dev_attr_pull_enable.attr,
+	&dev_attr_input_enable.attr,
+	&dev_attr_slew_rate.attr,
 	NULL,
 };
 
diff --git a/drivers/gpio/gpiolib.c b/drivers/gpio/gpiolib.c
old mode 100644
new mode 100755
index fe89fd5..b42b12f
--- a/drivers/gpio/gpiolib.c
+++ b/drivers/gpio/gpiolib.c
@@ -180,6 +180,176 @@ int gpiod_get_direction(struct gpio_desc *desc)
 }
 EXPORT_SYMBOL_GPL(gpiod_get_direction);
 
+int gpiod_set_drive(struct gpio_desc *desc, int strength)
+{
+	struct gpio_chip	*chip;
+	unsigned		offset;
+	int			status = -EINVAL;
+
+	chip = gpiod_to_chip(desc);
+	offset = gpio_chip_hwgpio(desc);
+
+	if (!chip->set_drive)
+		return status;
+
+	status = chip->set_drive(chip, offset, strength);
+	return status;
+}
+EXPORT_SYMBOL_GPL(gpiod_set_drive);
+
+int gpiod_get_drive(struct gpio_desc *desc)
+{
+	struct gpio_chip	*chip;
+	unsigned		offset;
+	int			status = -EINVAL;
+
+	chip = gpiod_to_chip(desc);
+	offset = gpio_chip_hwgpio(desc);
+
+	if (!chip->get_drive)
+		return status;
+
+	status = chip->get_drive(chip, offset);
+	return status;
+}
+EXPORT_SYMBOL_GPL(gpiod_get_drive);
+
+int gpiod_set_pull_polarity(struct gpio_desc *desc, int pullup)
+{
+	struct gpio_chip	*chip;
+	unsigned		offset;
+	int			status = -EINVAL;
+
+	chip = gpiod_to_chip(desc);
+	offset = gpio_chip_hwgpio(desc);
+
+	if (!chip->set_pull_polarity)
+		return status;
+
+	status = chip->set_pull_polarity(chip, offset, pullup);
+	return status;
+}
+EXPORT_SYMBOL_GPL(gpiod_set_pull_polarity);
+
+int gpiod_get_pull_polarity(struct gpio_desc *desc)
+{
+	struct gpio_chip	*chip;
+	unsigned		offset;
+	int			status = -EINVAL;
+
+	chip = gpiod_to_chip(desc);
+	offset = gpio_chip_hwgpio(desc);
+
+	if (!chip->get_pull_polarity)
+		return status;
+
+	status = chip->get_pull_polarity(chip, offset);
+	return status;
+}
+EXPORT_SYMBOL_GPL(gpiod_get_pull_polarity);
+
+int gpiod_set_pull_enable(struct gpio_desc *desc, int enable)
+{
+	struct gpio_chip	*chip;
+	unsigned		offset;
+	int			status = -EINVAL;
+
+	chip = gpiod_to_chip(desc);
+	offset = gpio_chip_hwgpio(desc);
+
+	if (!chip->set_pull_enable)
+		return status;
+
+	status = chip->set_pull_enable(chip, offset, enable);
+	return status;
+}
+EXPORT_SYMBOL_GPL(gpiod_set_pull_enable);
+
+int gpiod_get_pull_enable(struct gpio_desc *desc)
+{
+	struct gpio_chip	*chip;
+	unsigned		offset;
+	int			status = -EINVAL;
+
+	chip = gpiod_to_chip(desc);
+	offset = gpio_chip_hwgpio(desc);
+
+	if (!chip->get_pull_enable)
+		return status;
+
+	status = chip->get_pull_enable(chip, offset);
+	return status;
+}
+EXPORT_SYMBOL_GPL(gpiod_get_pull_enable);
+
+int gpiod_set_input_enable(struct gpio_desc *desc, int enable)
+{
+	struct gpio_chip	*chip;
+	unsigned		offset;
+	int			status = -EINVAL;
+
+	chip = gpiod_to_chip(desc);
+	offset = gpio_chip_hwgpio(desc);
+
+	if (!chip->set_input_enable)
+		return status;
+
+	status = chip->set_input_enable(chip, offset, enable);
+	return status;
+}
+EXPORT_SYMBOL_GPL(gpiod_set_input_enable);
+
+int gpiod_get_input_enable(struct gpio_desc *desc)
+{
+	struct gpio_chip	*chip;
+	unsigned		offset;
+	int			status = -EINVAL;
+
+	chip = gpiod_to_chip(desc);
+	offset = gpio_chip_hwgpio(desc);
+
+	if (!chip->get_input_enable)
+		return status;
+
+	status = chip->get_input_enable(chip, offset);
+	return status;
+}
+EXPORT_SYMBOL_GPL(gpiod_get_input_enable);
+
+int gpiod_set_slew_rate(struct gpio_desc *desc, int fast)
+{
+	struct gpio_chip	*chip;
+	unsigned		offset;
+	int			status = -EINVAL;
+
+	chip = gpiod_to_chip(desc);
+	offset = gpio_chip_hwgpio(desc);
+
+	if (!chip->set_slew_rate)
+		return status;
+
+	status = chip->set_slew_rate(chip, offset, fast);
+	return status;
+}
+EXPORT_SYMBOL_GPL(gpiod_set_slew_rate);
+
+int gpiod_get_slew_rate(struct gpio_desc *desc)
+{
+	struct gpio_chip	*chip;
+	unsigned		offset;
+	int			status = -EINVAL;
+
+	chip = gpiod_to_chip(desc);
+	offset = gpio_chip_hwgpio(desc);
+
+	if (!chip->get_slew_rate)
+		return status;
+
+	status = chip->get_slew_rate(chip, offset);
+	return status;
+}
+EXPORT_SYMBOL_GPL(gpiod_get_slew_rate);
+
 /*
  * Add a new chip to the global chips list, keeping the list of chips sorted
  * by base order.
@@ -2120,12 +2290,12 @@ struct gpio_desc *__must_check gpiod_get_index(struct device *dev,
 	/* Maybe we have a device name, maybe not */
 	const char *devname = dev ? dev_name(dev) : "?";
 
-	dev_dbg(dev, "GPIO lookup for consumer %s\n", con_id);
+	//dev_dbg(dev, "GPIO lookup for consumer %s\n", con_id);
 
 	if (dev) {
 		/* Using device tree? */
 		if (IS_ENABLED(CONFIG_OF) && dev->of_node) {
-			dev_dbg(dev, "using device tree for GPIO lookup\n");
+			//dev_dbg(dev, "using device tree for GPIO lookup\n");
 			desc = of_find_gpio(dev, con_id, idx, &lookupflags);
 		} else if (ACPI_COMPANION(dev)) {
 			dev_dbg(dev, "using ACPI for GPIO lookup\n");
@@ -2138,7 +2308,7 @@ struct gpio_desc *__must_check gpiod_get_index(struct device *dev,
 	 * a result. In that case, use platform lookup as a fallback.
 	 */
 	if (!desc || desc == ERR_PTR(-ENOENT)) {
-		dev_dbg(dev, "using lookup tables for GPIO lookup\n");
+		//dev_dbg(dev, "using lookup tables for GPIO lookup\n");
 		desc = gpiod_find(dev, con_id, idx, &lookupflags);
 	}
 
diff --git a/drivers/irqchip/Makefile b/drivers/irqchip/Makefile
old mode 100644
new mode 100755
index 177f78f..c0722f7
--- a/drivers/irqchip/Makefile
+++ b/drivers/irqchip/Makefile
@@ -1,5 +1,6 @@
 obj-$(CONFIG_IRQCHIP)			+= irqchip.o
-
+obj-$(CONFIG_ARCH_AK39)         += ak_irq.o
+obj-$(CONFIG_ARCH_AK)           += ak_irq.o
 obj-$(CONFIG_ARCH_BCM2835)		+= irq-bcm2835.o
 obj-$(CONFIG_ARCH_BCM2835)		+= irq-bcm2836.o
 obj-$(CONFIG_ARCH_EXYNOS)		+= exynos-combiner.o
diff --git a/drivers/irqchip/ak_irq.c b/drivers/irqchip/ak_irq.c
new file mode 100755
index 0000000..e0fe3ba
--- /dev/null
+++ b/drivers/irqchip/ak_irq.c
@@ -0,0 +1,268 @@
+/*
+ * AKXX irq driver
+ *
+ * Copyright (C) 2018 Anyka(Guangzhou) Microelectronics Technology Co., Ltd.
+ *
+ * Author: Feilong Dong <dong_feilong@anyka.com>
+ * 		   Guohong  Ye  <ye_guohong@anyka.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#define pr_fmt(fmt) KBUILD_MODNAME ": " fmt
+
+#include <linux/io.h>
+#include <linux/slab.h>
+#include <linux/of_address.h>
+#include <linux/of_irq.h>
+#include <linux/irqchip.h>
+#include <linux/irqdomain.h>
+#include <asm/exception.h>
+#include <asm/mach/irq.h>
+#include <asm/irq.h>
+#include <mach/map.h>
+#include <mach/irqs.h>
+
+/* Put the bank and irq (32 bits) into the hwirq */
+#define MAKE_HWIRQ(b, n)	(bank_pre_irqs[(b)] + (n))
+#define HWIRQ_BANK(i)		(((i) < bank_pre_irqs[1]) ? (0):(((i) < bank_pre_irqs[2]) ? 1:2))
+#define HWIRQ_BIT(i)		BIT(bank_pre_irqs[HWIRQ_BANK(i)] - (i))
+
+#define BANK0_HWIRQ_MASK	(~((~0UL) << bank_irqs[0]))
+
+#define AK_IRQ_MASK				(AK_VA_SYSCTRL + 0x24)
+#define AK_FIQ_MASK				(AK_VA_SYSCTRL + 0x28)
+#define	AK_SYSCTRL_INT_MASK		(AK_VA_SYSCTRL + 0x2C)
+#define	AK_SYSCTRL_INT_STATUS	(AK_VA_SYSCTRL + 0x30)
+#define AK_INT_STATUS			(AK_VA_SYSCTRL + 0x4C)
+#define AK_L2MEM_IRQ_ENABLE		(AK_VA_L2CTRL + 0x9C)
+
+#define NR_BANKS		2
+static int bank_irqs[NR_BANKS];
+static int bank_pre_irqs[NR_BANKS];
+
+struct ak_irqchip_intc {
+	struct irq_domain *domain;
+	void __iomem *base;
+};
+
+static struct ak_irqchip_intc intc __read_mostly;
+
+/*
+ * Disable interrupt number "irq"
+ */
+static void ak_mask_irq(struct irq_data *d)
+{
+	unsigned long regval;
+	regval = __raw_readl(AK_IRQ_MASK);
+	regval &= ~(1UL << d->irq);
+	__raw_writel(regval, AK_IRQ_MASK);
+	
+	pr_debug("ak_mask_irq irq=%u, hwirq=%lu\n", d->irq, d->hwirq);
+}
+
+/*
+ * Enable interrupt number "irq"
+ */
+static void ak_unmask_irq(struct irq_data *d)
+{
+	unsigned long regval;
+
+	regval = __raw_readl(AK_IRQ_MASK);
+	regval |= (1UL << d->irq);
+	__raw_writel(regval, AK_IRQ_MASK);
+
+	pr_debug("ak_unmask_irq irq=%u, hwirq=%lu\n", d->irq, d->hwirq);
+}
+
+static struct irq_chip ak_irq_chip = {
+	.name = "module-irq",
+	.irq_mask_ack = ak_mask_irq,
+	.irq_mask = ak_mask_irq,
+	.irq_unmask = ak_unmask_irq,
+};
+
+static void sysctrl_mask_irq(struct irq_data *d)
+{
+	unsigned long regval;
+
+	regval = __raw_readl(AK_SYSCTRL_INT_MASK);
+	regval &= ~(1 << (d->irq - (bank_irqs[0]+1)));
+	__raw_writel(regval, AK_SYSCTRL_INT_MASK);
+
+	pr_debug("sysctrl_mask_irq irq=%u, hwirq=%lu\n", d->irq, d->hwirq);
+}
+
+static void sysctrl_unmask_irq(struct irq_data *d)
+{
+	unsigned long regval;
+
+	regval = __raw_readl(AK_SYSCTRL_INT_MASK);
+	regval |= (1 << (d->irq - (bank_irqs[0]+1) ));
+	__raw_writel(regval, AK_SYSCTRL_INT_MASK);
+
+	pr_debug("sysctrl_unmask_irq irq=%u, hwirq=%lu\n", d->irq, d->hwirq);
+}
+
+/* enable rtc alarm to wake up systerm */
+static int sysctrl_set_wake(struct irq_data *d, unsigned int on)
+{
+	pr_info("%s,%d\n",__func__,__LINE__);
+	// todo
+	return 0;
+}
+
+static struct irq_chip ak_sysctrl_chip = {
+	.name = "sysctrl-irq",
+	.irq_mask_ack = sysctrl_mask_irq,
+	.irq_mask = sysctrl_mask_irq,
+	.irq_unmask = sysctrl_unmask_irq,
+	.irq_set_wake = sysctrl_set_wake,
+};
+
+/**
+ * @brief: system module irq handler
+ * 
+ * @author: caolianming
+ * @param [in] irq: irq number
+ * @param [in] *desc: irq info description
+ */
+static void ak_sysctrl_handler(struct irq_desc *desc)
+{
+	unsigned long regval_mask, regval_sta;
+	unsigned long intpnd;
+	unsigned int offset;
+	u32 irq;
+	
+	regval_mask = __raw_readl(AK_SYSCTRL_INT_MASK);
+	regval_sta = __raw_readl(AK_SYSCTRL_INT_STATUS);
+	
+    /*Beware!  H3D chip System irq number is 20.  */
+    intpnd = (regval_mask & 0xFFFFF) & (regval_sta & 0xFFFFF);	
+
+    /*Beware!  H3D chip System irq number is 20.  */
+	for (offset = 0; intpnd && offset < 20; offset++) {
+
+		if (intpnd & (1 << offset))
+			intpnd &= ~(1 << offset);
+		else
+			continue;
+		irq = bank_irqs[0] + 1 + offset;
+		
+		generic_handle_irq(irq);
+	}
+}
+
+static int int_xlate(struct irq_domain *d, struct device_node *ctrlr,
+	const u32 *intspec, unsigned int intsize,
+	unsigned long *out_hwirq, unsigned int *out_type)
+{
+	if (WARN_ON(intsize != 2))
+		return -EINVAL;
+
+	if (WARN_ON(intspec[1] >= NR_BANKS))
+		return -EINVAL;
+
+	if (WARN_ON(intspec[0] > bank_irqs[intspec[1]]))  
+		return -EINVAL;
+
+	*out_hwirq = MAKE_HWIRQ(intspec[1], intspec[0]);
+	*out_type = IRQ_TYPE_NONE;
+	
+	return 0;
+}
+
+static const struct irq_domain_ops int_ops = {
+	.xlate = int_xlate
+};
+
+static int __init ak_int_of_init(struct device_node *node,
+					  struct device_node *parent)
+{
+	int b, i;
+	int irq;
+
+	intc.base = AK_VA_SYSCTRL;
+	/* 1st, clear all interrupts */
+	__raw_readl(AK_INT_STATUS);
+	__raw_readl(AK_SYSCTRL_INT_STATUS);
+
+	/* 2nd, mask all interrutps */
+	__raw_writel(0x0, AK_IRQ_MASK);
+	__raw_writel(0x0, AK_FIQ_MASK);
+	__raw_writel(0x0, AK_SYSCTRL_INT_MASK);
+
+	/* mask all l2 interrupts */
+	__raw_writel(0x0, AK_L2MEM_IRQ_ENABLE);
+
+	b = 0;
+	for (i = 0; i < NR_BANKS; i++) {
+		bank_pre_irqs[i] = b;
+		if(of_property_read_u32_index(node, "bank_irqs", i,&bank_irqs[i]) < 0)
+		{
+			pr_err("%s: unable to get bank_irqs\n", node->full_name);
+			return -1;
+		}
+		//pr_err("bank_irqs[%d]=%d\n", i, bank_irqs[i]);	
+		b += bank_irqs[i];
+	}
+	
+	intc.domain = irq_domain_add_linear(node, bank_irqs[0]+bank_irqs[1]+1,
+			&int_ops, NULL);
+	if (!intc.domain)
+		pr_err("%s: unable to create IRQ domain\n", node->full_name);
+
+	for (b = 0; b < NR_BANKS; b++) {
+		for (i = 1; i <= bank_irqs[b]; i++) {
+			irq = irq_create_mapping(intc.domain, MAKE_HWIRQ(b, i));
+			pr_debug("i = %d irq = %d\n", i, irq);
+			BUG_ON(irq <= 0);
+			if (b == 0)
+				irq_set_chip_and_handler(irq, &ak_irq_chip, handle_level_irq);
+			else if (b == 1)
+				irq_set_chip_and_handler(irq, &ak_sysctrl_chip, handle_level_irq);
+			
+			irq_set_probe(irq);
+		}
+	}
+	
+	//pr_err("ak_int_of_init success\n");
+	
+	return 0;
+}
+
+static int __init ak_sysint_of_init(struct device_node *node,
+		struct device_node *parent)
+{
+ 	int parent_irq = irq_of_parse_and_map(node, 0);
+	if (!parent_irq) {
+		panic("%s: unable to get parent interrupt.\n",
+			    node->full_name);
+	}
+	//pr_err("get parent interrupt = %d\n", parent_irq);
+
+	irq_set_chained_handler(parent_irq, ak_sysctrl_handler);
+	
+	//pr_err("ak_sysint_of_init success\n");
+
+	return 0;
+}
+			  
+IRQCHIP_DECLARE(ak39_irqchip, "anyka,ak3916ev300-ic",
+		ak_int_of_init);
+IRQCHIP_DECLARE(ak39_sysirqchip, "anyka,ak3916ev300-system-ic",
+		ak_sysint_of_init);			  
+
+IRQCHIP_DECLARE(ak37_irqchip, "anyka,ak3790d-ic",
+				ak_int_of_init);
+IRQCHIP_DECLARE(ak37_sysirqchip, "anyka,ak3790d-system-ic",
+				ak_sysint_of_init); 		  
+
diff --git a/drivers/media/platform/soc_camera/Kconfig b/drivers/media/platform/soc_camera/Kconfig
old mode 100644
new mode 100755
index f2776cd..a5a8318
--- a/drivers/media/platform/soc_camera/Kconfig
+++ b/drivers/media/platform/soc_camera/Kconfig
@@ -89,3 +89,12 @@ config VIDEO_ATMEL_ISI
 	  This module makes the ATMEL Image Sensor Interface available
 	  as a v4l2 device.
 
+config VIDEO_AK
+	tristate "AK Image Sensor Interface (ISI) support"
+	depends on VIDEO_DEV && SOC_CAMERA
+	depends on MACH_AK3790D
+	select VIDEOBUF2_DMA_CONTIG
+	---help---
+		This module makes the AK Image Sensor Interface available
+		as a v4l2 device.
+
diff --git a/drivers/mtd/Makefile b/drivers/mtd/Makefile
old mode 100644
new mode 100755
index 99bb9a1..6444822
--- a/drivers/mtd/Makefile
+++ b/drivers/mtd/Makefile
@@ -30,7 +30,7 @@ obj-$(CONFIG_MTD_SWAP)		+= mtdswap.o
 nftl-objs		:= nftlcore.o nftlmount.o
 inftl-objs		:= inftlcore.o inftlmount.o
 
-obj-y		+= chips/ lpddr/ maps/ devices/ nand/ onenand/ tests/
+obj-y		+= chips/ lpddr/ maps/ devices/ nand/ onenand/ tests/ partition/
 
 obj-$(CONFIG_MTD_SPI_NOR)	+= spi-nor/
 obj-$(CONFIG_MTD_UBI)		+= ubi/
diff --git a/drivers/mtd/devices/Kconfig b/drivers/mtd/devices/Kconfig
old mode 100644
new mode 100755
index 5ab9a46..1342d46
--- a/drivers/mtd/devices/Kconfig
+++ b/drivers/mtd/devices/Kconfig
@@ -120,6 +120,17 @@ config MTD_BCM47XXSFLASH
 	  registered by bcma as platform devices. This enables driver for
 	  serial flash memories (only read-only mode is implemented).
 
+config MTD_AK_SPIFLASH
+	tristate "Support Anyka SPI Flash chips(Most chips)"
+	depends on SPI_MASTER
+	help
+		Anyka driver enables access to most SPI flash chips, used for
+		program and data storage.
+
+		Set up your spi devices with the right board-specific platform data,
+		if you want to specify device partitioning or to use a device which
+		doesn't support the JEDEC ID instruction.
+		
 config MTD_SLRAM
 	tristate "Uncached system RAM"
 	help
@@ -233,4 +244,14 @@ config BCH_CONST_T
 	default 4
 endif
 
+config MTD_AK_SPINAND
+	tristate "Support Anyka SPI NandFlash chips(Most chips)"
+	depends on SPI_MASTER
+	help
+	  Anyka driver enables access to most SPI Nandflash chips, used for
+	  program and data storage.
+
+	  Set up your spi devices with the right board-specific platform data,
+	  if you want to specify device partitioning or to use a device which
+	  doesn't support the JEDEC ID instruction.
 endmenu
diff --git a/drivers/mtd/devices/Makefile b/drivers/mtd/devices/Makefile
old mode 100644
new mode 100755
index 7912d3a..848b868
--- a/drivers/mtd/devices/Makefile
+++ b/drivers/mtd/devices/Makefile
@@ -17,6 +17,8 @@ obj-$(CONFIG_MTD_SST25L)	+= sst25l.o
 obj-$(CONFIG_MTD_BCM47XXSFLASH)	+= bcm47xxsflash.o
 obj-$(CONFIG_MTD_ST_SPI_FSM)    += st_spi_fsm.o
 obj-$(CONFIG_MTD_POWERNV_FLASH)	+= powernv_flash.o
-
+obj-$(CONFIG_MTD_AK_SPIFLASH) 	+= ak_spiflash.o
+obj-$(CONFIG_MTD_AK_SPINAND) 	+= ak_spi_nandflash.o
+obj-y				+= ak_partition_table.o
 
 CFLAGS_docg3.o			+= -I$(src)
diff --git a/drivers/mtd/devices/ak_partition_table.c b/drivers/mtd/devices/ak_partition_table.c
new file mode 100755
index 0000000..f15482e
--- /dev/null
+++ b/drivers/mtd/devices/ak_partition_table.c
@@ -0,0 +1,436 @@
+ /**
+ *  @file      /driver/mtd/devices/ak_SPIFlash.c
+ *  @brief     SPI Flash driver for Anyka AK37 platform.
+ *   Copyright C 2012 Anyka CO.,LTD
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *  @author    She Shaohua
+ *  @date      2012-03-23
+ *  @note      2011-03-20  created
+ *  @note      2011-03-23  Debug OK.
+ */
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/device.h>
+#include <linux/interrupt.h>
+#include <linux/mutex.h>
+#include <linux/math64.h>
+#include <linux/sched.h>
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/partitions.h>
+#include <linux/spi/spi.h>
+#include <linux/spi/flash.h>
+#include <linux/delay.h>
+#include <mach/anyka_types.h>
+
+#include <linux/spinlock.h>
+#include <linux/mm.h>
+#include "../partition/partition_init.h" 
+#include "../partition/partition_lib.h"
+
+static struct kobject *partition_table_kobj;
+spinlock_t	partition_lock;
+
+
+/**
+* @brief	  ak spi flash partition table sys kobject attr show
+* 
+* ak spi flash partition table sys kobject attr show
+* @author SheShaohua
+* @date 2012-03-20
+* @param[in] kobj: sys kobject	
+* @param[in] attr: kobject show
+* @param[in] buf: kobject attr parameter show
+* @return ssize_t 
+* @retval return string len on success
+* @retval return zero error code if failed
+*/
+static ssize_t partition_show(struct kobject *kobj, struct kobj_attribute *attr, char *buf)
+{
+	unsigned long len = 0;
+	unsigned long flags;
+	int ret = 0;
+	void *handle ;
+	T_EX_PARTITION_CONFIG ex_arrt_buf;
+	T_PARTITION_TABLE_INFO *phandle = NULL;
+	T_BIN_CONFIG ex_binarrt_lenbuf = {0};
+	T_FS_CONFIG ex_fsarrt_lenbuf   = {0};
+	
+	spin_lock_irqsave(&partition_lock, flags);
+	
+	/* search open the same name partition */
+	handle = partition_open((unsigned char *)kobj->name);
+	if (handle == NULL) {
+		spin_unlock_irqrestore(&partition_lock, flags);
+		printk(KERN_ERR "%s, open partition error!\n", __func__);
+		return -ENOENT;
+	}
+
+	/* force tansmit handle type for get file type */
+	phandle = (T_PARTITION_TABLE_INFO *)handle;
+	
+	/* search the partition ext 16B params */
+	ret = partition_get_attr(handle, &ex_arrt_buf);
+	if (ret) {
+		printk(KERN_ERR "%s, open partition error!\n", __func__);
+		goto show_exit;
+	}
+	
+	/* transfer the ext struct format */
+	if (phandle->partition_info.type == PART_FS_TYPE) {
+		memcpy(&ex_fsarrt_lenbuf, &ex_arrt_buf, sizeof(T_EX_PARTITION_CONFIG));
+	}else {
+		memcpy(&ex_binarrt_lenbuf, &ex_arrt_buf, sizeof(T_EX_PARTITION_CONFIG));
+	}
+
+	/* first step: show partition infor transfer file_length data to char string */
+	if (strcmp(attr->attr.name, "type") == 0){
+		len = sprintf(buf, "%x:", phandle->partition_info.type);
+	}
+
+	if (strcmp(attr->attr.name, "r_w_flag") == 0){
+		len = sprintf(buf, "%x:", phandle->partition_info.r_w_flag);
+	}
+
+	if (strcmp(attr->attr.name, "hidden_flag") == 0){
+		len = sprintf(buf, "%x:", phandle->partition_info.hidden_flag);
+	}
+
+	if (strcmp(attr->attr.name, "name") == 0){
+		len = sprintf(buf, "%s:", phandle->partition_info.name);
+	}
+
+	if (strcmp(attr->attr.name, "ksize") == 0){
+		len = sprintf(buf, "%lx:", phandle->partition_info.ksize);
+	}
+
+	if (strcmp(attr->attr.name, "start_pos") == 0){
+		len = sprintf(buf, "%lx:", phandle->partition_info.start_pos);
+	}
+
+	/* second step: show ext partition infor transfer file_length data to char string */
+	if (strcmp(attr->attr.name, "file_length") == 0){
+		if (phandle->partition_info.type == PART_FS_TYPE) {
+			len = sprintf(buf, "%lx:", ex_fsarrt_lenbuf.file_length);
+		}else {
+			len = sprintf(buf, "%lx:", ex_binarrt_lenbuf.file_length);
+		}
+	}
+
+	if (strcmp(attr->attr.name, "ld_addr") == 0){
+		if (phandle->partition_info.type != PART_FS_TYPE) {
+			len = sprintf(buf, "%lx:", ex_binarrt_lenbuf.ld_addr);
+		}
+	}
+	
+	if (strcmp(attr->attr.name, "mtd_index") == 0) {
+		if (phandle->partition_info.type == PART_FS_TYPE) {
+			len = sprintf(buf, "%x:", ex_fsarrt_lenbuf.mtd_idex);
+		}else {
+			len = sprintf(buf, "%x:", ex_binarrt_lenbuf.mtd_idex);
+		}
+	}
+
+show_exit:
+	/* search open the same name partition */
+	ret = partition_close(handle);
+	if (ret) {
+		spin_unlock_irqrestore(&partition_lock, flags);
+		printk(KERN_ERR "%s, close partition error!\n", __func__);
+		return -ENOENT;
+	}
+
+	spin_unlock_irqrestore(&partition_lock, flags);
+	
+	
+	return len;
+}
+
+/**
+* @brief	 ak spi flash partition table sys kobject attr store
+* 
+* ak spi flash partition table sys kobject attr store
+* @author SheShaohua
+* @date 2012-03-20
+* @param[in] kobj: sys kobject	
+* @param[in] attr: kobject store
+* @param[in] buf: kobject attr parameter store
+* @param[in] count: attr parameter store cnt
+* @return ssize_t 
+* @retval return parameter store cnt on success
+* @retval return zero error code if failed
+*/
+static ssize_t partition_store(struct kobject *kobj, struct kobj_attribute *attr, const char *buf, size_t count)
+{
+	unsigned long file_len =0;
+	unsigned long flags;
+	int ret = 0;
+	void * handle ;
+	T_EX_PARTITION_CONFIG ex_arrt_buf;
+	T_PARTITION_TABLE_INFO *phandle = NULL;
+	T_BIN_CONFIG ex_binarrt_lenbuf;
+	T_FS_CONFIG ex_fsarrt_lenbuf;
+	
+	sscanf(buf, "%lx", &file_len);
+
+	spin_lock_irqsave(&partition_lock, flags);
+	
+	/* search the same name partition */
+	handle = partition_open((unsigned char *)kobj->name);
+	if (handle == NULL) {
+		spin_unlock_irqrestore(&partition_lock, flags);
+		printk(KERN_ERR "%s, open partition error!\n", __func__);
+		return -ENOENT;
+	}
+
+	phandle = (T_PARTITION_TABLE_INFO *)handle;
+	
+	/* search the partition ext 16B params */
+	ret = partition_get_attr(handle, &ex_arrt_buf);
+	if (ret) {
+		printk(KERN_ERR "%s, get attr error!\n", __func__);
+		goto store_exit;
+	}
+
+	/* transfer the ext struct format */
+	if (phandle->partition_info.type == PART_FS_TYPE) {
+		memcpy(&ex_fsarrt_lenbuf, &ex_arrt_buf, sizeof(T_EX_PARTITION_CONFIG));
+	}else {
+		memcpy(&ex_binarrt_lenbuf, &ex_arrt_buf, sizeof(T_EX_PARTITION_CONFIG));
+	}
+
+	/* transfer file_length data to char string */
+	if (strcmp(attr->attr.name, "file_length") == 0){
+		printk("cdh:%s, store attr.name:%s!\n", __func__, attr->attr.name);
+		if (phandle->partition_info.type == PART_FS_TYPE) {
+			ex_fsarrt_lenbuf.file_length = file_len;
+			memcpy(&ex_arrt_buf, &ex_fsarrt_lenbuf, sizeof(T_EX_PARTITION_CONFIG));
+		}else {
+			ex_binarrt_lenbuf.file_length = file_len;
+			memcpy(&ex_arrt_buf, &ex_binarrt_lenbuf, sizeof(T_EX_PARTITION_CONFIG));
+		}
+	}
+
+
+	/* search the partition ext 16B params */
+	ret = partition_set_attr(handle, &ex_arrt_buf);
+	if (ret) {
+		printk(KERN_ERR "%s, set attr error!\n", __func__);
+		goto store_exit;
+	}
+
+store_exit:
+	/* search open the same name partition */
+	ret = partition_close(handle);
+	if (ret) {
+		spin_unlock_irqrestore(&partition_lock, flags);
+		printk(KERN_ERR "%s, close partition error!\n", __func__);
+		return -ENOENT;
+	}
+
+	spin_unlock_irqrestore(&partition_lock, flags);
+	
+	return count;
+}
+
+
+static struct kobj_attribute type_attribute = 
+	__ATTR(type, 0664, partition_show, NULL);
+
+static struct kobj_attribute r_w_flag_attribute = 
+	__ATTR(r_w_flag, 0664, partition_show, NULL);
+
+static struct kobj_attribute hidden_flag_attribute = 
+	__ATTR(hidden_flag, 0664, partition_show, NULL);
+
+static struct kobj_attribute name_attribute = 
+	__ATTR(name, 0664, partition_show, NULL);
+
+static struct kobj_attribute ksize_attribute = 
+	__ATTR(ksize, 0664, partition_show, NULL);
+
+static struct kobj_attribute start_pos_attribute = 
+	__ATTR(start_pos, 0664, partition_show, NULL);
+
+static struct kobj_attribute file_length_attribute = 
+	__ATTR(file_length, 0664, partition_show, partition_store);
+
+static struct kobj_attribute ld_addr_attribute = 
+	__ATTR(ld_addr, 0664, partition_show, NULL);
+
+static struct kobj_attribute mtd_index_attribute = 
+	__ATTR(mtd_index, 0664, partition_show, NULL);
+
+
+static struct attribute *partition_attribute[] = {
+	&type_attribute.attr,
+	&r_w_flag_attribute.attr,
+	&hidden_flag_attribute.attr,
+	&name_attribute.attr,
+	&ksize_attribute.attr,
+	&start_pos_attribute.attr,
+	NULL
+};
+
+static struct attribute *binfile_attribute[] = {
+	&file_length_attribute.attr,
+	&ld_addr_attribute.attr,
+	&mtd_index_attribute.attr,
+	NULL
+};
+
+static struct attribute *filefs_attribute[] = {
+	&file_length_attribute.attr,
+	&mtd_index_attribute.attr,
+	NULL
+};
+
+static struct attribute_group partition_attr_group = {
+	.attrs = partition_attribute,
+};
+
+static struct attribute_group binfile_attr_group = {
+	.attrs = binfile_attribute,
+};
+
+static struct attribute_group filefs_attr_group = {
+	.attrs = filefs_attribute,
+};
+
+
+/**
+* @brief	  ak spi flash partition table sys kobject create
+* 
+* create ak spi flash partition table sys kobject for supply interface to app aplication
+* @author SheShaohua
+* @date 2012-03-20
+* @param[in] part_tab: partition tab buffer pointer	   
+* @return int return write success or failed
+* @retval returns zero on success
+* @retval return a non-zero error code if failed
+*/
+int ak_partition_table_sys_create(T_PARTITION_TABLE_CONFIG *part_tab)
+{
+	int i;
+	int ret = 0;
+	int error;
+	unsigned long nr_parts;
+	T_PARTITION_TABLE_INFO *parts = NULL;
+	struct kobject *tmp_kobj;
+	unsigned char part_name[PARTITION_NAME_LEN + 1];
+	
+	nr_parts = *(unsigned long *)part_tab->table;
+	
+	/* 
+	* if no partiton to mount, the buf will be all 0xFF but not constant.
+	*  So, it is not safe here. 
+	*/
+	// printk("nr_parts=0x%lx\n", nr_parts);
+	if (nr_parts <= 0 || nr_parts > 15) {
+		printk(KERN_ERR "partition count invalid\n");
+		ret = -EINVAL;
+		goto err_out1;
+	}
+
+	parts = (T_PARTITION_TABLE_INFO *)(&part_tab->table[sizeof(unsigned long)]);
+	for (i=0; i<nr_parts; i++) {
+		 memset(part_name, 0, 7);
+		 strncpy(part_name, parts[i].partition_info.name, 6);
+		 //printk("mtd_part[%d]:\nname = %s\n", i, part_name);
+		 
+		/* create sysfs partition table */
+		tmp_kobj = kobject_create_and_add(part_name, partition_table_kobj);
+		if (!tmp_kobj) {
+			ret = -EINVAL;
+			printk(KERN_ERR "Create %s kobject error!\n", part_name);
+			goto err_out1;
+		}else {
+			/* create sysfs partition table */
+			error = sysfs_create_group(tmp_kobj, &partition_attr_group);
+			if (error) {
+				ret = -EINVAL;
+				printk(KERN_ERR "Create %s kobject attr group error!\n", part_name);
+				goto err_out2;
+			}
+
+			/* create sysfs partition table */
+			if ((parts[i].partition_info.type == PART_DATA_TYPE) || (parts[i].partition_info.type == PART_BIN_TYPE)) {
+				error = sysfs_create_group(tmp_kobj, &binfile_attr_group);
+				if (error) {
+					ret = -EINVAL;
+					printk(KERN_ERR "Create %s kobject binfile attr group error!\n", parts[i].partition_info.name);
+					goto err_out2;
+				}
+			}else {
+				error = sysfs_create_group(tmp_kobj, &filefs_attr_group);
+				if (error) {
+					ret = -EINVAL;
+					printk(KERN_ERR "Create %s kobject filefs attr group error!\n", part_name);
+					goto err_out2;
+				}
+			}	
+		}
+		
+	}
+
+err_out1:
+	return ret;
+
+err_out2:
+	kobject_put(partition_table_kobj);
+	return ret;
+}
+
+EXPORT_SYMBOL(ak_partition_table_sys_create);
+
+
+/**
+* @brief	  ak spi flash partition table module init
+* 
+* ak spi flash partition table module init
+* @author SheShaohua
+* @date 2012-03-20
+* @param[in] void	   
+* @return int return write success or failed
+* @retval returns zero on success
+* @retval return a non-zero error code if failed
+*/
+static int __init ak_partition_table_init(void)
+{
+    printk("Start to init Anyka partition table...\n");
+
+	spin_lock_init(&partition_lock);
+    partition_table_kobj = kobject_create_and_add("partition_table", kernel_kobj);
+	if (!partition_table_kobj) {
+		printk("Create partition table kobject failed\n");
+		return -ENOMEM;
+	}
+	
+	return 0;
+}
+
+
+/**
+* @brief	  ak spi flash partition table module exit
+* 
+* ak spi flash partition table module exit
+* @author SheShaohua
+* @date 2012-03-20
+* @param[in] void	   
+* @return void
+* @retval none
+*/
+static void __exit ak_partition_table_exit(void)
+{
+	kobject_put(partition_table_kobj);
+}
+
+
+module_init(ak_partition_table_init);
+module_exit(ak_partition_table_exit);
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Cao Donghua");
+MODULE_DESCRIPTION("MTD Partition Table for Anyka spiflash chips");
diff --git a/drivers/mtd/devices/ak_partition_table.h b/drivers/mtd/devices/ak_partition_table.h
new file mode 100755
index 0000000..94d1ea3
--- /dev/null
+++ b/drivers/mtd/devices/ak_partition_table.h
@@ -0,0 +1,43 @@
+#ifndef        _AK_PARTITION_TABLE_H_
+#define        _AK_PARTITION_TABLE_H_
+
+#include "../partition/partition_lib.h"
+
+
+#define KERNEL_PARTITION_IDEX  				0
+#define A_PARTITION_IDEX  				    1
+#define B_PARTITION_IDEX  				    2
+
+
+
+
+
+#define PARTITION_CNT  				3
+
+typedef struct
+{
+    unsigned char partition_name[6];
+}T_PARTITION_NAME_INFO;
+
+typedef struct
+{
+    unsigned long partition_cnt;
+    T_PARTITION_NAME_INFO partition_name_info[PARTITION_CNT];
+}T_PARTITION_INFO;
+
+
+
+/*****************************************************************
+ *@brief:ak_partition_table_sys_create
+ *@author:cao_donghua
+ *@date:2017-02-22
+ *@param *part_tab:partition table sdram  first address
+ *@return:int
+ *@retval:0:success/ other value:fail
+ ******************************************************************/
+
+int ak_partition_table_sys_create(T_PARTITION_TABLE_CONFIG *part_tab);
+
+#endif      //_AK_PARTITION_TABLE_H_
+
+
diff --git a/drivers/mtd/devices/ak_spi_nandflash.c b/drivers/mtd/devices/ak_spi_nandflash.c
new file mode 100755
index 0000000..cc68052
--- /dev/null
+++ b/drivers/mtd/devices/ak_spi_nandflash.c
@@ -0,0 +1,3277 @@
+ /**
+ *  @file      /driver/mtd/devices/ak_spi_nand.c
+ *  @brief     SPI Flash driver for Anyka AK39e platform.
+ *  Copyright C 2016 Anyka CO.,LTD
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *  @author    luoyongchuang 
+ *  @date      2016-05-17
+ */
+
+
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/device.h>
+#include <linux/interrupt.h>
+#include <linux/mutex.h>
+#include <linux/math64.h>
+#include <linux/sched.h>
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/partitions.h>
+
+#include <linux/spi/spi.h>
+#include <linux/spi/flash.h>
+#include <linux/delay.h>
+//nclude <mach-anyka/fha.h>
+//nclude <mach-anyka/fha_asa.h>
+#include "../partition/nand_list.h"
+#include "../partition/partition_init.h"
+#include "../partition/partition_lib.h"
+#include "ak_partition_table.h"
+#include "../partition/spinand_badblock.h" 
+//#include <mach-ak37d/include/mach/anyka_types.h>
+#include <linux/mm.h>
+
+#include <mach/map.h>
+#include <linux/of_device.h>
+#include <linux/of_irq.h>
+
+
+//#define SPINAND_DEBUG  
+      
+#ifdef SPINAND_DEBUG
+#define PDEBUG(fmt, args...) printk( KERN_ALERT fmt,## args)
+#define DEBUG(n, args...) printk(KERN_ALERT args)
+#else
+#define PDEBUG(fmt, args...)
+#define DEBUG(n, args...) 
+#endif
+
+
+
+#define FHA_SUCCESS  				0
+#define FHA_FAIL     				-1
+
+
+
+#define FEATURE_ECC_EN  (1<<4)  //(1<<5)
+
+
+
+//#define FLASH_BUF_SIZE			(32*1024)
+#define FLASH_BUF_SIZE			(flash->info.page_size)
+
+#define SPI_FLASH_READ		1
+#define SPI_FLASH_WRITE		2
+#define BAD_BLOCK_MARK_OFFSET 4
+//#define CONFIG_SPINAND_USE_FAST_READ 1
+
+/*mtd layer allocate memory use for 'vmalloc' interface, need to convert.*/
+//#define SPINAND_USE_MTD_BLOCK_LAYER  
+
+
+#define OPCODE_RESET						0xff   
+#define OPCODE_WREN							0x06    /* Write Enable */ 
+#define OPCODE_WRDI							0x04    /* Write Disable */ 
+
+#define OPCODE_RDSR1    				0x0f    /* Read Status Register1 */
+#define OPCODE_RDSR2     				0x35    /* Read Status Register2 */ 
+#define OPCODE_RDSR3     				0x15    /* Read Status Register3 */ 
+#define OPCODE_WRSR1          	0x1f    /* Write Status Register */ 
+#define OPCODE_WRSR2          	0x31    /* Write Status2 Register*/ 
+#define OPCODE_WRSR3          	0x11    /* Write Status3 Register*/ 
+
+#define OPCODE_READ_TO_CACHE  	0x13
+#define OPCODE_NORM_READ     		0x03    /* Read Data Bytes */ 
+#define OPCODE_FAST_READ      	0x0b    /* Read Data Bytes at Higher Speed */ 
+#define OPCODE_FAST_D_READ     	0x3b    /* Read Data Bytes at Dual output */ 
+#define OPCODE_FAST_Q_READ     	0x6b    /* Read Data Bytes at Quad output */ 
+#define OPCODE_FAST_D_IO     		0xbb    /* Read Data Bytes at Dual i/o */ 
+#define OPCODE_FAST_Q_IO     		0xeb    /* Read Data Bytes at Quad i/o */ 
+
+#define OPCODE_PP            		0x02    /* Page Program */
+#define OPCODE_PP_DUAL					0x12		/* Dual Page Program*/
+#define OPCODE_PP_QUAD					0x32		/* Quad Page Program*/
+#define OPCODE_2IO_PP						0x18		/* 2I/O Page Program (tmp)*/
+#define OPCODE_4IO_PP						0x38		/* 4I/O Page Program*/
+#define OPCODE_PP_EXEC 					0x10
+
+#define OPCODE_BE_4K						0x20    /* Sector (4K) Erase */ 
+#define OPCODE_BE_32K       		0x52    /* Block (32K) Erase */
+#define OPCODE_BE_64K          	0xd8    /* Block (64K) Erase */ 
+#define	OPCODE_SE								0xd8		/* Sector erase (usually 64KiB) */
+#define OPCODE_ERASE_BLOCK 			0xd8    /* block Erase */ 
+#define	OPCODE_RDID							0x9f		/* Read JEDEC ID */
+#define OPCODE_DP         	  	0xb9    /* Deep Power-down */ 
+#define OPCODE_RES         		 	0xab    /* Release from DP, and Read Signature */ 
+
+
+#define SPI_STATUS_REG1	1
+#define SPI_STATUS_REG2	2
+
+
+/* Define max times to check status register before we give up. */
+#define	MAX_READY_WAIT_JIFFIES	(40 * HZ)	/* 40s max chip erase */
+
+#define	CMD_SIZE		(1)
+#define ADDR_SIZE		(2)
+#define CMD_ADDR_SIZE	(CMD_SIZE + ADDR_SIZE)
+#define MAX_DUMMY_SIZE	(4)
+
+#define MTD_PART_NAME_LEN (4)
+
+#ifdef CONFIG_SPINAND_USE_FAST_READ
+#define OPCODE_READ 	OPCODE_FAST_READ
+#define FAST_READ_DUMMY_BYTE 1
+#else
+#define OPCODE_READ 	OPCODE_NORM_READ
+#define FAST_READ_DUMMY_BYTE 0
+#endif
+
+#define SPINAND_OOB_LEN(info) 	\
+	((info.oob_up_skiplen + info.oob_seglen + info.oob_down_skiplen)*info.oob_seg_perpage)
+
+#define ALIGN_DOWN(a, b)  (((a) / (b)) * (b))
+
+#define SPINAND_BIN_PAGE_START 	(62)
+/****************************************************************************/
+struct partitions
+{
+	char name[MTD_PART_NAME_LEN]; 		   
+	unsigned long long size;
+	unsigned long long offset;         
+	unsigned int mask_flags;
+}__attribute__((packed));
+
+typedef struct
+{
+    u32 BinPageStart; /*bin data start addr*/
+    u32 PageSize;     /*spi page size*/
+    u32 PagesPerBlock;/*page per block*/
+    u32 BinInfoStart;
+    u32 FSPartStart;
+}
+T_SPI_BURN_INIT_INFO;
+
+
+T_PARTITION_INFO g_partition_info = {0};
+T_PARTITION_TABLE_CONFIG g_part_tab;
+
+//extern char saved_root_name[64];
+
+#define	SFLAG_UNDER_PROTECT			(1<<0)
+#define SFLAG_FAST_READ           	(1<<1)
+#define SFLAG_AAAI                	(1<<2)
+#define SFLAG_COM_STATUS2         	(1<<3)
+
+#define SFLAG_DUAL_IO_READ         	(1<<4)
+#define SFLAG_DUAL_READ           	(1<<5)
+#define SFLAG_QUAD_IO_READ         	(1<<6)
+#define SFLAG_QUAD_READ           	(1<<7)
+
+#define SFLAG_DUAL_IO_WRITE        	(1<<8)
+#define SFLAG_DUAL_WRITE          	(1<<9)
+#define SFLAG_QUAD_IO_WRITE        	(1<<10)
+#define SFLAG_QUAD_WRITE          	(1<<11)
+
+#define SFLAG_SECT_4K       		(1<<12)
+
+
+
+/*
+ * SPI device driver setup and teardown
+ */
+struct flash_info {
+	const char		*name;
+
+	/* JEDEC id zero means "no ID" (most older chips); otherwise it has
+	 * a high byte of zero plus three data bytes: the manufacturer id,
+	 * then a two byte device id.
+	 */
+	u32			jedec_id;
+	u16			ext_id;
+
+	u32 		page_size;
+	u32 		page_per_block;
+
+	/* The size listed here is what works with OPCODE_SE, which isn't
+	 * necessarily called a "sector" by the vendor.
+	 */
+	unsigned	block_size;
+	u16			n_blocks;
+
+	/*|--------------------64bytes------------------------------|*/
+	/*|---12---|-4--|---12----|-4--|---12---|-4--|---12----|-4--|*/
+	/*|-seglen-|skip|-segllen-|skip|-seglen-|skip|-segllen-|skip|*/
+	u32 		oob_size;        
+	u16 		oob_up_skiplen;
+	u16 		oob_seglen;
+	u16 		oob_down_skiplen;	
+	u16 		oob_seg_perpage;
+	u16			oob_vail_data_offset;
+
+	/**
+	 *  chip character bits:
+	 *  bit 0: under_protect flag, the serial flash under protection or not when power on
+	 *  bit 1: fast read flag, the serial flash support fast read or not(command 0Bh)
+	 *  bit 2: AAI flag, the serial flash support auto address increment word programming
+	 *  bit 3: support dual write or no
+	 *  bit 4: support dual read or no
+	 *  bit 5: support quad write or no
+	 *  bit 6: support quad read or no
+	 *  bit 7: the second status command (35h) flag,if use 4-wire(quad) mode,the bit must be is enable
+	 */
+	u16			flags;
+
+	struct device_node *child;
+};
+
+/**
+  *because of some spi nand is difference of status register difinition.
+  *this structure use mapping the status reg function and corresponding.
+*/
+struct flash_status_reg
+{
+	u32		jedec_id;	
+	u16		ext_id;
+	unsigned b_wip:4;		/*write in progress*/
+	unsigned b_wel:4;		/*wrute ebabke latch*/
+	unsigned b_bp0:4;		/*block protected 0*/
+	unsigned b_bp1:4;		/*block protected 1*/
+	unsigned b_bp2:4;		/*block protected 2*/
+	unsigned b_bp3:4;		/*block protected 3*/
+	unsigned b_bp4:4;		/*block protected 4*/
+	unsigned b_srp0:4;		/*status register protect 0*/
+	
+	unsigned b_srp1:4;		/*status register protect 1*/
+	unsigned b_qe:4;		/*quad enable*/
+	unsigned b_lb:4;		/*write protect control and status to the security reg.*/
+/*
+	unsigned b_reserved0:4;
+	unsigned b_reserved1:4;
+	unsigned b_reserved2:4;
+*/
+	unsigned b_cmp:4;		/*conjunction bp0-bp4 bit*/
+	unsigned b_sus:4;		/*exec an erase/program suspend cmd_buf*/
+	unsigned b_efail:4;		/**/
+	unsigned b_pfail:4;		/**/
+};
+
+struct ak_spinand {
+	struct spi_device	*spi;
+	struct mutex		lock;
+	struct flash_info	info;
+	struct mtd_info		mtd;
+	unsigned			partitioned:1;
+	
+	u8		bus_width;
+	unsigned char 		*buf;
+	u8		cmd_buf[CMD_ADDR_SIZE + MAX_DUMMY_SIZE];
+	u8		dummy_len;
+
+	u8		erase_opcode;
+	u8		tx_opcode;
+	u8		rx_opcode;
+	u8		txd_bus_width;
+	u8		rxd_bus_width;
+	
+	u8		txa_bus_width;
+	u8		rxa_bus_width;	
+	u32 	page_shift;
+	struct flash_status_reg stat_reg;
+};
+
+static struct mtd_info *ak_mtd_info;
+
+
+//extern char saved_root_name[64];
+
+/*
+ * feature cmd list ,reference by spec.
+ * */
+static int feature_cmd[3] = {0xC0, 0xB0, 0xA0};
+
+static inline struct ak_spinand *mtd_to_spiflash(struct mtd_info *mtd)
+{
+	return container_of(mtd, struct ak_spinand, mtd);
+}
+
+#if 0
+static 	struct flash_status_reg  status_reg_list[] = {
+		/*normal status reg define*/
+		{
+			.jedec_id = 0xc8f4c8f4,	.ext_id = 0,
+			.b_wip = 0,	.b_wel = 1,	.b_efail= 2,	.b_pfail= 3,
+			.b_bp2 = 4,	.b_bp3 = 5,	.b_bp4 = 6,	.b_srp0 = 7,
+
+			.b_qe = 8,	.b_srp1 = 9,.b_lb = 10,	.b_cmp = 14,
+			.b_sus = 15,
+		},
+		/*normal status reg define*/
+		{
+			.jedec_id = 0xc8f2c8f2,	.ext_id = 0,
+			.b_wip = 0,	.b_wel = 1,	.b_efail= 2,	.b_pfail= 3,
+			.b_bp2 = 4,	.b_bp3 = 5,	.b_bp4 = 6,	.b_srp0 = 7,
+
+			.b_qe = 8,	.b_srp1 = 9,.b_lb = 10,	.b_cmp = 14,
+			.b_sus = 15,
+		},
+		/*normal status reg define*/
+		{
+			.jedec_id = 0xc8f1c8f1,	.ext_id = 0,
+			.b_wip = 0,	.b_wel = 1,	.b_efail= 2,	.b_pfail= 3,
+			.b_bp2 = 4,	.b_bp3 = 5,	.b_bp4 = 6,	.b_srp0 = 7,
+
+			.b_qe = 8,	.b_srp1 = 9,.b_lb = 10,	.b_cmp = 14,
+			.b_sus = 15,
+		},
+		/*normal status reg define*/
+		{
+			.jedec_id = 0xc8d1c8d1,	.ext_id = 0,
+			.b_wip = 0,	.b_wel = 1,	.b_efail= 2,	.b_pfail= 3,
+			.b_bp2 = 4,	.b_bp3 = 5,	.b_bp4 = 6,	.b_srp0 = 7,
+
+			.b_qe = 8,	.b_srp1 = 9,.b_lb = 10,	.b_cmp = 14,
+			.b_sus = 15,
+		},	
+		/*normal status reg define*/
+		{
+			.jedec_id = 0xc8d2c8d2,	.ext_id = 0,
+			.b_wip = 0,	.b_wel = 1,	.b_efail= 2,	.b_pfail= 3,
+			.b_bp2 = 4,	.b_bp3 = 5,	.b_bp4 = 6,	.b_srp0 = 7,
+
+			.b_qe = 8,	.b_srp1 = 9,.b_lb = 10,	.b_cmp = 14,
+			.b_sus = 15,
+		},				
+		/*normal status reg define*/
+		{
+			.jedec_id = 0xb148c8b1,	.ext_id = 0,
+			.b_wip = 0,	.b_wel = 1,	.b_efail= 2,	.b_pfail= 3,
+			.b_bp2 = 4,	.b_bp3 = 5,	.b_bp4 = 6,	.b_srp0 = 7,
+
+			.b_qe = 8,	.b_srp1 = 9,.b_lb = 10,	.b_cmp = 14,
+			.b_sus = 15,
+		},
+		/*normal status reg define*/
+		{
+			.jedec_id = 0xc8217f7f,	.ext_id = 0,
+			.b_wip = 0,	.b_wel = 1,	.b_efail= 2,	.b_pfail= 3,
+			.b_bp2 = 4,	.b_bp3 = 5,	.b_bp4 = 6,	.b_srp0 = 7,
+
+			.b_qe = 8,	.b_srp1 = 9,.b_lb = 10,	.b_cmp = 14,
+			.b_sus = 15,
+		},
+		/*normal status reg define*/
+		{
+			.jedec_id = 0xc831C831,	.ext_id = 0,
+			.b_wip = 0,	.b_wel = 1,	.b_efail= 2,	.b_pfail= 3,
+			.b_bp2 = 4,	.b_bp3 = 5,	.b_bp4 = 6,	.b_srp0 = 7,
+
+			.b_qe = 8,	.b_srp1 = 9,.b_lb = 10,	.b_cmp = 14,
+			.b_sus = 15,
+		},	
+		/*normal status reg define*/
+		{
+			.jedec_id = 0xa1e1a1e1,	.ext_id = 0,
+			.b_wip = 0,	.b_wel = 1,	.b_efail= 2,	.b_pfail= 3,
+			.b_bp2 = 4,	.b_bp3 = 5,	.b_bp4 = 6,	.b_srp0 = 7,
+
+			.b_qe = 8,	.b_srp1 = 9,.b_lb = 10,	.b_cmp = 14,
+			.b_sus = 15,
+		},
+		{
+			.jedec_id = 0xc212c212,	.ext_id = 0,
+			.b_wip = 0,	.b_wel = 1,	.b_efail= 2,	.b_pfail= 3,
+			.b_bp2 = 4,	.b_bp3 = 5,	.b_bp4 = 6,	.b_srp0 = 7,
+
+			.b_qe = 8,	.b_srp1 = 9,.b_lb = 10,	.b_cmp = 14,
+			.b_sus = 15,
+		},		
+		{
+			.jedec_id = 0xefaa2100,	.ext_id = 0,
+			.b_wip = 0,	.b_wel = 1,	.b_efail= 2,	.b_pfail= 3,
+			.b_bp2 = 4,	.b_bp3 = 5,	.b_bp4 = 6,	.b_srp0 = 7,
+
+			.b_qe = 8,	.b_srp1 = 9,.b_lb = 10,	.b_cmp = 14,
+			.b_sus = 15,
+		},	
+		/*normal status reg define*/
+		{
+			.jedec_id = 0,	.ext_id = 0,
+			.b_wip = 0,	.b_wel = 1,	.b_bp0 = 2,	.b_bp1 = 3,
+			.b_bp2 = 4,	.b_bp3 = 5,	.b_bp4 = 6,	.b_srp0 = 7,
+			
+			.b_srp1 = 8,.b_qe = 9,	.b_lb = 10,	.b_cmp = 14,
+			.b_sus = 15,
+		},
+};
+
+
+/* NOTE: double check command sets and memory organization when you add
+ * more flash chips.  This current list focusses on newer chips, which
+ * have been converging on command sets which including JEDEC ID.
+ */
+static struct flash_info ak_spinand_supportlist [] = {
+  { "GD5G1GQ4U", 0xc8f1c8f1, 0, 2048, 64, 128*1024, 1024, 64, 0, 12, 4, 4, 4, SFLAG_DUAL_READ|SFLAG_QUAD_READ|SFLAG_QUAD_WRITE,},
+  { "GD5F1GQ4UB", 0xc8d1c8d1, 0, 2048, 64, 128*1024, 1024, 64, 0, 12, 4, 4, 4, SFLAG_DUAL_READ|SFLAG_QUAD_READ|SFLAG_QUAD_WRITE,},  
+  { "GD5G2GQ4U", 0xc8f2c8f2, 0, 2048, 64, 128*1024, 2048, 64, 0, 12, 4, 4, 4, SFLAG_DUAL_READ|SFLAG_QUAD_READ|SFLAG_QUAD_WRITE,},
+  { "GD5F2GQ4UB", 0xc8d2c8d2, 0, 2048, 64, 128*1024, 2048, 64, 0, 12, 4, 4, 4, SFLAG_DUAL_READ|SFLAG_QUAD_READ|SFLAG_QUAD_WRITE,},
+  { "GD5G4GQ4U", 0xc8f4c8f4, 0, 2048, 64, 128*1024, 4096, 64, 0, 12, 4, 4, 4, SFLAG_DUAL_READ|SFLAG_QUAD_READ|SFLAG_QUAD_WRITE,},	
+  { "PSU1GQ4U", 0xc8217f7f, 0, 2048, 64, 128*1024, 1024, 64, 8, 8, 0, 4, 8, SFLAG_DUAL_READ|SFLAG_QUAD_READ|SFLAG_QUAD_WRITE,},
+  { "AFS1GQ4UAAWC2", 0xc831C831, 0, 2048, 128, 256*1024, 512, 64, 0, 6, 10, 4, 4, SFLAG_DUAL_READ|SFLAG_QUAD_READ|SFLAG_QUAD_WRITE,},	
+  { "PN26G01AWSIUG", 0xa1e1a1e1, 0, 2048, 64, 128*1024, 1024, 64, 0, 8, 0, 4, 6, SFLAG_DUAL_READ|SFLAG_QUAD_READ|SFLAG_QUAD_WRITE,},
+  {"MX35LF1GE4AB", 0xc212c212, 0, 2048, 64, 128*1024, 1024, 64, 0, 16, 0, 4, 4, SFLAG_DUAL_READ|SFLAG_QUAD_READ|SFLAG_QUAD_WRITE,},
+  { "W25N01GV", 0xefaa2100, 0, 2048, 64, 128*1024, 1024, 64, 0, 4, 12, 4, 4, SFLAG_DUAL_READ|SFLAG_QUAD_READ|SFLAG_QUAD_WRITE,},
+};
+#endif
+
+#ifdef SPINAND_USE_MTD_BLOCK_LAYER
+/**
+* @brief: because of the _read() function call by mtd block layer, the buffer be
+* allocate by vmalloc() in mtd layer, spi driver layer may use this buffer that 
+* intents of use for DMA transfer, so, add this function to transition buffer.
+* call this function at before real read/write data.
+* 
+* @author lixinhai
+* @date 2013-04-10
+* @param[in] flash  spiflash handle.
+* @param[in] buffer.
+* @param[in] buffer len
+* @param[in] read/write
+* @retval return the transition buffer
+*/
+static void *flash_buf_bounce_pre(struct ak_spinand *flash,
+				void *buf, u32 len, int dir)
+{
+	if(!is_vmalloc_addr(buf)) {
+		return buf;
+	}
+
+	if(dir == SPI_FLASH_WRITE) {
+		memcpy(flash->buf, buf, len);
+	}
+	return flash->buf;
+}
+
+/**
+* @brief: because of the _read() function call by mtd block layer, the buffer be
+* allocate by vmalloc() in mtd layer, spi driver layer may use this buffer that 
+* intents of use for DMA transfer, so, add this function to transition buffer.
+* call this function at after real read/write data
+* 
+* @author lixinhai
+* @date 2013-04-10
+* @param[in] flash  spiflash handle.
+* @param[in] buffer.
+* @param[in] buffer len
+* @param[in] read/write
+* @retval return the transition buffer
+*/
+static void flash_buf_bounce_post(struct ak_spinand *flash,
+				void *buf, u32 len, int dir)
+{
+	if(!is_vmalloc_addr(buf)) {
+		return;
+	}
+
+	if(dir == SPI_FLASH_READ) {
+		memcpy(buf, flash->buf, len);
+	}
+}
+#else
+static inline void *flash_buf_bounce_pre(struct ak_spinand *flash,
+				void *buf, u32 len, int dir)
+{
+	return buf;
+}
+
+static inline void flash_buf_bounce_post(struct ak_spinand *flash,
+				void *buf, u32 len, int dir)
+{
+}
+#endif
+
+
+
+
+/*
+ * Internal helper functions
+ */
+
+/**
+* @brief Read the status register.
+* 
+*  returning its value in the location
+* @author lixinhai
+* @date 2014-03-20
+* @param[in] spiflash handle.
+* @return int Return the status register value.
+*/
+static int read_sr(struct ak_spinand *flash, u32 addr)
+{
+
+	u8 			st_tmp= 0;
+	int			status;
+	struct spi_message	message;
+	struct spi_transfer	x[2];
+
+	spi_message_init(&message);
+	memset(x, 0, sizeof x);
+	
+	flash->cmd_buf[0]= OPCODE_RDSR1;
+	flash->cmd_buf[1]= addr;	
+	
+	x[0].tx_buf = flash->cmd_buf;
+	x[0].len = 2;
+	spi_message_add_tail(&x[0], &message);
+
+
+	x[1].rx_buf = flash->cmd_buf + 2;
+	x[1].len = 1;
+	spi_message_add_tail(&x[1], &message);
+
+	/* do the i/o */
+	status = spi_sync(flash->spi, &message);
+	if (status == 0)
+		memcpy(&st_tmp, x[1].rx_buf, 1);
+
+	return st_tmp;	
+	
+	/*
+	ssize_t retval;
+	u32 status;
+	u8 st_tmp= 0;
+//printk("%s\n",__func__);
+	flash->cmd_buf[0]= OPCODE_RDSR1;
+	flash->cmd_buf[1]= addr;
+
+	if((retval = spi_write_then_read(flash->spi, flash->cmd_buf, 2, &st_tmp, 1))<0)
+		return retval;
+
+	status = st_tmp;
+	return status;
+	*/
+}
+
+
+/**
+* @brief Write status register
+* 
+*  Write status register 1 byte.
+* @author lixinhai
+* @date 2014-03-20
+* @param[in] flash  spiflash handle.
+* @param[in] val  register value to be write.
+* @return int return write success or failed
+* @retval returns zero on success
+* @retval return a negative error code if failed
+*/
+static int write_sr(struct ak_spinand *flash, u32 addr, u16 val)
+{
+	struct spi_transfer t[1];
+	struct spi_message m;
+	spi_message_init(&m);
+	memset(t, 0, (sizeof t));
+		
+	flash->cmd_buf[0] = OPCODE_WRSR1;
+	flash->cmd_buf[1] = addr;
+	flash->cmd_buf[2] = val;
+	
+	t[0].tx_buf = flash->cmd_buf;
+	t[0].len = 3;	
+	spi_message_add_tail(&t[0], &m);
+	
+	return spi_sync(flash->spi, &m);
+}
+
+static inline int sflash_reset(struct ak_spinand *flash)
+{
+	u8	code = OPCODE_RESET;
+	int ret;
+
+	ret = spi_write_then_read(flash->spi, &code, 1, NULL, 0);
+	ret |= write_sr(flash, 0xa0, 0x0);
+	return ret;
+}
+
+/**
+* @brief Set write enable latch.
+* 
+*  Set write enable latch with Write Enable command.
+* @author lixinhai
+* @date 2014-03-20
+* @param[in] flash  spiflash handle.
+* @return int return write success or failed
+* @retval returns zero on success
+* @retval return a negative error code if failed
+*/
+static inline int write_enable(struct ak_spinand *flash)
+{
+	
+//	u8 			st_tmp= 0;
+	int			status;
+	struct spi_message	message;
+	struct spi_transfer	x[2];
+
+	spi_message_init(&message);
+	memset(x, 0, sizeof x);
+	
+	flash->cmd_buf[0]= OPCODE_WREN;
+
+	
+	x[0].tx_buf = flash->cmd_buf;
+	x[0].len = 1;
+	spi_message_add_tail(&x[0], &message);
+
+	/* do the i/o */
+	status = spi_sync(flash->spi, &message);
+
+
+	return status;		
+
+/*	
+	u8	code = OPCODE_WREN;
+	
+//printk("%s\n",__func__);
+	return spi_write_then_read(flash->spi, &code, 1, NULL, 0);
+*/
+}
+
+
+/**
+* @brief Set write disble
+* 
+*  Set write disble instruction to the chip.
+* @author lixinhai
+* @date 2014-03-20
+* @param[in] flash	spiflash handle.
+* @return int return write success or failed
+* @retval returns zero on success
+* @retval return a negative error code if failed
+*/
+static inline int write_disable(struct ak_spinand *flash)
+{
+	u8	code = OPCODE_WRDI;
+
+	return spi_write_then_read(flash->spi, &code, 1, NULL, 0);
+}
+
+/**
+* @brief  Wait for SPI flash ready.
+* 
+*  Service routine to read status register until ready, or timeout occurs.
+* @author lixinhai
+* @date 2014-03-20
+* @param[in] flash	spiflash handle.
+* @return int return write success or failed
+* @retval returns zero on success
+* @retval return a non-zero error code if failed
+*/
+static int wait_till_ready(struct ak_spinand *flash)
+{
+	unsigned long deadline;
+	int idx, shift;
+	u32 sr;
+	u8 addr;
+	struct flash_status_reg *fsr = &flash->stat_reg;
+
+	deadline = jiffies + MAX_READY_WAIT_JIFFIES;
+
+	shift = fsr->b_wip / 8;
+	idx = fsr->b_wip % 8;
+	addr = feature_cmd[shift];
+	do {
+		if ((sr = read_sr(flash, addr)) < 0)
+			break;
+		else if (!(sr & (1<<(fsr->b_wip%8))))
+			return 0;
+
+		cond_resched();
+
+	} while (!time_after_eq(jiffies, deadline));
+
+	return 1;
+}
+
+
+static int check_ecc_status(struct ak_spinand *flash)
+{
+	unsigned long deadline;
+	int idx, shift;
+	u32 sr;
+	u8 addr;
+	struct flash_status_reg *fsr = &flash->stat_reg;
+
+	deadline = jiffies + MAX_READY_WAIT_JIFFIES;
+
+	shift = fsr->b_wip / 8;
+	idx = fsr->b_wip % 8;
+	addr = feature_cmd[shift];
+	do {
+		if ((sr = read_sr(flash, addr)) < 0)
+		{
+			printk(KERN_ERR "read_sr fail\n" );
+			break;
+		}
+
+		if(((sr >> 4) & 0x3) == 2)
+		{
+			printk(KERN_ERR "ecc error sr:%d\n", sr );
+			return 1;
+		}
+		else
+		{
+			return 0;
+		}
+
+		cond_resched();
+
+	} while (!time_after_eq(jiffies, deadline));
+
+	return 1;
+
+}
+
+
+
+/**
+* @brief: enable 4 wire transfer mode.
+* 
+* @author lixinhai
+* @date 2014-04-10
+* @param[in] flash  spiflash handle.
+*/
+static int quad_mode_enable(struct ak_spinand *flash)
+{
+	int ret, idx, shift;
+	u32 regval;
+	u8 addr;
+	struct flash_status_reg *fsr = &flash->stat_reg;
+
+	shift = fsr->b_qe / 8;
+	idx = fsr->b_qe % 8;
+	
+	addr = feature_cmd[shift];
+	ret = wait_till_ready(flash);
+	if (ret)
+		return -EBUSY;
+
+	write_enable(flash);
+	
+	regval = read_sr(flash, addr);
+	regval |= 1<<(fsr->b_qe % 8);
+	write_sr(flash, addr, regval);
+
+
+	regval = read_sr(flash, addr);
+
+	write_disable(flash);
+	return 0;
+}
+
+/**
+* @brief: disable 4 wire transfer mode.
+* 
+* @author lixinhai
+* @date 2014-04-10
+* @param[in] flash  spiflash handle.
+*/
+static int quad_mode_disable(struct ak_spinand *flash)
+{
+	int ret, idx, shift;
+	u32 regval;
+	u8 addr;
+	struct flash_status_reg *fsr = &flash->stat_reg;
+
+	shift = fsr->b_qe / 8;
+	idx = fsr->b_qe % 8; 
+	addr = feature_cmd[shift];
+	ret = wait_till_ready(flash);
+	if (ret)
+		return -EBUSY;
+	
+	write_enable(flash);
+	
+	regval = read_sr(flash, addr);
+	regval &= ~(1<<(fsr->b_qe%8));
+	write_sr(flash, addr, regval);
+
+
+	regval = read_sr(flash, addr);
+	write_disable(flash);
+	return 0;
+}
+
+
+/**
+* @brief  Erase sector
+* 
+*  Erase a sector specialed by user.
+* @author lixinhai
+* @date 2014-03-20
+* @param[in] flash	    spiflash handle.
+* @param[in] offset    which is any address within the sector which should be erased.
+* @return int return write success or failed
+* @retval returns zero on success
+* @retval return a non-zero error code if failed
+*/
+static int erase_block(struct ak_spinand *flash, u32 offset)
+{
+	u32 row;	
+	struct spi_transfer t[1];
+	struct spi_message m;
+	
+	spi_message_init(&m);
+	memset(t, 0, (sizeof t));
+		
+	DEBUG(MTD_DEBUG_LEVEL3, "%s: %s %dKiB at 0x%08x\n",
+			dev_name(&flash->spi->dev), __func__,
+			flash->mtd.erasesize / 1024, offset);
+
+	row = ((offset>>flash->page_shift) & 0xffffff);
+
+	/* Wait until finished previous write command. */
+	if (wait_till_ready(flash))
+	{
+		printk(KERN_ERR "kernel: error erase_block previous write command fail\n" );
+		return -EBUSY;
+	}
+
+	/* Send write enable, then erase commands. */
+	write_enable(flash);
+
+	/* Set up command buffer. */
+	flash->cmd_buf[0] = flash->erase_opcode;
+	flash->cmd_buf[1] = row >> 16;
+	flash->cmd_buf[2] = row >> 8;
+	flash->cmd_buf[3] = row;
+
+	t[0].tx_buf = flash->cmd_buf;
+	t[0].len = 4;	
+	spi_message_add_tail(&t[0], &m);
+	
+  spi_sync(flash->spi, &m);
+
+
+//	spi_write(flash->spi, flash->cmd_buf, 4);
+
+	if (wait_till_ready(flash)) {
+		printk(KERN_ERR "kernel: error erase_block write command fail\n" );
+		/* REVISIT status return?? */		
+		return -EBUSY;
+	}
+
+	return 0;
+}
+
+
+/**
+* @brief  MTD Erase
+* 
+* Erase an address range on the flash chip.
+* @author luoyongchuang
+* @date 2015-05-17
+* @param[in] mtd    mtd info handle.
+* @param[in] instr   erase info.
+* @return int return write success or failed
+* @retval returns zero on success
+* @retval return a non-zero error code if failed
+*/
+static int ak_spinand_erase(struct mtd_info *mtd, struct erase_info *instr)
+{
+	struct ak_spinand *flash = mtd_to_spiflash(mtd);
+	u32 addr,len;
+	uint32_t rem;
+
+
+	DEBUG(MTD_DEBUG_LEVEL2, "%s: %s %s 0x%llx, len %lld\n",
+	      dev_name(&flash->spi->dev), __func__, "at",
+	      (long long)instr->addr, (long long)instr->len);
+
+	/* sanity checks */
+	if (instr->addr + instr->len > mtd->size)
+	{
+		printk(KERN_ERR "ak_spinand_erase:instr->addr[0x%llx] + instr->len[%lld] > mtd->size[%lld]\n",
+			instr->addr, instr->len, mtd->size );
+		return -EINVAL;
+	}
+	div_u64_rem(instr->len, mtd->erasesize, &rem);
+	if (rem != 0)
+	{
+		printk(KERN_ERR "ak_spinand_erase:rem!=0 [%u]\n", rem );
+		return -EINVAL;
+	}
+
+	addr = instr->addr;
+	len = instr->len;
+
+	mutex_lock(&flash->lock);
+
+	//printk("ak_spinand_erase:%d:%d\n", addr, len);
+	while (len) {
+		if (erase_block(flash, addr)) {
+			instr->state = MTD_ERASE_FAILED;
+			mutex_unlock(&flash->lock);
+			return -EIO;
+		}
+
+		addr += mtd->erasesize;
+		len -= mtd->erasesize;
+	}
+
+	mutex_unlock(&flash->lock);
+
+	instr->state = MTD_ERASE_DONE;
+	mtd_erase_callback(instr);
+
+	return 0;
+}
+
+/**
+* @brief initilize spi nand flash read/write param. 
+* 
+* @author lixinhai
+* @date 2014-04-20
+* @param[in] spiflash info handle.
+* @return int return config success or failed
+* @retval returns zero on success
+* @retval return a non-zero error code if failed
+*/
+
+
+static int init_spiflash_rw_info(struct ak_spinand *flash)
+{
+	/**default param.*/
+	flash->rx_opcode = OPCODE_READ;
+	flash->rxd_bus_width = SPI_NBITS_SINGLE; //XFER_1DATAWIRE;
+	flash->rxa_bus_width = SPI_NBITS_SINGLE; //XFER_1DATAWIRE;
+	flash->tx_opcode = OPCODE_PP;
+	flash->txd_bus_width = SPI_NBITS_SINGLE; //XFER_1DATAWIRE;
+	flash->txa_bus_width = SPI_NBITS_SINGLE; //XFER_1DATAWIRE;
+	flash->dummy_len = 1;
+
+	if(flash->bus_width & FLASH_BUS_WIDTH_2WIRE){
+		if(flash->info.flags & SFLAG_DUAL_READ) {
+			flash->rx_opcode = OPCODE_FAST_D_READ;
+			flash->rxd_bus_width = SPI_NBITS_DUAL; //XFER_2DATAWIRE;
+			flash->rxa_bus_width = SPI_NBITS_SINGLE; //XFER_1DATAWIRE;
+			flash->dummy_len = 1;
+		} else if (flash->info.flags & SFLAG_DUAL_IO_READ) {
+			flash->rx_opcode = OPCODE_FAST_D_IO;
+			flash->rxd_bus_width = SPI_NBITS_DUAL; //XFER_2DATAWIRE;
+			flash->rxa_bus_width = SPI_NBITS_DUAL; //XFER_2DATAWIRE;
+			flash->dummy_len = 1;
+		}
+
+		if(flash->info.flags & SFLAG_DUAL_WRITE) {
+			flash->tx_opcode = OPCODE_PP_DUAL;
+			flash->txd_bus_width = SPI_NBITS_DUAL; //XFER_2DATAWIRE;
+			flash->txa_bus_width = SPI_NBITS_SINGLE; //XFER_1DATAWIRE;
+		} else if(flash->info.flags & SFLAG_DUAL_IO_WRITE) {
+			flash->tx_opcode = OPCODE_2IO_PP;
+			flash->txd_bus_width = SPI_NBITS_DUAL; //XFER_2DATAWIRE;
+			flash->txa_bus_width = SPI_NBITS_DUAL; //XFER_2DATAWIRE;
+		}	
+	}
+
+	if(flash->bus_width & FLASH_BUS_WIDTH_4WIRE){
+		if(flash->info.flags & SFLAG_QUAD_READ) {
+			flash->rx_opcode = OPCODE_FAST_Q_READ;
+			flash->rxd_bus_width = SPI_NBITS_QUAD; //XFER_4DATAWIRE;
+			flash->rxa_bus_width = SPI_NBITS_SINGLE; //XFER_1DATAWIRE;
+			flash->dummy_len = 1;
+		}else if(flash->info.flags & SFLAG_QUAD_IO_READ){
+			flash->rx_opcode = OPCODE_FAST_Q_IO;
+			flash->rxd_bus_width = SPI_NBITS_QUAD; //XFER_4DATAWIRE;
+			flash->rxa_bus_width = SPI_NBITS_QUAD; //XFER_4DATAWIRE;
+			flash->dummy_len = 3;
+		}
+
+		if(flash->info.flags & SFLAG_QUAD_WRITE) {
+			flash->tx_opcode = OPCODE_PP_QUAD;
+			flash->txd_bus_width = SPI_NBITS_QUAD; //XFER_4DATAWIRE;			
+			flash->txa_bus_width = SPI_NBITS_SINGLE; //XFER_1DATAWIRE;
+		}else if(flash->info.flags & SFLAG_QUAD_IO_WRITE) {
+			flash->tx_opcode = OPCODE_4IO_PP;
+			flash->txd_bus_width = SPI_NBITS_QUAD; //XFER_4DATAWIRE;
+			flash->txa_bus_width = SPI_NBITS_QUAD; //XFER_4DATAWIRE;
+		}
+	
+	}
+	return 0;
+}
+
+
+#if 0
+
+bool ak_spinand_get_protect(void)
+{
+	struct ak_spinand *flash;
+	u32 regval; 
+
+	if(ak_mtd_info == NULL) 
+		return false;
+		
+	flash = mtd_to_spiflash(ak_mtd_info);
+	if(flash == NULL) 
+		return false;
+		
+	mutex_lock(&flash->lock);
+	regval = read_sr(flash, 0xA0);
+	mutex_unlock(&flash->lock);
+
+    if((regval & (0x7<<3)) == 0)
+        return false;
+    else
+        return true;
+}
+
+
+
+//0: none, 1:1/64, 2:1/32, 3:1/16, 4:1/8, 5:1/4, 6:1/2
+int ak_spinand_cfg_protect(bool protect)
+{
+	struct ak_spinand *flash;
+	const unsigned char protect_bit[7] = {0, 0x0C, 0x14, 0x1C, 0x24, 0x2C, 0x34};
+    const unsigned char mode = 6;
+	u8 addr = 0xA0;
+	u32 regval; 
+
+	if(ak_mtd_info == NULL) 
+		return -1;
+
+	flash = mtd_to_spiflash(ak_mtd_info);
+	if(flash == NULL) 
+		return -1;
+		
+	mutex_lock(&flash->lock);
+
+	if(protect)
+    	regval = protect_bit[mode];
+	else
+    	regval = protect_bit[0];
+	
+	if(wait_till_ready(flash)) {
+        mutex_unlock(&flash->lock);
+		return -EBUSY;
+    }
+    
+	write_enable(flash);
+	write_sr(flash, addr, regval);
+	regval = read_sr(flash, addr);
+	printk(KERN_ERR "[protect regval: %x]\n", regval);
+	write_disable(flash);
+
+	mutex_unlock(&flash->lock);
+	
+	return 0;		
+}
+#endif
+
+
+/**
+* @brief configure spi nandflash transfer mode according to flags. 
+* 
+* @author lixinhai
+* @date 2014-04-20
+* @param[in] spiflash info handle.
+* @return int return config success or failed
+* @retval returns zero on success
+* @retval return a non-zero error code if failed
+*/
+static int ak_spinand_cfg_quad_mode(struct ak_spinand *flash)
+{
+	int ret = 0;
+
+
+	//intk("flash->bus_width:%d, flash->info.flags:%x, %x\n", flash->bus_width, flash->info.flags, (SFLAG_QUAD_WRITE|SFLAG_QUAD_IO_WRITE|SFLAG_DUAL_READ|SFLAG_DUAL_IO_READ));
+	
+	if((flash->bus_width & FLASH_BUS_WIDTH_4WIRE) && 
+		(flash->info.flags & (SFLAG_QUAD_WRITE|SFLAG_QUAD_IO_WRITE|
+			SFLAG_DUAL_READ|SFLAG_DUAL_IO_READ))) {	
+			//intk("quad_mode_enable@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n");
+		ret = quad_mode_enable(flash);
+		if(ret) {
+			flash->bus_width &= ~FLASH_BUS_WIDTH_4WIRE;
+			printk("config the spiflash quad enable fail. transfer use 1 wire.\n");
+		}
+	}
+	else
+		quad_mode_disable(flash);
+
+	return ret;
+}
+
+
+#define FILL_CMD(c, val) do{c[0] = (val);}while(0)
+#define FILL_ADDR(c, val) do{	\
+		c[CMD_SIZE] = ((val) >> 8) & 0xf;	\
+		c[CMD_SIZE+1] = ((val) & 0xff);	\
+		}while(0)
+		
+#define FILL_DUMMY_DATA(c, val) do{	\
+			c[CMD_ADDR_SIZE] = val >> 16;	\
+			c[CMD_ADDR_SIZE+1] = 0;	\
+			c[CMD_ADDR_SIZE+2] = 0;	\
+			c[CMD_ADDR_SIZE+3] = 0;	\
+			}while(0)
+
+/**
+* @brief configure spi nandflash transfer mode according to flags. 
+* 
+* @author lixinhai
+* @date 2014-04-20
+* @param[in] mtd info handle.
+* @param[in] row address.
+* @param[in] column address.
+* @param[in] transfer len.
+* @param[out] transfer result len.
+* @param[out] result buffer.
+* @return int return config success or failed
+* @retval returns zero on success
+* @retval return a non-zero error code if failed
+*/
+static int spinand_read(struct mtd_info *mtd, int row, int col, size_t len,
+		size_t *retlen, u_char *buf)
+{
+	struct ak_spinand *flash = mtd_to_spiflash(mtd);
+	struct spi_transfer t[4];
+	struct spi_message m;
+	struct spi_message m1;	
+	void *bounce_buf;
+
+	//printk(KERN_ERR"spinand_read@@@@@@@@@@@@@@@@@@@@@@@@@@@@, row:%d\n", row);
+ 	//printk(KERN_ERR"[r");
+	
+	spi_message_init(&m);
+	spi_message_init(&m1);	
+	memset(t, 0, (sizeof t));
+	
+	mutex_lock(&flash->lock);
+	bounce_buf = flash_buf_bounce_pre(flash, buf, len, SPI_FLASH_READ);
+
+	/*fill command*/
+	flash->cmd_buf[0] = OPCODE_READ_TO_CACHE;
+	flash->cmd_buf[1] = (row >> 16) & 0xff;
+	flash->cmd_buf[2] = (row >> 8) & 0xff;
+	flash->cmd_buf[3] = row & 0xff;
+	t[3].tx_buf = flash->cmd_buf;
+	t[3].len = 4;	
+	spi_message_add_tail(&t[3], &m1);
+	spi_sync(flash->spi, &m1);
+	
+//	spi_write(flash->spi, flash->cmd_buf, 4);
+
+	t[0].tx_buf = flash->cmd_buf;
+	t[0].len = CMD_SIZE;
+	//t[0].tx_nbits = flash->txa_bus_width;
+	spi_message_add_tail(&t[0], &m);
+
+	t[1].tx_buf = &flash->cmd_buf[CMD_SIZE];
+	t[1].len = ADDR_SIZE + flash->dummy_len;
+	//t[1].xfer_mode = flash->rxa_bus_width;
+	//t[1].tx_nbits = flash->txa_bus_width;
+	spi_message_add_tail(&t[1], &m);
+
+	t[2].rx_buf = bounce_buf;
+	t[2].len = len;	
+	t[2].cs_change = 0; //1;	
+	//t[2].xfer_mode = flash->rxd_bus_width;
+	t[2].rx_nbits = flash->rxd_bus_width;
+	
+
+	spi_message_add_tail(&t[2], &m);
+
+	/* Byte count starts at zero. */
+	if (retlen)
+		*retlen = 0;
+
+	/* Wait till previous write/erase is done. */
+	if (wait_till_ready(flash)) {
+		/* REVISIT status return?? */		
+		mutex_unlock(&flash->lock);
+		printk(KERN_ERR"kernel: error spinand_read fail, row:%d\n", row);
+		return -EBUSY;
+	}
+
+	/* Set up the write data buffer. */
+	FILL_CMD(flash->cmd_buf, flash->rx_opcode);
+	FILL_ADDR(flash->cmd_buf, col);
+	FILL_DUMMY_DATA(flash->cmd_buf, 0x00);
+
+	spi_sync(flash->spi, &m);
+
+	*retlen = m.actual_length - CMD_ADDR_SIZE - flash->dummy_len;
+	//intk(KERN_ERR"actual_length:%d, %d, %d, %d\n", *retlen, m.actual_length, CMD_ADDR_SIZE, flash->dummy_len);
+
+	if (check_ecc_status(flash)) {
+		/* REVISIT status return?? */
+		mutex_unlock(&flash->lock);
+		printk(KERN_ERR"kernel: check_ecc_status error, row:%d\n", row);
+		return -EBUSY;
+	}
+
+	
+	flash_buf_bounce_post(flash, buf, len, SPI_FLASH_READ);
+	
+	mutex_unlock(&flash->lock);
+	//printk(KERN_ERR"spinand_read@@@@@@@@@@@@@@@@@@@@@@@@@@@@ end, row:%d\n", row);
+	//printk(KERN_ERR"]");
+	return 0;
+}
+
+#if 0
+
+static int ecc_ctl(struct ak_spinand *flash, bool enable)
+{
+	u8 addr = 0xB0;
+	int regval; 
+	
+	if(wait_till_ready(flash)) {
+		return -1;
+	}
+	
+	write_enable(flash);
+
+	regval = read_sr(flash, addr);
+
+	if(enable)
+        regval |= FEATURE_ECC_EN;
+    else
+        regval &= ~FEATURE_ECC_EN;
+	
+	write_sr(flash, addr, regval);
+	//regval = read_sr(flash, addr);
+	//printk(KERN_ERR "[ecc enable regval: %x]\n", regval);
+	write_disable(flash);
+
+	return 0;		
+}
+
+
+static int spinand_read_noecc(struct mtd_info *mtd, int row, int col, size_t len,
+		size_t *retlen, u_char *buf)
+{
+	struct ak_spinand *flash = mtd_to_spiflash(mtd);
+	struct spi_transfer t[4];
+	struct spi_message m;
+	struct spi_message m1;	
+	void *bounce_buf;
+	int ret = 0;
+  
+  
+	spi_message_init(&m);
+	spi_message_init(&m1);	
+	memset(t, 0, (sizeof t));
+	
+	mutex_lock(&flash->lock);
+
+	//set to no ecc
+    if (-1 == ecc_ctl(flash, false))
+    {
+        printk(KERN_ERR"ecc_ctl fail\r\n");  
+        mutex_unlock(&flash->lock);
+        return -EBUSY;
+    }
+
+	
+	bounce_buf = flash_buf_bounce_pre(flash, buf, len, SPI_FLASH_READ);
+
+	/*fill command*/
+	flash->cmd_buf[0] = OPCODE_READ_TO_CACHE;
+	flash->cmd_buf[1] = (row >> 16) & 0xff;
+	flash->cmd_buf[2] = (row >> 8) & 0xff;
+	flash->cmd_buf[3] = row & 0xff;
+	t[3].tx_buf = flash->cmd_buf;
+	t[3].len = 4;	
+	spi_message_add_tail(&t[3], &m1);
+	spi_sync(flash->spi, &m1);
+	
+//	spi_write(flash->spi, flash->cmd_buf, 4);
+
+	t[0].tx_buf = flash->cmd_buf;
+	t[0].len = CMD_SIZE;
+	spi_message_add_tail(&t[0], &m);
+
+	t[1].tx_buf = &flash->cmd_buf[CMD_SIZE];
+	t[1].len = ADDR_SIZE + flash->dummy_len;
+	t[1].xfer_mode = flash->rxa_bus_width;
+	spi_message_add_tail(&t[1], &m);
+
+	t[2].rx_buf = bounce_buf;
+	t[2].len = len; 
+	t[2].cs_change = 1; 
+	t[2].xfer_mode = flash->rxd_bus_width;
+
+	spi_message_add_tail(&t[2], &m);
+
+	/* Byte count starts at zero. */
+	if (retlen)
+		*retlen = 0;
+
+	/* Wait till previous write/erase is done. */
+	if (wait_till_ready(flash)) {
+		/* REVISIT status return?? */		
+		printk(KERN_ERR"kernel: error spinand_read fail\n");
+		ret = -EBUSY;
+		goto OUT;
+	}
+
+	/* Set up the write data buffer. */
+	FILL_CMD(flash->cmd_buf, flash->rx_opcode);
+	FILL_ADDR(flash->cmd_buf, col);
+	FILL_DUMMY_DATA(flash->cmd_buf, 0x00);
+
+	spi_sync(flash->spi, &m);
+
+	*retlen = m.actual_length - CMD_ADDR_SIZE - flash->dummy_len;
+	
+	flash_buf_bounce_post(flash, buf, len, SPI_FLASH_READ);
+
+OUT:
+	if (-1 == ecc_ctl(flash, true))
+    {
+    	mutex_unlock(&flash->lock);
+        printk(KERN_ERR"spi_nand_read_noecc ecc_ctl fail\r\n");
+        return -EBUSY;
+    }
+	
+	mutex_unlock(&flash->lock);
+
+	return ret;
+}ak_spi_nand
+#endif
+
+
+/**
+* @brief configure spi nandflash transfer mode according to flags. 
+* 
+* @author lixinhai
+* @date 2014-04-20
+* @param[in] mtd info handle.
+* @param[in] from: address.
+* @param[in] transfer len.
+* @param[out] transfer result len.
+* @param[out] result buffer.
+* @return int return config success or failed
+* @retval returns zero on success
+* @retval return a non-zero error code if failed
+*/
+static int ak_spinand_read(struct mtd_info *mtd, loff_t from, size_t len,
+		size_t *retlen, u_char *buf)
+{
+	int ret = 0;
+	size_t rlen = 0;
+	u32 xfer_len;
+	u32 offset = 0;
+	u32 count = len;
+	int row, column;
+	struct ak_spinand *flash = mtd_to_spiflash(mtd);
+
+	*retlen = 0;
+
+	/*decode row/column in address param*/
+	row = ((from>>flash->page_shift) & 0xffffff);
+	column = (from & 0x7ff);
+  	//printk(KERN_ERR"count: %d, %d", count, row);
+	while(count > 0) {
+		xfer_len = (count > FLASH_BUF_SIZE) ? FLASH_BUF_SIZE : count;
+
+		/*transfer len not greater than page size*/
+		if(xfer_len > flash->info.page_size)
+			xfer_len = ALIGN_DOWN(xfer_len, flash->info.page_size);
+		if(xfer_len+column >= flash->info.page_size)
+			xfer_len = flash->info.page_size - column;
+
+
+		//printk(KERN_ERR"<%d, %d, %d, %d", row, xfer_len, flash->info.page_size, column);
+    
+		ret = spinand_read(mtd, row, column, xfer_len, &rlen, buf + offset);
+		if(unlikely(ret)) {
+			ret = -EBUSY;
+			goto out;
+		}
+		row++;
+		column = 0;
+		*retlen += rlen;
+		count -= rlen;		
+		offset += rlen;
+
+		//printk(KERN_ERR"; %d, %d, %d>", row, count, rlen);
+	}	
+out:
+	return ret;
+}
+
+
+//此函数暂不实?
+
+static int ak_spinand_read_noecc(struct mtd_info *mtd, loff_t from, size_t len,size_t *retlen, u_char *buf)
+{
+	printk("%s: no support\n",__func__);
+	return 0;
+}
+
+
+
+static int spinand_do_read_page(struct mtd_info *mtd, loff_t from, struct mtd_oob_ops *ops)
+{
+	int ret = 0;
+	size_t rlen = 0;
+	u32 xfer_len,read_len,read_len_oob,oob_size,oob_xfer_len,oob_add_len,oob_seglen_len;
+	u32 offset = 0;
+	u32 oob_offset = 0;	
+	u32 count = ops->len;
+	int row, column;
+	uint8_t r_buftmp[2112]={0};
+	
+	uint8_t *buf = NULL;	
+	uint8_t *oobbuf = ops->oobbuf;
+	uint8_t *datbuf = ops->datbuf;
+	struct ak_spinand *flash = mtd_to_spiflash(mtd);
+	
+//printk("%d\n",count);	
+	/*decode row/column in address param*/
+	row = ((from>>flash->page_shift) & 0xffffff);
+	column = (from & 0x7ff);
+  
+	read_len_oob = ops->ooblen;
+	oob_seglen_len = flash->info.oob_up_skiplen + flash->info.oob_seglen + flash->info.oob_down_skiplen;
+	oob_size  = flash->info.oob_size;
+	oob_xfer_len = flash->info.oob_seglen;
+
+	while(count > 0) {
+		xfer_len = (count > FLASH_BUF_SIZE) ? FLASH_BUF_SIZE : count;
+
+		/*transfer len not greater than page size*/
+		if(xfer_len > flash->info.page_size)
+			xfer_len = ALIGN_DOWN(xfer_len, flash->info.page_size);
+		if(xfer_len+column >= flash->info.page_size)
+			xfer_len = flash->info.page_size - column;
+    
+    	read_len = xfer_len + oob_size;
+
+    
+		ret = spinand_read(mtd, row, column, read_len, &rlen, r_buftmp/**/);
+		if(unlikely(ret)) {
+			ret = -EBUSY;
+			goto out;
+		}
+		memcpy(datbuf + offset, r_buftmp, xfer_len);
+		
+	  	//buf	 = buftmp + rlen - oob_size;
+	  	//skip bad block mark.
+	  	buf	 = r_buftmp + rlen - oob_size + flash->info.oob_vail_data_offset;
+	    oob_add_len = flash->info.oob_up_skiplen;
+		
+
+   if(read_len_oob > 0)
+   	{
+		while(read_len_oob > 0)
+			{	
+							 							 	
+			 	oob_xfer_len = (read_len_oob > flash->info.oob_seglen) ? flash->info.oob_seglen : read_len_oob;
+
+				memcpy(oobbuf+oob_offset, buf+oob_add_len, oob_xfer_len);
+				
+			 	oob_add_len += oob_seglen_len;							
+				read_len_oob -= oob_xfer_len;		
+				oob_offset += oob_xfer_len;
+				ops->oobretlen += oob_xfer_len;			 
+		  }
+		}
+	 else
+	 	{
+	 		oob_size = 0 ; 		
+	 	} 
+		row++;
+		column = 0;
+		ops->retlen += (rlen - oob_size);
+		count -= (rlen - oob_size);		
+		offset += (rlen-oob_size);	
+  }
+out:
+	return 0;//ops->retlen;
+}
+
+/**
+* @brief   MTD write
+* 
+* Write an address range to the flash chip.
+* @author lixinhai
+* @date 2014-03-20
+* @param[in] mtd	mtd info handle.
+* @param[in] to 	write start address.
+* @param[in] len	write length.
+* @param[out] retlen  write length at actually.
+* @param[out] buf	   the pointer to write data.
+* @return int return write success or failed
+* @retval returns zero on success
+* @retval return a non-zero error code if failed
+*/
+static int spinand_write(struct mtd_info *mtd, int row, int col, size_t len,
+	size_t *retlen, const u_char *buf)
+{
+	struct ak_spinand *flash = mtd_to_spiflash(mtd);
+	struct spi_transfer t[4];
+	struct spi_message m;
+	struct spi_message m1;	
+	void *bounce_buf;
+	//u_char buf_read[128]={0};
+	//size_t read_rlen = 0;
+	//int ret = 0;
+
+	//printk(KERN_ERR"(w");
+
+	DEBUG(MTD_DEBUG_LEVEL2, "%s: %s %s 0x%08x, len %zd\n",
+			dev_name(&flash->spi->dev), __func__, "to(page_shift)",
+			(u32)row, len);
+
+	if (retlen)
+		*retlen = 0;
+
+	/* sanity checks */
+	if (!len)
+		return(0);
+
+	spi_message_init(&m);
+	spi_message_init(&m1);	
+	memset(t, 0, (sizeof t));
+
+
+	//printk(KERN_ERR"1");
+	
+	mutex_lock(&flash->lock);
+	bounce_buf = flash_buf_bounce_pre(flash, (void*)buf, len, SPI_FLASH_WRITE);
+	//printk(KERN_ERR"2");
+	t[0].tx_buf = flash->cmd_buf;
+	t[0].len = CMD_SIZE;
+	//t[0].tx_nbits = flash->txa_bus_width;
+	spi_message_add_tail(&t[0], &m);
+	//printk(KERN_ERR"3");
+	t[1].tx_buf = &flash->cmd_buf[CMD_SIZE];
+	t[1].len = ADDR_SIZE;
+	//t[1].xfer_mode = flash->txa_bus_width;
+	//t[1].tx_nbits = flash->txa_bus_width;
+	spi_message_add_tail(&t[1], &m);
+	//printk(KERN_ERR"4");
+	t[2].tx_buf = bounce_buf;
+	t[2].cs_change = 0;
+	//t[2].xfer_mode = flash->txd_bus_width;
+	t[2].tx_nbits = flash->txd_bus_width;
+	
+	spi_message_add_tail(&t[2], &m);
+	//printk(KERN_ERR"5");
+	/* Wait until finished previous write command. */
+	if (wait_till_ready(flash)) {
+		mutex_unlock(&flash->lock);
+		printk(KERN_ERR"kernel: error spinand_write write cmd fail\n");
+		return -EBUSY;
+	}
+	//printk(KERN_ERR"6");
+	write_enable(flash);
+	/* Set up the opcode in the write buffer. */
+	FILL_CMD(flash->cmd_buf, flash->tx_opcode);
+	FILL_ADDR(flash->cmd_buf, col);
+	
+	t[2].len = len;
+	//printk(KERN_ERR"7");
+	spi_sync(flash->spi, &m);
+	//printk(KERN_ERR"8");
+	*retlen = m.actual_length - CMD_ADDR_SIZE;
+
+	flash->cmd_buf[0] = OPCODE_PP_EXEC;
+	flash->cmd_buf[1] = (row >> 16) & 0xff;
+	flash->cmd_buf[2] = (row >> 8) & 0xff;
+	flash->cmd_buf[3] = row & 0xff;
+	//printk(KERN_ERR"8");
+	t[3].tx_buf = flash->cmd_buf;
+	t[3].len = 4;
+	//t[3].tx_nbits = flash->txd_bus_width;
+	spi_message_add_tail(&t[3], &m1);
+	spi_sync(flash->spi, &m1);		
+	
+//	spi_write(flash->spi, flash->cmd_buf, 4);
+	//printk(KERN_ERR"9");
+	/* Wait until finished previous write command. */
+	if (wait_till_ready(flash))
+	{
+		mutex_unlock(&flash->lock);
+		printk(KERN_ERR"kernel: error spinand_write write data fail\n");
+		return -EBUSY;
+	}
+
+	PDEBUG("ak_spinand_write: retlen=%ld\n", *retlen);
+	flash_buf_bounce_post(flash, (void*)buf, len, SPI_FLASH_WRITE);
+	//printk(KERN_ERR"10");
+	mutex_unlock(&flash->lock);
+
+	//printk(KERN_ERR")");
+
+	return 0;
+}
+
+
+#define FLASH_OOB_SIZE  8 
+static int ak_spinand_write(struct mtd_info *mtd, loff_t to, size_t len,
+		size_t *retlen, const u_char *buf)
+{
+	int ret = 0;
+	size_t rlen = 0;
+	u32 xfer_len;
+	u32 offset = 0;
+	u32 count = len;
+	int row, column;
+	struct ak_spinand *flash = mtd_to_spiflash(mtd);
+
+	*retlen = 0;
+
+	/*decode row/column in address param*/
+	row = ((to>>flash->page_shift) & 0xffffff);
+	column = (to & 0x7ff);
+
+
+	while(count > 0) {
+		xfer_len = (count > FLASH_BUF_SIZE) ? FLASH_BUF_SIZE : count;
+
+		/*transfer len not greater than page size*/
+		if(xfer_len > flash->info.page_size)
+			xfer_len = ALIGN_DOWN(xfer_len, flash->info.page_size);
+		if(xfer_len+column >= flash->info.page_size)
+			xfer_len = flash->info.page_size - column;
+
+		ret = spinand_write(mtd, row, column, xfer_len, &rlen, buf + offset);
+		if(unlikely(ret)) {
+			ret = -EBUSY;
+			goto out;
+		}
+		
+		row++;
+		column = 0;
+		*retlen += rlen;
+		count -= rlen;		
+		offset += rlen;
+	}	
+out:
+	return ret;
+}
+
+
+/**
+* @brief adjust transfer len according to readlen and column. 
+* 
+* @author lixinhai
+* @date 2014-04-20
+* @param[in] spiflash info handle.
+* @param[in] column pos.
+* @param[in] need read length.
+* @retval return transfer len 
+*/
+static int adjust_xfer_len(struct ak_spinand *flash, int column, int readlen)
+{
+	int seg_oob;
+	int xfer_len;
+	int ofs = flash->mtd.writesize;
+	int start = column - ofs;
+	int end;
+
+	/*|--------------------64bytes------------------------------|*/
+	/*|---12---|-4--|---12----|-4--|---12---|-4--|---12----|-4--|*/
+	/*|-seglen-|skip|-segllen-|skip|-seglen-|skip|-segllen-|skip|*/
+
+	xfer_len = (readlen > flash->info.oob_seglen) ? flash->info.oob_seglen : readlen;
+	end = start + xfer_len;
+	seg_oob = flash->info.oob_up_skiplen + flash->info.oob_seglen + flash->info.oob_down_skiplen;
+	if(start/seg_oob != end/seg_oob)
+		end = (start/seg_oob + 1)*seg_oob;
+
+	xfer_len = end - start;
+
+	return xfer_len;	
+}
+
+/**
+* @brief convert oob offset and addr pos to row/column coord. 
+* 
+* @author lixinhai
+* @date 2014-04-20
+* @param[in] spiflash info handle.
+* @param[in] read from addr
+* @param[in] offset to read from
+* @return int return write success or failed
+* @retval returns zero on success
+* @retval return a non-zero error code if failed
+*/
+static int spinand_oobpos_to_coord(struct ak_spinand *flash,
+	   	loff_t addr, uint32_t ooboffs, int *row, int *column)
+{
+	*row = ((addr >> flash->page_shift) & 0xffffff);
+	*column = (addr & (flash->mtd.writesize - 1));
+
+	*row += ooboffs / flash->mtd.oobsize;
+	*column += ooboffs % flash->mtd.oobsize;
+
+	*column += flash->mtd.writesize;
+
+	if(*column > (flash->mtd.writesize + FLASH_OOB_SIZE))
+		return -EINVAL;
+
+	return 0;
+}
+
+
+
+static int spinand_do_read_oob(struct mtd_info *mtd, loff_t from,
+			    struct mtd_oob_ops *ops)
+{
+
+	struct ak_spinand *flash = mtd_to_spiflash(mtd);
+	int ret = 0;
+	size_t rlen = 0;
+	u32 xfer_len;
+	u32 offset = 0;
+	int row, column;
+	uint8_t *oobrw_buf;	
+	int readlen ;			
+	uint8_t *buf = NULL ;
+	ops->oobretlen = 0;	
+	readlen = ops->ooblen;
+	buf = ops->oobbuf;
+	
+	DEBUG(MTD_DEBUG_LEVEL3, "%s: from = 0x%08Lx, len = %i\n",
+			__func__, (unsigned long long)from, readlen);
+
+
+	if (unlikely(ops->ooboffs >= mtd->oobsize)) {
+		DEBUG(MTD_DEBUG_LEVEL0, "%s: Attempt to start read "
+					"outside oob\n", __func__);
+		return -EINVAL;
+	}
+
+	/* Do not allow reads past end of device */
+	if (unlikely(from >= mtd->size ||
+		     ops->ooboffs + readlen > ((mtd->size >> flash->page_shift) -
+					(from >> flash->page_shift)) * mtd->oobsize)) {
+		DEBUG(MTD_DEBUG_LEVEL0, "%s: Attempt read beyond end "
+					"of device\n", __func__);
+		return -EINVAL;
+	}				
+		oobrw_buf =(uint8_t *)kmalloc(SPINAND_OOB_LEN(flash->info), GFP_KERNEL);	
+		if (!oobrw_buf) {
+		  oobrw_buf =(uint8_t *)kmalloc(SPINAND_OOB_LEN(flash->info), GFP_KERNEL);	
+			if (!oobrw_buf) {
+				printk("allocate memory for pInit_info failed\n");
+				return -ENOMEM;
+				} 
+			} 		
+		spinand_oobpos_to_coord(flash, from, ops->ooboffs, &row, &column);
+		memset(oobrw_buf,0,SPINAND_OOB_LEN(flash->info));
+	  // printk("rd:xfer_len:%d,%d,%d,%d,%d", row, column, xfer_len, from, ops->ooboffs);
+		ret = spinand_read(mtd, row, column, SPINAND_OOB_LEN(flash->info), &rlen, oobrw_buf);
+		if(unlikely(ret)) {
+			ret = -EBUSY;
+			goto out;
+		}
+		column = 0;
+		//column += flash->info.oob_up_skiplen;
+		column += flash->info.oob_vail_data_offset;
+
+		
+		while(readlen > 0) {
+	
+			xfer_len = (readlen > flash->info.oob_seglen) ? flash->info.oob_seglen : readlen;
+			memcpy(buf + offset, oobrw_buf + column, xfer_len);
+			
+			column += (flash->info.oob_up_skiplen + flash->info.oob_seglen + flash->info.oob_down_skiplen);
+	
+			readlen -= xfer_len;		
+			offset += xfer_len;
+			ops->oobretlen += xfer_len;
+		}
+out:
+	kfree(oobrw_buf);
+	return 0;
+}
+
+
+static int ak_spinand_read_oob(struct mtd_info *mtd, loff_t from,
+			 struct mtd_oob_ops *ops)
+{
+	int ret = -ENOTSUPP;
+
+	ops->retlen = 0;
+
+	/* Do not allow reads past end of device */
+	if (ops->datbuf && (from + ops->len) > mtd->size) {
+		DEBUG(MTD_DEBUG_LEVEL0, "%s: Attempt read "
+				"beyond end of device\n", __func__);
+		return -EINVAL;
+	}
+
+	switch(ops->mode) {
+	case MTD_OOB_PLACE:
+	case MTD_OOB_AUTO:
+	case MTD_OOB_RAW:
+		break;
+
+	default:
+		goto out;
+	}
+
+	if (!ops->datbuf){
+//		printk("spinand_do_read_oob\n");
+		ret = spinand_do_read_oob(mtd, from, ops);
+	} else {
+//		printk("spinand_do_read_page\n");
+		ret = spinand_do_read_page(mtd, from, ops);
+	}
+
+ out:
+// 	printk("%s,%d\n",__func__,ret);
+	return 0;//ret;
+}
+
+
+static int spinand_do_write_oob(struct mtd_info *mtd, loff_t to,
+			    struct mtd_oob_ops *ops)
+{
+	int ret = 0;
+	size_t rlen = 0;
+	u32 xfer_len;
+	u32 offset = 0;
+	int row, column;
+	int ofs = mtd->writesize;
+	int writelen = ops->ooblen;
+	uint8_t *buf = ops->oobbuf;	
+	struct ak_spinand *flash = mtd_to_spiflash(mtd);
+
+	DEBUG(MTD_DEBUG_LEVEL3, "%s: from = 0x%08Lx, len = %i\n",
+			__func__, (unsigned long long)to, writelen);
+
+	if (unlikely(ops->ooboffs >= mtd->oobsize)) {
+		DEBUG(MTD_DEBUG_LEVEL0, "%s: Attempt to start read "
+					"outside oob\n", __func__);
+		return -EINVAL;
+	}
+
+	/* Do not allow reads past end of device */
+	if (unlikely(to >= mtd->size ||
+		     ops->ooboffs + writelen > ((mtd->size >> flash->page_shift) -
+					(to >> flash->page_shift)) * mtd->oobsize)) {
+		DEBUG(MTD_DEBUG_LEVEL0, "%s: Attempt write beyond end "
+					"of device\n", __func__);
+		return -EINVAL;
+	}
+		ret = spinand_oobpos_to_coord(flash, to, ops->ooboffs, &row, &column);
+		//column += flash->info.oob_up_skiplen;
+		column += flash->info.oob_vail_data_offset;
+		while(writelen> 0) {
+			xfer_len = adjust_xfer_len(flash, column, writelen);
+	
+			//printk("wr:to(%d)ofs(%d):%d,%d,%d,%p", (u32)to, ops->ooboffs, row, column, xfer_len, buf);
+			ret = spinand_write(mtd, row, column, xfer_len, &rlen, buf + offset);
+			if(unlikely(ret)) {
+				ret = -EBUSY;
+				goto out;
+			}
+			
+			column += (flash->info.oob_up_skiplen + rlen + flash->info.oob_down_skiplen);
+			if(column >= ofs + SPINAND_OOB_LEN(flash->info)) {
+				column = ofs;
+				row++;
+			}
+			writelen -= rlen;
+			offset += rlen;
+		}
+out:	
+	return 0;		
+	
+}
+
+
+static int spinand_do_write_page(struct mtd_info *mtd, loff_t to, struct mtd_oob_ops *ops)
+{
+	int ret = 0;
+	size_t rlen = 0;
+	u32 xfer_len,read_len_oob,oob_size,oob_xfer_len,oob_seglen_len;// read_len,
+	u16 spare_offset;
+	u32 offset = 0;
+	u32 oob_offset = 0;	
+	u32 oob_add_len = 0;
+	u32 count = ops->len;
+	int row, column;
+	int row_oob, column_oob;
+	//uint8_t buftmp_oob[64]={0};		
+	uint8_t *p_buftmp_oob;
+	//uint8_t buftmp[2112]={0};
+	u32 buftmp_len = 0;	
+	uint8_t w_buftmp_oob[64]={0};	
+	uint8_t w_buftmp[2112]={0};
+//	uint8_t *buf = NULL;	
+	int i;
+	uint8_t *oobbuf = ops->oobbuf;
+	uint8_t *datbuf = ops->datbuf;
+	struct ak_spinand *flash = mtd_to_spiflash(mtd);
+	/*decode row/column in address param*/
+	row = ((to>>flash->page_shift) & 0xffffff);
+	column = (to & 0x7ff);
+  
+	read_len_oob = ops->ooblen;
+	oob_seglen_len = flash->info.oob_up_skiplen + flash->info.oob_seglen + flash->info.oob_down_skiplen;
+	oob_size  = flash->info.oob_size;
+	oob_xfer_len = flash->info.oob_seglen;
+	spare_offset = flash->info.oob_vail_data_offset;
+
+	while(count > 0) {
+		xfer_len = (count > FLASH_BUF_SIZE) ? FLASH_BUF_SIZE : count;
+
+		/*transfer len not greater than page size*/
+		if(xfer_len > flash->info.page_size)
+			xfer_len = ALIGN_DOWN(xfer_len, flash->info.page_size);
+		if(xfer_len+column >= flash->info.page_size)
+			xfer_len = flash->info.page_size - column;
+
+		memcpy(w_buftmp, datbuf+offset, xfer_len);
+		
+		
+		spinand_oobpos_to_coord(flash, to, ops->ooboffs, &row_oob, &column_oob);
+		ret = spinand_read(mtd, row_oob, column_oob, oob_size, &rlen, w_buftmp_oob/**/);
+
+		PDEBUG("count=%d, xfer_data_len=%d, xfer_oob_len=%d\n", count, xfer_len, read_len_oob);
+		PDEBUG("row_oob=%d, column_oob=%d\n", row_oob, column_oob);
+		
+		for(i=0; i<4; i++)
+			PDEBUG("w_buftmp_oob[%d] = 0x%02x ", i, w_buftmp_oob[i]);
+		PDEBUG("\n");
+		
+		p_buftmp_oob = w_buftmp_oob + spare_offset; //offset to spare data
+			
+		while(read_len_oob> 0){
+			buftmp_len = (read_len_oob > oob_xfer_len) ? oob_xfer_len : read_len_oob;	   	
+			memcpy(p_buftmp_oob + oob_add_len, oobbuf+oob_offset, buftmp_len);			
+			read_len_oob -= buftmp_len;
+			oob_offset += buftmp_len;
+			oob_add_len +=oob_seglen_len;
+		}
+		memcpy(w_buftmp+xfer_len, w_buftmp_oob, oob_size);
+
+ 
+		ret = spinand_write(mtd, row, column, xfer_len+oob_size, &rlen, w_buftmp);
+		if(unlikely(ret)) {
+			ret = -EBUSY;
+			goto out;
+		}
+		
+		row++;
+		column = 0;
+//		*retlen += xfer_len;
+		count -= xfer_len;		
+		offset += xfer_len;
+	}	
+out:
+	return 0;//ret;	
+	
+}
+
+#if 0
+static int spinand_do_write_ops(struct mtd_info *mtd, loff_t to,
+			    struct mtd_oob_ops *ops)
+{
+	int ret;
+
+	ret = spinand_do_write_oob(mtd, to, ops);
+
+	ret |= ak_spinand_write(mtd, to, ops->len, &ops->retlen, ops->datbuf);
+	return ret;
+}
+#endif
+
+
+static int ak_spinand_write_oob(struct mtd_info *mtd, loff_t to,
+			 struct mtd_oob_ops *ops)
+{
+	int ret = -ENOTSUPP;
+
+	ops->retlen = 0;
+
+	/* Do not allow writes past end of device */
+	if (ops->datbuf && (to + ops->len) > mtd->size) {
+		DEBUG(MTD_DEBUG_LEVEL0, "%s: Attempt write beyond "
+				"end of device\n", __func__);
+		return -EINVAL;
+	}
+
+	switch(ops->mode) {
+	case MTD_OOB_PLACE:
+	case MTD_OOB_AUTO:
+	case MTD_OOB_RAW:
+		break;
+
+	default:
+		goto out;
+	}
+
+	if (!ops->datbuf)
+		ret = spinand_do_write_oob(mtd, to, ops);
+	else
+		ret =  spinand_do_write_page(mtd, to, ops);//  spinand_do_write_ops(mtd, to, ops);
+
+ out:
+	return 0;//ret;
+}
+
+static int _ak_spinand_read(struct mtd_info *mtd, loff_t from, size_t len,
+			size_t *retlen, u_char *buf)
+{
+	ak_spinand_read(mtd,from,len,retlen,buf);
+	return 0;
+}
+
+static int _ak_spinand_write(struct mtd_info *mtd, loff_t to, size_t len,
+		size_t *retlen, const u_char *buf)
+{
+	ak_spinand_write(mtd,to,len,retlen,buf);
+	return 0;			
+}
+
+/**
+ * nand_block_bad - [anyka] Read bad block marker in anyka bbt
+ * @mtd:	MTD device structure
+ * @ofs:	offset from device start
+ *
+ * Check, if the block is bad.
+ */
+int ak_spinand_block_isbad(struct mtd_info *mtd, loff_t offs)
+{
+	u32 blk_no = 0;
+	u32 ret = 0;
+
+	if (offs > mtd->size)
+	{
+	    printk("spinand %s %d offs=0x%llx erase:%08x Error!!!\n!!!\n", __func__, __LINE__, offs, mtd->erasesize);
+		return -EINVAL;
+	}
+
+	blk_no = div_u64(offs, mtd->erasesize);
+	//t = FHA_check_bad_block(blk_no); 
+	ret = spinand_is_badblock(blk_no);
+
+	ret = !ret;
+	if(ret)
+	{
+		printk("blk_no:%d is bad block\n!!!\n", blk_no);
+	}
+	
+	return ret;
+}
+
+/**
+ * ak_nand_block_markbad - [anyka] mark a block bad in anyka bbt
+ * @mtd:	MTD device structure
+ * @ofs:	offset from device start
+ *
+*/
+int ak_spinand_block_markbad(struct mtd_info *mtd, loff_t offs)
+{
+	u32 blk_no = 0;
+	u32 ret = 0;
+	//bool protect = false;
+
+	if (offs > mtd->size)
+	{
+	    printk("spinand %s %d offs=0x%llx erase:%08x Error!!!\n!!!\n", __func__, __LINE__, offs, mtd->erasesize);
+		return -EINVAL;
+	}
+
+	//protect = ak_spinand_get_protect();
+
+   // if(protect)
+    	//ak_spinand_cfg_protect(false);
+
+	blk_no = div_u64(offs, mtd->erasesize);
+	//t = FHA_set_bad_block(blk_no);
+	ret = spinand_set_badblock(blk_no);
+	//printk("ak_spinand_block_markbad:%d\n", ret);
+   // if(protect)
+    	//ak_spinand_cfg_protect(true);
+
+	if(ret == 0)
+	{
+		return 0;  //mark successed
+	}
+	else
+	{
+		return 1;  //mark failed
+	}
+}
+
+
+
+/**
+* @brief	MTD get device ID
+* 
+* get the device ID of  the spi nand chip.
+* @author lixinhai
+* @date 2014-03-20
+* @param[in] mtd	 mtd info handle.
+* @return int return device ID of  the spi nand chip.
+*/
+static int ak_spinand_get_devid(struct mtd_info *mtd)
+{
+	struct ak_spinand *flash = mtd_to_spiflash(mtd);
+	int			ret;
+	u8			id[5];
+	u32			jedec;
+
+	/* Wait until finished previous write command. */
+	if (wait_till_ready(flash))
+		return -EBUSY;
+
+	flash->cmd_buf[0]  = OPCODE_RDID;
+	flash->cmd_buf[1]  = 0x0;
+	/* JEDEC also defines an optional "extended device information"
+	 * string for after vendor-specific data, after the three bytes
+	 * we use here.  Supporting some chips might require using it.
+	 */
+	ret = spi_write_then_read(flash->spi, flash->cmd_buf, 2, id, 4);
+	if (ret < 0) {
+		DEBUG(MTD_DEBUG_LEVEL0, "%s: error %d ak_spinand_get_devid\n",
+			dev_name(&flash->spi->dev), ret);
+		return false;
+	}
+
+	jedec = id[0] | (id[1]<<8) | (id[2]<<16) | (id[3]<<24) ;
+	printk("spi nand ID: 0x%08x\n", jedec);
+
+	return jedec;
+}
+
+static int ak_fha_erase_spinand_callback(u32 chip_num,  u32 block)
+{
+	struct erase_info einfo;
+	struct ak_spinand *flash = mtd_to_spiflash(ak_mtd_info);
+  
+	memset(&einfo, 0, sizeof(struct erase_info));
+	einfo.addr = block* flash->info.page_per_block * flash->info.page_size;
+	einfo.len = ak_mtd_info->erasesize;
+	einfo.mtd = ak_mtd_info;
+
+	if(ak_spinand_erase(ak_mtd_info, &einfo) == 0)
+	{
+		return FHA_SUCCESS;
+	}
+	else
+	{
+		printk(KERN_ERR"***erase failed, block:%d\n", block);
+		return FHA_FAIL;
+	}
+}
+
+#if 0
+T_U32 ak_fha_write_callback(T_U32 chip_num, T_U32 page_num, const T_U8 *data,
+		T_U32 data_len, T_U8 *oob, T_U32 oob_len, T_U32 eDataType)
+{
+	int ret;
+	ssize_t retlen;
+	struct ak_spinand *flash = mtd_to_spiflash(ak_mtd_info);
+	loff_t to = page_num * flash->info.page_size;
+
+	
+	ret = ak_spinand_write(ak_mtd_info, to, data_len, &retlen, (u_char *)data);
+	if(ret)
+	{
+		printk("%s:%d\n", __func__, __LINE__);
+		return FHA_FAIL;
+	}
+#if 0	
+		struct mtd_oob_ops ops;	
+		if(oob_len >0)
+		{
+
+			ops.ooblen = oob_len;
+			ops.oobbuf = oob;	
+			ops.ooboffs = 0;			
+			ret = spinand_do_write_oob(ak_mtd_info, to, &ops);
+			if (ret) {
+				printk("%s:%d\n", __func__, __LINE__);
+				return FHA_FAIL;
+			}
+		}
+#endif		
+	return FHA_SUCCESS;
+}
+
+#else
+
+int ak_fha_write_spinand_callback(u32 chip_num, u32 page_num, const u8 *data,u32 data_len, u8 *oob, u32 oob_len, u32 eDataType)
+{
+
+    int row = 0, column = 0;
+    int row_oob = 0, column_oob = 0;
+    uint8_t *p_buftmp_oob;
+    u32 buftmp_len = 0; 
+    u32 count = data_len;
+    u32 xfer_len,read_len_oob,oob_size,oob_xfer_len,oob_seglen_len;// read_len,
+    size_t rlen = 0;
+    u32 offset = 0;
+    u16 spare_offset = 0;
+    int i = 0;
+    u32 oob_offset = 0; 
+    u32 oob_add_len = 0;
+    u32 ooboffs = 0;
+	uint8_t f_w_buftmp[2112]={0};
+	uint8_t f_w_buftmp_oob[64]={0}; 
+
+    int ret;
+    struct ak_spinand *flash = mtd_to_spiflash(ak_mtd_info);
+    loff_t to = page_num * flash->info.page_size;
+
+
+    row = ((to>>flash->page_shift) & 0xffffff);
+    column = (to & 0x7ff);
+
+    read_len_oob = oob_len;
+    oob_seglen_len = flash->info.oob_up_skiplen + flash->info.oob_seglen + flash->info.oob_down_skiplen;
+    oob_size  = flash->info.oob_size;
+    oob_xfer_len = flash->info.oob_seglen;
+    spare_offset = flash->info.oob_vail_data_offset;
+    ooboffs = flash->info.oob_vail_data_offset;
+
+    while(count > 0) {
+        xfer_len = (count > FLASH_BUF_SIZE) ? FLASH_BUF_SIZE : count;
+
+        /*transfer len not greater than page size*/
+        if(xfer_len > flash->info.page_size)
+            xfer_len = ALIGN_DOWN(xfer_len, flash->info.page_size);
+        if(xfer_len+column >= flash->info.page_size)
+            xfer_len = flash->info.page_size - column;
+
+        memcpy(f_w_buftmp, data+offset, xfer_len);
+
+        //printk("ooboffs:%d\n", ooboffs);
+        spinand_oobpos_to_coord(flash, to, ooboffs, &row_oob, &column_oob);
+        ret = spinand_read(ak_mtd_info, row_oob, column_oob, oob_size, &rlen, f_w_buftmp_oob/**/);
+
+        PDEBUG("count=%d, xfer_data_len=%d, xfer_oob_len=%d\n", count, xfer_len, read_len_oob);
+        PDEBUG("row_oob=%d, column_oob=%d\n", row_oob, column_oob);
+
+        for(i=0; i<4; i++)
+        PDEBUG("f_w_buftmp_oob[%d] = 0x%02x ", i, f_w_buftmp_oob[i]);
+        PDEBUG("\n");
+
+        p_buftmp_oob = f_w_buftmp_oob + spare_offset; //offset to spare data
+
+
+        while(read_len_oob> 0){
+            buftmp_len = (read_len_oob > oob_xfer_len) ? oob_xfer_len : read_len_oob;     
+            memcpy(p_buftmp_oob + oob_add_len, oob+oob_offset, buftmp_len);   
+            read_len_oob -= buftmp_len;
+            oob_offset += buftmp_len;
+            oob_add_len +=oob_seglen_len;
+        }
+        memcpy(f_w_buftmp+xfer_len, f_w_buftmp_oob, oob_size);
+
+
+        ret = spinand_write(ak_mtd_info, row, column, xfer_len+oob_size, &rlen, f_w_buftmp);
+        if(unlikely(ret)) {
+            ret = -1;
+            goto out;
+        }
+
+        row++;
+        column = 0;
+        //  *retlen += xfer_len;
+        count -= xfer_len;  
+        offset += xfer_len;
+    }
+
+out:
+    return ret; 
+ 
+}
+
+
+#endif
+
+int ak_fha_read_spinand_callback(u32 chip_num, u32 page_num, u8 *data,
+		u32 data_len, u8 *oob, u32 oob_len, u32 eDataType)
+{
+	int ret;
+	ssize_t retlen;
+	struct mtd_oob_ops ops;	
+	//printk("%s,data_len:%d,oob_len:%d\n",__func__,data_len,oob_len);
+	struct ak_spinand *flash = mtd_to_spiflash(ak_mtd_info);
+	loff_t from = page_num * flash->info.page_size;
+
+	//intk(KERN_ERR"ak_fha_read_spinand_callback@@@@@@@@@@@@@@@@@@@@@@@@@@@@, from:%d, data_len:%d\n", (size_t)from, data_len);
+
+	if(data_len > 0)
+	{
+		ret = ak_spinand_read(ak_mtd_info, from, data_len, &retlen, data);
+		if (ret) {
+			printk("%s:%d\n", __func__, __LINE__);
+			return FHA_FAIL;
+		}
+	}
+
+	//intk(KERN_ERR"data:%02x, %02x, %02x, %02x, %02x, %02x, %02x, %02x, %02x, %02x, %02x, %02x, %02x, %02x, %02x, %02x, %02x, %02x, %02x, %02x, %02x, %02x, %02x, %02x, %02x, %02x, %02x, %02x, %02x, %02x, %02x, %02x\n"
+	//ata[0], data[1], data[2], data[3], data[4], data[5], data[6], data[7]
+	//ata[8], data[9], data[10], data[11], data[12], data[13], data[14], data[15]
+	//ata[16], data[17], data[18], data[19], data[20], data[21], data[22], data[23]
+	//ata[24], data[25], data[26], data[27], data[28], data[29], data[30], data[31]);
+	
+#if 1	
+	
+	if(oob_len >0)
+	{
+
+		ops.ooblen = oob_len;
+		ops.oobbuf = oob;
+		ops.ooboffs = 0;
+		ret = spinand_do_read_oob(ak_mtd_info, from, &ops);
+		if (ret) {
+			printk("%s:%d\n", __func__, __LINE__);
+			return FHA_FAIL;
+		}
+	}
+#endif	
+	return FHA_SUCCESS;
+}
+
+int ak_fha_readbyte_spinand_callback(u32 chip_num, u32 page_num, u8 *data,
+		u32 data_len, u8 *oob, u32 oob_len, u32 eDataType)
+{
+	int ret;
+	ssize_t retlen;
+	//printk("%s,data_len:%d,oob_len:%d\n",__func__,data_len,oob_len);
+	struct ak_spinand *flash = mtd_to_spiflash(ak_mtd_info);
+	loff_t from = page_num * flash->info.page_size;
+
+	if(data_len > 0)
+		{
+			ret = ak_spinand_read_noecc(ak_mtd_info, from, data_len, &retlen, data);
+			if (ret) {
+				printk("%s:%d\n", __func__, __LINE__);
+				return FHA_FAIL;
+			}
+		}
+#if 0	
+	struct mtd_oob_ops ops;	
+	if(oob_len >0)
+		{
+
+			ops.ooblen = oob_len;
+			ops.oobbuf = oob;
+			ops.ooboffs = 0;
+			ret = spinand_do_read_oob(ak_mtd_info, from, &ops);
+			if (ret) {
+				printk("%s:%d\n", __func__, __LINE__);
+				return FHA_FAIL;
+			}
+		}
+#endif	
+	return FHA_SUCCESS;
+}
+
+
+static void *fha_ram_alloc(u32 size)
+{
+	return kmalloc(size, GFP_KERNEL);
+}
+
+static void *fha_ram_free(void *point)
+{
+	kfree(point);
+	return NULL;
+}
+
+static s32 fha_print(const signed char *fmt, ...)
+{
+	va_list args;
+	int r;
+    
+	va_start(args, fmt);
+    	vprintk("FHA:",args);
+	r = vprintk(fmt, args);
+	va_end(args);
+
+	return r;
+}
+
+
+
+int ak_get_partition_bak_name_idex(u32 partition_idex)
+{
+	char name[8] = {0};
+	u32 i = 0, nr_parts= 0;
+	T_PARTITION_TABLE_INFO *parts = NULL;
+
+	nr_parts = *(unsigned long *)g_part_tab.table;
+	parts = (T_PARTITION_TABLE_INFO *)(&g_part_tab.table[sizeof(unsigned long)]);
+
+	//printk(KERN_ERR "nr_parts:%d\n", nr_parts);
+	for(i = 0; i < nr_parts; i++)
+	{
+		memset(name, 0, 8);
+		memcpy(name, parts[i].partition_info.name, PARTITION_NAME_LEN);
+
+		//printk(KERN_ERR "name:%s, %s\n",g_partition_info.partition_name_info[partition_idex].partition_name, name);
+		if(strlen(g_partition_info.partition_name_info[partition_idex].partition_name) == strlen(name))
+		{
+			if(memcmp(g_partition_info.partition_name_info[partition_idex].partition_name, name, strlen(name)) == 0)
+			{
+				break;
+			}
+		}
+	}
+
+	if(i == nr_parts || i == 0)
+	{
+		return -1;
+	}
+
+
+	return (int)i;
+}
+
+
+/*
+* no need by lixingjian
+*/
+#if 0
+int ak_ckeck_partition_A_bak_name(void)
+{
+	char buf[10] = {0};
+	u32 str_len = 0;
+	int idex = 0;
+	char *dev_name_temp = "/dev/mtdblock";
+	u32 partition_idex = A_PARTITION_IDEX;  //1表示A分区
+
+	//判断ROOT盘应用哪个mtdblock
+	if(g_partition_info.partition_name_info[partition_idex].partition_name[0] != 0 && g_partition_info.partition_cnt == PARTITION_CNT)
+	{
+		str_len = strlen(dev_name_temp);
+		idex = ak_get_partition_bak_name_idex(partition_idex);
+		if(idex == -1)
+		{
+			return -1;
+		}
+		
+		printk(KERN_ERR "saved_root_name:%s\n", saved_root_name);
+		printk(KERN_ERR "idex:%d, str_len:%d\n", idex, str_len);
+		memset(buf, 0, 10);
+		sprintf(buf, "%d", idex + 1);
+		memcpy(&saved_root_name[str_len], buf, strlen(buf)+1);
+	}
+	
+	printk(KERN_ERR "saved_root_name:%s\n", saved_root_name);
+
+	return 0;
+}
+#endif
+
+
+
+
+static int ak_fha_init(void)
+{
+	int ret = FHA_FAIL;
+	//T_PFHA_INIT_INFO pInit_info = NULL;
+	T_PFHA_LIB_CALLBACK pCallback = NULL;
+	T_NAND_PHY_INFO pNandPhyInfo;
+	struct ak_spinand *flash = mtd_to_spiflash(ak_mtd_info);
+	unsigned long asa_start_block = 1;
+	unsigned char pa_data[64] = {0};
+
+	pCallback = kmalloc(sizeof(T_FHA_LIB_CALLBACK), GFP_KERNEL);
+	if (!pCallback) {
+		printk("allocate memory for pCallback failed\n");
+		ret = -ENOMEM;
+		goto err_out;
+	}
+	
+	pCallback->Erase = (FHA_Erase)ak_fha_erase_spinand_callback;
+	pCallback->Write = (FHA_Write)ak_fha_write_spinand_callback;
+	pCallback->Read = (FHA_Read)ak_fha_read_spinand_callback;
+	pCallback->ReadNandBytes = (FHA_ReadNandBytes)ak_fha_readbyte_spinand_callback;
+	pCallback->RamAlloc = (FHA_RamAlloc)fha_ram_alloc;
+	pCallback->RamFree = (FHA_RamFree)fha_ram_free;
+	pCallback->MemCmp = (FHA_MemCmp)memcmp;
+	pCallback->MemSet = (FHA_MemSet)memset;
+	pCallback->MemCpy = (FHA_MemCpy)memcpy;
+	pCallback->Printf = (FHA_Printf)fha_print;	
+
+
+	//ret = FHA_mount(pInit_info, pCallback, &pNandPhyInfo);
+
+	pNandPhyInfo.chip_id = flash->info.jedec_id;
+	pNandPhyInfo.page_size = flash->info.page_size;
+	pNandPhyInfo.page_per_blk = flash->info.page_per_block;
+	pNandPhyInfo.blk_num = flash->info.n_blocks;
+	pNandPhyInfo.plane_blk_num = flash->info.n_blocks;
+	pNandPhyInfo.spare_size = flash->info.oob_size;
+	
+	ret = partition_init(pCallback, &pNandPhyInfo, 0);
+	if (ret == FHA_FAIL) {
+		printk(KERN_ERR "partition_init failed\n");
+		ret = FHA_FAIL;
+	} else {
+		ret = 0;
+	}
+
+	//获取第一个坏块表的开始块
+	
+
+	//badblock init
+	if(-1 == spinand_babblock_tbl_init(0, true, asa_start_block))
+	{
+		printk(KERN_ERR "spinand_babblock_tbl_init failed\n");
+		ret = FHA_FAIL;
+	}
+	else
+	{
+		ret = 0;
+	}
+
+	//printk(KERN_ERR "saved_root_name:%s\n", saved_root_name);
+	//read the update partition name
+	
+	memset(pa_data, 0, 64);
+	
+	if(spinand_read_asa_data(pa_data, sizeof(T_PARTITION_INFO)) == -1)
+	{
+		printk(KERN_ERR "not read the update partition name\n");
+		memset(&g_partition_info, 0, sizeof(T_PARTITION_INFO));
+	}
+	else
+	{
+		memcpy(&g_partition_info, pa_data, sizeof(T_PARTITION_INFO));
+		printk(KERN_ERR "g_partition_info.partition_cnt:%ld\n", g_partition_info.partition_cnt);
+		printk(KERN_ERR "partition_name_info[0].partition_name:%s\n", g_partition_info.partition_name_info[0].partition_name);
+		printk(KERN_ERR "partition_name_info[1].partition_name:%s\n", g_partition_info.partition_name_info[1].partition_name);
+		printk(KERN_ERR "partition_name_info[2].partition_name:%s\n", g_partition_info.partition_name_info[2].partition_name);
+		
+	}
+
+
+	//FHA_asa_scan(AK_TRUE);
+	kfree(pCallback);
+err_out:
+	//kfree(pInit_info);
+	return ret;
+}
+#if 0
+
+int ak_fha_init_for_update(int n)
+{
+
+	int ret = 0,retval = 0;
+	T_PFHA_INIT_INFO pInit_info = NULL;
+	T_PFHA_LIB_CALLBACK pCallback = NULL;
+	T_NAND_PHY_INFO pNandPhyInfo;
+
+	pInit_info = kmalloc(sizeof(T_FHA_INIT_INFO), GFP_KERNEL);
+	if (!pInit_info) {
+		printk("allocate memory for pInit_info failed\n");
+		return -ENOMEM;
+	}
+
+	pInit_info->nChipCnt = 1;
+	pInit_info->nBlockStep = 1;
+	pInit_info->eAKChip = FHA_CHIP_SET_TYPE;
+	pInit_info->ePlatform = PLAT_LINUX;
+	pInit_info->eMedium = MEDIUM_SPI_NAND;
+	pInit_info->eMode = MODE_UPDATE;
+
+	pCallback = kmalloc(sizeof(T_FHA_LIB_CALLBACK), GFP_KERNEL);
+	if (!pCallback) {
+		printk("allocate memory for pCallback failed\n");
+		ret = -ENOMEM;
+		goto err_out;
+	}
+	
+	pCallback->Erase = ak_fha_erase_callback;
+	pCallback->Write = (FHA_Write)ak_fha_write_callback;
+	pCallback->Read = (FHA_Read)ak_fha_read_callback;
+	pCallback->RamAlloc = fha_ram_alloc;
+	pCallback->RamFree = fha_ram_free;
+	pCallback->MemCmp = (FHA_MemCmp)memcmp;
+	pCallback->MemSet = (FHA_MemSet)memset;
+	pCallback->MemCpy = (FHA_MemCpy)memcpy;
+	pCallback->Printf = (FHA_Printf)fha_print;
+
+	ret = FHA_mount(pInit_info, pCallback, &pNandPhyInfo);
+	if (ret == FHA_FAIL) {
+		printk("FHA_mount failed\n");
+		ret = -EINVAL;
+	} else {
+		ret = 0;
+	}
+  retval =  FHA_burn_init(pInit_info, pCallback, &pNandPhyInfo);
+  FHA_asa_scan(AK_TRUE);
+  if(retval == FHA_FAIL)
+  {
+      goto err_out;
+  }
+  
+
+
+	kfree(pCallback);
+err_out:
+	kfree(pInit_info);
+	return ret;
+
+	int ret = 0;
+
+	return ret;
+	
+ 
+
+}
+#endif
+
+
+
+#if 0
+
+
+unsigned long ak_check_sn_flag(unsigned char *data)
+{
+	void *handle = NULL;
+	unsigned char *name = "ENV";//"NVT";  //"ENV"
+	unsigned long data_len;
+	int ret = -1;
+	
+	printk(KERN_ERR "partition_open:%s\n", name);
+	handle = partition_open(name);
+	if(handle == NULL)
+	{
+		printk(KERN_ERR "partition_open fail:%s\n", name);
+		return 0;
+	}
+
+	data_len = partition_get_data_size(handle);
+	printk(KERN_ERR "data_len:%ld\n", data_len);
+	if(data_len == 0 || data_len > 2048)
+	{
+		partition_close(handle);
+		printk(KERN_ERR "the partition no have anything, name:%s, data_len:%ld\n", name, data_len);
+		return 0;
+	}
+
+	ret = partition_read(handle, data, data_len);
+	if(ret == -1)
+	{
+		partition_close(handle);
+		printk(KERN_ERR "partition_read fail, data_len:%ld\n", data_len);
+		return 0;
+	}
+
+	partition_close(handle);
+
+	//printk(KERN_ERR "data:%02x,%02x,%02x,%02x,%02x,%02x,%02x,%02x\n", data[0], data[1], data[2], data[3], data[4], data[5], data[6], data[7], data[8]);
+	printk(KERN_ERR "data:%s\n", data);
+
+
+	return data_len; 
+	
+
+}
+
+
+int check_sn_data(char *data)
+{
+	if(memcmp(data, "0601BOK184403N", strlen("0601BOK184403N")) == 0){
+		return 0;
+	}
+
+	return -1;
+}
+
+static int ak_check_chang_flash_param(void)
+{
+	unsigned long data_len =  0;
+	unsigned char data[2048] = {0};	
+
+	struct ak_spinand *flash = mtd_to_spiflash(ak_mtd_info);
+
+	printk(KERN_ERR "flash->info.oob_up_skiplen:%u\n", flash->info.oob_up_skiplen);
+	printk(KERN_ERR "flash->info.oob_seglen:%u\n", flash->info.oob_seglen);
+	printk(KERN_ERR "flash->info.oob_down_skiplen:%u\n", flash->info.oob_down_skiplen);
+	printk(KERN_ERR "flash->info.oob_seg_perpage:%u\n", flash->info.oob_seg_perpage);
+
+	data_len = ak_check_sn_flag(data);
+	if(0 == data_len)
+	{
+		return -1;
+	}
+
+	//0601BOK184403N000145
+	if(check_sn_data(data) == 0)
+	{
+		flash->info.oob_up_skiplen = 0;
+		flash->info.oob_seglen = 16;
+		flash->info.oob_down_skiplen = 0;
+		printk(KERN_ERR "need to chang the flash param\n");
+	}
+	printk(KERN_ERR "flash->info.oob_up_skiplen:%u\n", flash->info.oob_up_skiplen);
+	printk(KERN_ERR "flash->info.oob_seglen:%u\n", flash->info.oob_seglen);
+	printk(KERN_ERR "flash->info.oob_down_skiplen:%u\n", flash->info.oob_down_skiplen);
+	printk(KERN_ERR "flash->info.oob_seg_perpage:%u\n", flash->info.oob_seg_perpage);
+
+	return 0;
+}
+
+#endif
+
+#ifndef CONFIG_MTD_SPINAND_PRODUCER	
+static int ak_mount_partitions(struct spi_device *spi)
+{
+	int i, ret;
+	unsigned long nr_parts;
+	//unsigned char *buf;
+	T_PARTITION_TABLE_INFO *parts = NULL;
+	struct mtd_partition *mtd_part;
+	struct mtd_part_parser_data	ppdata;	
+	//struct ak_spinand *flash = mtd_to_spiflash(ak_mtd_info);
+
+	ret = ak_fha_init();
+	if (ret == FHA_FAIL) {
+		printk("Init FHA lib failed\n");
+		goto err_out;
+	}
+
+
+#if 1
+	ret = partition_get_partition_table(&g_part_tab, MEDIUM_SPINAND);
+	if (ret == FHA_FAIL) {
+		printk(KERN_ERR "get src partition failed, and read back partition\n");
+		ret =  partition_get_partition_backup_table(&g_part_tab, MEDIUM_SPINAND);
+		if (ret == FHA_FAIL) {
+			printk(KERN_ERR "get back partition info failed\n");
+			ret = !ret;
+			goto no_parts;
+		}
+	}
+
+	/* 
+	* if no partiton to mount, the buf will be all 0xFF but not constant.
+	* So, it is not safe here. 
+	*/
+	nr_parts = *(unsigned long *)g_part_tab.table;
+	//15 --> partition_get_partition_table only copy 512 byte,so max cnt is 15
+	if (nr_parts <= 0 || nr_parts > 15) {
+		printk(KERN_ERR "get src partition num:%ld error, and read back partition\n", nr_parts);
+		ret =  partition_get_partition_backup_table(&g_part_tab, MEDIUM_SPINAND);
+		if (ret == FHA_FAIL) {
+			printk(KERN_ERR "get partition info failed\n");
+			ret = !ret;
+			goto no_parts;
+		}
+
+		nr_parts = *(unsigned long *)g_part_tab.table;
+		if (nr_parts <= 0 || nr_parts > 15) 
+		{
+			printk(KERN_ERR "partition count invalid, nr_parts:%ld\n", nr_parts);
+			ret = -EINVAL;
+			goto no_parts;
+		}
+	}
+
+	mtd_part = kzalloc(sizeof(struct mtd_partition) * nr_parts, GFP_KERNEL);
+	if (!mtd_part) {
+		printk(KERN_ERR "allocate memory for mtd_partition failed\n");
+		ret = -ENOMEM;
+		goto no_parts;
+	}
+
+	parts = (T_PARTITION_TABLE_INFO *)(&g_part_tab.table[sizeof(unsigned long)]);
+	for (i = 0; i < nr_parts; i++) {
+		mtd_part[i].name = kzalloc(PARTITION_NAME_LEN, GFP_KERNEL);
+		memcpy((char *)(mtd_part[i].name), parts[i].partition_info.name, PARTITION_NAME_LEN);
+		mtd_part[i].size = parts[i].partition_info.ksize*1024;
+		mtd_part[i].offset = parts[i].partition_info.start_pos;
+		mtd_part[i].mask_flags = parts[i].partition_info.r_w_flag;
+		printk("mtd_part[%d]:\nname = %s\nsize = 0x%llx\noffset = 0x%llx\nmask_flags = 0x%x\n\n",
+				i, 
+				mtd_part[i].name, 
+				mtd_part[i].size, 
+				mtd_part[i].offset, 
+				mtd_part[i].mask_flags);
+
+	}
+	
+	//ak_ckeck_partition_A_bak_name();
+
+	//ak_check_chang_flash_param();
+	
+
+	/*
+	* call ak_partition_table_sys_create function , create sys kobject for app aplication
+	*/
+	ret = ak_partition_table_sys_create(&g_part_tab);
+	if (ret){
+		printk(KERN_ERR "create sys partition table kobject failed!\n");
+		ret = -EINVAL;
+		kfree(mtd_part);
+		goto no_parts;
+	}
+
+#else
+
+	buf = kzalloc(flash->info.page_size, GFP_KERNEL);
+	if (!buf) {
+		printk("allocate memory for page buffer failed\n");
+		ret = -ENOMEM;
+		goto err_out;
+	}
+
+	ret = FHA_get_fs_part(buf, flash->info.page_size);
+	if (ret == FHA_FAIL) {
+		printk("get partition info failed\n");
+		ret = !ret;
+		goto no_parts;
+	}
+
+	nr_parts = *(unsigned long *)buf;
+	/* if no partiton to mount, the buf will be all 0xFF but not constant.
+	 * So, it is not safe here. */
+	printk("nr_parts=0x%lx\n", nr_parts);
+	if (nr_parts <= 0 || nr_parts > 32) {
+		printk("partition count invalid\n");
+		ret = -EINVAL;
+		goto no_parts;
+	}
+
+	mtd_part = kzalloc(sizeof(struct mtd_partition) * nr_parts, GFP_KERNEL);
+	if (!mtd_part) {
+		printk("allocate memory for mtd_partition failed\n");
+		ret = -ENOMEM;
+		goto no_parts;
+	}
+
+	parts = (struct partitions *)(&buf[sizeof(unsigned long)]);
+
+
+	for (i = 0; i < nr_parts; i++) {
+		mtd_part[i].name = kzalloc(MTD_PART_NAME_LEN, GFP_KERNEL);
+		memcpy(mtd_part[i].name, parts[i].name, MTD_PART_NAME_LEN);
+		mtd_part[i].size = parts[i].size;
+		mtd_part[i].offset = parts[i].offset;
+		mtd_part[i].mask_flags = parts[i].mask_flags;
+		printk("mtd_part[%d]:\nname = %s\nsize = 0x%llx\noffset = 0x%llx\nmask_flags = 0x%x\n\n",
+				i, mtd_part[i].name, mtd_part[i].size, mtd_part[i].offset, mtd_part[i].mask_flags);
+	}
+/*
+	ret = add_mtd_partitions(ak_mtd_info, (const struct mtd_partition *)mtd_part, nr_parts);
+
+	if (ret) {
+		printk("add mtd partition failed\n");
+		goto no_parts;
+	}
+*/
+#endif
+	ppdata.of_node = spi->dev.of_node;
+
+	ret = mtd_device_parse_register(ak_mtd_info, NULL, &ppdata, 
+			(const struct mtd_partition *)mtd_part, nr_parts);
+	if (ret) {
+		printk("add mtd partition failed\n");
+		goto no_parts;
+	}
+
+
+no_parts:
+	//kfree(buf);
+err_out:
+	return ret;
+}
+#endif
+
+/**
+* @brief	 get_flash_info
+* 
+* Read the device ID and identify that it was supported or not.
+* @author 	luoyongchuang
+* @date 		2016-03-17
+* @param[in] mtd	  spi device handle.
+* @return int return the device info.
+*/
+
+static struct flash_info *get_flash_info(struct spi_device *spi)
+{
+	int			tmp;
+	u8			cmd[2];
+	u8			id[5];
+	u32			jedec;
+	u16                     ext_jedec = 0;
+	struct flash_info *ofinfo = NULL;
+	struct device *dev = &spi->dev;
+	struct property *prop  = NULL;
+	const char *namestr = NULL;
+	struct device_node *child;
+	u32 readid = 0;
+	u32 ext_readid = 0;
+	u32 dataout;
+	
+	/* JEDEC also defines an optional "extended device information"
+	 * string for after vendor-specific data, after the three bytes
+	 * we use here.  Supporting some chips might require using it.
+	 */
+
+	cmd[0] = OPCODE_RDID; 
+	cmd[1] = 0x0; 
+	tmp = spi_write_then_read(spi, cmd, 2, id, 4);
+	if (tmp < 0) {
+		DEBUG(MTD_DEBUG_LEVEL0, "%s: error %d reading JEDEC ID\n",
+			dev_name(&spi->dev), tmp);
+		return NULL;
+	}
+	jedec = id[0];
+	jedec = jedec << 8;
+	jedec |= id[1];
+	jedec = jedec << 8;
+	jedec |= id[2];
+	jedec = jedec << 8;
+	jedec |= id[3];
+
+	printk("akspi nand ID: 0x%08x\n", jedec);
+
+	/*cdh:search for spi controller device */
+	prop = of_find_property(dev->of_node,"compatible", NULL);
+	if(!prop){
+		printk(KERN_ERR"%s,line:%d, find compatible failed\n", __func__, __LINE__);
+		return NULL;
+	}
+
+	/*cdh:from norflash dtsi get match spi nandflash information */
+	namestr = (const char *)kzalloc(20, GFP_KERNEL);
+	if (!namestr){
+		printk(KERN_ERR"%s,line:%d, allocate name buffer failed\n", __func__, __LINE__);
+		return NULL;
+	}
+
+	ofinfo = (struct flash_info *)kzalloc(sizeof(struct flash_info), GFP_KERNEL);
+	if (!ofinfo){
+		printk(KERN_ERR"%s,line:%d, allocate flash info failed\n", __func__, __LINE__);
+		kfree(namestr);
+		return NULL;
+	}
+
+	for_each_available_child_of_node(dev->of_node, child){
+		if (child->name && (of_node_cmp(child->name, "spi-nandflash") == 0)){
+			of_property_read_u32(child, "nandflash-jedec-id", &readid);
+			if (readid == jedec){
+				of_property_read_u32(child, "nandflash-ext-id", &ext_readid);
+				if (ext_readid != 0 && ext_readid != ext_jedec){
+					continue;
+				}else{
+					ofinfo->child = child;
+					break;
+				}
+			}
+		}
+	}
+
+	/*
+	* cdh:judge search spi norflash device whether success or not
+	*/
+	if (!ofinfo->child){
+		printk(KERN_ERR"%s,line:%d, no find match device!\n", __func__, __LINE__);
+		goto err_exit;
+	}
+	
+	/*
+	* cdh:get spi nandflash information
+	*/
+	of_property_read_string(child, "nandflash-name", &namestr);
+	//printk(KERN_ERR"%s,child qijian. node name = %s\n", __func__, namestr);
+	ofinfo->name = namestr;
+	ofinfo->jedec_id = readid;
+	ofinfo->ext_id = ext_readid;
+	
+	of_property_read_u32(child, "nandflash-page_size", &ofinfo->page_size);
+	of_property_read_u32(child, "nandflash-page_per_block", &ofinfo->page_per_block);
+	of_property_read_u32(child, "nandflash-block_size", &ofinfo->block_size);
+	of_property_read_u32(child, "nandflash-n_blocks", &dataout);
+	ofinfo->n_blocks = (u16)dataout;
+	of_property_read_u32(child, "nandflash-flags", &dataout);
+	ofinfo->flags = (u16)dataout;
+
+	of_property_read_u32(child, "nandflash-oob_size", &ofinfo->oob_size);
+	of_property_read_u32(child, "nandflash-oob_seglen", &dataout);
+	ofinfo->oob_seglen = (u16)dataout;
+	of_property_read_u32(child, "nandflash-oob_seg_perpage", &dataout);
+	ofinfo->oob_seg_perpage = (u16)dataout;
+	of_property_read_u32(child, "nandflash-oob_up_skiplen", &dataout);
+	ofinfo->oob_up_skiplen = (u16)dataout;
+	of_property_read_u32(child, "nandflash-oob_down_skiplen", &dataout);
+	ofinfo->oob_down_skiplen = (u16)dataout;
+	of_property_read_u32(child, "nandflash-oob_vail_data_offset", &dataout);
+	ofinfo->oob_vail_data_offset = (u16)dataout;
+	
+	return ofinfo;
+err_exit:
+	kfree(namestr);
+	kfree(ofinfo);
+	dev_err(&spi->dev, "get_flash_info() unrecognized flash id %06x\n", jedec);
+	return NULL;
+}
+
+static int ak_spinand_init_stat_reg(struct ak_spinand *flash)
+{
+	struct flash_info *info = &flash->info;
+	u32 dataout;
+
+	of_property_read_u32(info->child, "nandflash-b_wip", &dataout);
+	flash->stat_reg.b_wip = dataout;
+	of_property_read_u32(info->child, "nandflash-b_qe", &dataout);
+	flash->stat_reg.b_qe = dataout;
+
+	return 0;
+}
+
+
+
+
+/**
+* @brief	 spi nand probe
+* 
+* Initial the spi nand device driver to kernel.
+* @author luoyongchuang
+* @date 2016-03-17
+* @param[in] mtd	  spi device handle.
+* @return int return write success or failed
+* @retval returns zero on success
+* @retval return a non-zero error code if failed
+*/
+//static
+int ak_spinand_probe(struct spi_device *spi)
+{
+
+	unsigned										i;
+	unsigned										ret = 0;
+	struct flash_info						*info;
+	struct ak_spinand						*flash;	
+	struct flash_platform_data	*data;	
+	
+	printk("ak spinandflash probe enter.\n");
+	
+	/* Platform data helps sort out which chip type we have, as
+	 * well as how this board partitions it.  If we don't have
+	 * a chip ID, try the JEDEC id commands; they'll work for most
+	 * newer chips, even if we don't recognize the particular chip.
+	 */
+	 
+	data = spi->dev.platform_data;
+
+	info = get_flash_info(spi);
+	if (!info)
+		return -ENODEV;
+	
+
+	flash = kzalloc(sizeof *flash, GFP_KERNEL);
+	if (!flash)
+		return -ENOMEM;
+
+ 	 memset(flash, 0, sizeof *flash);
+  
+	ak_mtd_info = &flash->mtd;
+
+	spi->mode =  SPI_TX_QUAD | SPI_RX_QUAD;	
+
+	flash->spi = spi;
+	flash->info = *info;
+	mutex_init(&flash->lock);
+	dev_set_drvdata(&spi->dev, flash);
+	
+	sflash_reset(flash);
+
+	if (data && data->name)
+		flash->mtd.name = data->name;
+	else
+		flash->mtd.name = dev_name(&spi->dev);
+
+	flash->mtd.type = MTD_NANDFLASH;
+	flash->mtd.writesize = flash->info.page_size;
+	flash->mtd.flags = MTD_WRITEABLE;
+	flash->mtd.size = info->block_size * info->n_blocks;
+	flash->mtd._erase = ak_spinand_erase;
+	flash->mtd._write = _ak_spinand_write;
+	flash->mtd._read = _ak_spinand_read;
+	flash->mtd._read_oob = ak_spinand_read_oob;
+	flash->mtd._write_oob = ak_spinand_write_oob;
+	flash->mtd._block_isbad = ak_spinand_block_isbad;
+	flash->mtd._block_markbad = ak_spinand_block_markbad;
+	flash->mtd.get_device_id = ak_spinand_get_devid;
+	//printk("%s, info->block_size = %d, info->n_blocks = %d\n", info->name, info->block_size, info->n_blocks);
+
+	flash->erase_opcode = OPCODE_ERASE_BLOCK;
+	flash->mtd.erasesize = info->block_size;
+	flash->mtd.oobsize = info->oob_size;
+	flash->mtd.oobavail = info->oob_seglen * info->oob_seg_perpage;
+	
+	flash->bus_width = FLASH_BUS_WIDTH_4WIRE | FLASH_BUS_WIDTH_2WIRE | FLASH_BUS_WIDTH_1WIRE; //data->bus_width;
+ 
+	flash->page_shift = ffs(flash->mtd.writesize)-1; 
+#ifdef SPINAND_USE_MTD_BLOCK_LAYER
+	/*pre-allocation buffer use for spi nand data transfer.*/
+	flash->buf = kzalloc(FLASH_BUF_SIZE, GFP_KERNEL);
+	if (!flash->buf) {
+		printk("Allocate buf for spi page failed\n");
+		kfree(flash);
+		return -ENOMEM;
+	}
+#endif
+
+	ak_spinand_init_stat_reg(flash); 
+	ak_spinand_cfg_quad_mode(flash); 
+	init_spiflash_rw_info(flash);
+
+	flash->mtd.dev.parent = &spi->dev;
+	
+	dev_info(&spi->dev, "%s (%lld Kbytes)\n", info->name,
+			(long long)flash->mtd.size >> 10);
+
+	DEBUG(MTD_DEBUG_LEVEL0,
+		"mtd .name = %s, .size = 0x%llx (%lldMiB) "
+			".erasesize = 0x%.8x (%uKiB) .numeraseregions = %d\n",
+		flash->mtd.name,
+		(long long)flash->mtd.size, (long long)(flash->mtd.size >> 20),
+		flash->mtd.erasesize, flash->mtd.erasesize / 1024,
+		flash->mtd.numeraseregions);
+
+	if (flash->mtd.numeraseregions)
+		for (i = 0; i < flash->mtd.numeraseregions; i++)
+			DEBUG(MTD_DEBUG_LEVEL0,
+				"mtd.eraseregions[%d] = { .offset = 0x%llx, "
+				".erasesize = 0x%.8x (%uKiB), "
+				".numblocks = %d }\n",
+				i, (long long)flash->mtd.eraseregions[i].offset,
+				flash->mtd.eraseregions[i].erasesize,
+				flash->mtd.eraseregions[i].erasesize / 1024,
+				flash->mtd.eraseregions[i].numblocks);
+
+	//ak_spinand_cfg_protect(true);
+
+
+	/* partitions should match sector boundaries; and it may be good to
+	 * use readonly partitions for writeprotected sectors (BP2..BP0).
+	 */
+ 
+	ret = mtd_device_parse_register(&flash->mtd, NULL, NULL, NULL, 0);
+	if (ret) {
+		printk("Add root MTD device failed\n");
+		kfree(flash->buf);
+		kfree(flash);
+		return -EINVAL;
+	}	
+
+#ifndef CONFIG_MTD_SPINAND_PRODUCER		
+	ret = ak_mount_partitions(spi);
+	if (ret)
+		printk("Add MTD partitions failed\n");
+#endif
+    printk("Init AK SPI Flash finish.\n"); 
+
+	return 0;
+}
+
+/**
+* @brief	  spi nand remove
+* 
+* Remove the spi nand device driver from kernel.
+* @author lixinhai
+* @date 2014-03-20
+* @param[in] mtd	   spi device handle.
+* @return int return write success or failed
+* @retval returns zero on success
+* @retval return a non-zero error code if failed
+*/
+static int ak_spinand_remove(struct spi_device *spi)
+{
+	struct ak_spinand	*flash = dev_get_drvdata(&spi->dev);
+	int		status;
+	
+	status = mtd_device_unregister(&flash->mtd);
+/*	
+	if (mtd_has_partitions() && flash->partitioned)
+		status = del_mtd_partitions(&flash->mtd);
+
+	status = del_mtd_device(&flash->mtd);
+*/
+	if (status == 0) {
+		kfree(flash->buf);
+		kfree(flash);
+	}
+	return 0;
+}
+
+
+static const struct of_device_id spinand_of_table[] = {
+	{ .compatible = "anyka,ak-spinand" },
+	{}
+};
+
+
+MODULE_DEVICE_TABLE(of, spinand_of_table);
+
+
+static struct spi_driver ak_spinand_driver = {
+	.driver = {
+		.name	= "ak-spinand",
+		.bus	= &spi_bus_type,
+		.owner	= THIS_MODULE,
+		.of_match_table = spinand_of_table,
+	},
+	.probe	= ak_spinand_probe,
+	.remove	= ak_spinand_remove,
+
+	/* REVISIT: many of these chips have deep power-down modes, which
+	 * should clearly be entered on suspend() to minimize power use.
+	 * And also when they're otherwise idle...
+	 */
+};
+
+/**
+* @brief spi nand device init
+* 
+*  Moudle initial.
+* @author luoyongchuang
+* @date 2016-05-17
+* @return int return write success or failed
+* @retval returns zero on success
+* @retval return a non-zero error code if failed
+*/
+static int __init ak_spinand_init(void)
+{
+	printk("init Anyka SPI Nand Flash driver\n");
+	return spi_register_driver(&ak_spinand_driver);
+}
+
+
+/**
+* @brief spi nand device exit
+* 
+*  Moudle exit.
+* @author luoyongchuang
+* @date 2016-05-17
+* @return None
+*/
+static void __exit ak_spinand_exit(void)
+{
+	printk("exit Anyka SPI Nand Flash driver\n");	
+	spi_unregister_driver(&ak_spinand_driver);
+}
+
+
+module_init(ak_spinand_init);
+module_exit(ak_spinand_exit);
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Luoyongchuang");
+MODULE_DESCRIPTION("MTD SPI Nand flash driver for Anyka chips");
+
+
diff --git a/drivers/mtd/devices/ak_spiflash.c b/drivers/mtd/devices/ak_spiflash.c
new file mode 100755
index 0000000..11d8345
--- /dev/null
+++ b/drivers/mtd/devices/ak_spiflash.c
@@ -0,0 +1,2538 @@
+ /**
+ *  @file      /driver/mtd/devices/ak_SPIFlash.c
+ *  @brief     SPI Flash driver for Anyka AK37 platform.
+ *   Copyright C 2012 Anyka CO.,LTD
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *  @author    She Shaohua
+ *  @date      2012-03-23
+ *  @note      2011-03-20  created
+ *  @note      2011-03-23  Debug OK.
+ */
+
+
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/device.h>
+#include <linux/interrupt.h>
+#include <linux/mutex.h>
+#include <linux/math64.h>
+#include <linux/sched.h>
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/partitions.h>
+#include <linux/spi/spi.h>
+#include <linux/spi/flash.h>
+#include <linux/delay.h>
+#include <mach/anyka_types.h>
+
+#include <mach/map.h>
+#include <linux/of_device.h>
+#include <linux/of_irq.h>
+
+
+#include <linux/spinlock.h>
+#include <linux/mm.h>
+#include "../partition/partition_init.h"
+#include "../partition/partition_lib.h"
+#include "ak_partition_table.h" 
+
+//#define SPIFLASH_DEBUG
+#undef PDEBUG           
+#ifdef SPIFLASH_DEBUG
+#define PDEBUG(fmt, args...) printk( KERN_INFO fmt,## args)
+#define DEBUG(n, args...) printk(KERN_INFO args)
+#else
+#define PDEBUG(fmt, args...)
+#define DEBUG(n, args...) 
+#endif
+
+
+#define FHA_SUCCESS  				0
+#define FHA_FAIL     				-1
+#define SPI_FLASH_BIN_PAGE_START 	558
+#define FLASH_BUF_SIZE				(32*1024)
+#define FLASH_PAGESIZE				256
+#define SPI_FLASH_READ				1
+#define SPI_FLASH_WRITE				2
+#define CONFIG_SPIFLASH_USE_FAST_READ 1
+
+/*
+* mtd layer allocate memory use for 'vmalloc' interface, need to convert.
+*/
+//#define SPIFLASH_USE_MTD_BLOCK_LAYER  
+
+#define OPCODE_WREN  			0x06    /* Write Enable */ 
+#define OPCODE_WRDI     		0x04    /* Write Disable */ 
+#define OPCODE_RDSR1    		0x05    /* Read Status Register1 */
+#define OPCODE_RDSR2     		0x35    /* Read Status Register2 */ 
+#define OPCODE_RDSR3     		0x15    /* Read Status Register3 */ 
+#define XMC_OPCODE_RDSR2     	0x09    /* XMC Spi flash Read Status Register2 */ 
+#define XMC_OPCODE_RDSR3     	0x95    /* XMC Spi flash Read Status Register3 */ 
+
+#define OPCODE_WRSR1          	0x01    /* Write Status Register */ 
+#define OPCODE_WRSR2          	0x31    /* Write Status2 Register eg:gd25q128c*/ 
+#define OPCODE_WRSR3          	0x11    /* Write Status3 Register eg:gd25q128c*/ 
+#define XMC_OPCODE_WRSR3        0xC0    /* XMC Spi flash Write Status3 Register eg:gd25q128c*/ 
+
+#define OPCODE_NORM_READ     	0x03    /* Read Data Bytes */ 
+#define OPCODE_FAST_READ      	0x0b    /* Read Data Bytes at Higher Speed */ 
+#define OPCODE_FAST_D_READ     	0x3b    /* Read Data Bytes at Dual output */ 
+#define OPCODE_FAST_Q_READ     	0x6b    /* Read Data Bytes at Quad output */ 
+#define OPCODE_FAST_D_IO     	0xbb    /* Read Data Bytes at Dual i/o */ 
+#define OPCODE_FAST_Q_IO     	0xeb    /* Read Data Bytes at Quad i/o */ 
+
+#define OPCODE_PP            	0x02    /* Page Program */
+#define OPCODE_PP_DUAL			0x12	/* Dual Page Program*/
+#define OPCODE_PP_QUAD			0x32	/* Quad Page Program*/
+#define OPCODE_2IO_PP			0x18	/* 2I/O Page Program (tmp)*/
+#define OPCODE_4IO_PP			0x38	/* 4I/O Page Program*/
+
+#define OPCODE_BE_4K         	0x20    /* Sector (4K) Erase */ 
+#define OPCODE_BE_32K       	0x52    /* Block (32K) Erase */
+#define OPCODE_BE_64K          	0xd8    /* Block (64K) Erase */ 
+#define	OPCODE_SE				0xd8	/* Sector erase (usually 64KiB) */
+#define OPCODE_CHIP_ERASE     	0xc7    /* Chip Erase */ 
+#define	OPCODE_RDID				0x9f	/* Read JEDEC ID */
+#define OPCODE_DP           	0xb9    /* Deep Power-down */ 
+#define OPCODE_RES          	0xab    /* Release from DP, and Read Signature */ 
+
+/* 
+* Used for SST flashes only. 
+*/
+#define	OPCODE_BP				0x02	/* Byte program */
+#define	OPCODE_WRDI				0x04	/* Write disable */
+#define	OPCODE_AAI_WP			0xad	/* Auto address increment word program */
+
+#define SPI_STATUS_REG1	1
+#define SPI_STATUS_REG2	2
+#define SPI_STATUS_REG3	3
+
+
+/* 
+* Define max times to check status register before we give up. 
+*/
+#define	MAX_READY_WAIT_JIFFIES	(40 * HZ)	/* 40s max chip erase */
+
+#define	CMD_SIZE			(1)
+#define ADDR_SIZE			(3)
+#define CMD_ADDR_SIZE		(CMD_SIZE + ADDR_SIZE)
+#define MAX_DUMMY_SIZE		(4)
+#define MTD_PART_NAME_LEN 	(4)
+
+#ifdef CONFIG_SPIFLASH_USE_FAST_READ
+#define OPCODE_READ 			OPCODE_FAST_READ
+#define FAST_READ_DUMMY_BYTE 	1
+#else
+#define OPCODE_READ 			OPCODE_NORM_READ
+#define FAST_READ_DUMMY_BYTE 	0
+#endif
+
+#define ALIGN_DOWN(a, b)  (((a) / (b)) * (b))
+
+#define	SFLAG_UNDER_PROTECT			(1<<0)
+#define SFLAG_FAST_READ           	(1<<1)
+#define SFLAG_AAAI                	(1<<2)
+#define SFLAG_COM_STATUS2         	(1<<3)
+#define SFLAG_DUAL_IO_READ         	(1<<4)
+#define SFLAG_DUAL_READ           	(1<<5)
+#define SFLAG_QUAD_IO_READ         	(1<<6)
+#define SFLAG_QUAD_READ           	(1<<7)
+#define SFLAG_DUAL_IO_WRITE        	(1<<8)
+#define SFLAG_DUAL_WRITE          	(1<<9)
+#define SFLAG_QUAD_IO_WRITE        	(1<<10)
+#define SFLAG_QUAD_WRITE          	(1<<11)
+#define SFLAG_SECT_4K       		(1<<12)
+#define SFLAG_COM_STATUS3         	(1<<13)
+#define SFLAG_QUAD_NO_QE         	(1<<14)
+#define SFLAG_WR_STAT_MODE			(1<<15)
+/****************************************************************************/
+struct partitions
+{
+	char name[MTD_PART_NAME_LEN]; 		   
+	unsigned long long size;
+	unsigned long long offset;         
+	unsigned int mask_flags;
+}__attribute__((packed));
+
+typedef struct
+{
+    T_U32 BinPageStart; /*bin data start addr*/
+    T_U32 PageSize;     /*spi page size*/
+    T_U32 PagesPerBlock;/*page per block*/
+    T_U32 BinInfoStart;
+    T_U32 FSPartStart;
+}
+T_SPI_BURN_INIT_INFO;
+
+
+/*
+ * SPI device driver setup and teardown
+ */
+struct flash_info {
+	const char		*name;
+
+	/* JEDEC id zero means "no ID" (most older chips); otherwise it has
+	 * a high byte of zero plus three data bytes: the manufacturer id,
+	 * then a two byte device id.
+	 */
+	u32			jedec_id;
+	u16			ext_id;
+	u8			id_ver_c;
+
+	/* The size listed here is what works with OPCODE_SE, which isn't
+	 * necessarily called a "sector" by the vendor.
+	 */
+	unsigned	sector_size;
+	u16			n_sectors;
+
+	/**
+	 *  chip character bits:
+	 *  bit 0: under_protect flag, the serial flash under protection or not when power on
+	 *  bit 1: fast read flag, the serial flash support fast read or not(command 0Bh)
+	 *  bit 2: AAI flag, the serial flash support auto address increment word programming
+	 *  bit 3: support dual write or no
+	 *  bit 4: support dual read or no
+	 *  bit 5: support quad write or no
+	 *  bit 6: support quad read or no
+	 *  bit 7: the second status command (35h) flag,if use 4-wire(quad) mode,the bit must be is enable
+	 */
+	u16			flags;
+
+	struct device_node *child;
+};
+
+struct ak_spiflash;
+
+/**
+* because of some spi flash is difference of status register difinition.
+* this structure use mapping the status reg function and corresponding.
+*/
+struct flash_status_reg
+{
+	u32		jedec_id;	
+	u16		ext_id;
+	unsigned b_wip:4;		/*write in progress*/
+	unsigned b_wel:4;		/*write ebable latch*/
+	unsigned b_bp0:4;		/*block protected 0*/
+	unsigned b_bp1:4;		/*block protected 1*/
+	unsigned b_bp2:4;		/*block protected 2*/
+	unsigned b_bp3:4;		/*block protected 3*/
+	unsigned b_bp4:4;		/*block protected 4*/
+	unsigned b_srp0:4;		/*status register protect 0*/
+	
+	unsigned b_srp1:4;		/*status register protect 1*/
+	unsigned b_qe:4;		/*quad enable*/
+	unsigned b_lb:4;		/*write protect control and status to the security reg.*/
+/*
+*	unsigned b_reserved0:4;
+*	unsigned b_reserved1:4;
+*	unsigned b_reserved2:4;
+*/
+	unsigned b_cmp:4;		/*conjunction bp0-bp4 bit*/
+	unsigned b_sus:4;		/*exec an erase/program suspend command*/
+	u8	rd_status_cmd[4];
+	u8	wr_status_cmd[4];
+	u32  wr_status_mode;
+	u32  wr_status_flag;
+	u32 (*read_sr)(struct ak_spiflash *);
+	int (*write_sr)(struct ak_spiflash *, u32);
+};
+
+struct ak_spiflash {
+	struct spi_device	*spi;
+	struct mutex		lock;
+	struct flash_info	info;
+	struct mtd_info		mtd;
+	unsigned			partitioned:1;
+	
+	u8		bus_width;
+	unsigned char 		*buf;
+	u8		command[CMD_ADDR_SIZE + MAX_DUMMY_SIZE];
+	u8		dummy_len;
+
+	u8		erase_opcode;
+	u8		tx_opcode;
+	u8		rx_opcode;
+	u8		txd_bus_width;
+	u8		rxd_bus_width;
+	
+	u8		txa_bus_width;
+	u8		rxa_bus_width;	
+	struct flash_status_reg stat_reg;
+};
+
+#define CONFIG_SECTION_SIZE 4096    	// cdh:add for erase section size
+#define CONFIG_PARATION_TAB_SIZE 512    // cdh:add for paration table section size
+#define CONFIG_SPIP_START_PAGE 0    	// cdh:add for searching SPIP flag start flash offset address
+#define CONFIG_SPIP_PAGE_CNT  3     	// cdh:add for searching SPIP flag
+#define CONFIG_PARATION_PAGE_CNT  2     // cdh:add for searching  paration table page cnt
+
+#define FILL_CMD(c, val) do{c[0] = (val);}while(0)
+#define FILL_ADDR(c, val) do{	\
+		c[CMD_SIZE] = (val) >> 16;	\
+		c[CMD_SIZE+1] = (val) >> 8;	\
+		c[CMD_SIZE+2] = (val);		\
+		}while(0)
+		
+#define FILL_DUMMY_DATA(c, val) do{	\
+		c[CMD_ADDR_SIZE] = val >> 16;	\
+		c[CMD_ADDR_SIZE+1] = 0;	\
+		c[CMD_ADDR_SIZE+2] = 0;	\
+		c[CMD_ADDR_SIZE+3] = 0;	\
+		}while(0)
+
+
+static struct mtd_info *ak_mtd_info;
+
+static inline int write_enable(struct ak_spiflash *flash);
+static int wait_till_ready(struct ak_spiflash *flash);
+
+
+/**
+* @brief: because of the _read() function call by mtd block layer, the buffer be
+* allocate by vmalloc() in mtd layer, spi driver layer may use this buffer that 
+* intents of use for DMA transfer, so, add this function to transition buffer.
+* call this function at before real read/write data.
+* 
+* @author lixinhai
+* @date 2013-04-10
+* @param[in] *mtd :mtd infor.
+* @return:struct ak_spiflash: ak_spiflash struct infor
+* @retval ak_spiflash struct infor
+*/
+static inline struct ak_spiflash *mtd_to_spiflash(struct mtd_info *mtd)
+{
+	return container_of(mtd, struct ak_spiflash, mtd);
+}
+
+#ifdef SPIFLASH_USE_MTD_BLOCK_LAYER
+
+/**
+* @brief: because of the _read() function call by mtd block layer, the buffer be
+* allocate by vmalloc() in mtd layer, spi driver layer may use this buffer that 
+* intents of use for DMA transfer, so, add this function to transition buffer.
+* call this function at before real read/write data.
+* 
+* @author lixinhai
+* @date 2013-04-10
+* @param[in] flash  spiflash handle.
+* @param[in] buffer.
+* @param[in] buffer len
+* @param[in] dir:read/write
+* @return void
+* @retval none
+*/
+static void *flash_buf_bounce_pre(struct ak_spiflash *flash,
+				void *buf, u32 len, int dir)
+{
+	if(!is_vmalloc_addr(buf)) {
+		return buf;
+	}
+
+	if(dir == SPI_FLASH_WRITE) {
+		memcpy(flash->buf, buf, len);
+	}
+	
+	return flash->buf;
+}
+
+/**
+* @brief: because of the _read() function call by mtd block layer, the buffer be
+* allocate by vmalloc() in mtd layer, spi driver layer may use this buffer that 
+* intents of use for DMA transfer, so, add this function to transition buffer.
+* call this function at after real read/write data
+* 
+* @author lixinhai
+* @date 2013-04-10
+* @param[in] flash  spiflash handle.
+* @param[in] buffer.
+* @param[in] buffer len
+* @param[in] dir:read/write
+* @return void
+* @retval none
+*/
+static void flash_buf_bounce_post(struct ak_spiflash *flash,
+				void *buf, u32 len, int dir)
+{
+	if(!is_vmalloc_addr(buf)) {
+		return;
+	}
+
+	if(dir == SPI_FLASH_READ) {
+		memcpy(buf, flash->buf, len);
+	}
+}
+
+#else
+
+/**
+* @brief: because of the _read() function call by mtd block layer, the buffer be
+* allocate by vmalloc() in mtd layer, spi driver layer may use this buffer that 
+* intents of use for DMA transfer, so, add this function to transition buffer.
+* call this function at before real read/write data.
+* 
+* @author lixinhai
+* @date 2013-04-10
+* @param[in] flash  spiflash handle.
+* @param[in] buffer.
+* @param[in] buffer len
+* @param[in] dir:read/write
+* @return void
+* @retval none
+*/
+static inline void *flash_buf_bounce_pre(struct ak_spiflash *flash,
+				void *buf, u32 len, int dir)
+{
+	return buf;
+}
+
+/**
+* @brief: because of the _read() function call by mtd block layer, the buffer be
+* allocate by vmalloc() in mtd layer, spi driver layer may use this buffer that 
+* intents of use for DMA transfer, so, add this function to transition buffer.
+* call this function at after real read/write data
+* 
+* @author lixinhai
+* @date 2013-04-10
+* @param[in] flash  spiflash handle.
+* @param[in] buffer.
+* @param[in] buffer len
+* @param[in] dir:read/write
+* @return void
+* @retval none
+*/
+static inline void flash_buf_bounce_post(struct ak_spiflash *flash,
+				void *buf, u32 len, int dir)
+{
+	
+}
+
+#endif
+
+#if 0
+
+// cdh:add
+static u32 xm25qh64a_read_sr(struct ak_spiflash *flash)
+{
+	ssize_t retval;
+	u8 code;
+	u32 status;
+	u8 st_tmp= 0;
+
+	code = OPCODE_RDSR1;
+	if((retval = spi_write_then_read(flash->spi, &code, 1, &st_tmp, 1))<0)
+		return retval;
+
+	status = st_tmp;
+	if(flash->info.flags & SFLAG_COM_STATUS2){
+		code = XMC_OPCODE_RDSR2;
+		if((retval = spi_write_then_read(flash->spi, &code, 1, &st_tmp, 1))<0)
+			return retval;
+		
+		 status = (status | (st_tmp << 8));		
+	}
+
+   	if(flash->info.flags & SFLAG_COM_STATUS3){
+		code = XMC_OPCODE_RDSR3;
+		if((retval = spi_write_then_read(flash->spi, &code, 1, &st_tmp, 1))<0)
+			return retval;
+		
+		 status = (status | (st_tmp << 16));		
+	}
+
+	return status;
+}
+
+static int xm25qh64a_write_sr(struct ak_spiflash *flash, u32 val)
+{
+	int ret;
+
+	wait_till_ready(flash);
+	write_enable(flash);
+	flash->command[0] = OPCODE_WRSR1;
+	flash->command[1] = val & 0xff;
+	ret = spi_write(flash->spi, flash->command, 2);
+
+#if 0
+	wait_till_ready(flash);
+	write_enable(flash);
+	flash->command[0] = XMC_OPCODE_WRSR3;
+	flash->command[1] = (val>>8) &0xff;
+	ret |= spi_write(flash->spi, flash->command, 2);
+	wait_till_ready(flash);
+#endif
+	return ret;
+}
+
+static int gd25q64c_write_sr(struct ak_spiflash *flash, u32 val)
+{
+	int ret;
+
+	wait_till_ready(flash);
+	write_enable(flash);
+	flash->command[0] = OPCODE_WRSR1;
+	flash->command[1] = val & 0xff;
+	ret = spi_write(flash->spi, flash->command, 2);
+
+	wait_till_ready(flash);
+	write_enable(flash);
+	flash->command[0] = OPCODE_WRSR2;
+	flash->command[1] = (val>>8) &0xff;
+	ret |= spi_write(flash->spi, flash->command, 2);
+	wait_till_ready(flash);
+
+	return ret;
+}
+
+/**
+* @brief: for gd25q128c spi norflash write status
+* 
+* @author lixinhai
+* @date 2013-04-10
+* @param[in] *flash:  spiflash handle.
+* @param[in] val: status value
+* @return int
+* @retval ret:return write cnt
+*/
+static int gd25q128c_write_sr(struct ak_spiflash *flash, u32 val)
+{
+	int ret;
+
+	wait_till_ready(flash);
+	write_enable(flash);
+	flash->command[0] = OPCODE_WRSR1;
+	flash->command[1] = val & 0xff;
+	ret = spi_write(flash->spi, flash->command, 2);
+
+	wait_till_ready(flash);
+	write_enable(flash);
+	flash->command[0] = OPCODE_WRSR2;
+	flash->command[1] = (val>>8) &0xff;
+	ret |= spi_write(flash->spi, flash->command, 2);
+	wait_till_ready(flash);
+
+	return ret;
+}
+
+/**
+* @brief: for normal spi norflash read status
+* 
+* @author lixinhai
+* @date 2013-04-10
+* @param[in] *flash:  spiflash handle.
+* @return u32
+* @retval ret:return read spi norflash status value
+*/
+static u32 normal_read_sr(struct ak_spiflash *flash)
+{
+	ssize_t retval;
+	u8 code;
+	u32 status;
+	u8 st_tmp= 0;
+
+	code = OPCODE_RDSR1;
+
+	if((retval = spi_write_then_read(flash->spi, &code, 1, &st_tmp, 1))<0)
+		return retval;
+
+	status = st_tmp;
+	if(flash->info.flags & SFLAG_COM_STATUS2){
+		code = OPCODE_RDSR2;
+		if((retval = spi_write_then_read(flash->spi, &code, 1, &st_tmp, 1))<0)
+			return retval;
+		
+		 status = (status | (st_tmp << 8));		
+	}
+
+   	if(flash->info.flags & SFLAG_COM_STATUS3){
+		code = OPCODE_RDSR3;
+		if((retval = spi_write_then_read(flash->spi, &code, 1, &st_tmp, 1))<0)
+			return retval;
+		
+		 status = (status | (st_tmp << 16));		
+	}
+
+	return status;
+}
+#endif
+
+
+static u32 ak_normal_read_sr(struct ak_spiflash *flash)
+{
+	ssize_t retval;
+	u8 code;
+	u32 status;
+	u8 st_tmp= 0;
+
+	/*
+	* OPCODE_RDSR1:the first read status cmd
+	*/
+	code = flash->stat_reg.rd_status_cmd[0];
+	if((retval = spi_write_then_read(flash->spi, &code, 1, &st_tmp, 1))<0){
+		return retval;
+	}
+	status = st_tmp;
+	if(flash->info.flags & SFLAG_COM_STATUS2){
+		code = flash->stat_reg.rd_status_cmd[1];
+		if((retval = spi_write_then_read(flash->spi, &code, 1, &st_tmp, 1))<0){
+			printk(KERN_ERR"%s,line:%d\n", __func__, __LINE__);
+			return retval;
+		}
+		status = (status | (st_tmp << 8));		
+	}
+
+   	if(flash->info.flags & SFLAG_COM_STATUS3){
+		code = flash->stat_reg.rd_status_cmd[2];
+		if((retval = spi_write_then_read(flash->spi, &code, 1, &st_tmp, 1))<0){
+			return retval;
+		}
+		status = (status | (st_tmp << 16));
+	}
+
+	return status;
+}
+
+
+#if 0
+/**
+* @brief: for normal spi norflash write status
+* 
+* @author lixinhai
+* @date 2013-04-10
+* @param[in] *flash:  spiflash handle.
+* @param[in] val: status value
+* @return int
+* @retval ret:return write cnt
+*/
+static int normal_write_sr(struct ak_spiflash *flash, u32 val)
+{
+	int wr_cnt;
+
+	flash->command[0] = OPCODE_WRSR1;
+	flash->command[1] = val & 0xff;
+	flash->command[2] = (val>>8) &0xff;
+	
+    if (flash->info.flags & SFLAG_COM_STATUS2) {
+        wr_cnt = 3;
+    } else {
+        wr_cnt = 2;
+    }
+
+	return spi_write(flash->spi, flash->command, wr_cnt);
+}
+#endif
+
+static int ak_normal_write_sr(struct ak_spiflash *flash, u32 val)
+{
+	int wr_cnt;
+	int ret;
+
+	if(flash->stat_reg.wr_status_mode == 0){
+		flash->command[0] = flash->stat_reg.wr_status_cmd[0];//OPCODE_WRSR1;
+		flash->command[1] = val & 0xff;
+		flash->command[2] = (val>>8) &0xff;
+
+		if (flash->info.flags & SFLAG_COM_STATUS2) {
+		    wr_cnt = 3;
+		} else {
+		    wr_cnt = 2;
+		}
+		return spi_write(flash->spi, flash->command, wr_cnt);
+	}else{	
+		wait_till_ready(flash);
+		write_enable(flash);
+		flash->command[0] = flash->stat_reg.wr_status_cmd[0]; //OPCODE_WRSR1;
+		flash->command[1] = val & 0xff;
+		ret = spi_write(flash->spi, flash->command, 2);
+
+		if(flash->stat_reg.wr_status_flag & 0x2){
+			wait_till_ready(flash);
+			write_enable(flash);
+			flash->command[0] = flash->stat_reg.wr_status_cmd[1]; //OPCODE_WRSR2;
+			flash->command[1] = (val>>8) &0xff;
+			ret |= spi_write(flash->spi, flash->command, 2);
+			wait_till_ready(flash);
+		}
+
+		return ret;
+	}
+
+}
+
+
+/**
+* @brief Read the status register.
+* 
+*  returning its value in the location
+* @author SheShaohua
+* @date 2012-03-20
+* @param[in] spiflash handle.
+* @return int 
+* @retval Return the status register value.
+*/
+static u32 read_sr(struct ak_spiflash *flash)
+{
+	struct flash_status_reg *fsr = &flash->stat_reg;
+
+	if(fsr && fsr->read_sr)
+		return fsr->read_sr(flash);
+
+	return -EINVAL;
+}
+
+
+/**
+* @brief Write status register
+* 
+*  Write status register 1 byte.
+* @author SheShaohua
+* @date 2012-03-20
+* @param[in] flash  spiflash handle.
+* @param[in] val  register value to be write.
+* @return int return write success or failed
+* @retval returns zero on success
+* @retval return a negative error code if failed
+*/
+static int write_sr(struct ak_spiflash *flash, u32 val)
+{
+	struct flash_status_reg *fsr = &flash->stat_reg;
+
+	if(fsr && fsr->write_sr)
+		return fsr->write_sr(flash, val);
+
+	return -EINVAL;
+}
+
+
+/**
+* @brief Set write enable latch.
+* 
+*  Set write enable latch with Write Enable command.
+* @author SheShaohua
+* @date 2012-03-20
+* @param[in] flash  spiflash handle.
+* @return int return write success or failed
+* @retval returns zero on success
+* @retval return a negative error code if failed
+*/
+static inline int write_enable(struct ak_spiflash *flash)
+{
+	u8	code = OPCODE_WREN;
+
+	return spi_write_then_read(flash->spi, &code, 1, NULL, 0);
+}
+
+
+/**
+* @brief Set write disble
+* 
+*  Set write disble instruction to the chip.
+* @author SheShaohua
+* @date 2012-03-20
+* @param[in] flash	spiflash handle.
+* @return int return write success or failed
+* @retval returns zero on success
+* @retval return a negative error code if failed
+*/
+static inline int write_disable(struct ak_spiflash *flash)
+{
+	u8	code = OPCODE_WRDI;
+
+	return spi_write_then_read(flash->spi, &code, 1, NULL, 0);
+}
+
+/**
+* @brief  Wait for SPI flash ready.
+* 
+*  Service routine to read status register until ready, or timeout occurs.
+* @author SheShaohua
+* @date 2012-03-20
+* @param[in] flash	spiflash handle.
+* @return int return write success or failed
+* @retval returns zero on success
+* @retval return a non-zero error code if failed
+*/
+static int wait_till_ready(struct ak_spiflash *flash)
+{
+	unsigned long deadline;
+	u32 sr;
+	struct flash_status_reg *fsr = &flash->stat_reg;
+
+	deadline = jiffies + MAX_READY_WAIT_JIFFIES;
+
+	do {
+		if ((sr = read_sr(flash)) < 0)
+			break;
+		else if (!(sr & (1<<fsr->b_wip)))
+			return 0;
+
+		cond_resched();
+
+	} while (!time_after_eq(jiffies, deadline));
+
+	return 1;
+}
+
+
+
+/**
+* @brief  enable spi norflash quad 4 wires mode.
+* 
+* enable spi norflash quad 4 wires mode can set  spi norflash spi_wp and spi_hold share pin as data io
+* @author SheShaohua
+* @date 2012-03-20
+* @param[in] flash	spiflash handle.
+* @return int return write success or failed
+* @retval returns zero on success
+* @retval return a non-zero error code if failed
+*/
+static int quad_mode_enable(struct ak_spiflash *flash)
+{
+	int ret;
+	u32 regval;	
+	struct flash_status_reg *fsr = &flash->stat_reg;
+	
+	ret = wait_till_ready(flash);
+	if (ret){
+		printk(KERN_ERR"%s,line:%d\n", __func__, __LINE__);
+		return -EBUSY;
+	}
+	//printk(KERN_ERR"%s,line:%d\n", __func__, __LINE__);
+	ret = write_enable(flash);
+	if (ret){
+		printk(KERN_ERR"%s,line:%d\n", __func__, __LINE__);
+		return -EIO;
+	}
+	
+	regval = read_sr(flash);
+	regval |= 1<<fsr->b_qe;
+	write_sr(flash, regval);
+
+	write_disable(flash);
+	
+	return 0;
+}
+
+
+/**
+* @brief  disable spi norflash quad 4 wires mode.
+* 
+* disable spi norflash quad 4 wires mode can set data io share pin as spi norflash spi_wp and spi_hold  
+* @author SheShaohua
+* @date 2012-03-20
+* @param[in] flash	spiflash handle.
+* @return int return write success or failed
+* @retval returns zero on success
+* @retval return a non-zero error code if failed
+*/
+#if 0
+static int quad_mode_disable(struct ak_spiflash *flash)
+{
+	int ret;
+	u32 regval;
+	struct flash_status_reg *fsr = &flash->stat_reg;
+		
+	ret = wait_till_ready(flash);
+	if (ret)
+		return -EBUSY;
+	
+	write_enable(flash);
+	
+	regval = read_sr(flash);
+	regval &= ~(1<<fsr->b_qe);
+	write_sr(flash, regval);
+
+	write_disable(flash);
+	return 0;
+}
+#endif
+
+/**
+* @brief   Erase chip
+* 
+*  Erase the whole flash memory.
+* @author SheShaohua
+* @date 2012-03-20
+* @param[in] flash	spiflash handle.
+* @return int return write success or failed
+* @retval returns zero on success
+* @retval return a non-zero error code if failed
+*/
+static int erase_chip(struct ak_spiflash *flash)
+{
+	DEBUG(MTD_DEBUG_LEVEL3, "%s: %s %lldKiB\n",
+	      dev_name(&flash->spi->dev), __func__,
+	      (long long)(flash->mtd.size >> 10));
+
+	/* Wait until finished previous write command. */
+	if (wait_till_ready(flash))
+		return -EBUSY;
+
+	/* Send write enable, then erase commands. */
+	write_enable(flash);
+
+	/* Set up command buffer. */
+	flash->command[0] = OPCODE_CHIP_ERASE;
+
+	spi_write(flash->spi, flash->command, 1);
+
+	return 0;
+}
+
+
+
+/**
+* @brief  Erase sector
+* 
+*  Erase a sector specialed by user.
+* @author SheShaohua
+* @date 2012-03-20
+* @param[in] flash	    spiflash handle.
+* @param[in] offset    which is any address within the sector which should be erased.
+* @return int return write success or failed
+* @retval returns zero on success
+* @retval return a non-zero error code if failed
+*/
+static int erase_sector(struct ak_spiflash *flash, u32 offset)
+{
+	DEBUG(MTD_DEBUG_LEVEL3, "%s: %s %dKiB at 0x%08x\n",
+			dev_name(&flash->spi->dev), __func__,
+			flash->mtd.erasesize / 1024, offset);
+
+	/* Wait until finished previous write command. */
+	if (wait_till_ready(flash))
+		return -EBUSY;
+
+	/* Send write enable, then erase commands. */
+	write_enable(flash);
+
+	/* Set up command buffer. */
+	flash->command[0] = flash->erase_opcode;
+	flash->command[1] = offset >> 16;
+	flash->command[2] = offset >> 8;
+	flash->command[3] = offset;
+
+	spi_write(flash->spi, flash->command, CMD_ADDR_SIZE);
+
+	return 0;
+}
+
+
+
+/**
+* @brief  MTD Erase
+* 
+* Erase an address range on the flash chip.
+* @author SheShaohua
+* @date 2012-03-20
+* @param[in] mtd    mtd info handle.
+* @param[in] instr   erase info.
+* @return int return write success or failed
+* @retval returns zero on success
+* @retval return a non-zero error code if failed
+*/
+static int ak_spiflash_erase(struct mtd_info *mtd, struct erase_info *instr)
+{
+	struct ak_spiflash *flash = mtd_to_spiflash(mtd);
+	u32 addr,len;
+	uint32_t rem;
+
+	//printk("%s: instr->len=%lld, mtd->erasesize=%ld, addr=%lld\n", __func__, instr->len,mtd->erasesize,(long long)instr->addr);
+
+	DEBUG(MTD_DEBUG_LEVEL2, "%s: %s %s 0x%llx, len %lld\n",
+	      dev_name(&flash->spi->dev), __func__, "at",
+	      (long long)instr->addr, (long long)instr->len);
+
+	/* sanity checks */
+	if (instr->addr + instr->len > mtd->size) {
+		printk(KERN_ERR "ak_spiflash_erase:instr->addr[0x%llx] + instr->len[%lld] > mtd->size[%lld]\n",
+			instr->addr, instr->len, mtd->size );
+		return -EINVAL;
+	}
+	
+	div_u64_rem(instr->len, mtd->erasesize, &rem);
+	if (rem != 0) {
+		printk(KERN_ERR "ak_spiflash_erase:rem!=0 [%u]\n", rem );
+		return -EINVAL;
+	}
+
+	addr = instr->addr;
+	len = instr->len;
+
+	mutex_lock(&flash->lock);
+
+	/* whole-chip erase? */
+	if (len == mtd->size) {
+		if (erase_chip(flash)) {
+			instr->state = MTD_ERASE_FAILED;
+			mutex_unlock(&flash->lock);
+			return -EIO;
+		}
+
+		/* REVISIT in some cases we could speed up erasing large regions
+		 * by using OPCODE_SE instead of OPCODE_BE_4K.  We may have set up
+		 * to use "small sector erase", but that's not always optimal.
+		 */
+
+		/* "sector"-at-a-time erase */
+	} else {
+		while (len) {
+			if (erase_sector(flash, addr)) {
+				instr->state = MTD_ERASE_FAILED;
+				mutex_unlock(&flash->lock);
+				return -EIO;
+			}
+
+			addr += mtd->erasesize;
+			len -= mtd->erasesize;
+		}
+	}
+
+	mutex_unlock(&flash->lock);
+
+	instr->state = MTD_ERASE_DONE;
+	mtd_erase_callback(instr);
+
+	return 0;
+}
+
+/**
+* @brief  init spiflash read and write cmd and data bus width info
+* 
+* @author SheShaohua
+* @date 2012-03-20
+* @param[in] flash	    spiflash handle.
+* @return int return init success or failed
+* @retval returns zero on success
+* @retval return a non-zero error code if failed
+*/
+static int init_spiflash_rw_info(struct ak_spiflash *flash)
+{
+	/**default param.*/
+	flash->rx_opcode = OPCODE_READ;
+	flash->rxd_bus_width = SPI_NBITS_SINGLE;
+	flash->rxa_bus_width = SPI_NBITS_SINGLE;
+	flash->tx_opcode = OPCODE_PP;
+	flash->txd_bus_width = SPI_NBITS_SINGLE;
+	flash->txa_bus_width = SPI_NBITS_SINGLE;
+	flash->dummy_len = 1;
+
+	/* force bus_width to  1 wire mode */
+	flash->bus_width = FLASH_BUS_WIDTH_1WIRE;
+	
+	if(flash->bus_width & FLASH_BUS_WIDTH_2WIRE){
+		if(flash->info.flags & SFLAG_DUAL_READ) {
+			flash->rx_opcode = OPCODE_FAST_D_READ;
+			flash->rxd_bus_width = SPI_NBITS_DUAL;
+			flash->rxa_bus_width = SPI_NBITS_SINGLE;
+			flash->dummy_len = 1;
+		} else if (flash->info.flags & SFLAG_DUAL_IO_READ) {
+			flash->rx_opcode = OPCODE_FAST_D_IO;
+			flash->rxd_bus_width = SPI_NBITS_DUAL;
+			flash->rxa_bus_width = SPI_NBITS_DUAL;
+			flash->dummy_len = 1;
+		}
+
+		if(flash->info.flags & SFLAG_DUAL_WRITE) {
+			flash->tx_opcode = OPCODE_PP_DUAL;
+			flash->txd_bus_width = SPI_NBITS_DUAL;
+			flash->txa_bus_width = SPI_NBITS_SINGLE;
+		} else if(flash->info.flags & SFLAG_DUAL_IO_WRITE) {
+			flash->tx_opcode = OPCODE_2IO_PP;
+			flash->txd_bus_width = SPI_NBITS_DUAL;
+			flash->txa_bus_width = SPI_NBITS_DUAL;
+		}	
+	}
+
+	if(flash->bus_width & FLASH_BUS_WIDTH_4WIRE){
+		if(flash->info.flags & SFLAG_QUAD_READ) {
+			flash->rx_opcode = OPCODE_FAST_Q_READ;
+			flash->rxd_bus_width = SPI_NBITS_QUAD;
+			flash->rxa_bus_width = SPI_NBITS_SINGLE;
+			flash->dummy_len = 1;
+		}else if(flash->info.flags & SFLAG_QUAD_IO_READ){
+			flash->rx_opcode = OPCODE_FAST_Q_IO;
+			flash->rxd_bus_width = SPI_NBITS_QUAD;
+			flash->rxa_bus_width = SPI_NBITS_QUAD;
+			flash->dummy_len = 3;
+		}
+
+		if(flash->info.flags & SFLAG_QUAD_WRITE) {
+			flash->tx_opcode = OPCODE_PP_QUAD;
+			flash->txd_bus_width = SPI_NBITS_QUAD;			
+			flash->txa_bus_width = SPI_NBITS_SINGLE;
+		}else if(flash->info.flags & SFLAG_QUAD_IO_WRITE) {
+			flash->tx_opcode = OPCODE_4IO_PP;
+			flash->txd_bus_width = SPI_NBITS_QUAD;
+			flash->txa_bus_width = SPI_NBITS_QUAD;
+		}
+	}
+	
+	return 0;
+}
+
+/**
+* @brief  cfg spi norflash into quad mode
+* 
+* @author SheShaohua
+* @date 2012-03-20
+* @param[in] flash	    spiflash handle.
+* @return int return init success or failed
+* @retval returns zero on success
+* @retval return a non-zero error code if failed
+*/
+static int ak_spiflash_cfg_quad_mode(struct ak_spiflash *flash)
+{
+	int ret = 0;
+ 
+	if((flash->bus_width & FLASH_BUS_WIDTH_4WIRE) && 
+		(flash->info.flags & (SFLAG_QUAD_WRITE|SFLAG_QUAD_IO_WRITE|
+			SFLAG_QUAD_READ|SFLAG_QUAD_IO_READ))) {		
+		if((flash->info.flags&SFLAG_QUAD_NO_QE) != SFLAG_QUAD_NO_QE){
+			ret = quad_mode_enable(flash);
+			if(ret) {
+				flash->bus_width &= ~FLASH_BUS_WIDTH_4WIRE;
+				printk(KERN_ERR"config the spiflash quad enable fail. transfer use 1 wire.\n");
+			}
+		}
+	}else {
+		if (flash->info.flags & (SFLAG_QUAD_WRITE|SFLAG_QUAD_IO_WRITE|
+			SFLAG_DUAL_READ|SFLAG_DUAL_IO_READ)){
+			if((flash->info.flags&SFLAG_QUAD_NO_QE) != SFLAG_QUAD_NO_QE){
+			    ret = quad_mode_enable(flash); // cdh: test KH 1 WIRE for pin7 is not spi_hold but reset
+			    if(ret) {
+					printk(KERN_ERR"config the spiflash quad enable fail.\n");
+			    }
+             }
+        }
+	}
+
+	return ret;
+}
+
+
+/**
+* @brief  spi norflash read 
+* 
+* spi norflash read operation
+* @author SheShaohua
+* @date 2012-03-20
+* @param[in] mtd    mtd info handle.
+* @param[in] from   spi norflash read offset.
+* @param[in] len 	  read len
+* @param[in] retlen  return real read len
+* @param[in] buf    read data buffer
+* @return int return write success or failed
+* @retval returns zero on success
+* @retval return a non-zero error code if failed
+*/
+static int spiflash_read(struct mtd_info *mtd, loff_t from, size_t len,
+		size_t *retlen, u_char *buf)
+{
+	struct ak_spiflash *flash = mtd_to_spiflash(mtd);
+	struct spi_transfer t[3];
+	struct spi_message m;
+	void *bounce_buf;
+
+	spi_message_init(&m);
+	memset(t, 0, (sizeof t));
+	
+	mutex_lock(&flash->lock);
+
+	bounce_buf = flash_buf_bounce_pre(flash, buf, len, SPI_FLASH_READ);
+
+	t[0].tx_buf = flash->command;
+	t[0].len = CMD_SIZE;
+	spi_message_add_tail(&t[0], &m);
+
+	t[1].tx_buf = &flash->command[CMD_SIZE];
+	t[1].len = ADDR_SIZE + flash->dummy_len;
+	//t[1].xfer_mode = flash->rxa_bus_width;
+	spi_message_add_tail(&t[1], &m);
+
+	t[2].rx_buf = bounce_buf;
+	t[2].len = len;	
+	t[2].cs_change = 0; //1;	
+	//t[2].xfer_mode = flash->rxd_bus_width;
+
+	spi_message_add_tail(&t[2], &m);
+
+	/* Byte count starts at zero. */
+	if (retlen)
+		*retlen = 0;
+
+	/* Wait till previous write/erase is done. */
+	if (wait_till_ready(flash)) {
+		/* REVISIT status return?? */		
+		mutex_unlock(&flash->lock);
+		return -EBUSY;
+	}
+
+	/* Set up the write data buffer. */
+	FILL_CMD(flash->command, flash->rx_opcode);
+	FILL_ADDR(flash->command, from);
+	FILL_DUMMY_DATA(flash->command, 0x00);
+
+	spi_sync(flash->spi, &m);
+
+	*retlen = m.actual_length - CMD_ADDR_SIZE - flash->dummy_len;
+	
+	flash_buf_bounce_post(flash, buf, len, SPI_FLASH_READ);
+	
+	mutex_unlock(&flash->lock);
+
+	return 0;
+}
+
+/**
+* @brief  mtd every time spi norflash read 
+* 
+* mtd spi norflash read operation
+* @author SheShaohua
+* @date 2012-03-20
+* @param[in] mtd    mtd info handle.
+* @param[in] from   spi norflash read offset.
+* @param[in] len 	  read len
+* @param[out] retlen  return real read len
+* @param[out] buf    read data buffer
+* @return int return write success or failed
+* @retval returns zero on success
+* @retval return a non-zero error code if failed
+*/
+static int ak_spiflash_read(struct mtd_info *mtd, loff_t from, size_t len,
+		size_t *retlen, u_char *buf)
+{
+	int ret = 0;
+	size_t rlen = 0;
+	u32 xfer_len;
+	u32 offset = 0;
+	u32 count = len;
+
+    
+	while(count > 0) {
+		xfer_len = (count > FLASH_BUF_SIZE) ? FLASH_BUF_SIZE : count;
+
+		if(xfer_len > FLASH_PAGESIZE)
+			xfer_len = ALIGN_DOWN(xfer_len, FLASH_PAGESIZE);
+
+		ret = spiflash_read(mtd, from + offset, xfer_len, &rlen, buf + offset);
+		if(unlikely(ret)) {
+			ret = -EBUSY;
+			goto out;
+		}
+		
+		*retlen += rlen;
+		count -= rlen;		
+		offset += rlen;
+	}	
+out:
+	return ret;
+}
+
+
+/**
+* @brief   MTD write
+* 
+* Write an address range to the flash chip.
+* @author SheShaohua
+* @date 2012-03-20
+* @param[in] mtd	mtd info handle.
+* @param[in] to 	write start address.
+* @param[in] len	write length.
+* @param[out] retlen  write length at actually.
+* @param[in] buf	   the pointer to write data.
+* @return int return write success or failed
+* @retval returns zero on success
+* @retval return a non-zero error code if failed
+*/
+static int ak_spiflash_write(struct mtd_info *mtd, loff_t to, size_t len,
+	size_t *retlen, const u_char *buf)
+{
+	u32 page_offset;
+	u32 page_size;
+	struct ak_spiflash *flash = mtd_to_spiflash(mtd);
+	struct spi_transfer t[3];
+	struct spi_message m;
+	void *bounce_buf;
+
+	DEBUG(MTD_DEBUG_LEVEL2, "%s: %s %s 0x%08x, len %zd\n",
+			dev_name(&flash->spi->dev), __func__, "to",
+			(u32)to, len);
+
+	if (retlen)
+		*retlen = 0;
+
+	/* sanity checks */
+	if (!len)
+		return(0);
+
+	if (to + len > mtd->size)
+		return -EINVAL;
+
+	spi_message_init(&m);
+	memset(t, 0, (sizeof t));
+	
+	mutex_lock(&flash->lock);
+	bounce_buf = flash_buf_bounce_pre(flash, (void*)buf, len, SPI_FLASH_WRITE);
+
+	t[0].tx_buf = flash->command;
+	t[0].len = CMD_SIZE;
+	spi_message_add_tail(&t[0], &m);
+
+	t[1].tx_buf = &flash->command[CMD_SIZE];
+	t[1].len = ADDR_SIZE;
+	//t[1].xfer_mode = flash->txa_bus_width;
+	spi_message_add_tail(&t[1], &m);
+
+	t[2].tx_buf = bounce_buf;
+	t[2].cs_change = 0;//1;
+	//t[2].xfer_mode = flash->txd_bus_width;
+
+	spi_message_add_tail(&t[2], &m);
+
+	//memcpy(flash->buf, buf, len);
+
+	/* Wait until finished previous write command. */
+	if (wait_till_ready(flash)) {
+		mutex_unlock(&flash->lock);
+		return 1;
+	}
+
+	write_enable(flash);
+
+	/* Set up the opcode in the write buffer. */
+	FILL_CMD(flash->command, flash->tx_opcode);
+	FILL_ADDR(flash->command, to);
+
+	/* what page do we start with? */
+	page_offset = to % FLASH_PAGESIZE;
+
+	/* do all the bytes fit onto one page? */
+	if (page_offset + len <= FLASH_PAGESIZE) {
+		t[2].len = len;
+
+		spi_sync(flash->spi, &m);
+
+		*retlen = m.actual_length - CMD_ADDR_SIZE;
+	} else {
+		u32 i;
+
+		/* the size of data remaining on the first page */
+		page_size = FLASH_PAGESIZE - page_offset;
+
+		t[2].len = page_size;
+		spi_sync(flash->spi, &m);
+
+		*retlen = m.actual_length - CMD_ADDR_SIZE;
+
+		/* write everything in PAGESIZE chunks */
+		for (i = page_size; i < len; i += page_size) {
+			page_size = len - i;
+			if (page_size > FLASH_PAGESIZE)
+				page_size = FLASH_PAGESIZE;
+
+			/* write the next page to flash */
+			FILL_ADDR(flash->command, to+i);
+
+			t[2].tx_buf = buf + i;
+			t[2].len = page_size;
+
+			wait_till_ready(flash);
+
+			write_enable(flash);
+
+			spi_sync(flash->spi, &m);
+
+			if (retlen)
+				*retlen += m.actual_length - CMD_ADDR_SIZE;
+		}
+	}
+
+	PDEBUG("ak_spiflash_write: retlen=%ld\n", *retlen);
+	flash_buf_bounce_post(flash, (void*)buf, len, SPI_FLASH_WRITE);
+
+	mutex_unlock(&flash->lock);
+
+	return 0;
+}
+
+/**
+* @brief	MTD get device ID
+* 
+* get the device ID of  the spi flash chip.
+* @author SheShaohua
+* @date 2012-03-20
+* @param[in] mtd	 mtd info handle.
+* @return int return device ID of  the spi flash chip.
+*/
+static int ak_spiflash_get_devid(struct mtd_info *mtd)
+{
+	struct ak_spiflash *flash = mtd_to_spiflash(mtd);
+	int			ret;
+	u8			code = OPCODE_RDID;
+	u8			id[5];
+	u32			jedec;
+
+	/* Wait until finished previous write command. */
+	if (wait_till_ready(flash))
+		return -EBUSY;
+
+	/* 
+	* JEDEC also defines an optional "extended device information"
+	* string for after vendor-specific data, after the three bytes
+	* we use here.  Supporting some chips might require using it.
+	*/
+	ret = spi_write_then_read(flash->spi, &code, 1, id, 3);
+	if (ret < 0) {
+		DEBUG(MTD_DEBUG_LEVEL0, "%s: error %d ak_spiflash_get_devid\n",
+			dev_name(&flash->spi->dev), ret);
+		return -EINVAL;
+	}
+
+	jedec = id[0] | (id[1]<<8) | (id[2]<<16);
+	printk("spi flash ID: 0x%08x\n", jedec);
+
+	return jedec;
+}
+
+
+ /**
+ * @brief	MTD write only for SST spi flash.
+ * 
+ * Write an address range to the flash chip.
+ * @author SheShaohua
+ * @date 2012-03-20
+ * @param[in] mtd	 mtd info handle.
+ * @param[in] to	 write start address.
+ * @param[in] len	 write length.
+ * @param[out] retlen  write length at actually.
+ * @param[out] buf		the pointer to write data.
+ * @return int return write success or failed
+ * @retval returns zero on success
+ * @retval return a non-zero error code if failed
+ */
+static int sst_write(struct mtd_info *mtd, loff_t to, size_t len,
+		size_t *retlen, const u_char *buf)
+{
+	struct ak_spiflash *flash = mtd_to_spiflash(mtd);
+	struct spi_transfer t[2];
+	struct spi_message m;
+	size_t actual;
+	int cmd_sz, ret;
+
+	if (retlen)
+		*retlen = 0;
+
+	/* sanity checks */
+	if (!len)
+		return 0;
+
+	if (to + len > flash->mtd.size)
+		return -EINVAL;
+
+	spi_message_init(&m);
+	memset(t, 0, (sizeof t));
+
+	t[0].tx_buf = flash->command;
+	t[0].len = CMD_ADDR_SIZE;
+	spi_message_add_tail(&t[0], &m);
+
+	t[1].tx_buf = buf;
+	spi_message_add_tail(&t[1], &m);
+
+	mutex_lock(&flash->lock);
+
+	/* Wait until finished previous write command. */
+	ret = wait_till_ready(flash);
+	if (ret)
+		goto time_out;
+
+	write_enable(flash);
+
+	actual = to % 2;
+	
+	/* Start write from odd address. */
+	if (actual) {
+		flash->command[0] = OPCODE_BP;
+		flash->command[1] = to >> 16;
+		flash->command[2] = to >> 8;
+		flash->command[3] = to;
+
+		/* write one byte. */
+		t[1].len = 1;
+		spi_sync(flash->spi, &m);
+		ret = wait_till_ready(flash);
+		if (ret)
+			goto time_out;
+		*retlen += m.actual_length - CMD_ADDR_SIZE;
+	}
+	to += actual;
+
+	flash->command[0] = OPCODE_AAI_WP;
+	flash->command[1] = to >> 16;
+	flash->command[2] = to >> 8;
+	flash->command[3] = to;
+
+	/* Write out most of the data here. */
+	cmd_sz = CMD_ADDR_SIZE;
+	for (; actual < len - 1; actual += 2) {
+		t[0].len = cmd_sz;
+		/* write two bytes. */
+		t[1].len = 2;
+		t[1].tx_buf = buf + actual;
+
+		spi_sync(flash->spi, &m);
+		ret = wait_till_ready(flash);
+		if (ret)
+			goto time_out;
+		*retlen += m.actual_length - cmd_sz;
+		cmd_sz = 1;
+		to += 2;
+	}
+	write_disable(flash);
+	ret = wait_till_ready(flash);
+	if (ret)
+		goto time_out;
+
+	/* Write out trailing byte if it exists. */
+	if (actual != len) {
+		write_enable(flash);
+		flash->command[0] = OPCODE_BP;
+		flash->command[1] = to >> 16;
+		flash->command[2] = to >> 8;
+		flash->command[3] = to;
+		t[0].len = CMD_ADDR_SIZE;
+		t[1].len = 1;
+		t[1].tx_buf = buf + actual;
+
+		spi_sync(flash->spi, &m);
+		ret = wait_till_ready(flash);
+		if (ret)
+			goto time_out;
+		*retlen += m.actual_length - CMD_ADDR_SIZE;
+		write_disable(flash);
+	}
+
+time_out:
+	mutex_unlock(&flash->lock);
+	return ret;
+}
+
+/****************************************************************************/
+#if 0
+static 	struct flash_status_reg status_reg_list[] = {
+		/*spiflash mx25l12805d*/
+		{
+			.jedec_id = 0xc22018,	.ext_id = 0,
+			.b_wip = 0,	.b_wel = 1,	.b_bp0 = 2,	.b_bp1 = 3,
+			.b_bp2 = 4,	.b_bp3 = 5,	.b_qe = 6,	.b_srp0 = 7,
+			.read_sr = normal_read_sr,
+			.write_sr = normal_write_sr,
+		},
+
+		/*spiflash xm25qh64a*/
+		{
+			.jedec_id = 0x207017,	.ext_id = 0,
+			.b_wip = 0,	.b_wel = 1,	.b_bp0 = 2,	.b_bp1 = 3,
+			.b_bp2 = 4,	.b_bp3 = 5,	.b_qe = 6,	.b_srp0 = 7,
+			.read_sr = xm25qh64a_read_sr,
+			.write_sr = xm25qh64a_write_sr,
+		},
+		
+		/*spiflash xm25qh128a*/
+		{
+			.jedec_id = 0x207018,	.ext_id = 0,
+			.b_wip = 0,	.b_wel = 1,	.b_bp0 = 2,	.b_bp1 = 3,
+			.b_bp2 = 4,	.b_bp3 = 5,	.b_qe = 6,	.b_srp0 = 7,
+			.read_sr = xm25qh64a_read_sr,
+			.write_sr = xm25qh64a_write_sr,
+		},	
+
+		/*spiflash PN26f64B*/
+		{
+			.jedec_id = 0x1c7017,	.ext_id = 0,
+			.b_wip = 0,	.b_wel = 1,	.b_bp0 = 2,	.b_bp1 = 3,
+			.b_bp2 = 4,	.b_bp3 = 5,	.b_qe = 6,	.b_srp0 = 7,
+			.read_sr = xm25qh64a_read_sr,
+			.write_sr = xm25qh64a_write_sr,
+		},	
+		
+		/*spiflash gd25q64c*/
+		{
+			.jedec_id = 0xc8401753,	.ext_id = 0,
+			.b_wip = 0,	.b_wel = 1,	.b_bp0 = 2,	.b_bp1 = 3,
+			.b_bp2 = 4,	.b_bp3 = 5,	.b_bp4 = 6,	.b_srp0 = 7,
+			
+			.b_srp1 = 8,.b_qe = 9,	.b_lb = 10,	.b_cmp = 14,
+			.b_sus = 15,
+			.read_sr = normal_read_sr,
+			.write_sr = gd25q64c_write_sr,
+		},		
+		/*spiflash gd25q128c*/
+		{
+			.jedec_id = 0xc84018,	.ext_id = 0,
+			.b_wip = 0,	.b_wel = 1,	.b_bp0 = 2,	.b_bp1 = 3,
+			.b_bp2 = 4,	.b_bp3 = 5,	.b_bp4 = 6,	.b_srp0 = 7,
+			
+			.b_srp1 = 8,.b_qe = 9,	.b_lb = 10,	.b_cmp = 14,
+			.b_sus = 15,
+			.read_sr = normal_read_sr,
+			.write_sr = gd25q128c_write_sr,
+		},
+		/*spiflash FM25Q64*/
+		{
+			.jedec_id = 0xa14017,	.ext_id = 0,
+			.b_wip = 0,	.b_wel = 1,	.b_bp0 = 2,	.b_bp1 = 3,
+			.b_bp2 = 4,	.b_srp0 = 7,
+			
+			.b_srp1 = 8,.b_qe = 9,	.b_lb = 10,	.b_cmp = 14,
+			.b_sus = 15,
+			.read_sr = normal_read_sr,
+			.write_sr = gd25q64c_write_sr,
+		},		
+		/*spiflash FM25Q128*/
+		{
+			.jedec_id = 0xa14018,	.ext_id = 0,
+			.b_wip = 0,	.b_wel = 1,	.b_bp0 = 2,	.b_bp1 = 3,
+			.b_bp2 = 4,	.b_srp0 = 7,
+			
+			.b_srp1 = 8,.b_qe = 9,	.b_lb = 10,	.b_cmp = 14,
+			.b_sus = 15,
+			.read_sr = normal_read_sr,
+			.write_sr = gd25q128c_write_sr,
+		},
+		/*normal status reg define*/
+		{
+			.jedec_id = 0,	.ext_id = 0,
+			.b_wip = 0,	.b_wel = 1,	.b_bp0 = 2,	.b_bp1 = 3,
+			.b_bp2 = 4,	.b_bp3 = 5,	.b_bp4 = 6,	.b_srp0 = 7,
+			
+			.b_srp1 = 8,.b_qe = 9,	.b_lb = 10,	.b_cmp = 14,
+			.b_sus = 15,
+			.read_sr = normal_read_sr,
+			.write_sr = normal_write_sr,
+		},
+};
+#endif
+
+#if 0
+/* NOTE: double check command sets and memory organization when you add
+ * more flash chips.  This current list focusses on newer chips, which
+ * have been converging on command sets which including JEDEC ID.
+ */
+static struct flash_info  ak_spiflash_supportlist [] = {
+
+	/* Atmel -- some are (confusingly) marketed as "DataFlash" */
+	{ "at25fs010",  0x1f6601, 0, 32 * 1024, 4, SFLAG_SECT_4K, },
+	{ "at25fs040",  0x1f6604, 0, 64 * 1024, 8, SFLAG_SECT_4K, },
+
+	{ "at25df041a", 0x1f4401, 0, 64 * 1024, 8, SFLAG_SECT_4K, },
+	{ "at25df641",  0x1f4800, 0, 64 * 1024, 128, SFLAG_SECT_4K, },
+
+	{ "at26f004",   0x1f0400, 0, 64 * 1024, 8, SFLAG_SECT_4K, },
+	{ "at26df081a", 0x1f4501, 0, 64 * 1024, 16, SFLAG_SECT_4K, },
+	{ "at26df161a", 0x1f4601, 0, 64 * 1024, 32, SFLAG_SECT_4K, },
+	{ "at26df321",  0x1f4701, 0, 64 * 1024, 64, SFLAG_SECT_4K, },
+
+	/* Macronix */
+	{ "mx25l3205d", 0xc22016, 0, 64 * 1024, 64, SFLAG_SECT_4K | SFLAG_DUAL_READ},
+	{ "mx25l6405d", 0xc22017, 0, 64 * 1024, 128, SFLAG_SECT_4K | SFLAG_DUAL_READ},
+	{ "mx25l12805d", 0xc22018, 0, 64 * 1024, 256, SFLAG_SECT_4K | SFLAG_DUAL_IO_READ | SFLAG_QUAD_IO_READ | SFLAG_QUAD_IO_WRITE},
+	{ "mx25l12855e", 0xc22618, 0, 64 * 1024, 256, SFLAG_SECT_4K | SFLAG_DUAL_READ},
+
+	/* Spansion -- single (large) sector size only, at least
+	 * for the chips listed here (without boot sectors).
+	 */
+	{ "s25sl004a", 0x010212, 0, 64 * 1024, 8, },
+	{ "s25sl008a", 0x010213, 0, 64 * 1024, 16, },
+	{ "s25sl016a", 0x010214, 0, 64 * 1024, 32, },
+	{ "s25sl032a", 0x010215, 0, 64 * 1024, 64, },
+	{ "s25sl064a", 0x010216, 0, 64 * 1024, 128, },
+	{ "s25sl12800", 0x012018, 0x0300, 256 * 1024, 64, },
+	{ "s25sl12801", 0x012018, 0x0301, 64 * 1024, 256, },
+	{ "s25fl129p0", 0x012018, 0x4d00, 256 * 1024, 64, },
+	{ "s25fl129p1", 0x012018, 0x4d01, 64 * 1024, 256, },
+
+	/* SST -- large erase sizes are "overlays", "sectors" are 4K */
+	{ "sst25vf040b", 0xbf258d, 0, 64 * 1024, 8, SFLAG_SECT_4K, },
+	{ "sst25vf080b", 0xbf258e, 0, 64 * 1024, 16, SFLAG_SECT_4K, },
+	{ "sst25vf016b", 0xbf2541, 0, 64 * 1024, 32, SFLAG_SECT_4K, },
+	{ "sst25vf032b", 0xbf254a, 0, 64 * 1024, 64, SFLAG_SECT_4K, },
+	{ "sst25wf512",  0xbf2501, 0, 64 * 1024, 1, SFLAG_SECT_4K, },
+	{ "sst25wf010",  0xbf2502, 0, 64 * 1024, 2, SFLAG_SECT_4K, },
+	{ "sst25wf020",  0xbf2503, 0, 64 * 1024, 4, SFLAG_SECT_4K, },
+	{ "sst25wf040",  0xbf2504, 0, 64 * 1024, 8, SFLAG_SECT_4K, },
+
+	/* ST Microelectronics -- newer production may have feature updates */
+	{ "m25p05",  0x202010,  0, 32 * 1024, 2, },
+	{ "m25p10",  0x202011,  0, 32 * 1024, 4, },
+	{ "m25p20",  0x202012,  0, 64 * 1024, 4, },
+	{ "m25p40",  0x202013,  0, 64 * 1024, 8, },
+	{ "m25p80",         0,  0, 64 * 1024, 16, },
+	{ "m25p16",  0x202015,  0, 64 * 1024, 32, },
+	{ "m25p32",  0x202016,  0, 64 * 1024, 64, },
+	{ "m25p64",  0x202017,  0, 64 * 1024, 128, },
+	{ "m25p128", 0x202018, 0, 256 * 1024, 64, },
+
+	{ "m45pe10", 0x204011,  0, 64 * 1024, 2, },
+	{ "m45pe80", 0x204014,  0, 64 * 1024, 16, },
+	{ "m45pe16", 0x204015,  0, 64 * 1024, 32, },
+
+	{ "m25pe80", 0x208014,  0, 64 * 1024, 16, },
+	{ "m25pe16", 0x208015,  0, 64 * 1024, 32, SFLAG_SECT_4K, },
+
+	/* Winbond -- w25x "blocks" are 64K, "sectors" are 4KiB */
+	{ "w25x10", 0xef3011, 0, 64 * 1024, 2, SFLAG_SECT_4K, },
+	{ "w25x20", 0xef3012, 0, 64 * 1024, 4, SFLAG_SECT_4K, },
+	{ "w25x40", 0xef3013, 0, 64 * 1024, 8, SFLAG_SECT_4K, },
+	{ "w25x80", 0xef3014, 0, 64 * 1024, 16, SFLAG_SECT_4K, },
+	{ "w25x16", 0xef3015, 0, 64 * 1024, 32, SFLAG_SECT_4K, },
+	{ "w25x32", 0xef3016, 0, 64 * 1024, 64, SFLAG_SECT_4K, },
+	{ "w25x64", 0xef3017, 0, 64 * 1024, 128, SFLAG_SECT_4K, },
+	
+	{ "w25q32", 0xef4016, 0, 32 * 1024, 128, SFLAG_SECT_4K|SFLAG_COM_STATUS2|SFLAG_DUAL_READ|SFLAG_QUAD_READ|SFLAG_QUAD_WRITE, },
+	{ "w25q64", 0xef4017, 0, 64 * 1024, 128, SFLAG_SECT_4K|SFLAG_COM_STATUS2|SFLAG_DUAL_READ|SFLAG_QUAD_READ|SFLAG_QUAD_WRITE, },
+	{ "w25q128", 0xef4018, 0, 64 * 1024, 256, SFLAG_SECT_4K|SFLAG_COM_STATUS2|SFLAG_DUAL_READ|SFLAG_QUAD_READ|SFLAG_QUAD_WRITE, },
+
+	/* GigaDevice -- w25x "blocks" are 64K, "sectors" are 4KiB */
+	{ "gd25q64", 0xc84017, 0, 64 * 1024, 128, SFLAG_SECT_4K|SFLAG_COM_STATUS2|SFLAG_DUAL_READ|SFLAG_QUAD_READ|SFLAG_DUAL_IO_READ|SFLAG_QUAD_IO_READ|SFLAG_QUAD_WRITE , },
+ 	{ "gd25q128", 0xc84018, 0, 64 * 1024, 256, SFLAG_SECT_4K|SFLAG_COM_STATUS2|SFLAG_DUAL_READ|SFLAG_QUAD_READ|SFLAG_DUAL_IO_READ|SFLAG_QUAD_IO_READ|SFLAG_QUAD_WRITE ,},
+
+	/* XMC -- xm25qh64a "blocks" are 64K, "sectors" are 4KiB */
+	{ "xm25qh64a", 0x207017, 0, 64 * 1024, 128, SFLAG_QUAD_NO_QE|SFLAG_SECT_4K|SFLAG_COM_STATUS2|SFLAG_DUAL_READ|SFLAG_QUAD_READ|SFLAG_DUAL_IO_READ|SFLAG_QUAD_IO_READ|SFLAG_QUAD_WRITE , },
+	{ "xm25qh128a", 0x207018, 0, 64 * 1024, 256, SFLAG_QUAD_NO_QE|SFLAG_SECT_4K|SFLAG_COM_STATUS2|SFLAG_DUAL_READ|SFLAG_QUAD_READ|SFLAG_DUAL_IO_READ|SFLAG_QUAD_IO_READ|SFLAG_QUAD_WRITE , },
+
+//	{ "xt25f128a", 0x207018, 0, 64 * 1024, 256, SFLAG_QUAD_NO_QE|SFLAG_SECT_4K|SFLAG_COM_STATUS2|SFLAG_DUAL_READ|SFLAG_QUAD_READ|SFLAG_DUAL_IO_READ|SFLAG_QUAD_IO_READ|SFLAG_QUAD_WRITE ,},
+	{ "PN26f64B",  0x1c7017, 0, 64 * 1024, 128, SFLAG_QUAD_NO_QE|SFLAG_SECT_4K|SFLAG_COM_STATUS2|SFLAG_DUAL_READ|SFLAG_QUAD_READ|SFLAG_DUAL_IO_READ|SFLAG_QUAD_IO_READ|SFLAG_QUAD_WRITE ,},
+
+      /* BOYA  BY25Q64ASSIG -- "blocks" are 64K, "sectors" are 4KiB */
+    { "BY25Q64ASSIG",  0x684017, 0, 64 * 1024, 128, SFLAG_SECT_4K|SFLAG_COM_STATUS2|SFLAG_DUAL_READ|SFLAG_QUAD_READ|SFLAG_DUAL_IO_READ|SFLAG_QUAD_IO_READ|SFLAG_QUAD_WRITE,},
+    { "BY25Q128ASSIG",  0x684018, 0, 64 * 1024, 256, SFLAG_SECT_4K|SFLAG_COM_STATUS2|SFLAG_DUAL_READ|SFLAG_QUAD_READ|SFLAG_DUAL_IO_READ|SFLAG_QUAD_IO_READ|SFLAG_QUAD_WRITE,},
+
+    /* FM25Q64  FM25Q128  "blocks" are 64K, "sectors" are 4KiB */
+    { "FM25Q64",  0xa14017, 0, 64 * 1024, 128, SFLAG_SECT_4K|SFLAG_COM_STATUS2|SFLAG_DUAL_READ|SFLAG_QUAD_READ|SFLAG_DUAL_IO_READ|SFLAG_QUAD_IO_READ|SFLAG_QUAD_WRITE,},
+    { "FM25Q128",  0xa14018, 0, 64 * 1024, 256, SFLAG_SECT_4K|SFLAG_COM_STATUS2|SFLAG_DUAL_READ|SFLAG_QUAD_READ|SFLAG_DUAL_IO_READ|SFLAG_QUAD_IO_READ|SFLAG_QUAD_WRITE,},
+
+    /* ZB25VQ32  "blocks" are 64K, "sectors" are 4KiB */
+    { "ZB25VQ32",  0x5e4016, 0, 32 * 1024, 128, SFLAG_SECT_4K|SFLAG_COM_STATUS2|SFLAG_DUAL_READ|SFLAG_QUAD_READ|SFLAG_DUAL_IO_READ|SFLAG_QUAD_IO_READ|SFLAG_QUAD_WRITE,},
+
+    /* ZD25Q64A SIZE:8M,  "blocks" are 64K, "sectors" are 4KiB */
+    { "ZD25Q64A",  0xba4017, 0, 64 * 1024, 128, SFLAG_SECT_4K|SFLAG_COM_STATUS2|SFLAG_DUAL_READ|SFLAG_QUAD_READ|SFLAG_DUAL_IO_READ|SFLAG_QUAD_IO_READ|SFLAG_QUAD_WRITE,},
+
+   /* ZB25VQ64  "blocks" are 64K, "sectors" are 4KiB */
+   { "ZB25VQ64",  0x5e4017, 0, 64 * 1024, 128, SFLAG_SECT_4K|SFLAG_COM_STATUS2|SFLAG_DUAL_READ|SFLAG_QUAD_READ|SFLAG_DUAL_IO_READ|SFLAG_QUAD_IO_READ|SFLAG_QUAD_WRITE,},
+
+   /* ZB25VQ128  "blocks" are 64K, "sectors" are 4KiB */
+   { "ZB25VQ128",  0x5e4018, 0, 64 * 1024, 256, SFLAG_SECT_4K|SFLAG_COM_STATUS2|SFLAG_DUAL_READ|SFLAG_QUAD_READ|SFLAG_DUAL_IO_READ|SFLAG_QUAD_IO_READ|SFLAG_QUAD_WRITE,}
+
+};
+#endif
+
+/**
+* @brief	partition lib erase callback
+* 
+* partition lib spi norflash erase callback function.
+* @author SheShaohua
+* @date 2012-03-20
+* @param[in] chip_num: chip select index
+* @param[in] startblock: erase block index
+* @return int 
+* @retval: succes:FHA_SUCCESS; fail:FHA_FAIL
+*/
+int ak_fha_erase_callback(T_U32 chip_num,  T_U32 startblock) // startpage
+{
+	struct erase_info einfo;
+	
+	memset(&einfo, 0, sizeof(struct erase_info));
+	einfo.addr = startblock * ak_mtd_info->erasesize; // startpage *  FLASH_PAGESIZE;
+	einfo.len = ak_mtd_info->erasesize;
+	einfo.mtd = ak_mtd_info;
+	
+	if(ak_spiflash_erase(ak_mtd_info, &einfo) == 0){
+		return FHA_SUCCESS;
+	}else {
+		printk(KERN_ERR "***erase failed\n");
+		return FHA_FAIL;
+	}
+}
+
+/**
+* @brief	partition lib write callback
+* 
+* partition lib spi norflash write callback function.
+* @author SheShaohua
+* @date 2012-03-20
+* @param[in] chip_num: chip select index
+* @param[in] page_num: write start page  index
+* @param[in] data: write data buffer
+* @param[in] data_len: write data len
+* @param[in] oob:write oob buffer
+* @param[in] oob_len: write oob len
+* @param[in] eDataType:write data type
+* @return int 
+* @retval: succes:FHA_SUCCESS; fail:FHA_FAIL
+*/
+int ak_fha_write_callback(T_U32 chip_num, T_U32 page_num, const T_U8 *data,
+		T_U32 data_len, T_U8 *oob, T_U32 oob_len, T_U32 eDataType)
+{
+	int ret;
+	ssize_t retlen;
+	loff_t to = page_num * FLASH_PAGESIZE;
+	
+	ret = ak_spiflash_write(ak_mtd_info, to, data_len * FLASH_PAGESIZE, &retlen, data);
+	if(ret){
+		printk(KERN_ERR "%s:%d\n", __func__, __LINE__);
+		return FHA_FAIL;
+	}
+	
+	return FHA_SUCCESS;
+}
+
+/**
+* @brief	partition lib read callback
+* 
+* partition lib spi norflash read callback function.
+* @author SheShaohua
+* @date 2012-03-20
+* @param[in] chip_num: chip select index
+* @param[in] page_num: read start page  index
+* @param[in] data: read data buffer
+* @param[in] data_len: read data len
+* @param[in] oob:read oob buffer
+* @param[in] oob_len: read oob len
+* @param[in] eDataType:read data type
+* @return int 
+* @retval: succes:FHA_SUCCESS; fail:FHA_FAIL
+*/
+int ak_fha_read_callback(T_U32 chip_num, T_U32 page_num, T_U8 *data,
+		T_U32 data_len, T_U8 *oob, T_U32 oob_len, T_U32 eDataType)
+{
+	int ret;
+	ssize_t retlen;
+	loff_t from = page_num * FLASH_PAGESIZE;
+
+	ret = ak_spiflash_read(ak_mtd_info, from, data_len * FLASH_PAGESIZE, &retlen, data);
+	if (ret) {
+		printk(KERN_ERR "%s:%d\n", __func__, __LINE__);
+		return FHA_FAIL;
+	}
+	
+	return FHA_SUCCESS;
+}
+
+
+/**
+* @brief	partition lib malloc callback
+* 
+* partition lib spi norflash malloc callback function.
+* @author SheShaohua
+* @date 2012-03-20
+* @param[in] size: malloc size
+* @return void 
+* @retval: malloc address pointer
+*/
+static T_VOID *fha_ram_alloc(T_U32 size)
+{
+	return kmalloc(size, GFP_KERNEL);
+}
+
+/**
+* @brief	partition lib free callback
+* 
+* partition lib spi norflash free callback function.
+* @author SheShaohua
+* @date 2012-03-20
+* @param[in] point: malloc address pointer
+* @return void 
+* @retval: none
+*/
+static T_VOID *fha_ram_free(void *point)
+{
+	kfree(point);
+	return NULL;
+}
+
+/**
+* @brief	partition lib print callback
+* 
+* partition lib spi norflash print callback function.
+* @author SheShaohua
+* @date 2012-03-20
+* @param[in] fmt: format string
+* @return T_S32 
+* @retval: r:
+*/
+static T_S32 fha_print(T_pCSTR fmt, ...)
+{
+	va_list args;
+	int r;
+    
+	va_start(args, fmt);
+    vprintk("FHA:",args);
+	r = vprintk(fmt, args);
+	va_end(args);
+
+	return r;
+}
+
+/**
+* @brief	partition lib init callback
+* 
+* partition lib spi norflash init callback function.
+* @author SheShaohua
+* @date 2012-03-20
+* @param[in] void: none
+* @return int 
+* @retval: 0: success, othet :failed
+*/
+int ak_fha_init(void)
+{
+	int ret = 0;
+	T_PFHA_LIB_CALLBACK pCallback = NULL;
+	T_SPI_INIT_INFO spi_info;
+
+	pCallback = kmalloc(sizeof(T_FHA_LIB_CALLBACK), GFP_KERNEL);
+	if (!pCallback) {
+		printk(KERN_ERR "allocate memory for pCallback failed\n");
+		ret = -ENOMEM;
+		goto err_out;
+	}
+	
+	pCallback->Erase = ak_fha_erase_callback;
+	pCallback->Write = (FHA_Write)ak_fha_write_callback;
+	pCallback->Read = (FHA_Read)ak_fha_read_callback;
+	pCallback->RamAlloc = fha_ram_alloc;
+	pCallback->RamFree = fha_ram_free;
+	pCallback->MemCmp = (FHA_MemCmp)memcmp;
+	pCallback->MemSet = (FHA_MemSet)memset;
+	pCallback->MemCpy = (FHA_MemCpy)memcpy;
+	pCallback->Printf = (FHA_Printf)fha_print;
+	pCallback->ReadNandBytes = NULL;
+	/* 
+	* Yea, PagePerBlock=16 in producer_all, 
+	* when SPI flash didn`t suport 4k sector erase,
+	* all will dead, Why can be forbear of this big BUG ? 
+	*/
+	spi_info.page_size = 256;
+	spi_info.pages_per_block = ak_mtd_info->erasesize / 256;
+	spi_info.total_size = ak_mtd_info->size;
+	
+	ret = partition_init(pCallback, &spi_info, 0);
+	if (ret == FHA_FAIL) {
+		printk(KERN_ERR "FHA_mount failed\n");
+		ret = -EINVAL;
+	} else {
+		ret = 0;
+	}
+
+	
+	
+
+	kfree(pCallback);
+err_out:
+	return ret;
+}
+
+/**
+* @brief	partition lib update init callback
+* 
+* partition lib spi norflash update init callback function.
+* @author SheShaohua
+* @date 2012-03-20
+* @param[in] n: none
+* @return int 
+* @retval: 0: success, othet :failed
+*/
+int ak_fha_init_for_update(int n)
+{
+	int ret = 0;
+
+	return ret;
+}
+
+/**
+* @brief	partition lib mount init 
+* 
+* partition lib spi norflash mount init function.
+* @author SheShaohua
+* @date 2012-03-20
+* @param[in] spi: spi device handle
+* @return int 
+* @retval: 0: success, othet :failed
+*/
+static int ak_mount_partitions(struct spi_device *spi)
+{
+	int i;
+	int ret;
+	unsigned long nr_parts;
+	T_PARTITION_TABLE_INFO *parts = NULL;
+	T_PARTITION_TABLE_CONFIG part_tab;
+	struct mtd_partition *mtd_part;
+	struct mtd_part_parser_data	ppdata;
+	
+	ret = ak_fha_init();
+	if (ret) {
+		printk(KERN_ERR "Init FHA lib failed\n");
+		goto no_parts;
+	}
+
+
+	ret = partition_get_partition_table(&part_tab, MEDIUM_SPINOR);
+	if (ret == FHA_FAIL) {
+		printk(KERN_ERR "get partition info failed\n");
+		ret = !ret;
+		goto no_parts;
+	}
+
+	/* 
+	* if no partiton to mount, the buf will be all 0xFF but not constant.
+	* So, it is not safe here. 
+	*/
+	nr_parts = *(unsigned long *)part_tab.table;
+	if (nr_parts <= 0 || nr_parts > 15) {
+		printk(KERN_ERR "partition count invalid\n");
+		ret = -EINVAL;
+		goto no_parts;
+	}
+
+	mtd_part = kzalloc(sizeof(struct mtd_partition) * nr_parts, GFP_KERNEL);
+	if (!mtd_part) {
+		printk(KERN_ERR "allocate memory for mtd_partition failed\n");
+		ret = -ENOMEM;
+		goto no_parts;
+	}
+
+	parts = (T_PARTITION_TABLE_INFO *)(&part_tab.table[sizeof(unsigned long)]);
+	for (i = 0; i < nr_parts; i++) {
+		mtd_part[i].name = kzalloc(PARTITION_NAME_LEN, GFP_KERNEL);
+		memcpy((void *)mtd_part[i].name, (void *)parts[i].partition_info.name, PARTITION_NAME_LEN);
+		mtd_part[i].size = parts[i].partition_info.ksize*1024;
+		mtd_part[i].offset = parts[i].partition_info.start_pos;
+		mtd_part[i].mask_flags = parts[i].partition_info.r_w_flag;
+/*
+		printk("mtd_part[%d]:\nname = %s\nsize = 0x%llx\noffset = 0x%llx\nmask_flags = 0x%x\n\n",
+				i, 
+				mtd_part[i].name, 
+				mtd_part[i].size, 
+				mtd_part[i].offset, 
+				mtd_part[i].mask_flags);
+*/
+
+	}
+
+	/*
+	* call ak_partition_table_sys_create function , create sys kobject for app aplication
+	*/
+	ret = ak_partition_table_sys_create(&part_tab);
+	if (ret){
+		printk(KERN_ERR "create sys partition table kobject failed!\n");
+		ret = -EINVAL;
+		kfree(mtd_part);
+		goto no_parts;
+	}
+
+	
+	
+	ppdata.of_node = spi->dev.of_node;
+	ret = mtd_device_parse_register(ak_mtd_info, NULL, &ppdata, 
+			(const struct mtd_partition *)mtd_part, nr_parts);
+	if (ret) {
+		printk(KERN_ERR "add mtd partition failed\n");
+		kfree(mtd_part);
+		goto no_parts;
+	}
+
+no_parts:
+	return ret;
+}
+
+/**
+* @brief	 spi norfalsh device jedec probe
+* 
+* Read the spi norfalsh device ID and identify that it was supported or not.
+* @author SheShaohua
+* @date 2012-03-20
+* @param[in] spi: spi device handle.
+* @return struct flash_info * 
+* @retval return the device info.
+*/
+static struct flash_info * jedec_probe(struct spi_device *spi)
+{
+	int			tmp;
+	u8			code = OPCODE_RDID;
+	u8			id[5];
+	u32			jedec;
+	u16         ext_jedec = 0;
+	struct device *dev = &spi->dev;
+	struct property *prop  = NULL;
+	struct flash_info *ofinfo = NULL;
+	struct device_node *child;
+	u32 readid = 0;
+	u32 ext_readid = 0;
+	const char *namestr = NULL;
+	u32 dataout;
+
+	/* JEDEC also defines an optional "extended device information"
+	 * string for after vendor-specific data, after the three bytes
+	 * we use here.  Supporting some chips might require using it.
+	 */
+	tmp = spi_write_then_read(spi, &code, 1, id, 3);
+	if (tmp < 0) {
+		DEBUG(MTD_DEBUG_LEVEL0, "%s: error %d reading JEDEC ID\n",
+			dev_name(&spi->dev), tmp);
+		return NULL;
+	}
+	
+	jedec = id[0];
+	jedec = jedec << 8;
+	jedec |= id[1];
+	jedec = jedec << 8;
+	jedec |= id[2];
+	
+	printk(KERN_ERR"akspi flash ID: 0x%08x\n", jedec);
+
+	/*cdh:search for spi controller device */
+	prop = of_find_property(dev->of_node,"compatible", NULL);
+	if(!prop){
+		printk(KERN_ERR"%s,line:%d, find compatible failed\n", __func__, __LINE__);
+		return NULL;
+	}
+
+	/*cdh:from norflash dtsi get match spi norflash information */
+	namestr = (const char *)kzalloc(20, GFP_KERNEL);
+	if (!namestr){
+		printk(KERN_ERR"%s,line:%d, allocate name buffer failed\n", __func__, __LINE__);
+		return NULL;
+	}
+
+	ofinfo = (struct flash_info *)kzalloc(sizeof(struct flash_info), GFP_KERNEL);
+	if (!ofinfo){
+		printk(KERN_ERR"%s,line:%d, allocate flash info failed\n", __func__, __LINE__);
+		kfree(namestr);
+		return NULL;
+	}
+	
+	for_each_available_child_of_node(dev->of_node, child){
+		if (child->name && (of_node_cmp(child->name, "spi-norflash") == 0)){
+			of_property_read_u32(child, "norflash-jedec-id", &readid);
+			if (readid == jedec){
+				of_property_read_u32(child, "norflash-ext-id", &ext_readid);
+				if (ext_readid != 0 && ext_readid != ext_jedec){
+					continue;
+				}else{
+					ofinfo->child = child;
+					break;
+				}
+			}
+		}
+	}
+
+	/*
+	* cdh:judge search spi norflash device whether success or not
+	*/
+	if (!ofinfo->child){
+		printk(KERN_ERR"%s,line:%d, no find match device!\n", __func__, __LINE__);
+		goto err_exit;
+	}
+
+	/*
+	* cdh:get spi norflash information
+	*/
+	of_property_read_string(child, "norflash-name", &namestr);
+	//printk(KERN_ERR"%s,child qijian. node name = %s\n", __func__, namestr);
+	ofinfo->name = namestr;
+	ofinfo->jedec_id = readid;
+	ofinfo->ext_id = ext_readid;
+
+	of_property_read_u32(child, "norflash-sector-size", &ofinfo->sector_size);
+	of_property_read_u32(child, "norflash-n-sectors", &dataout);
+	ofinfo->n_sectors = (u16)dataout;
+	of_property_read_u32(child, "norflash-flags", &dataout);
+	ofinfo->flags = (u16)dataout;
+
+	return ofinfo;
+err_exit:
+	kfree(namestr);
+	kfree(ofinfo);
+	dev_err(&spi->dev, "jedec_probe() unrecognized JEDEC id %06x\n", jedec);
+	return NULL;
+}
+
+
+
+/**
+* @brief	 spi norfalsh device init status register
+* 
+* spi norfalsh device init status register
+* @author SheShaohua
+* @date 2012-03-20
+* @param[in] flash: spi flash handle.
+* @return int 
+* @retval: 0: success, othet :failed
+*/
+static int ak_spiflash_init_stat_reg(struct ak_spiflash *flash)
+{
+	//int i;
+	u8			code[5] = {0x5a,0x00,0x00,0x00,0x00}; //OPCODE_VER;		
+	u8			id[2];
+	u8			id_ver_c;	
+	//u32	tmp_id;	
+	//struct flash_status_reg *sr;
+	struct flash_info *info = &flash->info;
+	u32 dataout, index;
+	int number;
+	int ret;
+	
+	/*
+	*  gd25q64 B汾C 汾Ȼ汾״̬Ĵдһ˸Ķ
+	*/
+	if(0xc84017 == info->jedec_id){
+		ret = spi_write_then_read(flash->spi, code, 5, id, 7);
+		if (ret < 0) {
+			DEBUG(MTD_DEBUG_LEVEL0, "%s: error %d reading JEDEC VERSION\n",
+				dev_name(&spi->dev), ret);
+			return 1;
+		}
+	
+		id_ver_c = id[0]; 
+		//printk("akspi flash VERSION: 0x%x\n", id_ver_c);	
+		if (0x53==id_ver_c){
+			info->id_ver_c = 1;
+	  	}
+	}
+
+	/*
+	* search spi norflash status reg info
+	*/
+	flash->stat_reg.read_sr = ak_normal_read_sr;
+	flash->stat_reg.write_sr = ak_normal_write_sr;
+
+	/* get dts parameter
+	* if has no this property, return -22 less 0, so must judge return value
+	* get spi norflash read status reg cmd from dtsi
+	*/
+	number = of_property_count_u32_elems(info->child, "rd_status_cmd");
+	if(number < 0){
+		printk(KERN_ERR"%s,line:%d,Err no this property!!!\n", __func__, __LINE__);
+		goto err_int_stat_reg_exit;
+	}
+	
+	for (index = 0; index < number; index++) {
+		of_property_read_u32_index(info->child, "rd_status_cmd", index, &dataout);
+		flash->stat_reg.rd_status_cmd[index] = dataout;
+	}
+
+	/*
+	* if has no this property, return -22 less 0, so must judge return value
+	* get spi norflash write status reg cmd from dtsi
+	*/
+	number = of_property_count_u32_elems(info->child, "wr_status_cmd");
+	if(number < 0){
+		printk(KERN_ERR"%s,line:%d,Err no this property!!!\n", __func__, __LINE__);
+		goto err_int_stat_reg_exit;
+	}
+	
+	for (index = 0; index < number; index++) {
+		of_property_read_u32_index(info->child, "wr_status_cmd", index, &dataout);
+		flash->stat_reg.wr_status_cmd[index] = (u8)dataout;
+	}
+
+	/*
+	* get write status reg wr_mode & norflash-wr_flags config information from dtsi
+	* wr_mode:0:normal write status reg, 1:one cmd write one status reg, 2:no write cmd
+	* norflash-wr_flags: write status reg cnt
+	*/
+	ret = of_property_read_u32(info->child, "wr_mode", &flash->stat_reg.wr_status_mode);
+	if(ret){
+		printk(KERN_ERR"%s,line:%d,Err no this property!!!\n", __func__, __LINE__);
+		goto err_int_stat_reg_exit;
+	}
+	
+	if (info->id_ver_c == 1){
+		flash->stat_reg.wr_status_mode = 1;
+	}
+
+	ret = of_property_read_u32(info->child, "norflash-wr_flags", &flash->stat_reg.wr_status_flag);
+	if(ret){
+		printk(KERN_ERR"%s,line:%d,Err no this property!!!\n", __func__, __LINE__);
+		goto err_int_stat_reg_exit;
+	}
+	
+	/*
+	* get status reg b_wip & b_qe bit map information from dtsi
+	*/
+	ret = of_property_read_u32(info->child, "norflash-b-wip", &dataout);
+	if(ret){
+		printk(KERN_ERR"%s,line:%d,Err no this property!!!\n", __func__, __LINE__);
+		goto err_int_stat_reg_exit;
+	}
+
+	flash->stat_reg.b_wip = dataout;
+	ret = of_property_read_u32(info->child, "norflash-b-qe", &dataout);
+	if(ret){
+		printk(KERN_ERR"%s,line:%d,Err no this property!!!\n", __func__, __LINE__);
+		goto err_int_stat_reg_exit;
+	}
+	flash->stat_reg.b_qe = dataout;
+
+	return 0;
+	
+err_int_stat_reg_exit:
+	printk(KERN_ERR"%s,line:%d,Err no this property!!!\n", __func__, __LINE__);
+	return -EINVAL;
+}
+
+
+
+/**
+* @brief	 spi norflash probe
+* 
+* Initial the spi norflash device driver to kernel.
+* @author SheShaohua
+* @date 2012-03-20
+* @param[in] mtd	  spi device handle.
+* @return int return write success or failed
+* @retval returns zero on success
+* @retval return a non-zero error code if failed
+*/
+
+static int  ak_spiflash_probe(struct spi_device *spi)
+{
+	struct ak_spiflash		*flash;
+	struct flash_info		*info;
+	unsigned i;
+	int	ret = 0;
+	
+	printk("ak spiflash probe enter.\n");	
+
+	/* cdh: notes */
+	info = jedec_probe(spi);
+	if (!info){
+		printk(KERN_ERR"%s,line:%d, jedec probe device failed!\n", __func__, __LINE__);
+		return -ENODEV;
+	}
+	flash = kzalloc(sizeof *flash, GFP_KERNEL);
+	if (!flash){
+		goto err_flash_exit;
+	}
+
+	/*pre-allocation buffer use for spi flash data transfer.*/
+#ifdef SPIFLASH_USE_MTD_BLOCK_LAYER
+	flash->buf = kzalloc(FLASH_BUF_SIZE, GFP_KERNEL);
+	if (!flash->buf) {
+		printk("Allocate buf for spi page failed\n");
+		goto err_probe_exit;
+	}
+#endif
+
+	ak_mtd_info = &flash->mtd;
+	flash->spi = spi;
+	flash->info = *info;
+	mutex_init(&flash->lock);
+
+	dev_set_drvdata(&spi->dev, flash);
+	flash->bus_width = FLASH_BUS_WIDTH_4WIRE | FLASH_BUS_WIDTH_2WIRE | FLASH_BUS_WIDTH_1WIRE;
+	flash->mtd.name = dev_name(&spi->dev);
+	flash->mtd.type = MTD_NORFLASH;
+	flash->mtd.writesize = FLASH_PAGESIZE;
+	flash->mtd.flags = MTD_WRITEABLE;
+	flash->mtd.size = info->sector_size * info->n_sectors;
+	flash->mtd._erase = ak_spiflash_erase;
+	flash->mtd._read = ak_spiflash_read;
+	flash->mtd.get_device_id = ak_spiflash_get_devid;
+	
+	/* sst flash chips use AAI word program */
+	if ((info->jedec_id >> 16) == 0xbf)
+		flash->mtd._write = sst_write;
+	else
+		flash->mtd._write = ak_spiflash_write;
+
+	/* prefer "small sector" erase if possible */
+	if (info->flags & SFLAG_SECT_4K) {
+		flash->erase_opcode = OPCODE_BE_4K;
+		flash->mtd.erasesize = 4096;
+	} else {
+		flash->erase_opcode = OPCODE_SE;
+		flash->mtd.erasesize = info->sector_size;
+	}
+
+	/* get spi norflash status reg information from dtsi */
+	ret = ak_spiflash_init_stat_reg(flash);
+	if(ret){
+		printk(KERN_ERR"%s,line:%d, init stat reg failed!\n", __func__, __LINE__);
+		goto err_probe_flash_exit;
+	}
+
+	/*
+	* atmel serial flash tend to power up
+	* with the software protection bits set
+	* here has some notes, because now sr completed init
+	*/
+	if ((info->jedec_id >> 16) == 0x1f) {
+		write_enable(flash);
+		write_sr(flash, 0);
+	}
+
+	/* cfg norflash quad mode */
+	ret = ak_spiflash_cfg_quad_mode(flash);
+	if(ret){
+		printk(KERN_ERR"%s,line:%d, cfg quad mode failed!\n", __func__, __LINE__);
+		goto err_probe_flash_exit;
+	}
+
+	/* init norflash rw bus width cmd */
+	init_spiflash_rw_info(flash);
+
+	flash->mtd.dev.parent = &spi->dev;
+	dev_info(&spi->dev, "%s (%lld Kbytes)\n", info->name,
+			(long long)flash->mtd.size >> 10);
+
+	DEBUG(MTD_DEBUG_LEVEL0,
+		"mtd .name = %s, .size = 0x%llx (%lldMiB) "
+			".erasesize = 0x%.8x (%uKiB) .numeraseregions = %d\n",
+		flash->mtd.name,
+		(long long)flash->mtd.size, (long long)(flash->mtd.size >> 20),
+		flash->mtd.erasesize, flash->mtd.erasesize / 1024,
+		flash->mtd.numeraseregions);
+
+	if (flash->mtd.numeraseregions)
+		for (i = 0; i < flash->mtd.numeraseregions; i++)
+			DEBUG(MTD_DEBUG_LEVEL0,
+				"mtd.eraseregions[%d] = { .offset = 0x%llx, "
+				".erasesize = 0x%.8x (%uKiB), "
+				".numblocks = %d }\n",
+				i, (long long)flash->mtd.eraseregions[i].offset,
+				flash->mtd.eraseregions[i].erasesize,
+				flash->mtd.eraseregions[i].erasesize / 1024,
+				flash->mtd.eraseregions[i].numblocks);
+
+
+	/* partitions should match sector boundaries; and it may be good to
+	 * use readonly partitions for writeprotected sectors (BP2..BP0).
+	* cdh:must use ,here mount rootfs block
+	*/
+	ret = mtd_device_parse_register(ak_mtd_info, NULL, NULL, NULL, 0);
+	if (ret) {
+		printk("Add root MTD device failed\n");
+		goto err_probe_flash_exit;
+	}	
+	
+	ret = ak_mount_partitions(spi);
+	if (ret){
+		printk(KERN_ERR "Add MTD partitions failed\n");
+		goto err_probe_flash_exit;
+	}
+	
+    printk("Init AK SPI Flash finish.\n"); 
+	return 0;
+	
+err_probe_flash_exit:
+#ifdef SPIFLASH_USE_MTD_BLOCK_LAYER
+	kfree(flash->buf);
+#endif	
+
+#ifdef SPIFLASH_USE_MTD_BLOCK_LAYER
+err_probe_exit:
+#endif	
+	kfree(flash);
+err_flash_exit:
+	kfree(info->name);
+	kfree(info);
+	
+	return -EINVAL;
+}
+
+/**
+* @brief	  spi flash remove
+* 
+* Remove the spi flash device driver from kernel.
+* @author SheShaohua
+* @date 2012-03-20
+* @param[in] mtd	   spi device handle.
+* @return int return write success or failed
+* @retval returns zero on success
+* @retval return a non-zero error code if failed
+*/
+static int  ak_spiflash_remove(struct spi_device *spi)
+{
+	struct ak_spiflash	*flash = dev_get_drvdata(&spi->dev);
+	struct flash_info *info = &flash->info;
+	int		status;
+	
+	status = mtd_device_unregister(&flash->mtd);
+	if (status == 0) {
+#ifdef SPIFLASH_USE_MTD_BLOCK_LAYER
+		kfree(flash->buf);
+#endif	
+		kfree(flash);
+		kfree(info->name);
+		kfree(info);
+	}
+	return 0;
+}
+
+static const struct of_device_id spiflash_of_table[] = {
+	{ .compatible = "anyka,ak-spiflash" },
+	{}
+};
+MODULE_DEVICE_TABLE(of, spiflash_of_table);
+
+static struct spi_driver ak_spiflash_driver = {
+	.driver = {
+		.name	= "ak-spiflash",
+		.bus	= &spi_bus_type,
+		.owner	= THIS_MODULE,
+		.of_match_table = spiflash_of_table,
+	},
+	.probe	= ak_spiflash_probe,
+	.remove	= ak_spiflash_remove,
+
+	/* REVISIT: many of these chips have deep power-down modes, which
+	 * should clearly be entered on suspend() to minimize power use.
+	 * And also when they're otherwise idle...
+	 */
+};
+
+
+/**
+* @brief	  ak spi flash module init
+* 
+* ak spi norflash module init
+* @author SheShaohua
+* @date 2012-03-20
+* @param[in] void	   
+* @return int return write success or failed
+* @retval returns zero on success
+* @retval return a non-zero error code if failed
+*/
+static int __init ak_spiflash_init(void)
+{
+    printk("Start to init Anyka SPI Flash...\n");
+
+	return spi_register_driver(&ak_spiflash_driver);
+}
+
+/**
+* @brief	  ak spi flash module exit
+* 
+* ak spi norflash module exit
+* @author SheShaohua
+* @date 2012-03-20
+* @param[in] void	   
+* @return void
+* @retval none
+*/
+static void __exit ak_spiflash_exit(void)
+{
+	spi_unregister_driver(&ak_spiflash_driver);
+}
+
+
+module_init(ak_spiflash_init);
+module_exit(ak_spiflash_exit);
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("She Shaohua");
+MODULE_DESCRIPTION("MTD SPI driver for Anyka spiflash chips");
diff --git a/drivers/mtd/mtdchar.c b/drivers/mtd/mtdchar.c
old mode 100644
new mode 100755
index 0d244da..246fc27
--- a/drivers/mtd/mtdchar.c
+++ b/drivers/mtd/mtdchar.c
@@ -36,6 +36,10 @@
 #include <linux/mtd/mtd.h>
 #include <linux/mtd/partitions.h>
 #include <linux/mtd/map.h>
+#include <partition/partition_init.h>
+#include <partition/partition_lib.h>
+#include <devices/ak_partition_table.h>
+#include <partition/spinand_badblock.h>
 
 #include <asm/uaccess.h>
 
@@ -43,6 +47,8 @@
 
 static DEFINE_MUTEX(mtd_mutex);
 
+#define AK_UPDATE_PART_NAME             0x85
+#define AK_GET_PART_NAME                0x86
 /*
  * Data structure to hold the pointer to the mtd device as well
  * as mode information of various use cases.
@@ -50,6 +56,7 @@ static DEFINE_MUTEX(mtd_mutex);
 struct mtd_file_info {
 	struct mtd_info *mtd;
 	enum mtd_file_modes mode;
+	void *part_handle;
 };
 
 static loff_t mtdchar_lseek(struct file *file, loff_t offset, int orig)
@@ -98,6 +105,17 @@ static int mtdchar_open(struct inode *inode, struct file *file)
 	}
 	mfi->mtd = mtd;
 	file->private_data = mfi;
+
+	if(MTD_NANDFLASH == mtd->type)
+	{
+	    //open partition
+	    mfi->part_handle = partition_open((unsigned char *)mtd->name);
+		if (mfi->part_handle == NULL) {
+		    printk(KERN_ERR "%s, open partition error!\n", __func__);
+			goto out1;
+	    }
+	}
+
 	mutex_unlock(&mtd_mutex);
 	return 0;
 
@@ -121,6 +139,11 @@ static int mtdchar_close(struct inode *inode, struct file *file)
 	if ((file->f_mode & FMODE_WRITE))
 		mtd_sync(mtd);
 
+	if(MTD_NANDFLASH == mtd->type)
+	{
+		//close partition
+		partition_close(mfi->part_handle);
+	}
 	put_mtd_device(mtd);
 	file->private_data = NULL;
 	kfree(mfi);
@@ -200,7 +223,20 @@ static ssize_t mtdchar_read(struct file *file, char __user *buf, size_t count,
 			break;
 		}
 		default:
-			ret = mtd_read(mtd, *ppos, len, &retlen, kbuf);
+			if(MTD_NANDFLASH == mtd->type)
+			{
+			    retlen = partition_read(mfi->part_handle, kbuf, len);
+			    if(retlen < 0){
+					kfree(kbuf);
+					return -EFAULT;
+			    }
+	            else
+					ret = 0;
+			}
+			else
+			{
+				ret = mtd_read(mtd, *ppos, len, &retlen, kbuf);
+			}
 		}
 		/* Nand returns -EBADMSG on ECC errors, but it returns
 		 * the data. For our userspace tools it is important
@@ -247,6 +283,7 @@ static ssize_t mtdchar_write(struct file *file, const char __user *buf, size_t c
 	size_t total_retlen=0;
 	int ret=0;
 	int len;
+	T_PARTITION_TABLE_INFO *parttition_handle = NULL;
 
 	pr_debug("MTD_write\n");
 
@@ -263,8 +300,19 @@ static ssize_t mtdchar_write(struct file *file, const char __user *buf, size_t c
 	if (!kbuf)
 		return -ENOMEM;
 
+	if(MTD_NANDFLASH == mtd->type){
+		parttition_handle = (T_PARTITION_TABLE_INFO *)mfi->part_handle;
+	}
+
 	while (count) {
 		len = min_t(size_t, count, size);
+		if(MTD_NANDFLASH == mtd->type && size != count){
+			if(parttition_handle->partition_info.type == PART_FS_TYPE)
+			{
+				len = len/2112;
+				len = len*2112;
+			}
+		}
 
 		if (copy_from_user(kbuf, buf, len)) {
 			kfree(kbuf);
@@ -296,7 +344,20 @@ static ssize_t mtdchar_write(struct file *file, const char __user *buf, size_t c
 		}
 
 		default:
-			ret = mtd_write(mtd, *ppos, len, &retlen, kbuf);
+			if(MTD_NANDFLASH == mtd->type)
+			{
+				retlen = partition_write(mfi->part_handle, kbuf, len);
+				if(retlen <= 0){
+	                kfree(kbuf);
+					return -EFAULT;
+				}
+				else
+					ret = 0;
+			}
+			else
+			{
+				ret = mtd_write(mtd, *ppos, len, &retlen, kbuf);
+			}
 		}
 
 		/*
@@ -592,9 +653,12 @@ static int mtdchar_ioctl(struct file *file, u_int cmd, u_long arg)
 	struct mtd_file_info *mfi = file->private_data;
 	struct mtd_info *mtd = mfi->mtd;
 	void __user *argp = (void __user *)arg;
-	int ret = 0;
+	int ret = 0, i = 0;
 	u_long size;
 	struct mtd_info_user info;
+	T_PARTITION_INFO partition_info = {0};
+	T_PARTITION_INFO read_partition_info = {0};
+	char read_flag = 0;
 
 	pr_debug("MTD_ioctl\n");
 
@@ -609,6 +673,137 @@ static int mtdchar_ioctl(struct file *file, u_int cmd, u_long arg)
 	}
 
 	switch (cmd) {
+	case AK_GET_PART_NAME:
+			memset(&read_partition_info, 0, sizeof(T_PARTITION_INFO));
+
+			if(MTD_NANDFLASH != mtd->type)
+			{
+				printk(KERN_ERR "spi nor not support get part name\n");
+			}
+			else
+			{
+
+				//printk(KERN_ERR "sizeof(T_PARTITION_INFO):%d\n", sizeof(T_PARTITION_INFO));
+				if(spinand_read_asa_data((unsigned char *)&read_partition_info, sizeof(T_PARTITION_INFO)) == -1)
+				{
+					printk(KERN_ERR"spinand_read_asa_data fail\r\n");
+					return -EFAULT;
+				}
+
+				printk(KERN_ERR"partition_cnt:%ld\r\n", read_partition_info.partition_cnt);
+				/*
+				printk(KERN_ERR"partition_name_info[0].partition_name:%s\r\n"
+				, read_partition_info.partition_name_info[0].partition_name);
+				printk(KERN_ERR"partition_name_info[1].partition_name:%s\r\n"
+				, read_partition_info.partition_name_info[1].partition_name);
+				printk(KERN_ERR"partition_name_info[20].partition_name:%s\r\n"
+				, read_partition_info.partition_name_info[2].partition_name);
+				*/
+
+				if (copy_to_user(argp, &read_partition_info, sizeof(T_PARTITION_INFO)))
+				{
+					printk(KERN_ERR"copy_to_user fail\r\n");
+					return -EFAULT;
+				}
+			}
+
+		break;
+
+	case AK_UPDATE_PART_NAME:
+
+		//printk(KERN_ERR "mtdchar_ioctl@@@@@@@@@@@@@@@@@@, cmd:%d\n", cmd);
+		if(MTD_NANDFLASH != mtd->type)
+		{
+			printk(KERN_ERR "spi nor not support update part name\n");
+		}
+		else
+		{
+
+		#if 1
+
+		    //printk(KERN_ERR "len:%d\n", sizeof(T_PARTITION_INFO));
+			if(copy_from_user(&partition_info, argp,sizeof(T_PARTITION_INFO))) {
+				return -EFAULT;
+			 }
+
+			#if 0
+			//printk(KERN_ERR "partition_info.partition_cnt:%d\n", partition_info.partition_cnt);
+			for(i = 0; i < partition_info.partition_cnt; i++)
+			{
+				if(partition_info.partition_name_info[i].partition_name[0] == 0)
+				{
+					read_flag = 1;
+					break;
+				}
+			}
+			#endif
+
+			//printk(KERN_ERR "read_flag:%d\n", read_flag);
+			if(read_flag == 0)
+			{
+				printk(KERN_ERR"partition_cnt:%ld\r\n", partition_info.partition_cnt);
+				printk(KERN_ERR"partition_name_info[0].update_flag:%s\r\n"
+					, partition_info.partition_name_info[0].partition_name);
+				printk(KERN_ERR"partition_name_info[1].update_flag:%s\r\n"
+					, partition_info.partition_name_info[1].partition_name);
+				printk(KERN_ERR"partition_name_info[2].update_flag:%s\r\n"
+					, partition_info.partition_name_info[2].partition_name);
+
+				if(spinand_write_asa_data((unsigned char *)&partition_info, sizeof(T_PARTITION_INFO)) == -1)
+				{
+					printk(KERN_ERR"spinand_write_asa_data fail\r\n");
+					return -EFAULT;
+				}
+			}
+			else
+			{
+				//
+				memset(&read_partition_info, 0, sizeof(T_PARTITION_INFO));
+
+				//printk(KERN_ERR "sizeof(T_PARTITION_INFO):%d\n", sizeof(T_PARTITION_INFO));
+				if(spinand_read_asa_data((unsigned char *)&read_partition_info, sizeof(T_PARTITION_INFO)) == -1)
+				{
+					printk(KERN_ERR"spinand_read_asa_data fail\r\n");
+					return -EFAULT;
+				}
+
+				printk(KERN_ERR"partition_cnt:%ld\r\n", read_partition_info.partition_cnt);
+				printk(KERN_ERR"partition_name_info[0].update_flag:%s\r\n"
+					, read_partition_info.partition_name_info[0].partition_name);
+				printk(KERN_ERR"partition_name_info[1].update_flag:%s\r\n"
+					, read_partition_info.partition_name_info[1].partition_name);
+				printk(KERN_ERR"partition_name_info[20].update_flag:%s\r\n"
+					, read_partition_info.partition_name_info[2].partition_name);
+
+				//
+				for(i = 0; i < partition_info.partition_cnt; i++)
+				{
+					if(partition_info.partition_name_info[i].partition_name[0] != 0)
+					{
+						memset(read_partition_info.partition_name_info[i].partition_name, 0, 6);
+						strncpy(read_partition_info.partition_name_info[i].partition_name
+							, partition_info.partition_name_info[i].partition_name, 6);
+					}
+				}
+
+				printk(KERN_ERR"partition_cnt:%ld\r\n", read_partition_info.partition_cnt);
+				printk(KERN_ERR"partition_name_info[0].update_flag:%s\r\n"
+					, read_partition_info.partition_name_info[0].partition_name);
+				printk(KERN_ERR"partition_name_info[1].update_flag:%s\r\n"
+					, read_partition_info.partition_name_info[1].partition_name);
+				printk(KERN_ERR"partition_name_info[20].update_flag:%s\r\n"
+					,read_partition_info.partition_name_info[2].partition_name);
+
+				if(spinand_write_asa_data((unsigned char *)&read_partition_info, sizeof(T_PARTITION_INFO)) == -1)
+				{
+					printk(KERN_ERR"spinand_write_asa_data fail\r\n");
+					return -EFAULT;
+				}
+			}
+			#endif
+		}
+
+		break;
 	case MEMGETREGIONCOUNT:
 		if (copy_to_user(argp, &(mtd->numeraseregions), sizeof(int)))
 			return -EFAULT;
diff --git a/drivers/mtd/mtdpart.c b/drivers/mtd/mtdpart.c
old mode 100644
new mode 100755
index f8ba153..e11051f
--- a/drivers/mtd/mtdpart.c
+++ b/drivers/mtd/mtdpart.c
@@ -596,7 +596,7 @@ int mtd_add_partition(struct mtd_info *master, const char *name,
 	if (length <= 0)
 		return -EINVAL;
 
-	part.name = name;
+	part.name = (char *)name;
 	part.size = length;
 	part.offset = offset;
 	part.mask_flags = 0;
@@ -761,6 +761,7 @@ int parse_mtd_partitions(struct mtd_info *master, const char *const *types,
 		types = default_mtd_part_types;
 
 	for ( ; *types; types++) {
+		//printk(" master->name:%s, *types:%s\n",  master->name, *types);
 		pr_debug("%s: parsing partitions %s\n", master->name, *types);
 		parser = get_partition_parser(*types);
 		if (!parser && !request_module("%s", *types))
@@ -770,6 +771,8 @@ int parse_mtd_partitions(struct mtd_info *master, const char *const *types,
 		if (!parser)
 			continue;
 		ret = (*parser->parse_fn)(master, pparts, data);
+
+		//printk("master->name:%s, parser->name:%s, ret: %i\n", master->name, parser->name, ret);
 		pr_debug("%s: parser %s: %i\n",
 			 master->name, parser->name, ret);
 		put_partition_parser(parser);
diff --git a/drivers/mtd/partition/Makefile b/drivers/mtd/partition/Makefile
new file mode 100755
index 0000000..9d8a30b
--- /dev/null
+++ b/drivers/mtd/partition/Makefile
@@ -0,0 +1,8 @@
+obj-y				+= partition_lib.o
+obj-y				+= export_symbol.o
+
+obj-$(CONFIG_MTD_AK_SPIFLASH)	+= spiburn.o
+
+obj-$(CONFIG_MTD_AK_SPINAND)	+= spinand_burn.o
+obj-$(CONFIG_MTD_AK_SPINAND)	+= spinand_badblock.o
+obj-$(CONFIG_MTD_AK_SPINAND)	+= spinand_driver.o
\ No newline at end of file
diff --git a/drivers/mtd/partition/export_symbol.c b/drivers/mtd/partition/export_symbol.c
new file mode 100755
index 0000000..9341dc9
--- /dev/null
+++ b/drivers/mtd/partition/export_symbol.c
@@ -0,0 +1,41 @@
+
+
+#include <linux/module.h>
+
+#include "partition_lib.h"
+#include "partition_init.h"
+#include "spinand_badblock.h"
+
+
+
+
+EXPORT_SYMBOL(partition_burn_partitiontab_info_end_spiflash);
+EXPORT_SYMBOL(partition_burn_partitiontab_info_init_spiflash);
+EXPORT_SYMBOL(partition_set_partition_startpage_spinand);
+EXPORT_SYMBOL(partition_set_partition_startpage);
+EXPORT_SYMBOL(partition_set_attr);
+EXPORT_SYMBOL(partition_get_attr);
+EXPORT_SYMBOL(partition_get_partition_backup_table);
+EXPORT_SYMBOL(partition_get_partition_table);
+EXPORT_SYMBOL(partition_get_ksize);
+EXPORT_SYMBOL(partition_get_data_size);
+EXPORT_SYMBOL(partition_read);
+EXPORT_SYMBOL(partition_write);
+EXPORT_SYMBOL(partition_open);
+EXPORT_SYMBOL(partition_close);
+EXPORT_SYMBOL(partition_creat);
+EXPORT_SYMBOL(partition_init);
+EXPORT_SYMBOL(partition_getversion);
+
+#ifdef SUPPORT_SPINAND 
+EXPORT_SYMBOL(spinand_is_badblock);
+EXPORT_SYMBOL(spinand_get_badblock);
+EXPORT_SYMBOL(spinand_set_badblock);
+EXPORT_SYMBOL(spinand_babblock_tbl_creat);
+EXPORT_SYMBOL(spinand_babblock_tbl_init);
+EXPORT_SYMBOL(spinand_write_asa_data);
+EXPORT_SYMBOL(spinand_read_asa_data);
+
+#endif
+
+
diff --git a/drivers/mtd/partition/nand_list.h b/drivers/mtd/partition/nand_list.h
new file mode 100755
index 0000000..b905a77
--- /dev/null
+++ b/drivers/mtd/partition/nand_list.h
@@ -0,0 +1,84 @@
+/**
+ * @filename nand_list.h
+ * @brief: AK3223M interrupt
+ *
+ * This file describe what is in the table of nand list
+ * Copyright (C) 2006 Anyka (GuangZhou) Software Technology Co., Ltd.
+ * @author  zhaojiahuan
+ * @modify chenyanyan
+ * @date    2007-1-10
+ * @version 1.0
+ * @ref
+ */
+
+#ifndef __CHIP_NFC_3224__
+#define __CHIP_NFC_3224__
+
+//#include	"anyka_types.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/** @defgroup NandFlash Architecture NandFlash Interface
+ *  @ingroup Architecture
+ */
+/*@{*/
+
+/**
+* @BRIEF    Nandflash info define
+* @AUTHOR   zhaojiahuan
+* @DATE     2006-7-17
+*/
+#if 1
+typedef struct Nand_phy_info{
+    unsigned long  chip_id;//chip id
+    unsigned short  page_size; //page size
+    unsigned short  page_per_blk; //page of one blok
+    unsigned short  blk_num;//total block number
+    unsigned short  group_blk_num;//the same concept as die, according to nand's struture
+    unsigned short  plane_blk_num;   
+    unsigned char   spare_size;//spareСĵλ255 Byte
+    unsigned char   col_cycle;//column address cycle
+    unsigned char   lst_col_mask;//last column  addrress cycle mask bit
+    unsigned char   row_cycle;//row address cycle
+    unsigned char   delay_cnt;//Rb delay, unit is 1024 asic clock, default value corresponds to 84MHz
+    unsigned char   custom_nd;//nand type flag, used to detect the original invilid block
+        //currently there are 7 types, more types might be added when new nand come out
+        //˵ǰһpage,һpageеλ, ЩλòΪ0xFFblockǳ
+        //NAND_TYPE_SAMSUNG:        0x1 СҳSLC([0,1],[517]),   ҳSLC([0,1],[2048]),          MLC([127], [2048/4096])
+        //NAND_TYPE_HYNIX:          0x2 СҳSLC([0,1],[517]),   ҳSLC([0,1],[2048]),          MLC([125,127], [2048/4096])
+        //NAND_TYPE_TOSHIBA:        0x3 СҳSLC([0,1],[0,512]), ҳSLC([0,1],[0,2048]),        MLC([127], [0,2048/4096])
+        //NAND_TYPE_TOSHIBA_EXT:    0x4 СҳSLC(),              ҳSLC(),                      MLC([0,127/255], [0,2048/4096/8192])
+        //NAND_TYPE_MICRON:         0x5 СҳSLC([0,1],[512]),   ҳSLC([0,1],[2048]),          MLC([0,1], [2048/4096])
+        //NAND_TYPE_ST:             0x6 СҳSLC([0,1],[517]),   ҳSLC([0],[2048,2053]),       MLC([127], [0])
+        //NAND_TYPE_MICRON_4K       0x7 СҳSLC(),              ҳSLC(),                      MLC([0], [4096 ~ 4096+218])
+    unsigned long  flag;//character bits, 4λʾplaneԣλʾǷҪblock˳дpage
+    //bit31ʾǷcopyback1ʾcopyback
+    //bit30ʾǷֻһplane1ʾֻһplane
+    //bit29ʾǷǰplane1ʾǰplane
+    //bit28ʾǷżplane1ʾżplane
+
+    //bitΪ˽pageblockַӵĿbit:
+    //bit11ʾblock number per dieǷҪϹToshiba TH58NVG6D2ETA202048 block/die(ʵ2084 block/die)
+         //Ϊ˶һdieblockҪΪ4096 block/dieײ
+    //bit10ʾpage numberǷҪϹTLC192page/blockΪ˶һblockҪΪ256page/block
+    
+    //bit8~9ʾspareСĸλλ256 Bytesspare_sizeΪT_U8Աʾnand400ֽڵspareС
+    //bit4-7ʾECCͣ0Ϊ4 bit/512B1Ϊ8 bit/512B2Ϊ12 bit/512B3Ϊ16 bit/512B4Ϊ24 bit/1024B5Ϊ32 bit/1024B
+    //bit0ʾͬһblockǷҪ˳дpage1ʾҪ˳дnandΪMLC
+    //ע: (bit29bit28)Ϊ'11'ʾchip4planeżҲǰplane
+
+    unsigned long  cmd_len;//nandflash command length
+    unsigned long  data_len;//nandflash data length
+    unsigned char   des_str[32];//descriptor string
+}T_NAND_PARAM, T_NAND_PHY_INFO;
+#endif
+#define ERROR_CHIP_ID   0xFFFFFFFF
+
+/*@}*/
+#ifdef __cplusplus
+}
+#endif
+
+#endif
diff --git a/drivers/mtd/partition/partition_init.h b/drivers/mtd/partition/partition_init.h
new file mode 100755
index 0000000..c9f5e73
--- /dev/null
+++ b/drivers/mtd/partition/partition_init.h
@@ -0,0 +1,125 @@
+#ifndef        _PARTITION_INIT_H_
+#define        _PARTITION_INIT_H_
+
+#include "nand_list.h"
+
+
+typedef struct
+{
+    unsigned long    chip_id;
+    unsigned long    total_size;             ///< flash total size in bytes
+    unsigned long	 page_size;       ///< total bytes per page
+    unsigned long	 program_size;    ///< program size at 02h command
+    unsigned long	 erase_size;      ///< erase size at d8h command 
+    unsigned long	 clock;           ///< spi clock, 0 means use default clock 
+    
+    //chip character bits:
+    //bit 0: under_protect flag, the serial flash under protection or not when power on
+    //bit 1: fast read flag    
+    unsigned char    flag;            ///< chip character bits
+    unsigned char	 protect_mask;    ///< protect mask bits in status register:BIT2:BP0, 
+                             //BIT3:BP1, BIT4:BP2, BIT5:BP3, BIT7:BPL
+    unsigned char    reserved1;
+    unsigned char    reserved2;
+    unsigned char    des_str[32];		   //                                    
+}T_SFLASH_INFO;
+
+
+/************************************************************************
+ * NAME:     FHA_Erase
+ * FUNCTION  callback function, medium erase
+ * PARAM:    [in] nChip--meidum chip
+ *           [in] nPage--medium page
+ * RETURN:   success return 0, fail retuen -1
+**************************************************************************/
+typedef  int (*FHA_Erase)(unsigned long nChip,  unsigned long block); 
+
+/************************************************************************
+ * NAME:     FHA_Write
+ * FUNCTION  callback function, medium write
+ * PARAM:    [in] nChip-----meidum chip
+ *           [in] nPage-----medium page
+ *           [in] pData-----need to write data pointer addr
+ *           [in] nDataLen--need to write data length
+ *                          nand(unit byte)
+ *                          SD(unit sector count(1sec = 512byte))
+ *                          SPI(unit page count, page size in platform define, generally is 256bytes)
+ *           [in] pOob------Spare areaOut Of Band, only nand use
+ *           [in] nOobLen---Spare area length
+ *           [in] eDataType-burn medium data type
+ *                          nand -- E_FHA_DATA_TYPE
+ *                          SD----- MEDIUM_EMMC
+ *                          SPI---- MEDIUM_SPIFLASH
+ * RETURN:    success return 0, fail retuen -1
+**************************************************************************/
+typedef int (*FHA_Write)(unsigned long nChip, unsigned long nPage, const unsigned char *pData, unsigned long nDataLen,  unsigned char *pOob, unsigned long nOobLen, unsigned long eDataType);
+
+/************************************************************************
+ * NAME:     FHA_Read
+ * FUNCTION  callback function, medium read
+ * PARAM:    [in] nChip-----meidum chip
+ *           [in] nPage-----medium page
+ *           [out]pData-----need to read data pointer addr
+ *           [in] nDataLen--need to ren data length
+ *                          nand(unit byte)
+ *                          SD(unit sector count(1sec = 512byte))
+ *                          SPI(unit page count, page size in platform define, generally is 256bytes)
+ *           [out]pOob------Spare areaOut Of Band, only nand use
+ *           [in] nOobLen---Spare area length
+ *           [in] eDataType-burn medium data type
+ *                          nand -- E_FHA_DATA_TYPE
+ *                          SD----- MEDIUM_EMMC
+ *                          SPI---- MEDIUM_SPIFLASH
+ * RETURN:    success return 0, fail retuen -1
+**************************************************************************/
+typedef int (*FHA_Read)(unsigned long nChip,  unsigned long nPage, unsigned char *pData, unsigned long nDataLen,  unsigned char *pOob, unsigned long nOobLen , unsigned long eDataType);
+
+/************************************************************************
+ * NAME:     FHA_ReadNandBytes
+ * FUNCTION  callback function, nand read no ECC
+ * PARAM:    [in] nChip-------meidum chip
+ *           [in] rowAddr-----nand physical row addr
+ *           [in] columnAddr--nand physical cloumn addr
+ *           [out] pData------need to read data pointer addr
+ *           [in] nDataLen----need to ren data length
+ *                            nand(unit byte)
+ * RETURN:    success return 0, fail retuen -1
+**************************************************************************/
+typedef int (*FHA_ReadNandBytes)(unsigned long nChip, unsigned long rowAddr, unsigned long columnAddr, unsigned char *pData, unsigned long nDataLen);
+
+typedef void *(*FHA_RamAlloc)(unsigned long size);
+typedef void *(*FHA_RamFree)(void * var);
+typedef void *(*FHA_MemSet)(void * pBuf, signed long value, unsigned long count);
+typedef void *(*FHA_MemCpy)(void * dst, const void * src, unsigned long count);
+typedef signed long   (*FHA_MemCmp)(const void * pbuf1, const void * pbuf2, unsigned long count);
+typedef void *(*FHA_MemMov)(void * dst, const void * src, unsigned long count);
+typedef signed long    (*FHA_Printf)(const signed char *s, ...);
+
+typedef struct tag_FHA_LibCallback
+{
+    FHA_Erase Erase;
+    FHA_Write Write;
+    FHA_Read  Read;
+    FHA_ReadNandBytes ReadNandBytes;
+    FHA_RamAlloc RamAlloc;
+    FHA_RamFree  RamFree;
+    FHA_MemSet   MemSet;
+    FHA_MemCpy   MemCpy;
+    FHA_MemCmp   MemCmp;
+    FHA_MemMov   MemMov;
+    FHA_Printf   Printf;
+}T_FHA_LIB_CALLBACK, *T_PFHA_LIB_CALLBACK;
+
+
+
+/************************************************************************
+ * NAME:     Sflash_Init
+ * FUNCTION  partition init
+ * PARAM:    [in] T_pVOID SpiInfo
+ * RETURN:   success return FHA_SUCCESS, fail retuen FHA_ FAIL
+**************************************************************************/
+int partition_init(T_PFHA_LIB_CALLBACK pCB, void *pPhyInfo, unsigned long table_page);
+
+#endif      //_FHA_BINBURN_H_
+
+
diff --git a/drivers/mtd/partition/partition_lib.c b/drivers/mtd/partition/partition_lib.c
new file mode 100755
index 0000000..f52fc69
--- /dev/null
+++ b/drivers/mtd/partition/partition_lib.c
@@ -0,0 +1,793 @@
+/**
+ * @FILENAME: fha_binburn.c
+ * @BRIEF xx
+ * Copyright (C) 2011 Anyka (GuangZhou) Software Technology Co., Ltd.
+ * @AUTHOR luqiliu
+ * @DATE 2009-11-19
+ * @VERSION 1.0
+ * @modified lu 2011-11-03
+ * 
+ * @REF
+ */
+#include "spiburn.h"
+#include "partition_lib.h"
+#include "partition_init.h"
+#include "public_info.h"
+
+
+
+
+#define     PARTITION_LIB_VER              "V1.1.05"
+
+
+T_FHA_LIB_CALLBACK  gPrtition = {0};
+T_FHA_LIB_CALLBACK  spinand_gPrtition = {0};
+
+unsigned char g_medium = 0xFF; //PART_SPIFLASH;
+unsigned long g_dst_write_len = 0;
+unsigned long g_src_write_len = 0;
+
+#ifdef SUPPORT_SPIFLASH
+extern T_PARTITION  g_spi_partition;
+#endif
+
+#ifdef SUPPORT_SPINAND 
+extern T_PARTITION  g_partition;
+#endif
+
+unsigned char *partition_getversion(void)
+{
+    return (unsigned char *)PARTITION_LIB_VER;
+}
+
+
+
+int partition_callbackinit(T_PFHA_LIB_CALLBACK pCB)
+{
+    if (NULL == pCB) 
+    {
+        return -1;
+    }
+
+
+	if (NULL == pCB->Write
+        || NULL == pCB->Read
+        || NULL == pCB->Erase
+        ||NULL == pCB->RamAlloc
+        || NULL == pCB->RamFree
+        || NULL == pCB->MemSet
+        || NULL == pCB->MemCpy
+        || NULL == pCB->MemCmp
+        || NULL == pCB->Printf)
+    {
+        if (NULL == pCB->Printf)
+        {
+            //printf("FHA_CallbackInit(): some callback function not init!\r\n");
+        }
+        else
+        {
+            pCB->Printf("Partition_CallbackInit(): some callback function not init!\r\n");
+        }
+        
+        return -1;
+    }
+		
+
+	if(pCB->ReadNandBytes == NULL)
+	{
+		gPrtition.Erase = pCB->Erase;
+	    gPrtition.Write = pCB->Write;
+	    gPrtition.Read  = pCB->Read;
+	    gPrtition.ReadNandBytes = pCB->ReadNandBytes;
+	}
+	else
+	{
+		spinand_gPrtition.Erase = pCB->Erase;
+	    spinand_gPrtition.Write = pCB->Write;
+	    spinand_gPrtition.Read  = pCB->Read;
+	    spinand_gPrtition.ReadNandBytes = pCB->ReadNandBytes;
+	}
+    
+
+	
+    gPrtition.RamAlloc = pCB->RamAlloc;
+    gPrtition.RamFree  = pCB->RamFree;
+    gPrtition.MemSet   = pCB->MemSet;        
+    gPrtition.MemCpy   = pCB->MemCpy;
+    gPrtition.MemCmp   = pCB->MemCmp;
+    gPrtition.Printf   = pCB->Printf;
+
+
+    gPrtition.Printf("partition lib version: %s\r\n", partition_getversion());
+
+    return 0;
+}
+
+
+
+
+int partition_init(T_PFHA_LIB_CALLBACK pCB, void *pPhyInfo, unsigned long table_page)
+{ 
+    int ret = -1;
+	char change_medium_flag = 0;
+    
+    if (NULL == pCB || NULL == pPhyInfo)
+    {
+        return ret;
+    }
+
+    if (partition_callbackinit(pCB) != 0)
+    {
+        return ret;
+    }
+
+    if(pCB->ReadNandBytes == NULL)
+    {
+        g_medium = PART_SPIFLASH;
+        gPrtition.Printf("spiflash init\r\n");
+    }
+    else
+    {
+    	//spi nor and spinandģʽȳʼspi nor,ٳʼspinand, g_mediumʼ0xFF,Ǳʾspi nor and spinandģʽ
+    	if(g_medium == PART_SPIFLASH)
+		{
+			change_medium_flag = 1;
+    	}
+        g_medium = PART_SPINAND;
+        gPrtition.Printf("spinand init\r\n");
+    }
+    
+
+    if(g_medium == PART_SPIFLASH)
+    {
+        //gPrtition.Printf("spiflash initfffffffffffffffffffffff\r\n");
+        #ifdef SUPPORT_SPIFLASH
+        //gPrtition.Printf("spiflash initvvvvvvvvvvvvvvvvvvvvvvvvvvvv\r\n");
+        ret = sflash_init(pPhyInfo, table_page);
+        #endif
+    }
+    else if(g_medium == PART_SPINAND)
+    {
+        #ifdef SUPPORT_SPINAND 
+        ret = spinand_init(pPhyInfo, table_page);
+        #endif
+    }
+    else
+    {
+        gPrtition.Printf("partition_init fail g_medium %d error\r\n", g_medium);
+    }
+
+	if(change_medium_flag)
+	{
+		g_medium = PART_SPINOR_SPINAND;
+	}
+
+    return ret;
+}
+
+
+void * partition_creat(T_CREAT_PARTITION_INFO *partition)
+{
+    T_PARTITION_TABLE_INFO *phandle = NULL;
+
+    if((g_medium == PART_SPIFLASH) || (partition->medium_flag == 1 && partition->medium_type == PART_SPIFLASH) )
+    {
+        #ifdef SUPPORT_SPIFLASH
+        phandle = (T_PARTITION_TABLE_INFO *)sflash_creat(partition);
+        #endif
+		gPrtition.Printf("sflash_creat %d \r\n", g_medium);
+    }
+    else if((g_medium == PART_SPINAND) || (partition->medium_flag == 1 && partition->medium_type == PART_SPINAND) )
+    {
+        #ifdef SUPPORT_SPINAND 
+        phandle = (T_PARTITION_TABLE_INFO *)spinand_creat(partition);
+        #endif
+		gPrtition.Printf("spinand_creat %d \r\n", g_medium);
+    }
+	else
+	{
+		gPrtition.Printf("partition_creat fail g_medium %d, medium_flag:%d,  medium_type:%d, error\r\n", g_medium, partition->medium_flag, partition->medium_type);
+	}
+    
+    return (void *)phandle;
+}
+
+
+int partition_close(void *handle)
+{
+    T_PARTITION_TABLE_INFO *phandle = (T_PARTITION_TABLE_INFO *)handle;
+    int ret = -1;
+	char part_type = phandle->partition_info.type;
+	char medium_flag = 0;
+	char medium_type = 0;
+	T_BIN_CONFIG bin_config;
+    T_FS_CONFIG fs_config;
+
+
+	if(part_type == PART_BIN_TYPE || part_type == PART_DATA_TYPE)
+	{
+		gPrtition.MemCpy(&bin_config, &phandle->ex_partition_info, sizeof(T_BIN_CONFIG));
+
+		medium_flag = bin_config.medium_flag;
+		medium_type = bin_config.medium_type;
+	}
+	else if(part_type == PART_FS_TYPE)
+	{
+		gPrtition.MemCpy(&fs_config, &phandle->ex_partition_info, sizeof(T_FS_CONFIG));
+		medium_flag = fs_config.medium_flag;
+		medium_type = fs_config.medium_type;
+	}
+
+	gPrtition.Printf("medium_flag:%d, medium_type:%d\r\n", medium_flag, medium_type);
+	
+
+	//дݴСԭݴСһôͲҪ·
+	if(g_dst_write_len == g_src_write_len && g_src_write_len != 0)
+	{
+		
+		#ifdef SUPPORT_SPIFLASH
+		if(((medium_flag == 1 && medium_type == PART_SPIFLASH && g_medium == PART_SPINOR_SPINAND) 
+			||( g_medium == PART_SPIFLASH)) && g_spi_partition.set_attr_flag == 0)
+		{
+			g_spi_partition.write_table_flag = 0;
+			gPrtition.Printf("partition_close:data len is equal, no update p_table\r\n");
+		}
+		#endif
+		
+		#ifdef SUPPORT_SPINAND 
+		if(((medium_flag == 1 && medium_type == PART_SPINAND && g_medium == PART_SPINOR_SPINAND)
+			||(g_medium == PART_SPINAND)) && g_partition.set_attr_flag == 0)
+		{
+			g_partition.write_table_flag = 0;
+			gPrtition.Printf("partition_close:data len is equal, no update p_table\r\n");
+		}
+		#endif
+	}
+
+    if((medium_flag == 1 && medium_type == PART_SPIFLASH && g_medium == PART_SPINOR_SPINAND) ||(g_medium == PART_SPIFLASH))
+    {
+        #ifdef SUPPORT_SPIFLASH
+        ret = sflash_close(phandle);
+        #endif
+    }
+    else if((medium_flag == 1 && medium_type == PART_SPINAND && g_medium == PART_SPINOR_SPINAND) ||(g_medium == PART_SPINAND))
+    {
+        #ifdef SUPPORT_SPINAND 
+        ret = spinand_close(phandle);
+        #endif
+    }
+	else
+	{
+		gPrtition.Printf("partition_close fail g_medium %d, medium_flag:%d,  medium_type:%d, error\r\n", g_medium, medium_flag, medium_type);
+	}
+   
+    return ret;
+}
+
+void * partition_open(unsigned char *name)
+{
+    T_PARTITION_TABLE_INFO *phandle = NULL;
+
+	
+
+    if(g_medium == PART_SPIFLASH)
+    {
+        #ifdef SUPPORT_SPIFLASH
+        phandle = (T_PARTITION_TABLE_INFO *)sflash_open(name);
+        #endif
+    }
+    else if(g_medium == PART_SPINAND)
+    {
+        #ifdef SUPPORT_SPINAND 
+        phandle = (T_PARTITION_TABLE_INFO *)spinand_open(name);
+        #endif
+    }
+	else if(g_medium == PART_SPINOR_SPINAND)
+	{
+		#if ( (defined SUPPORT_SPIFLASH) || (defined SUPPORT_SPINAND) )
+
+		#ifdef SUPPORT_SPIFLASH
+        phandle = (T_PARTITION_TABLE_INFO *)sflash_open(name);
+		#endif
+
+		//spiflashϵķʱ,ûд˷ôͻжȡspinandϵķ
+		if(phandle == NULL)
+		{
+			gPrtition.Printf("the partiton name is not in spi nor table,and retry read spinand table, partiton name:%s\r\n", name);
+			#ifdef SUPPORT_SPINAND
+			phandle = (T_PARTITION_TABLE_INFO *)spinand_open(name);
+			#endif
+		}
+	    #endif
+	}
+
+	if(phandle != NULL)
+	{
+		g_src_write_len = phandle->ex_partition_info.parameter1;
+	}
+	g_dst_write_len = 0;
+    
+    return (void *)phandle;
+}
+
+
+int partition_write(void *handle, unsigned char *data, unsigned long data_len)
+{
+    T_PARTITION_TABLE_INFO *phandle = (T_PARTITION_TABLE_INFO *)handle;
+    int ret = -1;
+	char part_type = phandle->partition_info.type;
+	char medium_flag = 0;
+	char medium_type = 0;
+	T_BIN_CONFIG bin_config;
+    T_FS_CONFIG fs_config;
+
+
+	if(part_type == PART_BIN_TYPE || part_type == PART_DATA_TYPE)
+	{
+		gPrtition.MemCpy(&bin_config, &phandle->ex_partition_info, sizeof(T_BIN_CONFIG));
+
+		medium_flag = bin_config.medium_flag;
+		medium_type = bin_config.medium_type;
+	}
+	else if(part_type == PART_FS_TYPE)
+	{
+		gPrtition.MemCpy(&fs_config, &phandle->ex_partition_info, sizeof(T_FS_CONFIG));
+		medium_flag = fs_config.medium_flag;
+		medium_type = fs_config.medium_type;
+	}
+	
+
+	g_dst_write_len += data_len;
+    
+    if((g_medium == PART_SPIFLASH) || (medium_flag == 1 && medium_type == PART_SPIFLASH && g_medium == PART_SPINOR_SPINAND))
+    {
+        #ifdef SUPPORT_SPIFLASH
+        ret = sflash_write(phandle, data, data_len);
+        #endif
+    }
+    else if((g_medium == PART_SPINAND) || (medium_flag == 1 && medium_type == PART_SPINAND && g_medium == PART_SPINOR_SPINAND))
+    {
+        #ifdef SUPPORT_SPINAND 
+        ret = spinand_write(phandle, data, data_len);
+        #endif
+    }
+	else
+	{
+		gPrtition.Printf("partition_write fail g_medium %d, medium_flag:%d,  medium_type:%d, error\r\n", g_medium, medium_flag, medium_type);
+	}
+   
+
+	if(ret == -1)
+	{
+		#ifdef SUPPORT_SPIFLASH
+		g_spi_partition.write_table_flag = 0;//дʧܵ,closeʱҲҪ·
+		#endif
+		
+		#ifdef SUPPORT_SPINAND 
+		g_partition.write_table_flag = 0;
+		#endif
+	}
+	
+    return ret;
+}
+
+
+int partition_read(void *handle, unsigned char *data, unsigned long data_len)
+{
+    T_PARTITION_TABLE_INFO *phandle = (T_PARTITION_TABLE_INFO *)handle;
+    int ret = -1;
+	char part_type = phandle->partition_info.type;
+	char medium_flag = 0;
+	char medium_type = 0;
+	T_BIN_CONFIG bin_config;
+    T_FS_CONFIG fs_config;
+
+
+	if(part_type == PART_BIN_TYPE || part_type == PART_DATA_TYPE)
+	{
+		gPrtition.MemCpy(&bin_config, &phandle->ex_partition_info, sizeof(T_BIN_CONFIG));
+
+		medium_flag = bin_config.medium_flag;
+		medium_type = bin_config.medium_type;
+	}
+	else if(part_type == PART_FS_TYPE)
+	{
+		gPrtition.MemCpy(&fs_config, &phandle->ex_partition_info, sizeof(T_FS_CONFIG));
+		medium_flag = fs_config.medium_flag;
+		medium_type = fs_config.medium_type;
+	}
+	
+
+    if((g_medium == PART_SPIFLASH) || (medium_flag == 1 && medium_type == PART_SPIFLASH && g_medium == PART_SPINOR_SPINAND))
+    {
+        #ifdef SUPPORT_SPIFLASH
+        ret = sflash_read(phandle, data, data_len);
+        #endif
+    }
+    else if((g_medium == PART_SPINAND) || (medium_flag == 1 && medium_type == PART_SPINAND && g_medium == PART_SPINOR_SPINAND))
+    {
+        #ifdef SUPPORT_SPINAND 
+        ret = spinand_read(phandle, data, data_len);
+        #endif
+    }
+	else
+	{
+		gPrtition.Printf("partition_read fail g_medium %d, medium_flag:%d,  medium_type:%d, error\r\n", g_medium, medium_flag, medium_type);
+	}
+   
+    
+    return ret;
+}
+
+
+unsigned long  partition_get_data_size(void *handle)
+{
+    unsigned long ret = 0;
+	T_PARTITION_TABLE_INFO *phandle = (T_PARTITION_TABLE_INFO *)handle;
+	char part_type = phandle->partition_info.type;
+	char medium_flag = 0;
+	char medium_type = 0;
+	T_BIN_CONFIG bin_config;
+    T_FS_CONFIG fs_config;
+
+
+	if(part_type == PART_BIN_TYPE || part_type == PART_DATA_TYPE)
+	{
+		gPrtition.MemCpy(&bin_config, &phandle->ex_partition_info, sizeof(T_BIN_CONFIG));
+
+		medium_flag = bin_config.medium_flag;
+		medium_type = bin_config.medium_type;
+	}
+	else if(part_type == PART_FS_TYPE)
+	{
+		gPrtition.MemCpy(&fs_config, &phandle->ex_partition_info, sizeof(T_FS_CONFIG));
+		medium_flag = fs_config.medium_flag;
+		medium_type = fs_config.medium_type;
+	}
+    
+    if((g_medium == PART_SPIFLASH) || (medium_flag == 1 && medium_type == PART_SPIFLASH && g_medium == PART_SPINOR_SPINAND))
+    {
+        #ifdef SUPPORT_SPIFLASH
+         ret = sflash_get_partition_data_size(phandle);
+        #endif
+    }
+    else if((g_medium == PART_SPINAND) || (medium_flag == 1 && medium_type == PART_SPINAND && g_medium == PART_SPINOR_SPINAND))
+    {
+        #ifdef SUPPORT_SPINAND 
+        ret = spinand_get_partition_data_size(phandle);
+        #endif
+    }
+	else
+	{
+		gPrtition.Printf("partition_get_data_size fail g_medium %d, medium_flag:%d,  medium_type:%d, error\r\n", g_medium, medium_flag, medium_type);
+	}
+	
+    return ret;
+}
+
+
+unsigned long partition_get_ksize(void *handle)
+{
+    unsigned long ret = 0;
+	T_PARTITION_TABLE_INFO *phandle = (T_PARTITION_TABLE_INFO *)handle;
+	char part_type = phandle->partition_info.type;
+	char medium_flag = 0;
+	char medium_type = 0;
+	T_BIN_CONFIG bin_config;
+    T_FS_CONFIG fs_config;
+
+
+	if(part_type == PART_BIN_TYPE || part_type == PART_DATA_TYPE)
+	{
+		gPrtition.MemCpy(&bin_config, &phandle->ex_partition_info, sizeof(T_BIN_CONFIG));
+
+		medium_flag = bin_config.medium_flag;
+		medium_type = bin_config.medium_type;
+	}
+	else if(part_type == PART_FS_TYPE)
+	{
+		gPrtition.MemCpy(&fs_config, &phandle->ex_partition_info, sizeof(T_FS_CONFIG));
+		medium_flag = fs_config.medium_flag;
+		medium_type = fs_config.medium_type;
+	}
+    
+   if((g_medium == PART_SPIFLASH) || (medium_flag == 1 && medium_type == PART_SPIFLASH && g_medium == PART_SPINOR_SPINAND))
+    {
+        #ifdef SUPPORT_SPIFLASH
+        ret = sflash_get_partition_ksize((T_PARTITION_TABLE_INFO *)handle);
+        #endif
+    }
+    else if((g_medium == PART_SPINAND) || (medium_flag == 1 && medium_type == PART_SPINAND && g_medium == PART_SPINOR_SPINAND))
+    {
+        #ifdef SUPPORT_SPINAND 
+        ret = spinand_get_partition_ksize((T_PARTITION_TABLE_INFO *)handle);
+        #endif
+    }
+	else
+	{
+		gPrtition.Printf("partition_get_ksize fail g_medium %d, medium_flag:%d,  medium_type:%d, error\r\n", g_medium, medium_flag, medium_type);
+	}
+	
+    return ret;
+}
+
+
+
+int partition_get_partition_table(T_PARTITION_TABLE_CONFIG *part_talbe, PART_MEDIUM medium_type)
+{
+    int ret = -1;
+	
+    if(medium_type == PART_SPIFLASH)
+    {
+        #ifdef SUPPORT_SPIFLASH
+        ret = sflash_get_partition_table(part_talbe);
+        #endif
+    }
+    else if(medium_type == PART_SPINAND)
+    {
+        #ifdef SUPPORT_SPINAND 
+        ret = spinand_get_partition_table(part_talbe);
+        #endif
+    }
+	else
+	{
+		gPrtition.Printf("partition_get_partition_table fail  medium_type:%d, error\r\n", medium_type);
+	}
+	
+    return ret;
+}
+
+int partition_get_partition_backup_table(T_PARTITION_TABLE_CONFIG *part_talbe, PART_MEDIUM medium_type)
+{
+    int ret = -1;
+    if(medium_type == PART_SPIFLASH)
+    {
+        #ifdef SUPPORT_SPIFLASH
+        ret = sflash_get_partition_backup_table(part_talbe);
+        #endif
+    }
+    else if(medium_type == PART_SPINAND)
+    {
+        #ifdef SUPPORT_SPINAND 
+        ret = spinand_get_partition_backup_table(part_talbe);
+        #endif
+    }
+	else
+	{
+		gPrtition.Printf("partition_get_partition_table fail  medium_type:%d error\r\n", medium_type);
+	}
+	
+    return ret;
+}
+
+#if 0
+
+int partition_resize(unsigned char *name, unsigned long partition_size)
+{
+    int ret = -1;
+    
+    if(g_medium == PART_SPIFLASH)
+    {
+        #ifdef SUPPORT_SPIFLASH
+        ret = sflash_resize(name, partition_size);
+        #endif
+    }
+    else
+    {
+        #ifdef SUPPORT_SPINAND 
+        ret = spinand_resize(name, partition_size);
+        #endif
+    }
+    
+    return ret;
+}
+#endif 
+
+
+int partition_get_attr(void *handle, T_EX_PARTITION_CONFIG *ex_arrt)
+{
+   T_PARTITION_TABLE_INFO *phandle = (T_PARTITION_TABLE_INFO *)handle;
+   int ret = -1;
+	char part_type = phandle->partition_info.type;
+	char medium_flag = 0;
+	char medium_type = 0;
+	T_BIN_CONFIG bin_config;
+    T_FS_CONFIG fs_config;
+
+
+	if(part_type == PART_BIN_TYPE || part_type == PART_DATA_TYPE)
+	{
+		gPrtition.MemCpy(&bin_config, &phandle->ex_partition_info, sizeof(T_BIN_CONFIG));
+
+		medium_flag = bin_config.medium_flag;
+		medium_type = bin_config.medium_type;
+	}
+	else if(part_type == PART_FS_TYPE)
+	{
+		gPrtition.MemCpy(&fs_config, &phandle->ex_partition_info, sizeof(T_FS_CONFIG));
+		medium_flag = fs_config.medium_flag;
+		medium_type = fs_config.medium_type;
+	}
+
+   
+    if((g_medium == PART_SPIFLASH) || (medium_flag == 1 && medium_type == PART_SPIFLASH && g_medium == PART_SPINOR_SPINAND))
+    {
+        #ifdef SUPPORT_SPIFLASH
+        ret = sflash_get_attr(phandle, ex_arrt);
+        #endif
+    }
+    else if((g_medium == PART_SPINAND) || (medium_flag == 1 && medium_type == PART_SPINAND && g_medium == PART_SPINOR_SPINAND))
+    {
+        #ifdef SUPPORT_SPINAND 
+        ret = spinand_get_attr(phandle, ex_arrt);
+        #endif
+    }
+	else
+	{
+		gPrtition.Printf("partition_get_ksize fail g_medium %d, medium_flag:%d,  medium_type:%d, error\r\n", g_medium, medium_flag, medium_type);
+	}
+        
+    return ret;
+}
+
+int partition_set_attr(void *handle, T_EX_PARTITION_CONFIG *ex_arrt)
+{
+   T_PARTITION_TABLE_INFO *phandle = (T_PARTITION_TABLE_INFO *)handle;
+    int ret = -1;
+    char part_type = phandle->partition_info.type;
+	char medium_flag = 0;
+	char medium_type = 0;
+	T_BIN_CONFIG bin_config;
+    T_FS_CONFIG fs_config;
+
+
+	if(part_type == PART_BIN_TYPE || part_type == PART_DATA_TYPE)
+	{
+		gPrtition.MemCpy(&bin_config, &phandle->ex_partition_info, sizeof(T_BIN_CONFIG));
+
+		medium_flag = bin_config.medium_flag;
+		medium_type = bin_config.medium_type;
+	}
+	else if(part_type == PART_FS_TYPE)
+	{
+		gPrtition.MemCpy(&fs_config, &phandle->ex_partition_info, sizeof(T_FS_CONFIG));
+		medium_flag = fs_config.medium_flag;
+		medium_type = fs_config.medium_type;
+	}
+	
+    if((g_medium == PART_SPIFLASH) || (medium_flag == 1 && medium_type == PART_SPIFLASH && g_medium == PART_SPINOR_SPINAND))
+    {
+        #ifdef SUPPORT_SPIFLASH
+        ret = sflash_set_attr(phandle, ex_arrt);
+        #endif
+    }
+    else if((g_medium == PART_SPINAND) || (medium_flag == 1 && medium_type == PART_SPINAND && g_medium == PART_SPINOR_SPINAND))
+    {
+        #ifdef SUPPORT_SPINAND 
+        ret = spinand_set_attr(phandle, ex_arrt);
+        #endif
+    }
+	else
+	{
+		gPrtition.Printf("partition_get_ksize fail g_medium %d, medium_flag:%d,  medium_type:%d, error\r\n", g_medium, medium_flag, medium_type);
+	}
+    return ret;
+}
+
+#if 0
+int partition_delete(unsigned char *name)
+{
+    int ret = -1;
+    
+    if(g_medium == PART_SPIFLASH)
+    {
+        #ifdef SUPPORT_SPIFLASH
+        ret = sflash_delete(name);
+        #endif
+    }
+    else
+    {
+        #ifdef SUPPORT_SPINAND 
+        ret = spinand_delete(name);
+        #endif
+    }
+    return ret;
+}
+
+#endif
+///////////////////////////////////////////////////////////////////////////////////////
+//˽ӿṩ¼ʹã
+//ȫ¼ʱһmacַ
+//ʱbootĴС֮ǰһôλþͲһ
+//ڶmacַʱҪþɵķµķ
+void partition_set_partition_startpage(unsigned long start_page, PART_MEDIUM medium_type)
+{
+//    int ret = -1;
+    
+    if(medium_type == PART_SPIFLASH)
+    {
+        #ifdef SUPPORT_SPIFLASH 
+        sflash_set_partition_startpage(start_page);
+        #endif
+    }
+    else if(medium_type == PART_SPINAND)
+    {
+        #ifdef SUPPORT_SPINAND 
+        spinand_set_partition_startpage(start_page);
+        #endif
+    }
+	else
+	{
+		gPrtition.Printf("partition_set_partition_startpage fail  medium_type:%d error\r\n", medium_type);
+	}
+    
+}
+
+//˽ӿڴȫ󣬴ʱҪȡķλ,Ŀǰ¼
+void partition_set_partition_startpage_spinand(unsigned long *start_page, unsigned long *backup_start_page)
+{
+    #ifdef SUPPORT_SPINAND 
+    spinand_get_partition_startpage(start_page, backup_start_page);
+    #endif
+}
+
+
+
+//Żܵ⣬¼ʱpartitionжβдռһЩʱ䣬¼ʱֻʱٽаЩдȥ
+int partition_burn_partitiontab_info_init_spiflash(unsigned char burn_mode)
+{
+	if(g_medium == PART_SPIFLASH || g_medium == PART_SPINOR_SPINAND)
+	{
+		#ifdef SUPPORT_SPIFLASH
+			return spiflash_burn_partitiontab_info_init(burn_mode);
+		#endif
+	}
+	else
+	{
+		gPrtition.Printf("part: not support spinand\r\n");
+		return -1;
+	}
+
+	return -1;
+	
+}
+
+int partition_burn_partitiontab_info_end_spiflash(void)
+{
+	if(g_medium == PART_SPIFLASH || g_medium == PART_SPINOR_SPINAND)
+	{
+		#ifdef SUPPORT_SPIFLASH
+		return spiflash_burn_partitiontab_info_end();
+		#endif
+	}
+	else
+	{
+		gPrtition.Printf("part: not support spinand\r\n");
+		return -1;
+	}
+
+	return -1;
+}
+
+
+
+
+unsigned long sflash_str_len(const unsigned char *string)
+{
+    unsigned long i = 0;
+
+    while (string[i] != 0)
+    {
+        i++;
+        if (i>10000)
+            break;
+    }
+    return i;
+}
+
+
+
+
+
+
+
diff --git a/drivers/mtd/partition/partition_lib.h b/drivers/mtd/partition/partition_lib.h
new file mode 100755
index 0000000..6e27031
--- /dev/null
+++ b/drivers/mtd/partition/partition_lib.h
@@ -0,0 +1,275 @@
+#ifndef        _PARTITION_LIB_H_
+#define        _PARTITION_LIB_H_
+
+
+#ifndef	NULL
+#define	NULL	((void *) 0)
+#endif
+
+#ifdef CONFIG_MTD_AK_SPIFLASH
+#define SUPPORT_SPIFLASH
+#endif
+
+#ifdef CONFIG_MTD_AK_SPINAND
+#define SUPPORT_SPINAND
+#endif
+
+
+#define     PARTITION_NAME_LEN                  6
+
+typedef enum
+{
+   PART_NO_HIDDEN = 0,
+   PART_HIDDEN,
+}PART_HIDDEN_TYPE;
+
+
+typedef enum
+{
+   PART_ONLY_READ = 0,
+   PART_READ_WRITE,
+}PART_R_OR_W_TYPE;
+
+
+typedef enum
+{
+   PART_DATA_TYPE = 0,
+   PART_BIN_TYPE,
+   PART_FS_TYPE,
+}PART_TYPE;
+
+typedef enum
+{
+   FS_SQSH4 = 0,
+   FS_JFFS2,
+   FS_YAFFS2,
+}FS_TYPE;
+
+
+typedef enum
+{
+   MEDIUM_SPINOR = 0,
+   MEDIUM_SPINAND,
+}MEDIUM_TYPE;
+
+typedef enum
+{
+   PART_SPIFLASH = 0,
+   PART_SPINAND,
+   PART_SPINOR_SPINAND,
+}PART_MEDIUM;
+
+
+
+
+typedef struct
+{
+    unsigned long page_size; /*spi page size*/
+    unsigned long pages_per_block;/*page per block*/
+    unsigned long total_size;/*spiflash size*/
+}T_SPI_INIT_INFO, *T_PSPI_INIT_INFO;
+
+typedef struct
+{
+	unsigned char  name[PARTITION_NAME_LEN];	//̷
+	unsigned long  Size;                     //С
+    unsigned long  ld_addr;	                //еַ
+    unsigned char  type;				        //ͣdata , bin, fs
+    unsigned char  r_w_flag;			        //	r_w or onlyread
+    unsigned char  hidden_flag;			    //	hidden_flag or no hidden_flag
+    unsigned char  backup;				    //Ƿ񱸷
+	unsigned char  check;                   //Ƚ
+	unsigned char  mtd_idex;                //mtdidex
+    unsigned char  fs_type;                 //ļϵͳ
+    unsigned char  medium_flag:1;           //0 -> not need medium_tpye,1->need medium_type
+	unsigned char  medium_type:1;           //0->spi, 1->spinand
+	unsigned char  rev1:6;
+    unsigned long  flash_startpos;          //˷flash
+}T_CREAT_PARTITION_INFO;
+
+
+typedef struct
+{
+    unsigned long   file_length;    //bin:file_length  fs:δ      
+    unsigned long   ld_addr;        //bin: ld_addr     fs:δ
+    unsigned long   backup_pos;     //bin:backup_page  fs:δ     //ֽΪλ
+    unsigned char   check;          //bin:check          fs:δ  
+    unsigned char   mtd_idex;
+    unsigned char   medium_flag:1;  //介质是否区分的标志，0 -》not need medium_tpye,1->need medium_type
+	unsigned char   medium_type:1; //0表示spi, 1表示spinand
+	unsigned char   rev1:6;
+    unsigned char   rev2;
+}T_BIN_CONFIG;
+
+typedef struct
+{
+    unsigned long   file_length;    //  ļϵͳľļЧȣĿǰضõ    
+    unsigned char   check;          //  ǷȽ
+    unsigned char   mtd_idex;       //mtdidex
+    unsigned char   fs_type;        //ļϵͳ
+    unsigned char   medium_flag:1;  //介质是否区分的标志，0 -》not need medium_tpye,1->need medium_type
+	unsigned char   medium_type:1;  //0表示spi, 1表示spinand
+	unsigned char   rev1:6;
+    unsigned long   rev2;          //
+    unsigned long   rev3;          //  
+}T_FS_CONFIG;
+
+typedef struct
+{
+    unsigned long   pos;    //      
+    unsigned char   table[512];
+}T_PARTITION_TABLE_CONFIG;
+
+
+typedef struct
+{
+    unsigned long  parameter1;    //bin:file_length  fs:δ      
+    unsigned long  parameter2;    //bin: ld_addr     fs:δ
+    unsigned long  parameter3;    //bin:backup_page  fs:δ     
+    unsigned long  parameter4;    //bin:check          fs:δ     
+}T_EX_PARTITION_CONFIG;
+
+typedef struct
+{
+    unsigned char           type;                     //data,/bin/fs  ,  E_PARTITION_TYPE
+    volatile unsigned char  r_w_flag:4;               //only read or write
+    unsigned char           hidden_flag:4;            //hidden or no hidden
+    unsigned char           name[PARTITION_NAME_LEN]; //
+    unsigned long           ksize;                    //СKΪλ
+    unsigned long           start_pos;                //ĿʼλãֽΪλ     
+}T_PARTITION_CONFIG;
+
+
+typedef struct
+{
+    T_PARTITION_CONFIG        partition_info;
+    T_EX_PARTITION_CONFIG     ex_partition_info;
+}T_PARTITION_TABLE_INFO;
+
+
+
+/************************************************************************
+ * NAME:     partition_getversion
+ * FUNCTION  get partition vesion
+ * PARAM:    void
+ * RETURN:   version
+**************************************************************************/
+unsigned char *partition_getversion(void);
+
+/************************************************************************
+ * NAME:     Sflash_Creat
+ * FUNCTION  partition creat
+ * PARAM:    [in] T_CREAT_PARTITION_INFO *partition
+ * RETURN:   success handle, fail retuen null
+**************************************************************************/
+void *partition_creat(T_CREAT_PARTITION_INFO *partition);
+
+
+/************************************************************************
+ * NAME:     Sflash_Close
+ * FUNCTION  partition close
+ * PARAM:    [in] T_PARTITION_TABLE_INFO *pFile
+ * RETURN:   success return 0, fail retuen -1
+**************************************************************************/
+int partition_close(void *handle);
+
+/************************************************************************
+ * NAME:     Sflash_Open
+ * FUNCTION  partition open
+ * PARAM:    [in] unsigned char *partition_name
+ * RETURN:   success return T_PARTITION_TABLE_INFO *pFile, fail retuen AK_NULL
+**************************************************************************/
+void *partition_open(unsigned char *name);
+
+/************************************************************************
+ * NAME:     Sflash_Write
+ * FUNCTION  partition write
+ * PARAM:    [in] T_PARTITION_TABLE_INFO *pFile, 
+                   [in] unsigned char *data, 
+                   [in]  unsigned LONG data_len
+ * RETURN:   success handle, fail retuen null
+**************************************************************************/
+int partition_write(void *handle, unsigned char *data, unsigned long data_len);
+
+
+/************************************************************************
+ * NAME:     Sflash_Read
+ * FUNCTION  partition read
+ * PARAM:    [in] T_PARTITION_TABLE_INFO *pFile, 
+                   out] unsigned char *data, 
+                   [in]  unsigned LONG data_len
+ * RETURN:   success return 0, fail retuen -1
+**************************************************************************/
+int partition_read(void *handle, unsigned char *data, unsigned long data_len);
+
+
+/************************************************************************
+ * NAME:     Partition_Get_Attr
+ * FUNCTION  get partition ex_attr 
+ * PARAM:   [in] T_U32pFile, 
+                  [out]  T_pVOID ex_arrt
+ * RETURN:   success return 0, fail retuen -1
+**************************************************************************/
+
+int partition_get_attr(void *handle, T_EX_PARTITION_CONFIG *ex_arrt);
+
+
+/************************************************************************
+ * NAME:     Partition_Set_Attr
+ * FUNCTION  set partition ex_attr 
+ * PARAM:    [in] T_U32pFile, 
+                   [out]  T_pVOID ex_arrt
+ * RETURN:   success return 0, fail retuen -1
+**************************************************************************/
+int partition_set_attr(void *handle, T_EX_PARTITION_CONFIG *ex_arrt);
+
+
+/************************************************************************
+ * NAME:     Partition_Get_Partition_Table
+ * FUNCTION get the partition table
+ * PARAM:    T_PARTITION_TABLE_CONFIG *part_talbe
+ * RETURN:    success return 0, fail retuen -1
+**************************************************************************/
+//spiflashspinandpage size is diffrent
+int partition_get_partition_table(T_PARTITION_TABLE_CONFIG *part_talbe, PART_MEDIUM medium_type);
+int partition_get_partition_backup_table(T_PARTITION_TABLE_CONFIG *part_talbe, PART_MEDIUM medium_type);
+
+
+/************************************************************************
+ * NAME:     partition_get_data_size
+ * FUNCTION get the partition data size
+ * PARAM:    T_PARTITION_TABLE_CONFIG *part_talbe
+ * RETURN:    success return data_size, fail retuen 0
+**************************************************************************/
+unsigned long partition_get_data_size(void *handle);
+
+
+/************************************************************************
+ * NAME:     partition_get_ksize
+ * FUNCTION get partition size ,K
+ * PARAM:    void *handle
+ * RETURN:    success return ksize, fail retuen 0
+**************************************************************************/
+
+unsigned long partition_get_ksize(void *handle);
+
+
+///////////////////////////////////////////////////////////////////////////////////////
+//˽ӿṩ¼ʹã
+//ȫ¼ʱһmacַ
+//ʱbootĴС֮ǰһôλþͲһ
+//ڶmacַʱҪþɵķµķ
+void partition_set_partition_startpage(unsigned long start_page, PART_MEDIUM medium_type);
+void partition_set_partition_startpage_spinand(unsigned long *start_page, unsigned long *backup_start_page);
+
+
+//ӿֻӦspiflash
+//Żܵ⣬¼ʱpartitionжβдռһЩʱ䣬¼ʱֻʱٽаЩдȥ
+int partition_burn_partitiontab_info_init_spiflash(unsigned char burn_mode);
+int partition_burn_partitiontab_info_end_spiflash(void);
+
+
+
+#endif      //_FHA_BINBURN_H_
+
+
diff --git a/drivers/mtd/partition/public_info.h b/drivers/mtd/partition/public_info.h
new file mode 100755
index 0000000..2bae177
--- /dev/null
+++ b/drivers/mtd/partition/public_info.h
@@ -0,0 +1,60 @@
+
+#ifndef _PUBILC_INFO_H_
+#define _PUBILC_INFO_H_
+
+//public_info.h
+
+#include "spinand_burn.h"
+
+
+
+#define K_SIZE              1024
+
+
+typedef struct
+{
+   unsigned long    read_block_num;//ʱ¼ɹȡĿ
+   unsigned long    block_id;      //дʱ¼ٸ飬
+   unsigned long    block_origin;
+   unsigned long    block_backup;
+   unsigned long    r_w_data_size;
+   unsigned long    partition_start_page;
+   unsigned long    current_erase_block;//дʱж뵱ǰ鲻ȣͽв
+   unsigned char    write_table_flag;
+   unsigned char    init_success_flag;
+   unsigned char    open_time; //򿪵Ĵ
+   unsigned char    write_flag;//д־,дĹ,ܶ
+   unsigned char    read_flag; //־ĹУд
+   unsigned char    set_attr_flag; //Եı־
+}T_PARTITION; 
+
+
+#ifdef SUPPORT_SPINAND
+typedef struct
+{
+    unsigned long partition_start; /*bin data start addr*/
+    unsigned long page_size;     /*spi page size*/
+	unsigned long oob_size;     /*oob size*/
+	unsigned long initbad_offset;     /*oob size*/
+    unsigned long pages_per_block;/*page per block*/
+    unsigned long partition_table_start;
+    unsigned long partition_table_start_backup;
+    unsigned long total_size;
+}T_SPINAND_INIT_INFO, *T_pSPINAND_INIT_INFO;
+
+
+//bin nand struct info
+typedef struct
+{
+    unsigned long  bin_page_size;          //bin page size to write
+    unsigned long  page_per_block;         //pages per block
+    unsigned long  block_per_plane;        //blocks per plane
+    unsigned long  total_block_num;        //total_block_num
+    unsigned short boot_page_size;         //boot page size to write
+}T_BIN_NAND_INFO;
+
+#endif
+
+
+#endif
+
diff --git a/drivers/mtd/partition/spiburn.c b/drivers/mtd/partition/spiburn.c
new file mode 100755
index 0000000..38bffa8
--- /dev/null
+++ b/drivers/mtd/partition/spiburn.c
@@ -0,0 +1,2462 @@
+/**
+ * @FILENAME: spiburn.c
+ * @BRIEF xx
+ * Copyright (C) 2011 Anyka (GuangZhou) Software Technology Co., Ltd.
+ * @AUTHOR luqiliu
+ * @DATE 2009-11-19
+ * @VERSION 1.0
+ * @modified lu 2011-11-03
+ * Ҫ֧޸SPIĴ洢ṹblockΪλ洢ļ
+ * @REF
+ */
+
+#include "spiburn.h"
+#include "public_info.h"
+#include "partition_lib.h"
+
+
+
+
+#ifdef SUPPORT_SPIFLASH 
+
+
+#define ONE_PAGE_FILE_NUM   7
+#define T_MAX_FILE_NUM      15
+
+
+typedef enum
+{
+    P_MODE_NEWBURN = 1,           //new burn
+    P_MODE_UPDATE,                //update mode
+}E_P_BURN_MODE;
+
+
+
+extern T_FHA_LIB_CALLBACK  gPrtition;
+
+T_PARTITION  g_spi_partition = {0};
+
+T_PARTITION_TABLE_INFO g_partition_table_info[T_MAX_FILE_NUM];
+
+
+unsigned char g_spiflash_burn_mode = 0;  //1ʾȫ¼, 2ʾ ¼
+unsigned char g_burn_flag = 0;//Ĭ0ʾ¼, 1ʾ¼
+unsigned char g_partition_num = 0;
+unsigned char g_burn_partition_flag = 0;
+
+
+
+
+
+
+
+
+typedef struct
+{
+    unsigned long partition_start; /*bin data start addr*/
+    unsigned long page_size;     /*spi page size*/
+    unsigned long pages_per_block;/*page per block*/
+    unsigned long partition_table_start;
+    unsigned long total_size;
+}
+T_SPI_BURN_INIT_INFO;
+
+static T_SPI_BURN_INIT_INFO m_spi_burn;
+
+
+extern unsigned long sflash_str_len(const unsigned char *string);
+
+
+
+//only erase a block
+static int prod_spierase(unsigned long nchip,  unsigned long nblock)
+{
+    return gPrtition.Erase(nchip, nblock);
+}
+
+//only write a page each time
+static int prod_spiwritepage(unsigned long page, unsigned long pagecnt, const unsigned char *pdata)
+{
+    return gPrtition.Write(0, page, pdata, pagecnt, 0, 0, 0);
+}
+
+//only read a page each time
+static int prod_spireadpage(unsigned long page, unsigned long pagecnt, unsigned char *pdata)
+{
+    return gPrtition.Read(0, page, pdata, pagecnt, 0, 0, 0);
+} 
+
+int sflash_write_page(const unsigned char *pData, unsigned long startpage, unsigned long pagecnt)
+{
+    unsigned long i = 0; 
+    unsigned long blockstart, blockend;
+    unsigned char erase_flag = 1;
+
+    blockstart = startpage / m_spi_burn.pages_per_block;
+    blockend = (startpage + pagecnt) / m_spi_burn.pages_per_block;
+    
+    //gPrtition.Printf(" erase block:%d, %d\r\n", blockstart, blockend);
+    for (i=blockstart; i<=blockend; i++)
+    {
+       // gFHAf.Printf("FHA_S block:%d\r\n", i);
+        if((i == blockend) && ((startpage + pagecnt) % m_spi_burn.pages_per_block) == 0)
+        {
+            break;
+        }
+        else
+        {
+            if (g_spi_partition.current_erase_block != i)
+            {
+                //gPrtition.Printf("erase:%d\r\n", i);
+                if(erase_flag)
+                {
+                    erase_flag = 0;
+                    //gPrtition.Printf("e.");
+                }
+                if (0 != prod_spierase(0, i))
+                {
+                    gPrtition.Printf("erase fail at block:%d\r\n", i);
+                    return -1;
+                }
+                g_spi_partition.current_erase_block = i;
+
+            }
+        }
+    } 
+
+    //gPrtition.Printf("startpage%d, pagecnt:%d, %02x, %02x, %x02xr\n", startpage, pagecnt, pData[0], pData[1], pData[2], pData[3]);
+
+    if(0 != prod_spiwritepage(startpage, pagecnt, pData))
+    {
+        gPrtition.Printf("part: prod_spiwritepage write fail at page start:%d, cnt:%d\r\n", startpage, pagecnt);
+        return -1;
+    }
+
+    return 0;
+}
+
+
+
+int sflash_write_data(const unsigned char *pData, unsigned long data_len, unsigned long startpage, unsigned long page_cnt, unsigned char check)
+{
+    unsigned long i = 0, j = 0, compare_size = 0, read_size = data_len;
+    unsigned char *pBuf = NULL;
+    
+    if(0 != sflash_write_page(pData, startpage, page_cnt))
+    {
+        return -1;
+    }
+    else
+    {    
+        if (check)
+        {
+            pBuf = gPrtition.RamAlloc(m_spi_burn.page_size);
+            if(NULL == pBuf)
+            {
+                gPrtition.Printf("pBuf malloc fail\r\n");
+                return -1;
+            }
+
+            //malloc buffer to read data
+            for(j = 0; j < page_cnt; j++)
+            {
+                if(read_size >= m_spi_burn.page_size)
+                {
+                    compare_size = m_spi_burn.page_size;
+                }
+                else
+                {
+                    compare_size = read_size;
+                }
+                //gPrtition.Printf("read page:%d,  compare_size:%d, startpage:%d, page_cnt:%d\r\n", j, compare_size, startpage, page_cnt);
+                
+                gPrtition.MemSet(pBuf, 0, m_spi_burn.page_size);    
+                if(0 != prod_spireadpage(startpage+j, 1, pBuf))
+                {
+                    gPrtition.Printf("compare fail at page start:%d, cnt:%d\r\n", startpage+j, 1);
+                    gPrtition.RamFree(pBuf);
+                    return -1;
+                }
+
+                if(0 != gPrtition.MemCmp(&pData[j*m_spi_burn.page_size], pBuf, compare_size))
+                {
+                    //gPrtition.Printf("read_size:%d\r\n", read_size);
+                    
+                    gPrtition.Printf("compare fail, compare_size:%d\r\n", compare_size);
+                    for (i=0; i<compare_size; i++)
+                    {
+                        //if (!(i%16))
+                        //    gFHAf.Printf("\r\n"); 
+                        if (pData[j*m_spi_burn.page_size + i] != pBuf[i])
+                        {
+                            gPrtition.Printf("St:%d, i:%d,S:%02x_D:%02x\r\n", startpage+j, i, pData[j *m_spi_burn.page_size + i],pBuf[i]);
+                            break;
+                        }
+                    }
+                    
+                    gPrtition.Printf("\r\n");    
+                    
+                    gPrtition.RamFree(pBuf);
+                    return -1;
+                }
+
+                read_size -= compare_size;
+            }
+
+            gPrtition.RamFree(pBuf);
+        }
+    }
+
+    return 0;
+}
+
+
+//˽ӿṩ¼ʹã
+//ȫ¼ʱһmacַ
+//ʱbootĴС֮ǰһôλþͲһ
+//ڶmacַʱҪþɵķµķ
+void sflash_set_partition_startpage(unsigned long start_page)
+{
+    m_spi_burn.partition_table_start = start_page;
+    gPrtition.Printf("m_spi_burn.partition_table_start:%d\r\n", m_spi_burn.partition_table_start);
+}
+
+
+int sflash_get_partition_startpage(void)
+{
+    unsigned long boot_len = 0;//
+    unsigned char boot_temp = 0;//
+    unsigned char *buf = NULL;
+    unsigned long offset = 0;
+    unsigned long page_cnt = 3;//ҳ
+    unsigned long i=0;
+
+    buf =  (unsigned char *)gPrtition.RamAlloc(sizeof(unsigned char)*page_cnt*m_spi_burn.page_size);
+    if(NULL == buf)
+    {
+        gPrtition.Printf("update burn buf malloc fail\n");
+        return -1;
+    }
+
+    gPrtition.MemSet(buf, 0, sizeof(unsigned char)*page_cnt*m_spi_burn.page_size);
+    
+    //ȡ  binС
+    if (0 != prod_spireadpage(0, page_cnt, buf))//3ҳ
+	{
+        gPrtition.RamFree(buf);
+        gPrtition.Printf("update burn spi_flash_read fail\n");
+		return -1;
+	}
+    
+    for (i = 0; i < page_cnt*m_spi_burn.page_size - 4; i++)
+	{
+		if (('S' == buf[i]) && ('P' == buf[i+1]) && ('I' == buf[i+2]) && ('P' == buf[i+3]))
+		{
+			offset = i;
+			break;
+		}
+	}
+
+    if(i == page_cnt*m_spi_burn.page_size- 4)
+    {
+        gPrtition.RamFree(buf);
+        gPrtition.Printf("update get boot size fail\n");
+        return -1; 
+    }
+
+    //ȡspiһԱֵ
+    //gPrtition.Printf("boot block num offset:%d\n", offset + 4 + sizeof(T_SFLASH_INFO) - 33);
+    gPrtition.MemCpy(&boot_temp, buf + offset + 4 + sizeof(T_SFLASH_INFO) - 33, 1);//ȡֵǿ
+ 
+    gPrtition.RamFree(buf);
+    
+    boot_len = boot_temp*m_spi_burn.pages_per_block;//ȡҳ
+    //gPrtition.Printf("Sflash_Get_Partition_Startpage g_boot_len:%d\n", boot_len);
+
+    return (int)boot_len;
+}
+
+
+//Żܵ⣬¼ʱpartitionжβдռһЩʱ䣬¼ʱֻʱٽаЩдȥ
+int spiflash_burn_partitiontab_info_init(unsigned char burn_mode)
+{
+	if(1 != g_spi_partition.init_success_flag)
+    {
+        if (NULL == gPrtition.Printf)
+        {
+        }
+        else
+        {
+            gPrtition.Printf("part: Sflash_Creat not Sflash_Init\r\n");
+        }
+        return -1;
+    }
+
+	if(P_MODE_NEWBURN != burn_mode)
+	{
+		gPrtition.Printf("part: it is not new burn mode, P_MODE_NEWBURN\r\n");
+		 return -1;
+	}
+	
+	gPrtition.MemSet(g_partition_table_info, 0, T_MAX_FILE_NUM*sizeof(T_PARTITION_TABLE_INFO));
+	g_spiflash_burn_mode = burn_mode;
+	g_burn_flag = 1;//ʾ¼߽¼
+	g_partition_num = 0;
+
+	return 0;
+
+}
+
+
+int spiflash_burn_partitiontab_info_end(void)
+{
+	unsigned long page_cnt = 1;//, i = 0;
+    unsigned long page_size = m_spi_burn.page_size;
+	unsigned char *buf = NULL;
+
+	if(g_spiflash_burn_mode != P_MODE_NEWBURN  || g_burn_flag == 0)
+	{
+		gPrtition.Printf("part: it is not in burntool P_MODE_NEWBURN, g_burn_mode:%d\r\n", g_spiflash_burn_mode);
+        return -1;
+	}
+
+	if(g_partition_num == 0 || g_partition_num > T_MAX_FILE_NUM)
+	{
+		gPrtition.Printf("part: spiflash_burn_partitiontab_info_end fail, g_partition_num:%d\r\n", g_partition_num);
+        return -1;
+	}
+
+	if(g_partition_num > ONE_PAGE_FILE_NUM)
+	{
+		page_cnt = 2;
+	}
+	
+    //ļҪ2ҳ·
+    buf = gPrtition.RamAlloc(page_size * page_cnt * sizeof(unsigned char));
+    if(NULL == buf)
+    {
+        gPrtition.Printf("part: Sflash_Creat buf malloc fail\r\n");
+        return -1;
+    }
+
+    gPrtition.MemSet(buf, 0xFF, page_size* page_cnt *sizeof(unsigned char));
+
+	gPrtition.MemCpy(&buf[0], &g_partition_num, 4);
+	gPrtition.MemCpy(&buf[4], &g_partition_table_info, g_partition_num*sizeof(T_PARTITION_TABLE_INFO));
+	
+
+	//дݵ
+    gPrtition.Printf("write table page:%d\r\n", m_spi_burn.partition_table_start);
+    if(0 != sflash_write_data(buf, page_cnt*page_size, m_spi_burn.partition_table_start, page_cnt, 1))
+    {
+        gPrtition.RamFree(buf);
+        gPrtition.Printf("part: Sflash_Close write partition table fail, page:%d\r\n", m_spi_burn.partition_table_start);
+        return -1;
+    }
+
+    gPrtition.Printf("write table back page:%d\r\n", m_spi_burn.partition_table_start+m_spi_burn.pages_per_block);
+    //д
+    if(0 != sflash_write_data(buf, page_cnt*page_size, m_spi_burn.partition_table_start+m_spi_burn.pages_per_block, page_cnt, 1))
+    {
+        gPrtition.RamFree(buf);
+        gPrtition.Printf("part: Sflash_Close write partition table back fail, page:%d\r\n", m_spi_burn.partition_table_start+1);
+        return -1;
+    }
+
+	if(buf != NULL)
+    {
+        gPrtition.RamFree(buf);
+        buf = NULL;
+    }
+
+
+	g_spiflash_burn_mode = 0;
+	g_burn_flag = 0;
+	g_partition_num = 0;
+
+
+	return 0;
+}
+
+
+
+
+int sflash_init(void *SpiInfo, unsigned long table_page)
+{
+   T_SPI_INIT_INFO *info = (T_SPI_INIT_INFO *)SpiInfo;
+   unsigned long table_start_page = table_page;
+
+    g_spi_partition.init_success_flag = 0;
+   
+    if (NULL == info)
+    {
+        gPrtition.Printf("Sflash_Init info AK_NULL\n");
+        return -1;
+    }
+
+    m_spi_burn.page_size      = info->page_size;
+    m_spi_burn.pages_per_block = info->pages_per_block;
+    m_spi_burn.total_size    = info->total_size;
+
+    if(table_start_page == 0)
+    {
+        //read the partition start
+        table_start_page = sflash_get_partition_startpage();
+        if(table_start_page == 0 || table_start_page == -1)
+        {
+            gPrtition.Printf("Sflash_Init read partition_start == 0 or -1\n", table_start_page);
+            return -1;
+        }
+        
+    }
+
+    //ӦԿ
+    if(table_start_page % info->pages_per_block != 0)
+    {
+        gPrtition.Printf("partition table start page is error (exp:BinPageStart%PagesPerBlock!=0), page:%d,\r\n", table_start_page);
+        return -1;
+    }
+
+    //ʼ
+    m_spi_burn.partition_table_start  = table_start_page;
+
+    //ʼֵ
+    m_spi_burn.partition_start  = table_start_page + info->pages_per_block*2;//һıݿ
+
+    g_spi_partition.write_table_flag = 0; 
+    g_spi_partition.init_success_flag = 1;
+
+    //ʼҪӦʹùУֵ仯
+    g_spi_partition.partition_start_page = m_spi_burn.partition_start;//ֵ,
+    g_spi_partition.current_erase_block = 0xFFFFFFFF;
+    g_spi_partition.open_time = 0; //򿪵Ĵ
+    g_spi_partition.write_flag = 0;//д־,дĹ,ܶ
+    g_spi_partition.read_flag = 0; //־ĹУд
+    
+    return 0;
+}
+
+
+
+int sflash_check_name_is_exist(unsigned char *dst_name, unsigned char *buf, unsigned long file_num, unsigned long *name_idex)
+{
+    unsigned long i = 0, j = 0;
+    unsigned long src_name_len = 0, dst_name_len = 0;
+    unsigned char *name = NULL;
+    unsigned char name_dst[PARTITION_NAME_LEN + 1];
+    unsigned char name_src[PARTITION_NAME_LEN + 1];
+
+    for(i = 0; i < file_num; i++)
+    {
+        unsigned long offset = 4 + i*sizeof(T_PARTITION_TABLE_INFO) + 2;//T_PARTITION_CONFIGǰֽ
+        //gPrtition.Printf("partition name:%d, %d, %d\r\n", offset, sizeof(T_PARTITION_TABLE_INFO));
+        name = &buf[offset];
+
+        gPrtition.MemSet(name_dst, 0, PARTITION_NAME_LEN + 1);
+        gPrtition.MemSet(name_src, 0, PARTITION_NAME_LEN + 1);
+        gPrtition.MemCpy(name_dst, dst_name, PARTITION_NAME_LEN );
+        gPrtition.MemCpy(name_src, name, PARTITION_NAME_LEN );
+        src_name_len = sflash_str_len(name_src);
+        dst_name_len = sflash_str_len(name_dst);
+        //gPrtition.Printf("partition name:%s, %s\r\n", name, dst_name);
+        //gPrtition.Printf("name len:%d, %d\r\n", dst_name_len, src_name_len);
+        if(src_name_len == dst_name_len)
+        {
+            for(j=0; j < src_name_len; j++)
+            {
+                //gPrtition.Printf("partition name:%02x, %02x\r\n", name[j], dst_name[j]);
+                if(name_src[j] != name_dst[j])
+                {
+                    break;
+                }    
+            }
+
+            if(j == src_name_len)
+            {
+                //gPrtition.Printf("partition name is exist:%s, %s\r\n", name_src, name_dst);
+                break;
+            }
+        }
+    }
+
+    if(i == file_num)
+    {
+        //gPrtition.Printf("partition name is not exist:%s \r\n",  name_dst);
+        return -1;
+    }
+
+    *name_idex = i;
+
+    return 0;
+}
+
+
+T_PARTITION_TABLE_INFO *sflash_creat(T_CREAT_PARTITION_INFO *partition)
+{
+    unsigned char *buf = NULL;
+    unsigned long file_num = 0;//, i = 0;
+    T_PARTITION_TABLE_INFO *pFile = NULL;
+    unsigned long page_cnt = 2;
+    unsigned long page_size = m_spi_burn.page_size;
+    unsigned long PagesPerBlock = m_spi_burn.pages_per_block;
+    unsigned long Total_Size = m_spi_burn.total_size;
+    T_BIN_CONFIG bin_config;
+    T_FS_CONFIG fs_config;
+    unsigned long name_idex = 0;
+	unsigned long last_start_page = 0;
+	unsigned long last_page_cnt = 0;
+    
+    if(1 != g_spi_partition.init_success_flag)
+    {
+        if (NULL == gPrtition.Printf)
+        {
+        }
+        else
+        {
+            gPrtition.Printf("part: Sflash_Creat not Sflash_Init\r\n");
+        }
+        return NULL;
+    }
+
+    //
+    if(g_spi_partition.open_time == 1)
+    {
+        gPrtition.Printf("part: Sflash_Creat the other partition name is openning\r\n");
+        return NULL;
+    }
+
+    if(sflash_str_len(partition->name) > PARTITION_NAME_LEN)
+    {
+        gPrtition.Printf("part: sflash_creat the partition name len more than %d\r\n", PARTITION_NAME_LEN);
+        return NULL;
+    }
+
+    //read the partition table to get the filecnt
+    buf = gPrtition.RamAlloc(page_size*sizeof(unsigned char));
+    if(NULL == buf)
+    {
+        gPrtition.Printf("part: Sflash_Creat buf malloc fail\r\n");
+        return NULL;
+    }
+
+    gPrtition.MemSet(buf, 0x0, page_size*sizeof(unsigned char));
+    gPrtition.Printf("read partition_table_start:%d\r\n", m_spi_burn.partition_table_start);
+
+	if(g_spiflash_burn_mode == P_MODE_NEWBURN && g_burn_flag == 1)
+	{
+		gPrtition.MemCpy(&buf[0], &g_partition_num, 4);
+		gPrtition.MemCpy(&buf[4], &g_partition_table_info, ONE_PAGE_FILE_NUM*sizeof(T_PARTITION_TABLE_INFO));
+	}
+	else
+	{
+	    if(0 != prod_spireadpage(m_spi_burn.partition_table_start, 1, buf))
+	    {
+	        gPrtition.RamFree(buf);
+	        gPrtition.Printf("part: Sflash_Creat read fail\r\n");
+	        return NULL;
+	    }
+	}
+    /*
+    for (i=0; i<256; i++)
+    {
+        if (!(i%16))
+           gPrtition.Printf("\r\n"); 
+
+        gPrtition.Printf("%02x ", buf[i]);
+    }
+    */
+   
+    gPrtition.MemCpy(&file_num, buf, 4);
+    gPrtition.Printf("part: Sflash_Creat file_num:%d\r\n", file_num);
+   
+    if(file_num == 0 || file_num == 0xFFFFFFFF)
+    {
+        file_num = 0;
+    }
+
+    //жļĸǷ񳬹һĸ
+    //if(file_num > ((m_spi_burn.PagesPerBlock*m_spi_burn.PageSize)/sizeof(T_PARTITION_TABLE_INFO) - 1))
+    //Ŀǰ15
+    if(file_num >= T_MAX_FILE_NUM)
+    {
+        gPrtition.RamFree(buf);
+        gPrtition.Printf("part: file_num is more than the max(15)\r\n");
+        return NULL;
+    }
+
+    if(file_num > 0)
+    {
+        T_PARTITION_TABLE_INFO *pFile_temp;
+        
+        if(file_num > ONE_PAGE_FILE_NUM)
+        {
+            if(buf != NULL)
+            {
+                gPrtition.RamFree(buf);
+                buf = NULL;
+            }
+			
+            //ļҪ2ҳ·
+            buf = gPrtition.RamAlloc(page_size * page_cnt * sizeof(unsigned char));
+            if(NULL == buf)
+            {
+                gPrtition.Printf("part: Sflash_Creat buf malloc fail\r\n");
+                return NULL;
+            }
+
+            gPrtition.MemSet(buf, 0x0, page_size* page_cnt *sizeof(unsigned char));
+			if(g_spiflash_burn_mode == P_MODE_NEWBURN && g_burn_flag == 1)
+			{
+				gPrtition.MemCpy(&buf[0], &g_partition_num, 4);
+				gPrtition.MemCpy(&buf[4], &g_partition_table_info, T_MAX_FILE_NUM*sizeof(T_PARTITION_TABLE_INFO));
+			}
+			else
+			{
+	            gPrtition.Printf("2 read partition_table_start:%d\r\n", m_spi_burn.partition_table_start);
+	            if(0 != prod_spireadpage(m_spi_burn.partition_table_start, page_cnt, buf))
+	            {
+	                gPrtition.RamFree(buf);
+	                gPrtition.Printf("part: Sflash_Creat read fail\r\n");
+	                return NULL;
+	            }
+			}
+        }
+        
+        //ȡһļĿʼλúͷС
+        //ԵõһļĿʼλ
+        pFile_temp = (T_PARTITION_TABLE_INFO *)(buf + 4);
+        last_start_page = pFile_temp[file_num - 1].partition_info.start_pos/page_size;
+        last_page_cnt = ((pFile_temp[file_num - 1].partition_info.ksize*K_SIZE)/page_size);
+        g_spi_partition.partition_start_page= last_start_page + last_page_cnt;
+    }
+
+	 //жϷǷ
+    if(sflash_check_name_is_exist(partition->name, buf, file_num, &name_idex) == 0)
+    {
+        gPrtition.RamFree(buf);
+        gPrtition.Printf("part: Sflash_Creat fail\r\n");
+        return NULL;
+    }
+
+    if(buf != NULL)
+    {
+        gPrtition.RamFree(buf);
+        buf = NULL;
+    }
+
+   //gPrtition.Printf("sizeof(T_PARTITION_TABLE_INFO):%d\r\n", sizeof(T_PARTITION_TABLE_INFO));
+    pFile = (T_PARTITION_TABLE_INFO *)gPrtition.RamAlloc(sizeof(T_PARTITION_TABLE_INFO));
+    if(NULL == pFile)
+    {
+        gPrtition.Printf("part: Sflash_Creat buf malloc fail\r\n");
+        return NULL;
+    }
+    gPrtition.MemSet(pFile, 0, sizeof(T_PARTITION_TABLE_INFO));
+    
+    gPrtition.MemCpy(pFile->partition_info.name, partition->name, PARTITION_NAME_LEN);
+    pFile->partition_info.type = partition->type;
+    pFile->partition_info.r_w_flag = partition->r_w_flag;
+    pFile->partition_info.hidden_flag = partition->hidden_flag;
+    if(partition->type == PART_BIN_TYPE || partition->type == PART_DATA_TYPE)
+    {
+        bin_config.check= partition->check;
+        bin_config.ld_addr= partition->ld_addr;
+        bin_config.mtd_idex = partition->mtd_idex;
+        bin_config.file_length = 0;//ʼ
+        bin_config.medium_flag = partition->medium_flag;
+		bin_config.medium_type = partition->medium_type;
+        bin_config.rev1 = 0;
+        bin_config.rev2 = 0;
+    }
+    else if(partition->type == PART_FS_TYPE)
+    {
+        fs_config.check = partition->check;
+        fs_config.fs_type = partition->fs_type;
+        fs_config.mtd_idex = partition->mtd_idex;
+        fs_config.file_length = 0;//ʼ
+		fs_config.medium_flag = partition->medium_flag;
+		fs_config.medium_type = partition->medium_type;
+        fs_config.rev1 = 0;
+        fs_config.rev2 = 0;
+        fs_config.rev3 = 0;
+    }
+    else
+    {
+        gPrtition.RamFree(pFile);
+        pFile = NULL;
+        gPrtition.Printf("part: Sflash_Creat type is error\r\n");
+        return NULL;
+    }
+
+	if(partition->flash_startpos != 0)
+	{
+		pFile->partition_info.start_pos = partition->flash_startpos;
+	}
+	else
+	{
+		pFile->partition_info.start_pos = g_spi_partition.partition_start_page*page_size;
+	}
+    
+   // gPrtition.Printf("start_page:%d\r\n", pFile->partition_info.start_page);
+    //ҳ
+    page_cnt = (partition->Size*K_SIZE + page_size - 1)/page_size;
+    //Կ
+    page_cnt = (page_cnt + PagesPerBlock - 1)/PagesPerBlock;
+    //ҳ
+    page_cnt = page_cnt * PagesPerBlock;
+    //gPrtition.Printf("page_cnt:%d\r\n", page_cnt);
+
+    //жϷСǷ񳬹spiС
+    if((pFile->partition_info.start_pos + page_cnt * page_size) > Total_Size)
+    {
+		gPrtition.Printf("part:  Sflash_burn_creat->partition page is more than spiflash, size:%d, %d\r\n", (pFile->partition_info.start_pos+page_cnt) * page_size, Total_Size);
+        gPrtition.RamFree(pFile);
+        pFile = NULL;
+        
+        return NULL;
+    }
+
+    if(partition->backup && partition->type != PART_FS_TYPE)
+    {
+        //бݣԷԿ󣬿Ƿƽ֣1
+        if(page_cnt%2 != 0)
+        {
+            page_cnt += 1;
+        }
+        
+        pFile->partition_info.ksize = (page_cnt*page_size/K_SIZE);
+        bin_config.backup_pos = pFile->partition_info.start_pos + (page_cnt/2)*page_size;
+
+    }
+    else
+    {
+         pFile->partition_info.ksize = (page_cnt*page_size/K_SIZE);
+        if(partition->type != PART_FS_TYPE)
+        {
+            bin_config.backup_pos = 0xFFFFFFFF;
+        }
+    }
+    
+    //¼binļչϢ
+    if(partition->type == PART_BIN_TYPE || partition->type == PART_DATA_TYPE)
+    {
+        //ṹԱȲһ򲻵16ֽڳ
+        if(sizeof(T_EX_PARTITION_CONFIG) != sizeof(T_BIN_CONFIG)  && sizeof(T_BIN_CONFIG) != 16)
+        {
+            gPrtition.RamFree(pFile);
+            pFile = NULL;
+            gPrtition.Printf("part: Sflash_Creat bin and ex parameter len is error\r\n");
+            return NULL;
+        }
+        gPrtition.MemSet(&pFile->ex_partition_info, 0, sizeof(T_EX_PARTITION_CONFIG));
+        gPrtition.MemCpy(&pFile->ex_partition_info, &bin_config, sizeof(T_EX_PARTITION_CONFIG));
+    }
+    else if(partition->type == PART_FS_TYPE)//¼ļϵͳ չϢ
+    {
+        if(sizeof(T_EX_PARTITION_CONFIG) != sizeof(T_FS_CONFIG) && sizeof(T_FS_CONFIG) != 16)
+        {
+            gPrtition.RamFree(pFile);
+            pFile = NULL;
+            gPrtition.Printf("part: Sflash_Creat fs and ex parameter len is error\r\n");
+            return NULL;
+        }
+        gPrtition.MemSet(&pFile->ex_partition_info, 0, sizeof(T_EX_PARTITION_CONFIG));
+        gPrtition.MemCpy(&pFile->ex_partition_info, &fs_config, sizeof(T_EX_PARTITION_CONFIG));
+    }
+    else
+    {
+        gPrtition.RamFree(pFile);
+        pFile = NULL;
+        gPrtition.Printf("part: Sflash_Creat type is error\r\n");
+        return NULL;
+    }
+
+    //gPrtition.Printf("creat type:%d \n", pFile->partition_info.type);
+    //gPrtition.Printf("creat r_w_flag:%d \n", pFile->partition_info.r_w_flag);
+   // gPrtition.Printf("creat hidden_flag:%d \n", pFile->partition_info.hidden_flag);
+   // gPrtition.Printf("creat ksize:%d \n", pFile->partition_info.ksize);
+   // gPrtition.Printf("creat start_pos:%d \n", pFile->partition_info.start_pos);
+   // gPrtition.Printf("creat name:%s \n", pFile->partition_info.name);
+    gPrtition.Printf("creat T:%d, R:%d, H:%d, K:%d, S:%d, N:%s \n"
+        , pFile->partition_info.type, pFile->partition_info.r_w_flag
+        , pFile->partition_info.hidden_flag, pFile->partition_info.ksize
+        , pFile->partition_info.start_pos, pFile->partition_info.name);
+    if(partition->type != PART_FS_TYPE)
+    {
+        //gPrtition.Printf("creat file_length:%d\r\n", bin_config.file_length);
+        //gPrtition.Printf("creat ld_addr:%x\r\n", bin_config.ld_addr);
+        //gPrtition.Printf("creat backup_pos:%d\r\n", bin_config.backup_pos);
+        //gPrtition.Printf("creat check:%d\r\n", bin_config.check);
+        //gPrtition.Printf("creat mtd_idex:%d\r\n", bin_config.mtd_idex);
+
+        gPrtition.Printf("creat ex_bin F:%d, L:%d, B:%d, C:%d, M:%d,fl:%d,ty:%d\r\n"
+            , bin_config.file_length, bin_config.ld_addr
+            , bin_config.backup_pos, bin_config.check
+            , bin_config.mtd_idex, bin_config.medium_flag, bin_config.medium_type);
+    }
+    else
+    {
+        //gPrtition.Printf("creat file_length:%d\r\n", fs_config.file_length);
+        //gPrtition.Printf("creat check:%d\r\n", fs_config.check);
+        //gPrtition.Printf("creat fs_type:%d\r\n", fs_config.fs_type);
+        //gPrtition.Printf("creat mtd_idex:%d\r\n", fs_config.mtd_idex);
+
+        gPrtition.Printf("creat ex_fs F:%d, C:%d, F:%d, M:%d,fl:%d,ty:%d\r\n"
+            , fs_config.file_length, fs_config.check
+            , fs_config.fs_type, fs_config.mtd_idex
+            , fs_config.medium_flag, fs_config.medium_type);
+    }
+    
+    g_spi_partition.write_table_flag = 1;
+    
+    g_spi_partition.open_time = 1; //򿪵Ĵ
+    g_spi_partition.write_flag = 0;//д־,дĹ,ܶ
+    g_spi_partition.read_flag = 0; //־ĹУд
+    g_spi_partition.r_w_data_size = 0;
+	g_spi_partition.current_erase_block = 0xFFFFFFFF;
+	g_spi_partition.set_attr_flag = 0;
+	
+    return pFile;
+}
+
+
+
+int sflash_close(T_PARTITION_TABLE_INFO *pFile)
+{
+    unsigned char *buf = NULL;
+    unsigned long file_num = 0;
+    unsigned long page_cnt = 1; //, i = 0;
+    unsigned long page_size = m_spi_burn.page_size;
+    unsigned long name_idex = 0;
+    T_BIN_CONFIG *bin_config;
+    T_FS_CONFIG *fs_config;
+
+
+    //gPrtition.Printf("c m_spi_burn.PageSize:%d\r\n", m_spi_burn.PageSize);    
+    if(NULL == pFile)
+    {
+        gPrtition.Printf("part: Sflash_Close pFile == AK_NULL\r\n");
+        return -1;
+    }
+
+    if(1 != g_spi_partition.init_success_flag)
+    {
+        gPrtition.RamFree(pFile);
+        pFile = NULL;
+        g_spi_partition.open_time = 0; 
+        g_spi_partition.write_flag = 0;
+        g_spi_partition.read_flag = 0; 
+        if (NULL == gPrtition.Printf)
+        {
+        }
+        else
+        {
+            gPrtition.Printf("part: Sflash_Close not Sflash_Init\r\n");
+        }
+        return -1;
+    }
+
+    if(g_spi_partition.write_table_flag)
+    {
+        g_spi_partition.write_table_flag = 0;
+
+        //read the partition table to get the filecnt
+        //gPrtition.Printf("page_size:%d, page_cnt:%d\r\n", page_size,  page_cnt);
+        buf = gPrtition.RamAlloc(page_size*page_cnt*sizeof(unsigned char));
+        if(NULL == buf)
+        {
+            gPrtition.RamFree(pFile);
+             pFile = NULL;
+            g_spi_partition.open_time = 0; 
+            g_spi_partition.write_flag = 0;
+            g_spi_partition.read_flag = 0; 
+            gPrtition.Printf("part: Sflash_Close buf malloc fail\r\n");
+            return -1;
+        }
+
+        gPrtition.MemSet(buf, 0xFF, page_size*page_cnt*sizeof(unsigned char));
+
+		if(g_spiflash_burn_mode == P_MODE_NEWBURN && g_burn_flag == 1)
+		{
+			gPrtition.MemCpy(&buf[0], &g_partition_num, 4);
+			gPrtition.MemCpy(&buf[4], &g_partition_table_info, ONE_PAGE_FILE_NUM*sizeof(T_PARTITION_TABLE_INFO));
+		}
+		else
+		{
+	        //gPrtition.Printf("3 read partition_table_start:%d\r\n", m_spi_burn.partition_table_start);
+	        if(0 != prod_spireadpage(m_spi_burn.partition_table_start, page_cnt, buf))
+	        {
+	            gPrtition.RamFree(buf);
+	            gPrtition.RamFree(pFile);
+	             pFile = NULL;
+	            g_spi_partition.open_time = 0; 
+	            g_spi_partition.write_flag = 0;
+	            g_spi_partition.read_flag = 0; 
+	            gPrtition.Printf("part: Sflash_Close read fail\r\n");
+	            return -1;
+	        }
+		}
+        /*
+        for (i=0; i<256; i++)
+        {
+            if (!(i%16))
+               gPrtition.Printf("\r\n"); 
+
+            gPrtition.Printf("%02x ", buf[i]);
+        }
+        */
+       
+        gPrtition.MemCpy(&file_num, buf, 4);
+        gPrtition.Printf("part: Sflash_Close file_num%d\r\n", file_num);
+       
+        if(file_num == 0 || file_num == 0xFFFFFFFF)
+        {
+            file_num = 0;
+        }
+
+        //жļĸǷ񳬹һĸ
+        //if(file_num > ((m_spi_burn.PagesPerBlock*m_spi_burn.PageSize)/sizeof(T_PARTITION_TABLE_INFO) - 1))
+        //Ŀǰ15
+        if(file_num >= T_MAX_FILE_NUM)
+        {
+            gPrtition.RamFree(buf);
+            gPrtition.RamFree(pFile);
+             pFile = NULL;
+            g_spi_partition.open_time = 0; 
+            g_spi_partition.write_flag = 0;
+            g_spi_partition.read_flag = 0; 
+            gPrtition.Printf("part: Sflash_Close file_num is more than the max(15)\r\n");
+            return -1;
+        }
+
+        if(file_num > 0)
+        {
+            if((file_num + 1 ) > ONE_PAGE_FILE_NUM)
+            {
+                if(buf != NULL)
+                {
+                    gPrtition.RamFree(buf);
+                    buf = NULL;
+                }
+                
+                page_cnt = 2;
+                
+                //ļҪ2ҳ·
+                buf = gPrtition.RamAlloc(page_size * page_cnt * sizeof(unsigned char));
+                if(NULL == buf)
+                {
+                    gPrtition.RamFree(pFile);
+                     pFile = NULL;
+                    g_spi_partition.open_time = 0; 
+                    g_spi_partition.write_flag = 0;
+                    g_spi_partition.read_flag = 0; 
+                    gPrtition.Printf("part: Sflash_Close buf malloc fail\r\n");
+                    return -1;
+                }
+
+                gPrtition.MemSet(buf, 0xFF, page_size* page_cnt *sizeof(unsigned char));
+
+				if(g_spiflash_burn_mode == P_MODE_NEWBURN && g_burn_flag == 1)
+				{
+					gPrtition.MemCpy(&buf[0], &g_partition_num, 4);
+					gPrtition.MemCpy(&buf[4], &g_partition_table_info, T_MAX_FILE_NUM*sizeof(T_PARTITION_TABLE_INFO));
+				}
+				else
+				{
+	                //gPrtition.Printf("4 read partition_table_start:%d\r\n", m_spi_burn.partition_table_start);
+	                if(0 != prod_spireadpage(m_spi_burn.partition_table_start, page_cnt, buf))
+	                {
+	                    gPrtition.RamFree(buf);
+	                    gPrtition.RamFree(pFile);
+	                     pFile = NULL;
+	                    g_spi_partition.open_time = 0; 
+	                    g_spi_partition.write_flag = 0;
+	                    g_spi_partition.read_flag = 0; 
+	                    gPrtition.Printf("part: Sflash_Close read fail\r\n");
+	                    return -1;
+	                }
+				}
+            }
+        }
+		
+
+        //¼µĳ?
+        //gPrtition.Printf("pFile->ex_partition_info.parameter1:%d \n", pFile->ex_partition_info.parameter1);
+        //gPrtition.MemCpy(&pFile->ex_partition_info.parameter1, &g_partition.r_w_data_size, 4);
+
+        if(pFile->partition_info.type == PART_BIN_TYPE || pFile->partition_info.type == PART_DATA_TYPE)
+        {
+            bin_config = (T_BIN_CONFIG *)(&pFile->ex_partition_info);
+        }
+        else if(pFile->partition_info.type == PART_FS_TYPE)
+        {
+            fs_config = (T_FS_CONFIG *)(&pFile->ex_partition_info);
+        }
+
+        //gPrtition.Printf("close type:%d \n", pFile->partition_info.type);
+        //gPrtition.Printf("close r_w_flag:%d \n", pFile->partition_info.r_w_flag);
+        //gPrtition.Printf("close hidden_flag:%d \n", pFile->partition_info.hidden_flag);
+        //gPrtition.Printf("close ksize:%d \n", pFile->partition_info.ksize);
+        //gPrtition.Printf("close start_pos:%d \n", pFile->partition_info.start_pos);
+        //gPrtition.Printf("close name:%s\n", pFile->partition_info.name);
+
+        gPrtition.Printf("close T:%d, R:%d, H:%d, K:%d, S:%d, N:%s\n"
+            , pFile->partition_info.type, pFile->partition_info.r_w_flag
+            , pFile->partition_info.hidden_flag, pFile->partition_info.ksize
+            , pFile->partition_info.start_pos, pFile->partition_info.name);
+        if(pFile->partition_info.type != PART_FS_TYPE)
+        {
+            //gPrtition.Printf("close file_length:%d\r\n", bin_config->file_length);
+            //gPrtition.Printf("close ld_addr:%d\r\n", bin_config->ld_addr);
+            //gPrtition.Printf("close backup_pos:%d\r\n", bin_config->backup_pos);
+            //gPrtition.Printf("close check:%d\r\n", bin_config->check);
+            //gPrtition.Printf("close mtd_idex:%d\r\n", bin_config->mtd_idex);
+            gPrtition.Printf("close ex_bin F:%d, L:%d, B:%d, C:%d, M:%d\r\n"
+                , bin_config->mtd_idex, bin_config->ld_addr
+                , bin_config->backup_pos, bin_config->check, bin_config->mtd_idex);
+            
+        }
+        else
+        {
+            //gPrtition.Printf("close file_length:%d\r\n", fs_config->file_length);
+            //gPrtition.Printf("close check:%d\r\n", fs_config->check);
+            //gPrtition.Printf("close mtd_idex:%d\r\n", fs_config->mtd_idex);
+            //gPrtition.Printf("close fs_type:%d\r\n", fs_config->fs_type);
+
+            gPrtition.Printf("close ex_fs F:%d, C:%d, M:%d, F:%d\r\n"
+                , fs_config->fs_type, fs_config->check
+                , fs_config->mtd_idex, fs_config->fs_type);
+        }
+
+
+        //Ƿ
+        if(sflash_check_name_is_exist(pFile->partition_info.name, buf, file_num, &name_idex) != 0)
+        {
+            name_idex = file_num;
+            file_num = file_num + 1;
+        }
+		
+        gPrtition.MemCpy(&buf[0], &file_num, 4);
+        //gPrtition.Printf("buf offset:%d\r\n", name_idex*sizeof(T_PARTITION_TABLE_INFO));
+        gPrtition.MemCpy(&buf[name_idex*sizeof(T_PARTITION_TABLE_INFO) + 4], pFile, sizeof(T_PARTITION_TABLE_INFO));
+
+		//¼ͨһӿڽд,ʵֻдֻһŻ¼ʱ
+		if(g_spiflash_burn_mode == P_MODE_NEWBURN && g_burn_flag == 1)
+		{
+			g_partition_num = file_num;
+			gPrtition.MemCpy(&g_partition_table_info[name_idex], pFile, sizeof(T_PARTITION_TABLE_INFO));
+			gPrtition.Printf("file_num:%d, name_idex:%d\r\n", file_num, name_idex);
+		}
+		else
+		{
+	        //дݵ
+	        gPrtition.Printf("write table page:%d\r\n", m_spi_burn.partition_table_start);
+	        if(0 != sflash_write_data(buf, page_cnt*page_size, m_spi_burn.partition_table_start, page_cnt, 1))
+	        {
+	            gPrtition.RamFree(buf);
+	            gPrtition.RamFree(pFile);
+	             pFile = NULL;
+	            g_spi_partition.open_time = 0; 
+	            g_spi_partition.write_flag = 0;
+	            g_spi_partition.read_flag = 0; 
+	            gPrtition.Printf("part: Sflash_Close write partition table fail, page:%d\r\n", m_spi_burn.partition_table_start);
+	            return -1;
+	        }
+
+	        gPrtition.Printf("write table back page:%d\r\n", m_spi_burn.partition_table_start+m_spi_burn.pages_per_block);
+	        //д
+	        if(0 != sflash_write_data(buf, page_cnt*page_size, m_spi_burn.partition_table_start+m_spi_burn.pages_per_block, page_cnt, 1))
+	        {
+	            gPrtition.RamFree(buf);
+	            gPrtition.RamFree(pFile);
+	             pFile = NULL;
+	            g_spi_partition.open_time = 0; 
+	            g_spi_partition.write_flag = 0;
+	            g_spi_partition.read_flag = 0; 
+	            gPrtition.Printf("part: Sflash_Close write partition table back fail, page:%d\r\n", m_spi_burn.partition_table_start+1);
+	            return -1;
+	        }
+		}
+       
+        if(buf != NULL)
+        {
+            gPrtition.RamFree(buf);
+            buf = NULL;
+        }
+        
+    }
+    
+    if(pFile != NULL)
+    {
+        gPrtition.RamFree(pFile);
+        pFile = NULL;
+    }
+    
+    g_spi_partition.open_time = 0; 
+    g_spi_partition.write_flag = 0;
+    g_spi_partition.read_flag = 0; 
+    
+   // gPrtition.Printf("part: Sflash_Close write partition table success\r\n");
+    return 0;
+}
+
+T_PARTITION_TABLE_INFO *sflash_open(unsigned char *partition_name)
+{
+    unsigned char *buf = NULL;
+    unsigned long file_num = 0;
+    unsigned long page_cnt = 1;
+    unsigned long page_size = m_spi_burn.page_size;
+    T_PARTITION_TABLE_INFO *pFile;
+    T_PARTITION_TABLE_INFO *pFile_temp;
+    unsigned long i = 0, j = 0;
+    unsigned long src_name_len = 0, dst_name_len = 0;
+    T_BIN_CONFIG bin_config;
+    T_FS_CONFIG fs_config;
+    unsigned char name_dst[PARTITION_NAME_LEN + 1];
+    unsigned char name_src[PARTITION_NAME_LEN + 1];
+    
+
+    if(NULL == partition_name)
+    {
+        gPrtition.Printf("part: Sflash_Open partition_name == AK_NULL\r\n");
+        return NULL;
+    }
+
+    if(1 != g_spi_partition.init_success_flag)
+    {
+        if (NULL == gPrtition.Printf)
+        {
+        }
+        else
+        {
+            gPrtition.Printf("part: Sflash_Open not Sflash_Init\r\n");
+        }
+        return NULL;
+    }
+
+    if(g_spi_partition.open_time == 1)
+    {
+        gPrtition.Printf("part: Sflash_Open the other partition name is openning\r\n");
+        return NULL;
+    }
+
+    if(sflash_str_len(partition_name) > PARTITION_NAME_LEN)
+    {
+        gPrtition.Printf("part: Sflash_Open the partition name len more than %d\r\n", PARTITION_NAME_LEN);
+        return NULL;
+    }
+    
+    buf = gPrtition.RamAlloc(page_size*page_cnt*sizeof(unsigned char));
+    if(NULL == buf)
+    {
+        gPrtition.Printf("part: Sflash_Open buf malloc fail\r\n");
+        return NULL;
+    }
+
+    gPrtition.MemSet(buf, 0x0, page_size*page_cnt*sizeof(unsigned char));
+
+	if(g_spiflash_burn_mode == P_MODE_NEWBURN && g_burn_flag == 1)
+	{
+		gPrtition.MemCpy(&buf[0], &g_partition_num, 4);
+		gPrtition.MemCpy(&buf[4], &g_partition_table_info, ONE_PAGE_FILE_NUM*sizeof(T_PARTITION_TABLE_INFO));
+	}
+	else
+	{
+	    if(0 != prod_spireadpage(m_spi_burn.partition_table_start, page_cnt, buf))
+	    {
+	        gPrtition.RamFree(buf);
+	        gPrtition.Printf("part: Sflash_Open read fail\r\n");
+	        return NULL;
+	    }
+	}
+   
+    gPrtition.MemCpy(&file_num, buf, 4);
+    gPrtition.Printf("part: Sflash_Open file_num:%d\r\n", file_num);
+   
+    if(file_num == 0 || file_num == 0xFFFFFFFF || file_num > T_MAX_FILE_NUM)
+    {
+        gPrtition.RamFree(buf);
+        gPrtition.Printf("part: Sflash_Open file_num == 0 || file_num == T_U32_MAX || file_num > 15\r\n");
+        return NULL;
+    }
+
+    if(file_num > ONE_PAGE_FILE_NUM)
+    {
+        if(buf != NULL)
+        {
+            gPrtition.RamFree(buf);
+            buf = NULL;
+        }
+        
+        page_cnt = 2;
+        
+        //ļҪ2ҳ·
+        buf = gPrtition.RamAlloc(page_size * page_cnt * sizeof(unsigned char));
+        if(NULL == buf)
+        {
+            gPrtition.Printf("part: Sflash_Open buf malloc fail\r\n");
+            return NULL;
+        }
+
+        gPrtition.MemSet(buf, 0x0, page_size* page_cnt *sizeof(unsigned char));
+        if(g_spiflash_burn_mode == P_MODE_NEWBURN && g_burn_flag == 1)
+		{
+			gPrtition.MemCpy(&buf[0], &g_partition_num, 4);
+			gPrtition.MemCpy(&buf[4], &g_partition_table_info, T_MAX_FILE_NUM*sizeof(T_PARTITION_TABLE_INFO));
+		}
+		else
+		{
+	        if(0 != prod_spireadpage(m_spi_burn.partition_table_start, page_cnt, buf))
+	        {
+	            gPrtition.RamFree(buf);
+	            gPrtition.Printf("part: Sflash_Open read fail\r\n");
+	            return NULL;
+	        }
+		}
+    }
+
+    //жļǷ
+    pFile_temp = (T_PARTITION_TABLE_INFO *)&buf[4];
+    for(i = 0; i < file_num; i++)
+    {
+        gPrtition.MemSet(name_dst, 0, PARTITION_NAME_LEN + 1);
+        gPrtition.MemSet(name_src, 0, PARTITION_NAME_LEN + 1);
+        gPrtition.MemCpy(name_dst, partition_name, PARTITION_NAME_LEN );
+        gPrtition.MemCpy(name_src, pFile_temp->partition_info.name, PARTITION_NAME_LEN );
+        
+        src_name_len = sflash_str_len(name_src);
+        dst_name_len = sflash_str_len(name_dst);
+        
+        //gPrtition.Printf("partition name:%s, %s\r\n", partition_name, pFile_temp->partition_info.name);
+        //gPrtition.Printf("name len:%d, %d\r\n", dst_name_len, src_name_len);
+        if(src_name_len == dst_name_len)
+        {
+            for(j=0; j < src_name_len; j++)
+            {
+                if(name_src[j] != name_dst[j])
+                {
+                    break;
+                }    
+            }
+
+            if(j == src_name_len)
+            {
+                //gPrtition.Printf("partition name open success:%s, %s\r\n", name_dst, name_src);
+                break;
+            }
+        }
+        pFile_temp++;
+    }
+    
+    if(i == file_num)
+    {
+        gPrtition.RamFree(buf);
+        gPrtition.Printf("partition name is not exist, open fail\r\n");
+        return NULL;    
+    }
+
+    pFile = gPrtition.RamAlloc(sizeof(T_PARTITION_TABLE_INFO));
+    if(NULL == pFile)
+    {
+        gPrtition.RamFree(buf);
+        gPrtition.Printf("part: Sflash_Open buf malloc fail\r\n");
+        return NULL;
+    }
+
+    gPrtition.MemSet(pFile, 0x0, sizeof(T_PARTITION_TABLE_INFO));
+    
+    gPrtition.MemCpy(pFile, pFile_temp, sizeof(T_PARTITION_TABLE_INFO));
+
+
+    if(pFile->partition_info.type == PART_BIN_TYPE || pFile->partition_info.type == PART_DATA_TYPE)
+    {
+        gPrtition.MemCpy(&bin_config, &pFile->ex_partition_info, sizeof(T_BIN_CONFIG));
+    }
+    else if(pFile->partition_info.type == PART_FS_TYPE)
+    {
+        gPrtition.MemCpy(&fs_config, &pFile->ex_partition_info, sizeof(T_FS_CONFIG));
+    }
+
+    //gPrtition.Printf("open type:%d \n", pFile->partition_info.type);
+    //gPrtition.Printf("open r_w_flag:%d \n", pFile->partition_info.r_w_flag);
+    //gPrtition.Printf("open hidden_flag:%d \n", pFile->partition_info.hidden_flag);
+    //gPrtition.Printf("open ksize:%d \n", pFile->partition_info.ksize);
+    //gPrtition.Printf("open start_pos:%d \n", pFile->partition_info.start_pos);
+    //gPrtition.Printf("open name:%s \n", pFile->partition_info.name);
+
+    gPrtition.Printf("open T:%d, R:%d, H:%d, K:%d, S:%d, N:%s \n"
+        , pFile->partition_info.type, pFile->partition_info.r_w_flag
+        , pFile->partition_info.hidden_flag, pFile->partition_info.ksize
+        , pFile->partition_info.start_pos, pFile->partition_info.name);
+    if(pFile->partition_info.type != PART_FS_TYPE)
+    {
+        //gPrtition.Printf("open file_length:%d\r\n", bin_config.file_length);
+        //gPrtition.Printf("open ld_addr:%d\r\n", bin_config.ld_addr);
+        //gPrtition.Printf("open backup_page:%d\r\n", bin_config.backup_pos);
+        //gPrtition.Printf("open check:%d\r\n", bin_config.check);
+
+        gPrtition.Printf("open ex_bin F:%d, L:%d, B:%d, C:%d\r\n"
+            , bin_config.file_length, bin_config.ld_addr
+            , bin_config.backup_pos, bin_config.check);
+    }
+    else
+    {
+         //gPrtition.Printf("open file_length:%d\r\n", fs_config.file_length);
+        //gPrtition.Printf("open check:%d\r\n", fs_config.check);
+        gPrtition.Printf("open ex_fs F:%d, C:%d\r\n"
+            , fs_config.file_length, fs_config.check);
+    }
+
+    if(buf != NULL)
+    {
+        gPrtition.RamFree(buf);
+        buf = NULL;
+    }
+
+    g_spi_partition.r_w_data_size = 0;
+    g_spi_partition.open_time = 1;
+	g_spi_partition.current_erase_block = 0xFFFFFFFF;
+	g_spi_partition.set_attr_flag = 0;
+	g_spi_partition.write_table_flag = 0;
+    
+    return pFile;
+}
+
+
+int sflash_write(T_PARTITION_TABLE_INFO *pFile, unsigned char *data, unsigned long data_len)
+{
+    unsigned long page_cnt = 0;
+    unsigned char check = 0;
+    unsigned long Total_Size = m_spi_burn.total_size;
+    unsigned long page_Size = m_spi_burn.page_size;
+    unsigned long start_page = 0;
+    unsigned long backup_page = 0;
+    unsigned long lenght_page_cnt = 0;
+    T_BIN_CONFIG bin_config;
+    T_FS_CONFIG fs_config;
+    unsigned char *write_buf = NULL;
+    unsigned long page_cnt_idex = 0;
+    
+   
+    if(pFile == NULL || data == NULL || data_len == 0 || data_len > Total_Size)
+    {
+        gPrtition.Printf("part: Sflash_Write fail, %x, %x, %d\r\n", pFile, data, data_len);
+        return -1;
+    }
+
+    if(1 != g_spi_partition.init_success_flag)
+    {
+        if (NULL == gPrtition.Printf)
+        {
+        }
+        else
+        {
+            gPrtition.Printf("part: Sflash_Write not Sflash_Init\r\n");
+        }
+        return -1;
+    }
+    
+    if(g_spi_partition.read_flag)
+    {
+        gPrtition.Printf("part: Sflash_Write read is running\r\n");
+        return -1;
+    }
+
+    if(pFile->partition_info.type == PART_BIN_TYPE || pFile->partition_info.type == PART_DATA_TYPE)
+    {
+        gPrtition.MemCpy(&bin_config, &pFile->ex_partition_info, sizeof(T_BIN_CONFIG));
+        check = bin_config.check;
+        backup_page = bin_config.backup_pos;
+        //gPrtition.Printf("backup_page:%d\r\n", backup_page);
+    }
+    else if(pFile->partition_info.type == PART_FS_TYPE)
+    {
+        gPrtition.MemCpy(&fs_config, &pFile->ex_partition_info, sizeof(T_FS_CONFIG));
+        check = fs_config.check;
+    }
+    else
+    {
+        gPrtition.Printf("part: Sflash_Write type IS error\r\n");
+        return -1;
+    }
+    
+    
+    //дǲһζӦҳд
+    if(0)//g_partition.r_w_data_size % page_Size != 0)
+    {
+        gPrtition.Printf("part: Sflash_Write write data is not page write\r\n");
+        return -1;
+    }
+	
+	
+    page_cnt_idex = data_len/page_Size;
+	//gPrtition.Printf("data_len:%d, page_cnt_idex:%d\r\n", data_len, page_cnt_idex);
+    if(page_cnt_idex != 0)
+    {
+        page_cnt = page_cnt_idex;
+        
+        //ΪһдĶǰҳдȥ
+        lenght_page_cnt = g_spi_partition.r_w_data_size/page_Size;
+
+        //һεĿʼλǷĿʼ+дݵҳ
+        start_page = pFile->partition_info.start_pos/page_Size + lenght_page_cnt;
+       // gPrtition.Printf("part: s:%d, p:%d\r\n", start_page, page_cnt);
+
+        if(backup_page != 0xFFFFFFFF && pFile->partition_info.type == PART_BIN_TYPE)
+        {
+            if(((lenght_page_cnt + page_cnt)*page_Size) > (pFile->partition_info.ksize*K_SIZE/2))
+            {
+                gPrtition.Printf("part: Sflash_Write page cnt more than the partition(backup) cnt, %d, %d\r\n", (lenght_page_cnt + page_cnt)*page_Size, pFile->partition_info.ksize*K_SIZE/2);
+                return -1;
+            }
+
+            if(start_page + page_cnt > (backup_page/page_Size))
+            {
+                gPrtition.Printf("part :Sflash_Write start page more than the backup_page, %d, %d\r\n", start_page, backup_page);
+                return -1;
+            }
+        }
+        else
+        {
+            if((lenght_page_cnt + page_cnt) > pFile->partition_info.ksize*K_SIZE/page_Size)
+            {
+                gPrtition.Printf("part: Sflash_Write page cnt more than the partition page, %d, %d\r\n", lenght_page_cnt + page_cnt, pFile->partition_info.ksize*K_SIZE/page_Size);
+                return -1;
+            }
+            
+            if((start_page + page_cnt)*page_Size > (pFile->partition_info.start_pos + pFile->partition_info.ksize*K_SIZE))
+            {
+                gPrtition.Printf("part :Sflash_Write start page more than the partition page cnt, %d, %d\r\n", (start_page + page_cnt)*page_Size, (pFile->partition_info.start_pos + pFile->partition_info.ksize*K_SIZE));
+                return -1;
+            }
+            
+        }
+
+       // gPrtition.Printf("Sflash_Write start_page: %d\r\n", start_page);
+        //д
+        if (0 != sflash_write_data(data, page_cnt_idex*page_Size, start_page, page_cnt, check))
+        {
+            return -1;
+        }
+        
+        //ݵģд
+        if (backup_page != 0xFFFFFFFF && pFile->partition_info.type == PART_BIN_TYPE)
+        {
+            unsigned long backup_page_temp = backup_page/page_Size + lenght_page_cnt;
+            
+            //gPrtition.Printf("Sflash_Write back_page_temp: %d\r\n", backup_page_temp);
+            if((backup_page_temp + page_cnt)*page_Size > (backup_page + pFile->partition_info.ksize*K_SIZE/2))
+            {
+                gPrtition.Printf("part :Sflash_Write back page more than the partition page, %d, %d, %d, %d\r\n", 
+                    backup_page_temp, page_cnt, backup_page, pFile->partition_info.ksize*K_SIZE/2);
+                return -1;
+            }
+            
+            /*ֻȫ¼ʱ򣬲Ŷbackupд*/
+            if (0 != sflash_write_data(data, page_cnt_idex*page_Size, backup_page_temp, page_cnt, check))
+            {
+                return -1;
+            }  
+        }
+        g_spi_partition.r_w_data_size += page_cnt_idex*page_Size;
+    }
+
+    //һҳСݣͰһҳСд
+    if(data_len%page_Size != 0)
+    {
+        write_buf = gPrtition.RamAlloc(page_Size);
+        if(NULL == write_buf)
+        {
+            gPrtition.Printf("Sflash_Write NULL == write_buf\r\n");
+            return -1;
+        }
+        gPrtition.MemSet(write_buf, 0, page_Size);
+        gPrtition.MemCpy(write_buf, &data[page_cnt_idex*page_Size], data_len%page_Size);
+        
+        page_cnt = 1;
+        
+        //ΪһдĶǰҳдȥ
+        lenght_page_cnt = g_spi_partition.r_w_data_size/page_Size;
+
+        //һεĿʼλǷĿʼ+дݵҳ
+        start_page = pFile->partition_info.start_pos/page_Size + lenght_page_cnt;
+       // gPrtition.Printf("part: dds:%d, p:%d\r\n", start_page, page_cnt);
+
+        if(backup_page != 0xFFFFFFFF && pFile->partition_info.type == PART_BIN_TYPE)
+        {
+            if(((lenght_page_cnt + page_cnt)*page_Size) > (pFile->partition_info.ksize*K_SIZE/2))
+            {
+                gPrtition.RamFree(write_buf);
+                gPrtition.Printf("part: Sflash_Write page cnt more than the partition(backup) cnt, %d, %d\r\n", (lenght_page_cnt + page_cnt)*page_Size, pFile->partition_info.ksize*K_SIZE/2);
+                return -1;
+            }
+
+            if(start_page + page_cnt > backup_page/page_Size)
+            {
+                gPrtition.RamFree(write_buf);
+                gPrtition.Printf("part :Sflash_Write start page more than the backup_page, %d, %d\r\n", start_page, backup_page);
+                return -1;
+            }
+        }
+        else
+        {
+            if(((lenght_page_cnt + page_cnt)*page_Size) > pFile->partition_info.ksize*K_SIZE)
+            {
+                gPrtition.RamFree(write_buf);
+                gPrtition.Printf("part: Sflash_Write page cnt more than the partition page, %d, %d\r\n", (lenght_page_cnt + page_cnt)*page_Size, pFile->partition_info.ksize*K_SIZE);
+                return -1;
+            }
+            
+            if((start_page + page_cnt)*page_Size > (pFile->partition_info.start_pos + pFile->partition_info.ksize*K_SIZE))
+            {
+                gPrtition.RamFree(write_buf);
+                gPrtition.Printf("part :Sflash_Write start page more than the partition page cnt, %d, %d\r\n", (start_page + page_cnt)*page_Size, (pFile->partition_info.start_pos + pFile->partition_info.ksize*K_SIZE));
+                return -1;
+            }
+            
+        }
+
+        //gPrtition.Printf("Sflash_Write data_len%page_Size:%d, start_page: %d\r\n", data_len%page_Size, start_page);
+        //д
+        if (0 != sflash_write_data(write_buf, data_len%page_Size, start_page, page_cnt, check))
+        {
+            gPrtition.RamFree(write_buf);
+            return -1;
+        }
+        
+        //ݵģд
+        if (backup_page != 0xFFFFFFFF && pFile->partition_info.type == PART_BIN_TYPE)
+        {
+            unsigned long backup_page_temp = backup_page/page_Size + lenght_page_cnt;
+            
+            //gPrtition.Printf("Sflash_Write back_page_temp: %d\r\n", backup_page_temp);
+            if((backup_page_temp + page_cnt)*page_Size > (backup_page + pFile->partition_info.ksize*K_SIZE/2))
+            {
+                gPrtition.RamFree(write_buf);
+                gPrtition.Printf("part :Sflash_Write back page more than the partition page, %d, %d, %d, %d\r\n", 
+                    backup_page_temp, page_cnt, backup_page, pFile->partition_info.ksize*K_SIZE/2);
+                return -1;
+            }
+            
+            /*ֻȫ¼ʱ򣬲Ŷbackupд*/
+            if (0 != sflash_write_data(write_buf, data_len%page_Size, backup_page_temp, page_cnt, check))
+            {
+                gPrtition.RamFree(write_buf);
+                return -1;
+            }  
+        }
+        g_spi_partition.r_w_data_size += data_len%page_Size;
+ 
+        gPrtition.RamFree(write_buf);
+    }
+
+    g_spi_partition.write_flag = 1;
+    g_spi_partition.write_table_flag = 1;
+    
+    pFile->ex_partition_info.parameter1 = g_spi_partition.r_w_data_size;
+    
+    
+    //gPrtition.Printf("Sflash_Write file_length: %d, data_len:%d \r\n", g_partition.r_w_data_size, data_len);
+    return data_len;
+}
+
+
+int sflash_read(T_PARTITION_TABLE_INFO *pFile, unsigned char *data, unsigned long data_len)
+{
+    unsigned long page_cnt = 0;
+    unsigned long start_page =0;
+    unsigned long Total_Size = m_spi_burn.total_size;
+    unsigned long page_Size = m_spi_burn.page_size;
+    T_BIN_CONFIG bin_config;
+    T_FS_CONFIG fs_config;
+    unsigned long file_len = 0;
+    unsigned char check = 0;
+    unsigned long backup_page = 0;
+    unsigned char *read_buf = NULL;
+    unsigned long page_cnt_idex = 0;
+    
+    if(pFile == NULL || data == NULL || data_len == 0 || data_len > Total_Size)
+    {
+        gPrtition.Printf("part: Sflash_Read fail, %x, %x, %d\r\n", pFile, data, data_len);
+        return -1;
+    }
+
+    if(1 != g_spi_partition.init_success_flag)
+    {
+        if (NULL == gPrtition.Printf)
+        {
+        }
+        else
+        {
+            gPrtition.Printf("part: Sflash_Read not Sflash_Init\r\n");
+        }
+        return -1;
+    }
+
+    if(g_spi_partition.write_flag)
+    {
+         gPrtition.Printf("part: Sflash_Read write is running\r\n");
+        return -1;
+    }
+
+    if(pFile->partition_info.type == PART_BIN_TYPE || pFile->partition_info.type == PART_DATA_TYPE)
+    {
+        gPrtition.MemCpy(&bin_config, &pFile->ex_partition_info, sizeof(T_BIN_CONFIG));
+        file_len = bin_config.file_length;
+        check = bin_config.check;
+        backup_page = bin_config.backup_pos;
+    }
+    else if(pFile->partition_info.type == PART_FS_TYPE)
+    {
+        gPrtition.MemCpy(&fs_config, &pFile->ex_partition_info, sizeof(T_FS_CONFIG));
+        file_len = fs_config.file_length;
+        check = fs_config.check;
+    }
+    else
+    {
+        gPrtition.Printf("part: Sflash_Write type IS error\r\n");
+        return -1;
+    }
+    
+
+    if(file_len == 0)
+    {
+        gPrtition.Printf("part: Sflash_Read partition not have data\r\n");
+        return -1;
+    }
+
+    if(g_spi_partition.r_w_data_size == file_len)
+    {
+        //Ѷ
+        gPrtition.Printf("part: Sflash_Read read data finish,%d, %d\r\n", g_spi_partition.r_w_data_size, file_len);
+        return -1;
+    }
+
+    
+    if(0)//g_partition.r_w_data_size%page_Size != 0)
+    {
+        gPrtition.Printf("part: Sflash_Read partition data is not page read\r\n");
+        return -1;
+    }
+
+    page_cnt_idex = data_len/page_Size;
+    if(page_cnt_idex != 0)
+    {
+        page_cnt = page_cnt_idex;
+        start_page = pFile->partition_info.start_pos/page_Size + g_spi_partition.r_w_data_size/page_Size;
+
+        g_spi_partition.r_w_data_size += page_cnt * page_Size;
+        
+        if(backup_page != 0xFFFFFFFF && pFile->partition_info.type == PART_BIN_TYPE)
+        {
+            if(start_page*page_Size >= pFile->partition_info.start_pos + pFile->partition_info.ksize*K_SIZE/2)
+            {
+                gPrtition.Printf("part: Sflash_Read(back) start page more than partition page,%d, %d, %d\r\n",start_page*page_Size, pFile->partition_info.start_pos, pFile->partition_info.ksize*K_SIZE/2);
+                return -1;
+            }
+            if((g_spi_partition.r_w_data_size/page_Size) > (unsigned long)(((pFile->partition_info.ksize*K_SIZE)/page_Size)/2))
+            {
+                gPrtition.Printf("part: Sflash_Read(back) page cnt more than partition page cnt,%d, %d, %d\r\n",page_cnt, g_spi_partition.r_w_data_size/page_Size, (pFile->partition_info.ksize*K_SIZE)/page_Size/2);
+                return -1;
+            }
+        }
+        else
+        {
+            if(start_page*page_Size >= pFile->partition_info.start_pos + pFile->partition_info.ksize*K_SIZE)
+            {
+                gPrtition.Printf("part: Sflash_Read start page more than partition page,%d, %d, %d\r\n",start_page*page_Size, pFile->partition_info.start_pos, pFile->partition_info.ksize*K_SIZE);
+                return -1;
+            }
+            if((g_spi_partition.r_w_data_size/page_Size) > (pFile->partition_info.ksize*K_SIZE)/page_Size)
+            {
+                gPrtition.Printf("part: Sflash_Read page cnt more than partition page cnt,%d, %d, %d\r\n",page_cnt, g_spi_partition.r_w_data_size/page_Size, (pFile->partition_info.ksize*K_SIZE)/page_Size);
+                return -1;
+            }
+        }
+
+        //gPrtition.Printf("Sflash_Read start:%d, cnt:%d\r\n", start_page, page_cnt);
+
+        if(0 != prod_spireadpage(start_page, page_cnt, data))
+        {
+            if(backup_page != 0xFFFFFFFF)
+            {
+                
+                //ʧٵĻж
+                start_page = backup_page/page_Size + g_spi_partition.r_w_data_size/page_Size;
+                //gPrtition.Printf("part: read back data start:%d, cnt:%d\r\n", start_page, page_cnt);
+                
+                if(start_page*page_Size >= backup_page + pFile->partition_info.ksize*K_SIZE/2)
+                {
+                    gPrtition.Printf("part: Sflash_Read(back) start page more than partition page,%d, %d, %d\r\n",start_page*page_Size, backup_page, pFile->partition_info.ksize*K_SIZE/2);
+                    return -1;
+                }
+                if((g_spi_partition.r_w_data_size/page_Size) > (unsigned long)(pFile->partition_info.ksize*K_SIZE/page_Size/2))
+                {
+                    gPrtition.Printf("part: Sflash_Read(back) page cnt more than partition page cnt,%d, %d, %d\r\n",page_cnt, g_spi_partition.r_w_data_size/page_Size, pFile->partition_info.ksize*K_SIZE/page_Size/2);
+                    return -1;
+                }
+                if(0 != prod_spireadpage(start_page, page_cnt, data))
+                {
+                    gPrtition.Printf("part: Sflash_Read(back) read fail start:%d, cnt:%d\r\n", start_page, page_cnt);
+                    return -1;
+                }
+            }
+            else
+            {
+                gPrtition.Printf("part: Sflash_Read read fail start:%d, cnt:%d\r\n", start_page, page_cnt);
+                return -1;
+            }
+        }
+    }
+
+    //ȡһҳ
+    if(data_len%page_Size != 0)
+    {
+        read_buf = gPrtition.RamAlloc(page_Size);
+        if(NULL == read_buf)
+        {
+            gPrtition.Printf("Sflash_Write NULL == write_buf\r\n");
+            return -1;
+        }
+        gPrtition.MemSet(read_buf, 0, page_Size);
+
+        page_cnt = 1;
+
+        start_page = pFile->partition_info.start_pos/page_Size + g_spi_partition.r_w_data_size/page_Size;
+
+        g_spi_partition.r_w_data_size += data_len%page_Size;
+        
+        if(backup_page != 0xFFFFFFFF && pFile->partition_info.type == PART_BIN_TYPE)
+        {
+            if(start_page*page_Size >= pFile->partition_info.start_pos + pFile->partition_info.ksize*K_SIZE/2)
+            {
+                gPrtition.RamFree(read_buf);
+                gPrtition.Printf("part: Sflash_Read(back) start page more than partition page,%d, %d, %d\r\n",start_page*page_Size, pFile->partition_info.start_pos, pFile->partition_info.ksize*K_SIZE/2);
+                return -1;
+            }
+            if((g_spi_partition.r_w_data_size/page_Size) > (unsigned long)(pFile->partition_info.ksize*K_SIZE/page_Size/2))
+            {
+                gPrtition.RamFree(read_buf);
+                gPrtition.Printf("part: Sflash_Read(back) page cnt more than partition page cnt,%d, %d, %d\r\n",page_cnt, g_spi_partition.r_w_data_size/page_Size, pFile->partition_info.ksize*K_SIZE/page_Size/2);
+                return -1;
+            }
+        }
+        else
+        {
+            if(start_page*page_Size >= pFile->partition_info.start_pos + pFile->partition_info.ksize*K_SIZE)
+            {
+                gPrtition.RamFree(read_buf);
+                gPrtition.Printf("part: Sflash_Read start page more than partition page,%d, %d, %d\r\n",start_page*page_Size, pFile->partition_info.start_pos, pFile->partition_info.ksize*K_SIZE);
+                return -1;
+            }
+            if((g_spi_partition.r_w_data_size/page_Size) > pFile->partition_info.ksize*K_SIZE/page_Size)
+            {
+                gPrtition.RamFree(read_buf);
+                gPrtition.Printf("part: Sflash_Read page cnt more than partition page cnt,%d, %d, %d\r\n",page_cnt, g_spi_partition.r_w_data_size/page_Size, pFile->partition_info.ksize*K_SIZE/page_Size);
+                return -1;
+            }
+        }
+
+        //gPrtition.Printf("Sflash_Read data_len%page_Size:%d, start:%d, cnt:%d\r\n",data_len%page_Size, start_page, page_cnt);
+
+        if(0 != prod_spireadpage(start_page, page_cnt, read_buf))
+        {
+            if(backup_page != 0xFFFFFFFF)
+            {
+                
+                //ʧٵĻж
+                start_page = backup_page/page_Size + g_spi_partition.r_w_data_size/page_Size;
+                //gPrtition.Printf("part: read back data start:%d, cnt:%d\r\n", start_page, page_cnt);
+                
+                if(start_page*page_Size >= backup_page + pFile->partition_info.ksize*K_SIZE/2)
+                {
+                    gPrtition.RamFree(read_buf);
+                    gPrtition.Printf("part: Sflash_Read(back) start page more than partition page,%d, %d, %d\r\n",start_page*page_Size, backup_page, pFile->partition_info.ksize*K_SIZE/2);
+                    return -1;
+                }
+                if((g_spi_partition.r_w_data_size/page_Size) > (unsigned long)(pFile->partition_info.ksize*K_SIZE/page_Size/2))
+                {
+                    gPrtition.RamFree(read_buf);
+                    gPrtition.Printf("part: Sflash_Read(back) page cnt more than partition page cnt,%d, %d, %d\r\n",page_cnt, g_spi_partition.r_w_data_size/page_Size, pFile->partition_info.ksize*K_SIZE/page_Size/2);
+                    return -1;
+                }
+                if(0 != prod_spireadpage(start_page, page_cnt, read_buf))
+                {
+                    gPrtition.RamFree(read_buf);
+                    gPrtition.Printf("part: Sflash_Read(back) read fail start:%d, cnt:%d\r\n", start_page, page_cnt);
+                    return -1;
+                }
+            }
+            else
+            {
+                gPrtition.RamFree(read_buf);
+                gPrtition.Printf("part: Sflash_Read read fail start:%d, cnt:%d\r\n", start_page, page_cnt);
+                return -1;
+            }
+        }
+
+        gPrtition.MemCpy(&data[page_cnt_idex*page_Size], read_buf, data_len%page_Size);
+
+        gPrtition.RamFree(read_buf);
+    }
+        
+    g_spi_partition.read_flag = 1;
+    return data_len;
+}
+
+int sflash_get_partition_table(T_PARTITION_TABLE_CONFIG *part_talbe)
+{
+    if(NULL == part_talbe)
+    {
+       gPrtition.Printf("part: Sflash_Get_Partition_Table buf == AK_NULL\r\n");
+        return -1; 
+    }
+
+    if(1 != g_spi_partition.init_success_flag)
+    {
+        if (NULL == gPrtition.Printf)
+        {
+        }
+        else
+        {
+            gPrtition.Printf("part: Sflash_Get_Partition_Table not Sflash_Init\r\n");
+        }
+        return -1;
+    }
+
+    gPrtition.MemSet(part_talbe->table, 0x0, 512);
+    if(0 != prod_spireadpage(m_spi_burn.partition_table_start, 2, part_talbe->table))
+    {
+        gPrtition.Printf("part: Sflash_Get_Partition_Table read fail\r\n");
+        return -1;
+    }
+
+    part_talbe->pos = m_spi_burn.partition_table_start*m_spi_burn.page_size;
+
+    return 0;
+}
+
+int sflash_get_partition_backup_table(T_PARTITION_TABLE_CONFIG *part_talbe)
+{
+    if(NULL == part_talbe)
+    {
+       gPrtition.Printf("part: Sflash_Get_Partition_Table buf == AK_NULL\r\n");
+        return -1; 
+    }
+
+    if(1 != g_spi_partition.init_success_flag)
+    {
+        if (NULL == gPrtition.Printf)
+        {
+        }
+        else
+        {
+            gPrtition.Printf("part: Sflash_Get_Partition_Table not Sflash_Init\r\n");
+        }
+        return -1;
+    }
+
+    gPrtition.MemSet(part_talbe->table, 0x0, 512);
+
+	//ȡķ
+    if(0 != prod_spireadpage(m_spi_burn.partition_table_start+m_spi_burn.pages_per_block, 2, part_talbe->table))
+    {
+        gPrtition.Printf("part: Sflash_Get_Partition_Table read fail\r\n");
+        return -1;
+    }
+
+    part_talbe->pos = (m_spi_burn.partition_table_start+m_spi_burn.pages_per_block)*m_spi_burn.page_size;
+
+    return 0;
+}
+
+
+
+int sflash_set_attr(T_PARTITION_TABLE_INFO *pFile, T_EX_PARTITION_CONFIG *ex_arrt)
+{
+    if(pFile == NULL || ex_arrt == NULL)
+    {
+        gPrtition.Printf("part: sflash_set_attr phandle == NULL || ex_arrt == NULL\r\n");
+        return -1;
+    }
+    
+    gPrtition.MemCpy(&pFile->ex_partition_info, ex_arrt, sizeof(T_EX_PARTITION_CONFIG));
+    
+    g_spi_partition.write_table_flag = 1;
+	g_spi_partition.set_attr_flag = 1;
+    return 0;
+}
+
+int sflash_get_attr(T_PARTITION_TABLE_INFO *pFile, T_EX_PARTITION_CONFIG *ex_arrt)
+{
+    if(pFile == NULL || ex_arrt == NULL)
+    {
+        gPrtition.Printf("part: sflash_get_attr phandle == NULL || ex_arrt == NULL\r\n");
+        return -1;
+    }
+    
+    gPrtition.MemCpy(ex_arrt, &pFile->ex_partition_info, sizeof(T_EX_PARTITION_CONFIG));
+    
+    return 0;
+}
+
+
+int sflash_move_partition_data(unsigned long start_page, unsigned long next_start_page, unsigned long last_page, unsigned char backwards_flag)
+{
+    unsigned long current_write_page = start_page;
+    unsigned long current_read_page = next_start_page;
+    unsigned long need_move_page_cnt = 0; 
+    unsigned char *buf = NULL;
+    unsigned long real_len = m_spi_burn.page_size *m_spi_burn.pages_per_block;
+
+    buf = (unsigned char *)gPrtition.RamAlloc(real_len*sizeof(unsigned char));
+    if(NULL == buf)
+    {
+        
+        gPrtition.Printf("part: malloc buf 4K fail\r\n");
+        return -1;
+    }
+
+    gPrtition.Printf("current_read_page:%d, current_write_page:%d, last_page:%d, backwards_flag:%d\r\n", current_read_page, current_write_page, last_page, backwards_flag);
+    while(1)
+    {
+        if(backwards_flag)//
+        {
+            if(current_read_page <= last_page)
+            {
+                break;
+            }
+
+            if((current_read_page - last_page) >=  m_spi_burn.pages_per_block)
+            {
+                need_move_page_cnt = m_spi_burn.pages_per_block;
+            }
+            else
+            {
+                need_move_page_cnt = current_read_page - last_page;
+            }
+        }
+        else//ǰ
+        {
+            if(current_read_page >= last_page)
+            {
+                break;
+            }
+
+            if((last_page - current_read_page) >=  m_spi_burn.pages_per_block)
+            {
+                need_move_page_cnt = m_spi_burn.pages_per_block;
+            }
+            else
+            {
+                need_move_page_cnt = last_page - current_read_page;
+            }
+        }
+
+        gPrtition.MemSet(buf, 0, real_len*sizeof(unsigned char));
+        //
+        if(0 != prod_spireadpage(current_read_page, need_move_page_cnt, buf))
+        {
+            gPrtition.RamFree(buf);
+            gPrtition.Printf("part: Sflash_Move_Partition_Data read fail start:%d, cnt:%d\r\n", current_read_page, need_move_page_cnt);
+            return -1;
+        }
+
+        //д
+        //д
+        if (0 != sflash_write_data(buf, need_move_page_cnt*m_spi_burn.page_size, current_write_page, need_move_page_cnt, 1))
+        {
+            gPrtition.RamFree(buf);
+            gPrtition.Printf("part: Sflash_Move_Partition_Data write fail start:%d, cnt:%d\r\n", current_write_page, need_move_page_cnt);
+            return -1;
+        }
+        if(backwards_flag)
+        {
+            current_read_page -= need_move_page_cnt;
+            current_write_page -= need_move_page_cnt;
+        }
+        else
+        {
+            current_read_page += need_move_page_cnt;
+            current_write_page += need_move_page_cnt;
+        }
+        
+        //gPrtition.Printf("current_read_page:%d, current_write_page:%d, need_move_page_cnt:%d\r\n", current_read_page, current_write_page, need_move_page_cnt);
+    }
+    
+    gPrtition.Printf("current_read_page:%d, current_write_page:%d, need_move_page_cnt:%d\r\n", current_read_page, current_write_page, need_move_page_cnt);
+
+    gPrtition.RamFree(buf);
+    return 0;
+    
+}
+
+int sflash_resize(unsigned char *partition_name, unsigned long partition_size)
+{
+    unsigned char *buf = NULL;
+    unsigned long page_size = m_spi_burn.page_size;
+    unsigned long page_cnt = 2, i = 0;
+    unsigned long file_num = 0;
+    unsigned long name_idex = 0;
+    T_PARTITION_TABLE_INFO *partition_temp;
+    T_PARTITION_TABLE_INFO partition;
+    T_PARTITION_TABLE_INFO last_partition;
+    unsigned long src_partition_size = 0;
+    unsigned long start_page = 0;
+//    unsigned long move_page_cnt = 0;
+    unsigned long next_start_page = 0;
+    unsigned long last_page = 0;
+    unsigned long add_partition_size = 0;
+    unsigned long next_partition_page = 0;
+    unsigned long next_partition_page_cnt = 0;
+    unsigned long partition_size_block = 0;
+    
+    
+
+    if(NULL == partition_name)
+    {
+       gPrtition.Printf("part: sflash_resize AK_NULL == partition_name\r\n");
+        return -1; 
+    }
+
+    if(sflash_str_len(partition_name) > PARTITION_NAME_LEN)
+    {
+        gPrtition.Printf("part: sflash_delete the partition name len more than %d\r\n", PARTITION_NAME_LEN);
+        return -1;
+    }
+
+    if(partition_size == 0)//ɾ
+    {
+         gPrtition.Printf("part: sflash_resize partition_size ==0\r\n");
+        return -1; 
+    }
+    
+    if(1 != g_spi_partition.init_success_flag)
+    {
+        if (NULL == gPrtition.Printf)
+        {
+        }
+        else
+        {
+            gPrtition.Printf("part: sflash_resize not Sflash_Init\r\n");
+        }
+        return -1;
+    }
+
+    if(g_spi_partition.open_time == 1)
+    {
+        gPrtition.Printf("part: sflash_resize the other partition name is openning\r\n");
+        return -1;
+    }
+    
+    //ͨķжϷǷ
+     buf = gPrtition.RamAlloc(page_cnt*page_size*sizeof(unsigned char));
+    if(NULL == buf)
+    {
+        gPrtition.Printf("part: sflash_resize buf malloc fail\r\n");
+        return -1;
+    }
+
+    gPrtition.MemSet(buf, 0x0, page_cnt*page_size*sizeof(unsigned char));
+    gPrtition.Printf("read partition_table_start:%d\r\n", m_spi_burn.partition_table_start);
+    if(0 != prod_spireadpage(m_spi_burn.partition_table_start, page_cnt, buf))
+    {
+        gPrtition.RamFree(buf);
+        gPrtition.Printf("part: sflash_resize read fail\r\n");
+        return -1;
+    }
+
+    gPrtition.MemCpy(&file_num, buf, 4);
+    gPrtition.Printf("part: sflash_resize file_num:%d\r\n", file_num);
+   
+    if(file_num == 0 || file_num == 0xFFFFFFFF)
+    {
+        gPrtition.RamFree(buf);
+        gPrtition.Printf("part: sflash_resize file_num:%d error\r\n", file_num);
+        return -1;
+    }
+    
+    //жϷǷ
+    if(0 != sflash_check_name_is_exist(partition_name, buf, file_num, &name_idex))
+    {
+        gPrtition.RamFree(buf);
+        gPrtition.Printf("part: sflash_resize partition_name :%s is not exist\r\n", partition_name);
+        return -1;
+    }
+    
+    //ȡ
+    gPrtition.MemCpy(&partition, &buf[name_idex*sizeof(T_PARTITION_TABLE_INFO) + 4], sizeof(T_PARTITION_TABLE_INFO));
+    gPrtition.Printf("change type:%d \n", partition.partition_info.type);
+    gPrtition.Printf("change r_w_flag:%d \n", partition.partition_info.r_w_flag);
+    gPrtition.Printf("change page_cnt:%d \n", partition.partition_info.ksize);
+    gPrtition.Printf("change start_page:%d \n", partition.partition_info.start_pos);
+    gPrtition.Printf("change name:%s \n", partition.partition_info.name);
+    
+    gPrtition.MemCpy(&last_partition, &buf[(file_num - 1)*sizeof(T_PARTITION_TABLE_INFO) + 4], sizeof(T_PARTITION_TABLE_INFO));
+    
+    gPrtition.Printf("last change type:%d \n", last_partition.partition_info.type);
+    gPrtition.Printf("last change r_w_flag:%d \n", last_partition.partition_info.r_w_flag);
+    gPrtition.Printf("last change page_cnt:%d \n", last_partition.partition_info.ksize);
+    gPrtition.Printf("last change start_page:%d \n", last_partition.partition_info.start_pos);
+    gPrtition.Printf("last change name:%s \n", last_partition.partition_info.name);
+   
+    src_partition_size = partition.partition_info.ksize*K_SIZE;
+
+    //С룬ƽ̨ĴСȽ
+    partition_size_block = (partition_size*K_SIZE + m_spi_burn.page_size - 1)/m_spi_burn.page_size;
+    partition_size_block = (partition_size_block + m_spi_burn.pages_per_block - 1)/m_spi_burn.pages_per_block;
+    partition_size_block = partition_size_block * m_spi_burn.pages_per_block*m_spi_burn.page_size;
+    gPrtition.Printf("part: partition_size_block:%d, src_partition_size:%d\r\n", partition_size_block, src_partition_size);
+    
+    if(partition_size_block > src_partition_size)//Ӵ
+    {
+        add_partition_size = partition_size_block - src_partition_size;
+        add_partition_size = add_partition_size/m_spi_burn.page_size;
+        gPrtition.Printf("part: add_partition_size:%d\r\n", add_partition_size);
+        //жspiǷô
+        if(add_partition_size*m_spi_burn.page_size > m_spi_burn.total_size - last_page*m_spi_burn.page_size)
+        {
+            gPrtition.RamFree(buf);
+            gPrtition.Printf("part: sflash_resize add partition_size more than free size\r\n");
+            return -1;
+        }
+
+        //ƶ
+        start_page = last_partition.partition_info.start_pos/m_spi_burn.page_size + (last_partition.partition_info.ksize*K_SIZE)/m_spi_burn.page_size;//д
+        next_start_page = last_partition.partition_info.start_pos/m_spi_burn.page_size;//
+        last_page = partition.partition_info.start_pos/m_spi_burn.page_size + (partition.partition_info.ksize*K_SIZE)/m_spi_burn.page_size;
+        gPrtition.Printf("1 last_page:%d, next_start_page:%d, start_page:%d \n", last_page, next_start_page, start_page);
+        if(sflash_move_partition_data(start_page, next_start_page, last_page, 1) == -1)
+        {
+            gPrtition.RamFree(buf);
+            gPrtition.Printf("part: sflash_resize sflash_move_partition_data fail\r\n");
+            return -1;
+        }
+        
+        
+        //·
+        partition_temp = (T_PARTITION_TABLE_INFO *)&buf[name_idex*sizeof(T_PARTITION_TABLE_INFO) + 4];
+
+        //¼ǰĿʼҳ
+        partition_temp->partition_info.ksize = partition_temp->partition_info.ksize + ((add_partition_size*m_spi_burn.page_size)/K_SIZE);
+        next_partition_page = partition_temp->partition_info.start_pos/m_spi_burn.page_size;
+        next_partition_page_cnt = (partition_temp->partition_info.ksize*K_SIZE)/m_spi_burn.page_size;
+       
+        for(i = name_idex + 1; i < file_num; i++)
+        {
+            partition_temp++;
+             //һʼһ
+            partition_temp->partition_info.start_pos = (next_partition_page + next_partition_page_cnt)*m_spi_burn.page_size;
+            next_partition_page = partition_temp->partition_info.start_pos/m_spi_burn.page_size;
+            next_partition_page_cnt = (partition_temp->partition_info.ksize*K_SIZE)/m_spi_burn.page_size;
+        }
+    }
+    else if(partition_size_block < src_partition_size)//С
+    {
+        //жϷ˶٣
+        add_partition_size = src_partition_size - partition_size_block;
+        add_partition_size = add_partition_size/m_spi_burn.page_size;
+        gPrtition.Printf("part: add_partition_size page:%d\r\n", add_partition_size);
+
+        
+        //Ѻķǰ
+        if(name_idex + 1 == file_num)
+        {
+            //һͲҪ
+        }
+        else
+        {
+            //
+            start_page = partition.partition_info.start_pos/m_spi_burn.page_size + (partition.partition_info.ksize*K_SIZE)/m_spi_burn.page_size- add_partition_size;
+            next_start_page = partition.partition_info.start_pos/m_spi_burn.page_size + (partition.partition_info.ksize*K_SIZE)/m_spi_burn.page_size;
+            last_page = last_partition.partition_info.start_pos/m_spi_burn.page_size + (last_partition.partition_info.ksize*K_SIZE)/m_spi_burn.page_size;
+            gPrtition.Printf("0 last_page:%d, next_start_page:%d, start_page:%d \n", last_page, next_start_page, start_page);
+            if(sflash_move_partition_data(start_page, next_start_page, last_page, 0) == -1)
+            {
+                gPrtition.RamFree(buf);
+                gPrtition.Printf("part: sflash_resize move data fail\r\n");
+                return -1;
+            }
+        }
+        
+        //·
+        partition_temp = (T_PARTITION_TABLE_INFO *)&buf[name_idex*sizeof(T_PARTITION_TABLE_INFO) + 4];
+
+        //¼ǰĿʼҳ
+        next_partition_page = partition_temp->partition_info.start_pos/m_spi_burn.page_size;
+        partition_temp->partition_info.ksize = partition_temp->partition_info.ksize - ((add_partition_size*m_spi_burn.page_size)/K_SIZE);
+        next_partition_page_cnt = (partition_temp->partition_info.ksize*K_SIZE)/m_spi_burn.page_size;
+        
+        for(i = name_idex + 1; i < file_num; i++)
+        {
+            partition_temp++;
+            
+            //һʼһ
+            partition_temp->partition_info.start_pos = (next_partition_page + next_partition_page_cnt)*m_spi_burn.page_size;
+            next_partition_page_cnt = (partition_temp->partition_info.ksize*K_SIZE)/m_spi_burn.page_size;
+            next_partition_page = partition_temp->partition_info.start_pos/m_spi_burn.page_size;
+        }
+    }
+    else//仯
+    {
+        if(buf != NULL)
+        {
+            gPrtition.RamFree(buf);
+            buf = NULL;
+        }
+        gPrtition.Printf("part: sflash_resize the partition size is same, no change \r\n");
+        return 0;
+    }
+
+
+    //д
+    if(0 != sflash_write_data(buf, file_num*sizeof(T_PARTITION_TABLE_INFO) + 4, m_spi_burn.partition_table_start, page_cnt, 1))
+    {
+        gPrtition.RamFree(buf);
+        gPrtition.Printf("part: sflash_resize write partition table start:%d, cnt:%d\r\n", m_spi_burn.partition_table_start, page_cnt);
+        return -1;
+    }
+
+    //д
+    if(0 != sflash_write_data(buf, file_num*sizeof(T_PARTITION_TABLE_INFO) + 4, m_spi_burn.partition_table_start + m_spi_burn.pages_per_block, page_cnt, 1))
+    {
+        gPrtition.RamFree(buf);
+        gPrtition.Printf("part: sflash_resize write partition table start:%d, cnt:%d\r\n", m_spi_burn.partition_table_start, page_cnt);
+        return -1;
+    }
+
+
+    if(buf != NULL)
+    {
+        gPrtition.RamFree(buf);
+        buf = NULL;
+    }
+
+    
+    return 0;
+}
+
+
+int sflash_delete(unsigned char *partition_name)
+{
+    unsigned char *buf = NULL;
+    unsigned long page_size = m_spi_burn.page_size;
+    unsigned long page_cnt = 2, i = 0;
+    unsigned long file_num = 0;
+    unsigned long name_idex = 0;
+    T_PARTITION_TABLE_INFO *partition_temp;
+    T_PARTITION_TABLE_INFO partition;
+    T_PARTITION_TABLE_INFO last_partition;
+    unsigned long start_page = 0;
+    unsigned long next_start_page = 0;
+    unsigned long last_page = 0;
+    unsigned long next_partition_page = 0;
+    unsigned long next_partition_page_cnt = 0;
+    
+    
+
+    if(NULL == partition_name)
+    {
+       gPrtition.Printf("part: sflash_delete AK_NULL == partition_name\r\n");
+        return -1; 
+    }
+
+    if(sflash_str_len(partition_name) > PARTITION_NAME_LEN)
+    {
+        gPrtition.Printf("part: sflash_delete the partition name len more than %d\r\n", PARTITION_NAME_LEN);
+        return -1;
+    }
+    
+    if(1 != g_spi_partition.init_success_flag)
+    {
+        if (NULL == gPrtition.Printf)
+        {
+        }
+        else
+        {
+            gPrtition.Printf("part: sflash_delete not Sflash_Init\r\n");
+        }
+        return -1;
+    }
+
+    if(g_spi_partition.open_time == 1)
+    {
+        gPrtition.Printf("part: sflash_delete the other partition name is openning\r\n");
+        return -1;
+    }
+    
+    //ͨķжϷǷ
+     buf = gPrtition.RamAlloc(page_cnt*page_size*sizeof(unsigned char));
+    if(NULL == buf)
+    {
+        gPrtition.Printf("part: sflash_delete buf malloc fail\r\n");
+        return -1;
+    }
+
+    gPrtition.MemSet(buf, 0x0, page_cnt*page_size*sizeof(unsigned char));
+    gPrtition.Printf("read partition_table_start:%d\r\n", m_spi_burn.partition_table_start);
+    if(0 != prod_spireadpage(m_spi_burn.partition_table_start, page_cnt, buf))
+    {
+        gPrtition.RamFree(buf);
+        gPrtition.Printf("part: sflash_delete read fail\r\n");
+        return -1;
+    }
+
+    gPrtition.MemCpy(&file_num, buf, 4);
+    gPrtition.Printf("part: sflash_delete file_num:%d\r\n", file_num);
+   
+    if(file_num == 0 || file_num == 0xFFFFFFFF)
+    {
+        gPrtition.RamFree(buf);
+        gPrtition.Printf("part: sflash_delete file_num:%d error\r\n", file_num);
+        return -1;
+    }
+    
+    //жϷǷ
+    if(0 != sflash_check_name_is_exist(partition_name, buf, file_num, &name_idex))
+    {
+        gPrtition.RamFree(buf);
+        gPrtition.Printf("part: sflash_delete partition_name :%s is not exist\r\n", partition_name);
+        return -1;
+    }
+    
+    //ȡ
+    gPrtition.MemCpy(&partition, &buf[name_idex*sizeof(T_PARTITION_TABLE_INFO) + 4], sizeof(T_PARTITION_TABLE_INFO));
+    gPrtition.Printf("change type:%d \n", partition.partition_info.type);
+    gPrtition.Printf("change r_w_flag:%d \n", partition.partition_info.r_w_flag);
+    gPrtition.Printf("change page_cnt:%d \n", partition.partition_info.ksize);
+    gPrtition.Printf("change start_page:%d \n", partition.partition_info.start_pos);
+    gPrtition.Printf("change name:%s \n", partition.partition_info.name);
+    
+    gPrtition.MemCpy(&last_partition, &buf[(file_num - 1)*sizeof(T_PARTITION_TABLE_INFO) + 4], sizeof(T_PARTITION_TABLE_INFO));
+    
+    gPrtition.Printf("last change type:%d \n", last_partition.partition_info.type);
+    gPrtition.Printf("last change r_w_flag:%d \n", last_partition.partition_info.r_w_flag);
+    gPrtition.Printf("last change page_cnt:%d \n", last_partition.partition_info.ksize);
+    gPrtition.Printf("last change start_page:%d \n", last_partition.partition_info.start_pos);
+    gPrtition.Printf("last change name:%s \n", last_partition.partition_info.name);
+   
+    //ǰƶ
+    if(name_idex + 1 == file_num)
+    {
+        //һͲҪ
+    }
+    else
+    {
+        //
+        start_page = partition.partition_info.start_pos/page_size;
+        next_start_page = partition.partition_info.start_pos/page_size + (partition.partition_info.ksize*K_SIZE)/page_size;
+        last_page = last_partition.partition_info.start_pos/page_size + (last_partition.partition_info.ksize*K_SIZE)/page_size;
+        gPrtition.Printf("last_partition.partition_info.start_page:%d, last_partition.partition_info.page_cnt:%d \n"
+            , last_partition.partition_info.start_pos/page_size, (last_partition.partition_info.ksize*K_SIZE)/page_size);
+        gPrtition.Printf("0 last_page:%d, next_start_page:%d, start_page:%d \n", last_page, next_start_page, start_page);
+        if(sflash_move_partition_data(start_page, next_start_page, last_page, 0) == -1)
+        {
+            gPrtition.RamFree(buf);
+            gPrtition.Printf("part: sflash_delete move data fail\r\n");
+            return -1;
+        }
+    }
+    
+    //·
+    partition_temp = (T_PARTITION_TABLE_INFO *)&buf[name_idex*sizeof(T_PARTITION_TABLE_INFO) + 4];
+
+    //¼ǰĿʼҳ
+    next_partition_page = partition_temp->partition_info.start_pos/page_size;
+    next_partition_page_cnt = 0;
+    
+    for(i = name_idex + 1; i < file_num; i++)
+    {
+        partition_temp++;
+        
+        //һʼһ
+        partition_temp->partition_info.start_pos = (next_partition_page + next_partition_page_cnt)*page_size;
+        next_partition_page_cnt = (partition_temp->partition_info.ksize*K_SIZE)/page_size;
+        next_partition_page = partition_temp->partition_info.start_pos/page_size;
+    }
+
+    //
+    gPrtition.MemCpy(&buf[name_idex*sizeof(T_PARTITION_TABLE_INFO) + 4], &buf[(name_idex + 1)*sizeof(T_PARTITION_TABLE_INFO) + 4], (file_num - 1 - name_idex)*sizeof(T_PARTITION_TABLE_INFO));
+    file_num--;
+    gPrtition.MemCpy(&buf[0], &file_num, 4);
+    //0
+    gPrtition.MemSet(&buf[file_num*sizeof(T_PARTITION_TABLE_INFO) + 4], 0xFF, sizeof(T_PARTITION_TABLE_INFO));
+
+
+    //д
+    if(0 != sflash_write_data(buf, file_num*sizeof(T_PARTITION_TABLE_INFO) + 4, m_spi_burn.partition_table_start, page_cnt, 1))
+    {
+        gPrtition.RamFree(buf);
+        gPrtition.Printf("part: sflash_delete write partition table start:%d, cnt:%d\r\n", m_spi_burn.partition_table_start, page_cnt);
+        return -1;
+    }
+
+    //д
+    if(0 != sflash_write_data(buf, file_num*sizeof(T_PARTITION_TABLE_INFO) + 4, m_spi_burn.partition_table_start + m_spi_burn.pages_per_block, page_cnt, 1))
+    {
+        gPrtition.RamFree(buf);
+        gPrtition.Printf("part: 00 sflash_delete write partition table start:%d, cnt:%d\r\n", m_spi_burn.partition_table_start, page_cnt);
+        return -1;
+    }
+
+
+    if(buf != NULL)
+    {
+        gPrtition.RamFree(buf);
+        buf = NULL;
+    }
+
+    
+    return 0;
+}
+
+
+unsigned long sflash_get_partition_ksize(T_PARTITION_TABLE_INFO *phandle)
+{
+    if(phandle == NULL)
+    {
+        gPrtition.Printf("part: sflash_get_partition_size phandle == NULL\r\n");
+        return 0;
+    }
+
+    return phandle->partition_info.ksize;
+}
+
+unsigned long sflash_get_partition_data_size(T_PARTITION_TABLE_INFO *phandle)
+{
+    T_FS_CONFIG fs_config;
+    T_BIN_CONFIG bin_config;
+    unsigned long lenght = 0;
+
+    if(phandle == NULL)
+    {
+        gPrtition.Printf("part: sflash_get_partition_size phandle == NULL\r\n");
+        return 0;
+    }
+
+    if(phandle->partition_info.type == PART_BIN_TYPE || phandle->partition_info.type == PART_DATA_TYPE)
+    {
+        gPrtition.MemCpy(&bin_config, &phandle->ex_partition_info, sizeof(T_BIN_CONFIG));
+        lenght = bin_config.file_length;
+    }
+    else if(phandle->partition_info.type == PART_FS_TYPE)
+    {
+        gPrtition.MemCpy(&fs_config, &phandle->ex_partition_info, sizeof(T_FS_CONFIG));
+        lenght = phandle->partition_info.ksize*K_SIZE;  //fs_config.file_length;
+    }
+    else
+    {
+        gPrtition.Printf("Partition_Get_DataSize type is error\r\n");
+        return 0;
+    }
+
+    gPrtition.Printf("sflash_get_partition_data_size:%d\r\n", lenght);
+
+    return lenght;
+}
+
+
+
+#endif
+
+
diff --git a/drivers/mtd/partition/spiburn.h b/drivers/mtd/partition/spiburn.h
new file mode 100755
index 0000000..50a3279
--- /dev/null
+++ b/drivers/mtd/partition/spiburn.h
@@ -0,0 +1,155 @@
+#ifndef _SFLASH_BURN_H_
+#define _SFLASH_BURN_H_
+
+
+//#include <stdio.h>
+//#include <stdlib.h>
+//#include <stdarg.h>
+//#include <string.h>
+#include "partition_lib.h"
+#include "partition_init.h"
+
+
+extern T_FHA_LIB_CALLBACK  gPrtition;
+
+//#define     PARTITION_TALBE_PAGE_NUM            2
+
+
+/************************************************************************
+ * NAME:     Sflash_Init
+ * FUNCTION  partition init
+ * PARAM:    [in] T_pVOID SpiInfo
+ * RETURN:    success return 0, fail retuen -1
+**************************************************************************/
+int sflash_init(void *SpiInfo, unsigned long table_page);
+
+/************************************************************************
+ * NAME:     Sflash_Creat
+ * FUNCTION  partition creat
+ * PARAM:    [in] T_CREAT_PARTITION_INFO *partition
+ * RETURN:   success return T_PARTITION_TABLE_INFO *pFile, fail retuen AK_NULL
+**************************************************************************/
+T_PARTITION_TABLE_INFO *sflash_creat(T_CREAT_PARTITION_INFO *partition);
+
+/************************************************************************
+ * NAME:     Sflash_Close
+ * FUNCTION  partition close
+ * PARAM:    [in] T_PARTITION_TABLE_INFO *pFile
+ * RETURN:    success return 0, fail retuen -1
+**************************************************************************/
+int sflash_close(T_PARTITION_TABLE_INFO *pFile);
+
+/************************************************************************
+ * NAME:     Sflash_Open
+ * FUNCTION  partition open
+ * PARAM:    [in] T_U8 *partition_name
+ * RETURN:   success return T_PARTITION_TABLE_INFO *pFile, fail retuen AK_NULL
+**************************************************************************/
+T_PARTITION_TABLE_INFO *sflash_open(unsigned char *partition_name);
+
+/************************************************************************
+ * NAME:     Sflash_Write
+ * FUNCTION  partition write
+ * PARAM:    [in] T_PARTITION_TABLE_INFO *pFile, 
+                   [in] T_U8 *data, 
+                   [in]  T_U32 data_len
+ * RETURN:    success return 0, fail retuen -1
+**************************************************************************/
+int sflash_write(T_PARTITION_TABLE_INFO *pFile, unsigned char *data, unsigned long data_len);
+
+
+/************************************************************************
+ * NAME:     Sflash_Read
+ * FUNCTION  partition read
+ * PARAM:    [in] T_PARTITION_TABLE_INFO *pFile, 
+                   out] T_U8 *data, 
+                   [in]  T_U32 data_len
+ * RETURN:    success return 0, fail retuen -1
+**************************************************************************/
+int sflash_read(T_PARTITION_TABLE_INFO *pFile, unsigned char *data, unsigned long data_len);
+
+/************************************************************************
+ * NAME:     sflash_set_attr
+ * FUNCTION  sflash_set_attr
+ * PARAM:    
+                   out] T_PARTITION_TABLE_CONFIG *part_talbe; 
+ * RETURN:   success return 0, fail retuen -1
+**************************************************************************/
+
+int sflash_set_attr(T_PARTITION_TABLE_INFO *pFile, T_EX_PARTITION_CONFIG *ex_arrt);
+
+/************************************************************************
+ * NAME:     sflash_get_attr
+ * FUNCTION  sflash_get_attr
+ * PARAM:    
+                   out] T_PARTITION_TABLE_CONFIG *part_talbe; 
+ * RETURN:   success return 0, fail retuen -1
+**************************************************************************/
+
+int sflash_get_attr(T_PARTITION_TABLE_INFO *pFile, T_EX_PARTITION_CONFIG *ex_arrt);
+
+/************************************************************************
+ * NAME:     sflash_resize
+ * FUNCTION  sflash_resize
+ * PARAM:    unsigned char *partition_name,
+                   unsigned long partition_size  K
+ * RETURN:   success return 0, fail retuen -1
+**************************************************************************/
+
+int sflash_resize(unsigned char *partition_name, unsigned long partition_size);
+
+/************************************************************************
+ * NAME:     sflash_get_partition_table
+ * FUNCTION  sflash get partition table
+ * PARAM:    
+                   out] T_PARTITION_TABLE_CONFIG *part_talbe; 
+ * RETURN:   success return 0, fail retuen -1
+**************************************************************************/
+int sflash_get_partition_table(T_PARTITION_TABLE_CONFIG *part_talbe);
+int sflash_get_partition_backup_table(T_PARTITION_TABLE_CONFIG *part_talbe);
+
+
+/************************************************************************
+ * NAME:     sflash_delete
+ * FUNCTION  sflash_delete
+ * PARAM:    
+                   [int]unsigned char *partition_name
+ * RETURN:   success return 0, fail retuen -1
+**************************************************************************/
+int sflash_delete(unsigned char *partition_name);
+
+
+/************************************************************************
+ * NAME:     sflash_delete
+ * FUNCTION  sflash_delete
+ * PARAM:    
+                   [int]unsigned char *partition_name
+ * RETURN:   success return 0, fail retuen -1
+**************************************************************************/
+unsigned long sflash_get_partition_ksize(T_PARTITION_TABLE_INFO *phandle);
+
+
+/************************************************************************
+ * NAME:     sflash_get_partition_data_size
+ * FUNCTION  sflash_get_partition_data_size
+ * PARAM:    
+                   [int]T_PARTITION_TABLE_INFO *phandle
+ * RETURN:   success return data_size, fail retuen -1
+**************************************************************************/
+
+unsigned long sflash_get_partition_data_size(T_PARTITION_TABLE_INFO *phandle);
+
+
+
+
+
+void sflash_set_partition_startpage(unsigned long start_page);
+
+
+//由于优化性能的问题，烧录时partition表进行多次擦写导致占用一些时间，现在修正在烧录时，只有最后完成时，再进行把这些数据写下去
+int spiflash_burn_partitiontab_info_init(unsigned char burn_mode);
+int spiflash_burn_partitiontab_info_end(void);
+
+
+#endif
+
diff --git a/drivers/mtd/partition/spinand_badblock.c b/drivers/mtd/partition/spinand_badblock.c
new file mode 100755
index 0000000..2e384a8
--- /dev/null
+++ b/drivers/mtd/partition/spinand_badblock.c
@@ -0,0 +1,2247 @@
+/**
+ * @FILENAME: spinand_badblock.c
+ * @BRIEF xx
+ * Copyright (C) 2011 Anyka (GuangZhou) Software Technology Co., Ltd.
+ * @AUTHOR lixinng
+ * @DATE 2016-12-10
+ * @VERSION 1.0
+ * @modified lxj  2016-12-10
+ * 
+ * @REF
+ */
+
+//#include <stdio.h>
+//#include <stdlib.h>
+//#include <stdarg.h>
+//#include <string.h>
+#include "spinand_badblock.h"
+#include "public_info.h"
+#include "partition_init.h"
+#include "spinand_driver.h"
+#include "partition_lib.h"
+
+
+
+
+#ifdef SUPPORT_SPINAND 
+
+T_ASA_PARAM m_fha_asa_param;
+T_ASA_BLOCK m_fha_asa_block; 
+//T_PART_INIT_INFO g_burn_param = {0};
+unsigned char  *m_pBuf_BadBlk = NULL;
+static unsigned char m_buf_stat = 0;
+
+
+extern T_FHA_LIB_CALLBACK  gPrtition;
+extern T_FHA_LIB_CALLBACK  spinand_gPrtition;
+
+
+extern T_PARTITION  g_partition;
+extern T_SPINAND_INIT_INFO m_spinand_burn ;
+extern T_BIN_NAND_INFO  m_bin_nand_info;
+extern T_NAND_PHY_INFO    g_nand_phy_info;
+
+unsigned char m_hinfo_data[HEAD_SIZE] = {0x41, 0x4E, 0x59, 0x4B, 0x41, 0x41, 0x53, 0x41};
+
+
+
+
+
+
+
+
+#define ASA_BUFFER_SIZE (g_nand_phy_info.page_size>8192?g_nand_phy_info.page_size:8192)
+
+
+/**
+ * @BREIF    asa_global_init
+ * @AUTHOR   luqiliu
+ * @DATE     2009-12-10
+ * @RETURN   T_U32 
+ * @retval   FHA_SUCCESS :  succeed
+ * @retval   FHA_FAIL :     fail
+ */
+
+//void asa_global_init()
+//{
+//    m_fha_asa_param.BlockNum     = g_nand_phy_info.blk_num;
+//    m_fha_asa_param.BytesPerPage = g_nand_phy_info.page_size;
+//    m_fha_asa_param.PagePerBlock = g_nand_phy_info.page_per_blk;
+
+    /*
+    if (PLAT_SPOT == g_burn_param.ePlatform)
+    {
+        if(512 == g_nand_phy_info.page_size)
+        {
+            m_fha_asa_param.BlockNum     = g_nand_phy_info.blk_num / 8;
+            m_fha_asa_param.BytesPerPage = 2048;
+            m_fha_asa_param.PagePerBlock = 64;
+        }
+        else
+        {
+            m_fha_asa_param.BytesPerPage = (g_nand_phy_info.page_size > 4096) ?  4096 : g_nand_phy_info.page_size;  
+        } 
+    }
+    */
+//}   
+
+
+/**
+ * @BREIF    asa_BadBlBufInit
+ * @AUTHOR   luqiliu
+ * @DATE     2009-12-10
+ * @RETURN   T_U32 
+ * @retval   FHA_SUCCESS :  succeed
+ * @retval   FHA_FAIL :     fail
+ */
+
+int asa_BadBlBufInit(void)
+{
+    m_pBuf_BadBlk = (unsigned char *)gPrtition.RamAlloc(g_nand_phy_info.blk_num >> 3);
+    if (NULL != m_pBuf_BadBlk)
+    {
+        m_buf_stat = 1;
+        return 0;
+    }
+    gPrtition.Printf("asa alloc err: %d, %d\n", g_nand_phy_info.blk_num, g_nand_phy_info.blk_num >> 3);
+    return -1;
+}
+
+static unsigned char count_bit0(unsigned char d)
+{
+    unsigned char i, j = 0;
+    for(i = 0; i < 8; i++)
+    {
+        if(0 == (d & (0x1 << i)))
+        {
+            j++;
+        } 
+    }
+
+    return j;         
+}
+
+
+//check wether a block is initial bad block or not
+/**
+ * @BREIF    check_block
+ * @AUTHOR   luqiliu
+ * @DATE     2009-12-10
+ * @RETURN   T_U32 
+ * @retval   FHA_SUCCESS :  succeed
+ * @retval   FHA_FAIL :     fail
+ */
+
+static int check_block(unsigned long chip, unsigned long block)
+{
+    unsigned long page_count = 0;
+    unsigned long pages[8] = {0};
+    unsigned long column_count = 0;
+    unsigned long columns[8] = {0};
+    unsigned short real_pages_per_block;
+    unsigned long i,j;
+    unsigned long rowAddr, columnAddr;
+    unsigned long page_size = 0;
+    unsigned char IBB_type = g_nand_phy_info.custom_nd;
+    
+    page_size = g_nand_phy_info.page_size;
+    real_pages_per_block = g_nand_phy_info.page_per_blk;
+    //in enhanced SLC mode , FHA just use the half pages of a block. must be reverted, when checking bad block
+    if (g_nand_phy_info.flag & (1 << 24))
+        real_pages_per_block <<= 1;
+
+    //gPrtition.Printf("IBB_type:%d\r\n", IBB_type);
+
+    //samsung
+    if(NAND_TYPE_SAMSUNG == IBB_type)
+    {
+        //slc
+        if(real_pages_per_block < 128)
+        {
+            page_count = 2;
+            pages[0] = 0;
+            pages[1] = 1;
+
+            //small page
+            if(page_size < 2048)
+            {
+                column_count = 1;
+                columns[0] = page_size + 5;
+            }
+            else
+            {
+                column_count = 1;
+                columns[0] = page_size;
+            }
+        }
+        else //mlc
+        {
+            page_count = 1;
+            pages[0] = real_pages_per_block - 1;
+
+            column_count = 1;
+            columns[0] = page_size;
+        }
+    }
+
+    //hynix
+    if(NAND_TYPE_HYNIX == IBB_type)
+    {
+        //slc
+        if(real_pages_per_block < 128)
+        {
+            page_count = 2;
+            pages[0] = 0;
+            pages[1] = 1;
+
+            //small page
+            if(page_size < 2048)
+            {
+                column_count = 1;
+                columns[0] = page_size + 5;
+            }
+            else
+            {
+                column_count = 1;
+                columns[0] = page_size;
+            }
+        }
+        else
+        {
+            page_count = 2;
+            pages[0] = real_pages_per_block - 1;
+            pages[1] = real_pages_per_block - 3;
+
+            column_count = 1;
+            columns[0] = page_size;
+        }
+    }
+
+    //toshiba normal
+    if(NAND_TYPE_TOSHIBA == IBB_type)
+    {
+        column_count = 2;
+        columns[0] = 0;
+        columns[1] = page_size;
+        
+        if(real_pages_per_block < 128)
+        {
+            page_count = 2;
+            pages[0] = 0;
+            pages[1] = 1;
+        }
+        else
+        {
+            page_count = 1;
+            pages[0] = real_pages_per_block - 1;
+        }
+    }
+
+    //toshiba with extented blocks
+    if(NAND_TYPE_TOSHIBA_EXT == IBB_type)
+    {
+        column_count = 2;
+        columns[0] = 0;
+        columns[1] = page_size;
+        
+        if(real_pages_per_block >= 128)
+        {
+            page_count = 2;
+            pages[0] = 0;
+            pages[1] = real_pages_per_block - 1;
+        }
+        else
+        {
+            gPrtition.Printf("asa check block param err\r\n");
+            while(1);
+        }    
+    }
+
+    //Micron
+    if(NAND_TYPE_MICRON == IBB_type)
+    {
+        page_count = 2;
+        pages[0] = 0;
+        pages[1] = 1;
+
+        column_count = 1;
+        columns[0] = page_size;
+    }
+    //4k micron
+    if(NAND_TYPE_MICRON_4K == IBB_type)
+    {
+        unsigned long count = 0;
+        unsigned char *pData = NULL;
+        
+        rowAddr = block * real_pages_per_block;
+        columnAddr = page_size;
+
+        pData = (unsigned char *)gPrtition.RamAlloc(256);
+        
+        spinand_gPrtition.ReadNandBytes(chip, rowAddr, columnAddr,  pData, 256);
+        
+        count = 0;
+        for(i = 0; i < 218; i++)
+        {
+            if(0 == pData[i])
+            {
+                count++;
+                //printf("%d_0x%x ", i, pData[i]);
+            }
+        }
+
+        gPrtition.RamFree(pData);
+        if(count > 0)
+        {
+            return -1;
+        }
+        else
+        {
+            return 0;
+        }               
+    }
+
+    //ST
+    if(NAND_TYPE_ST == IBB_type)
+    {
+        if(real_pages_per_block < 128)
+        {
+            if(page_size < 2048)
+            {
+                page_count = 2;
+                pages[0] = 0;
+                pages[1] = 1;
+
+                column_count = 1;
+                columns[0] = page_size+5;
+            }
+            else
+            {
+                page_count = 1;
+                pages[0] = 0;
+
+                column_count = 2;
+                columns[0] = page_size;
+                columns[1] = page_size+5;
+            }
+        }
+        else
+        {
+            page_count = 1;
+            pages[0] = real_pages_per_block - 1;
+
+            column_count = 1;
+            columns[0] = 0;
+        }
+    }
+    
+    //MIRA
+    if(NAND_TYPE_MIRA == IBB_type)
+    {
+        page_count = 2;
+        pages[0] = 0;
+        pages[1] = real_pages_per_block - 1;
+
+        column_count = 2;
+        columns[0] = 0;
+        columns[1] = page_size - 1;
+    }
+
+    //Other
+    if(NAND_TYPE_UNKNOWN == IBB_type)
+    {
+    }
+    if(SPINAND_TYPE_MIRA == IBB_type)
+    {
+        page_count = 2;
+        pages[0] = 0;
+        pages[1] = 1;
+
+        column_count = 1;
+        columns[0] = page_size;
+    }
+    if(SPINAND_TYPE_GD== IBB_type)
+    {
+        page_count = 1;
+        pages[0] = 0;
+
+        column_count = 1;
+        columns[0] = page_size;
+    }
+    if(0 == page_count || 0 == column_count)
+    {
+         gPrtition.Printf("asa IBB_type err\r\n");
+         while(1);
+    }
+
+    //check for initial bad block
+    for(i = 0; i < page_count; i++)
+    {
+        for(j = 0; j < column_count; j++)
+        {
+            unsigned char data[64];
+            rowAddr = block * real_pages_per_block + pages[i];
+                       
+            columnAddr = columns[j];
+            spinand_gPrtition.ReadNandBytes(chip, rowAddr, columnAddr,  data, 64);
+            //gPrtition.Printf("ReadNandBytes:%02x, %02x, %02x, %02x\r\n", data[0], data[1], data[2], data[3]);
+            if(data[0] != 0xFF)
+            {
+                return -1;
+            }
+        }
+    }
+    
+    return 0;
+}
+
+
+void fha_set_asa_end_block(unsigned long blk_end)
+{
+    unsigned char check_idex = 0;
+
+    while(1)
+    {
+        if(blk_end > 100)
+        {
+            gPrtition.Printf("bad block is too much, not find partition table,while(1)\r\n");
+            while(1);
+        }
+        
+        if(spinand_is_badblock(blk_end) == 0)
+        {
+            blk_end++;
+            gPrtition.Printf("asa end bad block:%d \r\n", blk_end);
+            continue;
+        }
+
+        if(check_idex == 0)
+        {
+            check_idex = 1;
+            m_spinand_burn.partition_table_start =  blk_end*m_spinand_burn.pages_per_block;
+            gPrtition.Printf("partition table block:%d \r\n", blk_end);
+        }
+        else if(check_idex == 1)
+        {
+            //жϻ飬ıݿ
+            m_spinand_burn.partition_table_start_backup = blk_end*m_spinand_burn.pages_per_block;
+            gPrtition.Printf("partition table backup block:%d \r\n", blk_end);
+            break;
+        }
+
+        blk_end++;
+
+       
+    }
+
+   m_spinand_burn.partition_start = m_spinand_burn.partition_table_start_backup + m_spinand_burn.pages_per_block;
+   g_partition.partition_start_page = m_spinand_burn.partition_start;
+   gPrtition.Printf("partition_start_page:%d \r\n", g_partition.partition_start_page);
+
+} 
+
+
+
+
+/**
+ * @BREIF    asa_scan_ewr
+  * :
+ * ҰĲдƻ
+ * @AUTHOR   luqiliu
+ * @DATE     2009-12-10
+ * @RETURN   T_U32 
+ * @retval   FHA_SUCCESS :  succeed
+ * @retval   FHA_FAIL :     fail
+ */
+
+int asa_scan_ewr(unsigned char pBuf[], unsigned long len, unsigned char mark)
+{
+    unsigned long block_count = 0;
+
+    unsigned long chip;
+    unsigned long block;
+    unsigned long page_size;
+    unsigned long byte_loc;
+    unsigned long byte_offset;
+    unsigned long i, j, k;
+    unsigned char *pData = NULL;
+    unsigned long spare;
+
+    if(NULL == pBuf)
+    {
+        return -1;
+    }
+    /*
+        жٸblock    
+      */
+    block_count = g_nand_phy_info.blk_num;
+    if(block_count > len * 8)
+    {
+        return -1;
+    }
+
+    page_size = g_nand_phy_info.page_size;
+    pData = gPrtition.RamAlloc(page_size);
+    if(NULL == pData)
+    {
+        gPrtition.Printf("alloc fail\n");
+        while(1);
+    }
+    gPrtition.MemSet(pData, mark, page_size);
+    gPrtition.MemSet(&spare, mark, 4);
+    gPrtition.Printf("spare: %x\r\n", spare);
+
+    gPrtition.Printf("before erase and write: %d\r\n", block_count);
+    /*
+       ʵֶnandblockдȲд
+      */
+    for(i = 0; i < block_count; i++)
+    {
+        gPrtition.Printf("%d,", i);
+        chip = i / (g_nand_phy_info.blk_num);
+        block = i % (g_nand_phy_info.blk_num);
+            
+        byte_loc = i/8;
+        byte_offset = 7 - i%8;
+
+        if(-1 == Prod_NandEraseBlock(block))
+        {
+            gPrtition.Printf("@@@Erase Bad Block: %d\r\n", i);
+            pBuf[byte_loc] |= 1 << byte_offset;
+            continue; 
+        }
+
+        for(j = 0; j < g_nand_phy_info.page_per_blk; j++)
+        {
+            if(-1 == Prod_NandWritePage(block, j, pData, (unsigned char *)&spare, 4))
+            {
+                gPrtition.Printf("@@@Write Bad Block: %d\r\n", i);
+                pBuf[byte_loc] |= 1 << byte_offset;
+                break; 
+            }
+        }
+    }
+
+    gPrtition.MemSet(pData, 0, page_size);
+    spare = 0;
+
+    gPrtition.Printf("\r\nbefore read\r\n");
+    /*
+       ʵֶnandblockдд
+      */
+    
+    for (i = 0; i <block_count; i++)
+    {
+        gPrtition.Printf("%d,", i);
+        chip = i / g_nand_phy_info.blk_num;
+        block = i % g_nand_phy_info.blk_num;
+        
+        byte_loc = i/8;
+        byte_offset = 7 - i%8;
+        
+        for(j = 0; j < g_nand_phy_info.page_per_blk; j++)
+        {
+            if(-1 == Prod_NandReadPage(block, j, pData, (unsigned char*)&spare, 4))
+            {
+                gPrtition.Printf("@@@Read Bad Block: %d\r\n", i);
+                pBuf[byte_loc] |= 1 << byte_offset;
+                goto BAD_BLOCK; 
+            }
+            else
+            {
+                
+                for(k = 0; k < 4; k++)
+                {
+                    if(((spare >> k*8) & 0xFF) != mark)
+                    {
+                        gPrtition.Printf("@@@Spare Changed Bad Block: %d, %x, %x\r\n", i, (spare >> k*8) & 0xFF, mark);
+                        pBuf[byte_loc] |= 1 << byte_offset;
+                        goto BAD_BLOCK;
+                    }
+                }
+                for(k = 0; k < page_size; k++)
+                {
+                    if(pData[k] != mark)
+                    {
+                        gPrtition.Printf("@@@Data Changed Bad Block: %d\r\n", i);
+                        pBuf[byte_loc] |= 1 << byte_offset;
+                        goto BAD_BLOCK;
+                    }
+                }
+            }
+BAD_BLOCK:
+            spare = 0;
+            gPrtition.MemSet(pData, 0, page_size);
+            break;
+        }
+    }       
+
+    gPrtition.RamFree(pData);
+    pData = NULL;
+    
+    return 0;
+}
+
+
+
+//scan initial bad blocks
+/**
+ * @BREIF    asa_scan_normal
+ * :
+ *  ɨ裬
+ * @AUTHOR   luqiliu
+ * @DATE     2009-12-10
+ * @RETURN   T_U32 
+ * @retval   FHA_SUCCESS :  succeed
+ * @retval   FHA_FAIL :     fail
+ */
+
+static int asa_scan_normal(unsigned char pBuf[], unsigned long len, unsigned long asa_startblock)
+{
+    unsigned long block_count = 0;
+    unsigned long chip;
+    unsigned long block;
+    unsigned long byte_loc;
+    unsigned long byte_offset;
+    unsigned long i, j;
+    unsigned long spare;
+    unsigned long k;
+    unsigned long bad_block_cnt = 0;
+    unsigned char bUsed = 0;
+
+    if(NULL == pBuf)
+    {
+        return -1;
+    }
+    /*
+       ȡnandжٸblock
+      */
+    
+    block_count = g_nand_phy_info.blk_num;
+    if(block_count > len*8)
+    {
+        return -1;
+    }
+    /*
+      ɨ
+      */
+
+    for(i = 0; i < g_nand_phy_info.page_per_blk; i++)
+    {
+        k = 0;
+        //check if block 0 is null or not
+        gPrtition.MemSet(pBuf, 0x0, len);
+        Prod_NandReadPage(0, i, pBuf, (unsigned char *)&spare, 4);
+       
+        for(j = 0; j < g_nand_phy_info.page_size; j++)
+        {
+            if(pBuf[j] != 0xFF)
+            {
+               k += count_bit0(pBuf[j]);
+                
+            }
+
+            if(k > 8)
+            {
+                bUsed = 1;
+                goto CHECK_BAD_BLOCK;
+            }
+        }
+    }
+
+CHECK_BAD_BLOCK:   
+    gPrtition.MemSet(pBuf, 0, len);
+    //check bad block
+    if(0 == bUsed)
+    {     
+        for(i = asa_startblock; i < block_count; i++)
+        {
+            chip = i / g_nand_phy_info.blk_num;
+            block = i % g_nand_phy_info.blk_num;
+
+            byte_loc = i/8;
+            byte_offset = 7 - i%8;     
+            
+            #if 1
+            //gPrtition.Printf("block: %d, %d, %d, %d, %d, %d\r\n", asa_startblock, block_count, byte_loc, byte_offset, block, i);
+            if(-1 == check_block(chip, block))
+            {
+                gPrtition.Printf("@@@Initial invalid block: %d\r\n", i);
+                pBuf[byte_loc] |= 1 << byte_offset;
+                bad_block_cnt++; 
+            }
+            #else
+            if ((PLAT_SPOT == g_burn_param.ePlatform || g_burn_param.eAKChip == FHA_CHIP_37XXL) 
+                && (1 == g_nand_phy_info.col_cycle) && (2048 == m_fha_asa_param.BytesPerPage))
+            {
+                unsigned long m;
+                unsigned long block_small;
+                for(m=0; m<8; m++)
+                {
+                    block_small = block * 8 + m;
+                    if(-1 == check_block(chip, block_small))
+                    {
+                        pBuf[byte_loc] |= 1 << byte_offset;
+                        bad_block_cnt++; 
+                        break;
+                    }
+                }    
+            }
+            else 
+            {
+                
+                if(-1 == check_block(chip, block))
+                {
+                    gPrtition.Printf("@@@Initial invalid block: %d\r\n", i);
+                    pBuf[byte_loc] |= 1 << byte_offset;
+                    bad_block_cnt++; 
+                }
+            }
+            #endif
+        }
+
+        //if bad block count <= 4%, think bad block is initial bad block
+        if(bad_block_cnt > block_count * 4 / 100)
+        {
+            gPrtition.Printf("bad block is initial bad block!!!\r\n");
+            gPrtition.MemSet(pBuf, 0, len);
+        }    
+        
+    }
+    return 0;
+}
+
+
+
+/*
+µĿ(m_asa_blocksΪm_asa_head)ʼγԴcountȥȡ
+*/
+ /**
+     * @BREIF    asa_read_page
+     * @AUTHOR   luqiliu
+     * @DATE     2009-12-10
+     * @RETURN   T_U32 
+     * @retval   FHA_SUCCESS :  succeed
+     * @retval   FHA_FAIL :     fail
+   */
+
+static int asa_read_page(unsigned long page, unsigned char data[], unsigned long count)
+{
+    unsigned char ret = -1;
+    unsigned long spare;
+    unsigned long i;
+    unsigned long read_index = m_fha_asa_block.asa_head;
+    
+    //check parameter
+    if(page >= g_nand_phy_info.page_per_blk|| m_fha_asa_block.asa_head>= ASA_BLOCK_COUNT || NULL == data)
+    {
+    	gPrtition.Printf("error: read fail, :%d, %d, %d\r\n", page, g_nand_phy_info.page_per_blk, m_fha_asa_block.asa_head);
+        return -1;
+    }
+
+    //read data
+    for (i=0; i<count; i++)
+    {
+    	//gPrtition.Printf("count:%d, %d\r\n", count, i);
+        //ȫдʧʱm_asa_blocksжӦݽֵΪ0
+        if (0 != m_fha_asa_block.asa_blocks[read_index])
+        {
+           //gPrtition.Printf("read_index:%d, %d, %d\r\n", read_index, m_fha_asa_block.asa_blocks[read_index], page);
+            ret = Prod_NandReadPage(m_fha_asa_block.asa_blocks[read_index], page, data, (unsigned char*)&spare, 4);
+        }
+        
+        if (ret == 0)
+        {
+            break;
+        }
+
+		//gPrtition.Printf("asa_count:%d, %d\r\n", read_index, m_fha_asa_block.asa_count);
+        //Ϊѭбݼ
+        read_index = (read_index > 0) ? (read_index - 1) : (m_fha_asa_block.asa_count - 1);
+    }    
+    
+    return ret;
+}
+
+
+/**
+ * @BREIF    asa_create_repair
+ * @AUTHOR   luqiliu
+ * @DATE     2009-12-10
+ * @RETURN   T_U32 
+ * @retval   FHA_SUCCESS :  succeed
+ * @retval   FHA_FAIL :     fail
+ */
+
+static int asa_create_repair(unsigned long block_start, unsigned long block_end, unsigned char* pBuf)
+{
+    unsigned long i ; 
+//	T_U32 j ;
+    unsigned long spare;
+    unsigned char badblock[ASA_MAX_BLOCK_TRY];
+
+    m_fha_asa_block.write_time = 1;
+    m_fha_asa_block.asa_count = 0;
+
+    //һ(spareΪ0)1ҳȡϢ
+    if (-1 == Prod_NandReadPage(block_end, 1, pBuf, (unsigned char *)&spare, 4))
+    {
+        return -1;
+    }
+
+    gPrtition.MemCpy(badblock, pBuf, ASA_MAX_BLOCK_TRY);
+
+    //ʼؽȫ
+    for(i = block_start; (i < block_end) && (m_fha_asa_block.asa_count < ASA_BLOCK_COUNT); i++)
+    {
+        unsigned long j;
+
+        //ȫг
+        if ((badblock[i/8] & (1 << (7 - i%8))) != 0)
+        {
+            continue;
+        }
+
+        if (-1 == Prod_NandEraseBlock(i))
+        {
+            continue;
+        }
+
+        //鿪ʼݵȫĿ
+        for (j=0; j<m_fha_asa_param.PagePerBlock; j++)
+        {
+            if (-1 == Prod_NandReadPage(block_end, j, pBuf, (unsigned char *)&spare, 4))
+            {
+                return -1;
+            }  
+            else
+            {
+                if (-1 == Prod_NandWritePage(i, j, pBuf, (unsigned char *)&m_fha_asa_block.write_time, 4))
+                {
+                    break;
+                }    
+            }    
+        }
+
+        if (j < m_fha_asa_param.PagePerBlock)
+        {
+            Prod_NandEraseBlock(i);
+            continue;
+        }
+        else
+        {
+            gPrtition.Printf("repair asa blk:%d, times:%d\r\n", i, m_fha_asa_block.write_time);
+            m_fha_asa_block.asa_head = m_fha_asa_block.asa_count;            
+            m_fha_asa_block.asa_blocks[m_fha_asa_block.asa_count++] = (unsigned char)i;
+            m_fha_asa_block.write_time++;
+        }    
+    }
+
+    return (m_fha_asa_block.asa_count > 0) ? 0 : -1;
+} 
+
+
+/**
+ * @BREIF    get  bad block information of one or more blocks
+ * @AUTHOR  Liao Zhijun
+ * @DATE     2009-11-23
+ * @PARAM   start_block: start block
+                  pData[IN]: buffer used to store bad blocks information data
+                  length: how many blocks u want to know
+ * @RETURN   AK_TRUE, success, 
+                    AK_FALSE, fail
+ */
+int asa_get_bad_block(unsigned long start_block, unsigned char pData[], unsigned long length)
+{
+    unsigned long page_index, page_offset;
+    unsigned long byte_loc, byte_offset;
+    unsigned long index_old = 0xFFFFFFFF;
+    unsigned char *pBuf = NULL;
+    unsigned long page_count;
+    unsigned long i;//, idex = 0;
+    
+    //check parameter
+    if(m_fha_asa_block.asa_head>= ASA_BLOCK_COUNT || NULL == pData)
+    {
+        return -1;
+    }
+
+    page_count = (g_nand_phy_info.blk_num - 1) / (g_nand_phy_info.page_size* 8) + 1;
+    //alloc memory
+    pBuf = (unsigned char *)gPrtition.RamAlloc(ASA_BUFFER_SIZE);
+    if(NULL == pBuf)
+    {
+        return -1;
+    }
+
+    //get all bad blocks
+    for(i = 0; i < length; i++)
+    {
+        page_index = (start_block + i) / (g_nand_phy_info.page_size * 8);
+        page_offset = (start_block + i) - page_index * (g_nand_phy_info.page_size * 8);
+        
+        byte_loc = page_offset / 8;
+        byte_offset = 7 - page_offset % 8;
+
+        //read page data if necessary
+        if(index_old != page_index)
+        {
+            index_old = page_index;
+            //ԴӰȫпȥȡϢ
+            //gPrtition.Printf("i:%d,%d, %d, %d\r\n", i, page_count, page_index, m_fha_asa_block.asa_count);
+            if(-1 == asa_read_page(1+page_count+page_index, pBuf, m_fha_asa_block.asa_count))
+            {
+                gPrtition.RamFree(pBuf);
+                return -1;
+            }
+            #if 0
+            gPrtition.Printf("bad table:\r\n");    
+            for(idex = 0; idex < 256; idex++)
+            {
+                if(idex %16 == 0)
+                {
+                    gPrtition.Printf("\r\n");
+                }
+                gPrtition.Printf("%02x ", pBuf[idex]);
+            }
+            #endif
+        }
+
+        //gPrtition.Printf("pBuf:%d, %d, %02x\r\n", byte_loc, byte_offset, pBuf[byte_loc]);
+        //update bad block buffer
+        if(pBuf[byte_loc] & (1 << byte_offset))
+        {
+            pData[i/8] |= 1<<(7-i%8);
+        }
+        else
+        {
+            pData[i/8] &= ~(1<<(7-i%8));
+        }
+
+    }
+    #if 0
+    gPrtition.Printf("pData bad table:\r\n");    
+    for(idex = 0; idex < 256; idex++)
+    {
+        if(idex %16 == 0)
+        {
+            gPrtition.Printf("\r\n");
+        }
+        gPrtition.Printf("%02x ", pBuf[idex]);
+    }
+    #endif
+
+    gPrtition.RamFree(pBuf);
+    return 0;
+}
+
+
+//update 
+/**
+ * @BREIF    asa_update_page_data
+ * @AUTHOR   luqiliu
+ * @DATE     2009-12-10
+ * @RETURN   T_U32 
+ * @retval   FHA_SUCCESS :  succeed
+ * @retval   FHA_FAIL :     fail
+ */
+
+static void asa_update_page_data(unsigned long page, unsigned char data[], unsigned long bad_blocks[], unsigned long bb_count)
+{
+    unsigned long page_count;
+    unsigned long page_index, page_offset;
+    unsigned long byte_loc, byte_offset;
+    unsigned char i;
+    
+    page_count = (g_nand_phy_info.blk_num- 1) / (g_nand_phy_info.page_size * 8) + 1;
+
+    for(i = 0; i < bb_count; i++)
+    {
+        page_index = bad_blocks[i] / (g_nand_phy_info.page_size * 8);
+        page_offset = bad_blocks[i] - page_index * (g_nand_phy_info.page_size * 8);
+
+        if(page != 1 + page_count + page_index)//the previous pages(1 ~ page_count ) stores the bitmap of initial bad block
+        {
+            continue;
+        }
+
+        byte_loc = page_offset / 8;
+        byte_offset = 7 - page_offset % 8;
+        
+        data[byte_loc] |= (1 << byte_offset);
+    }
+}
+
+
+
+/**
+ * @BREIF    set a block to bad block
+ * @AUTHOR  Liao Zhijun
+ * @DATE     2009-11-23
+ * @PARAM   block: which block u want to set
+ * @RETURN   AK_TRUE, success, 
+                    AK_FALSE, fail
+ */
+int asa_set_bad_block(unsigned long block)
+{
+    unsigned char *pBuf = NULL;
+    unsigned long block_next = 0;
+    unsigned long block_written = 0;
+    unsigned long i, j;
+    unsigned long bad_blocks[ASA_BLOCK_COUNT] = {0};
+    unsigned char bb_count = 0;
+
+    //check parameter
+    if(m_fha_asa_block.asa_head >= ASA_BLOCK_COUNT)
+    {
+        return -1;
+    }
+
+    //alloc memory
+    pBuf = (unsigned char *)gPrtition.RamAlloc(ASA_BUFFER_SIZE);
+    if(NULL == pBuf)
+    {
+        return -1;
+    }
+ 
+    bad_blocks[0] = block;
+    bb_count = 1;
+    
+    block_next = m_fha_asa_block.asa_head;
+    for(j = 0; (j < m_fha_asa_block.asa_count) && (block_written < 2); j++)
+    {
+        unsigned long ret;
+        unsigned long spare;
+
+        spare = m_fha_asa_block.write_time;
+
+        //get next block
+        block_next = (block_next+1) % m_fha_asa_block.asa_count;
+        if(0 == m_fha_asa_block.asa_blocks[block_next])
+        {
+            continue;
+        }
+
+        //˰ȫп
+        if(block_next == m_fha_asa_block.asa_head)
+        {
+            gPrtition.RamFree(pBuf);
+            gPrtition.Printf("FHA: set bad blk err, asa get only one blk.\r\n");
+            
+            return -1;
+        }
+
+         //erase block
+        if(-1 == Prod_NandEraseBlock(m_fha_asa_block.asa_blocks[block_next]))
+        {
+            goto WRITE_FAIL;
+        }
+        
+        //move pages before the page
+        for(i = 0; i < g_nand_phy_info.page_per_blk; i++)
+        {
+            //˸ձĿ飬пȥȡ
+            if(-1 == asa_read_page(i, pBuf, m_fha_asa_block.asa_count-1))
+            {
+                gPrtition.RamFree(pBuf);
+                return -1;
+            }
+
+            asa_update_page_data(i, pBuf, bad_blocks, bb_count);
+            ret = Prod_NandWritePage(m_fha_asa_block.asa_blocks[block_next], i, pBuf, (unsigned char*)&spare, 4);
+            if(-1 == ret)
+            {
+                goto WRITE_FAIL;
+            }
+        }
+
+        //update global variable
+        m_fha_asa_block.asa_head = (unsigned char)block_next;
+        
+        m_fha_asa_block.write_time++;
+        block_written++;
+
+        continue;
+
+WRITE_FAIL:
+        Prod_NandEraseBlock(m_fha_asa_block.asa_blocks[block_next]);
+        bad_blocks[bb_count++] = m_fha_asa_block.asa_blocks[block_next];
+        m_fha_asa_block.asa_blocks[block_next] = 0;
+
+        if (bb_count > 5)
+        {
+            gPrtition.Printf("asa fail, block more than %d@#@", bb_count);
+            gPrtition.RamFree(pBuf);
+            return -1;
+        }
+    }
+    
+    gPrtition.RamFree(pBuf);
+    
+    return (block_written > 0) ? 0 : -1;
+}
+
+
+
+
+/**
+ * @BREIF    asa_init_repair
+ * @AUTHOR   luqiliu
+ * @DATE     2009-12-10
+ * @RETURN   T_U32 
+ * @retval   FHA_SUCCESS :  succeed
+ * @retval   FHA_FAIL :     fail
+ */
+
+static void asa_init_repair(unsigned long block_start, unsigned long block_end, unsigned char* pBuf)
+{
+    unsigned char bad_blocks[ASA_MAX_BLOCK_TRY];
+    unsigned long i, j;
+    unsigned long spare = 1;
+
+    //get bad blocks
+    if(asa_get_bad_block(0, bad_blocks, ASA_MAX_BLOCK_TRY) == 0)
+    {
+        for(i = block_start; (i < block_end) && (m_fha_asa_block.asa_count < ASA_BLOCK_COUNT); i++)
+        {
+            for(j = 0; j < m_fha_asa_block.asa_count; j++)
+            {
+                if(m_fha_asa_block.asa_blocks[j] == i)
+                {
+                    break;
+                }
+            }
+            if(j < m_fha_asa_block.asa_count)
+            {
+                continue;
+            }
+            
+            if((bad_blocks[i/8] & (1<<(7-(i%8)))) == 0)
+            {
+               // T_U32 j;
+                if (Prod_NandEraseBlock(i) == -1)
+                {
+                    continue;
+                }
+
+                for (j=0; j<g_nand_phy_info.page_per_blk; j++)
+                {
+                    if (asa_read_page(j, pBuf, m_fha_asa_block.asa_count) == -1)
+                    {    
+                        break;
+                    }
+                    else
+                    {
+                        if (Prod_NandWritePage(i, j, pBuf, (unsigned char *)&spare, 4) == -1)
+                        {
+                            break;
+                        }    
+                    }    
+                }
+
+                if (j < m_fha_asa_param.PagePerBlock)
+                {
+                    Prod_NandEraseBlock(i);
+                    continue;
+                }
+                else
+                {
+                    gPrtition.Printf("repair:%d\n", i);
+                    m_fha_asa_block.asa_blocks[m_fha_asa_block.asa_count++] = (unsigned char)i;
+                }    
+            }
+        }
+    }
+}    
+
+
+int spinand_check_Initial_babblock(unsigned long block)
+{
+    unsigned long block_idex = 0;
+    unsigned long chip = 0;
+    
+    chip = block / g_nand_phy_info.blk_num;
+    block_idex = block % g_nand_phy_info.blk_num;
+    
+   // gPrtition.Printf("chip:%d, block_idex:%d\r\n", chip, block_idex);
+    
+    if(-1 == check_block(chip, block_idex))
+    {
+        gPrtition.Printf("@@@Initial invalid block: %d\r\n", block_idex);
+        return -1;
+    }
+
+    return 0;
+}
+
+
+int earse_write_check_badblock(unsigned long block, unsigned char mark)
+{
+//    unsigned long block_count = 0;
+   // unsigned long chip;
+    unsigned long page_size;
+    //unsigned long byte_loc;
+    //unsigned long byte_offset;
+    unsigned long j, k;
+    unsigned char *pData = NULL;
+    unsigned long spare;
+
+    page_size = g_nand_phy_info.page_size;
+    pData = gPrtition.RamAlloc(page_size);
+    if(NULL == pData)
+    {
+        gPrtition.Printf("malloc fail\n");
+        while(1);
+    }
+    gPrtition.MemSet(pData, mark, page_size);
+    gPrtition.MemSet(&spare, mark, 4);
+    gPrtition.Printf("spare: %x\r\n", spare);
+    /*
+       ʵֶnandblockдȲд
+      */
+    gPrtition.Printf("erase block: %d\r\n", block);
+    if(-1 == Prod_NandEraseBlock(block))
+    {
+        gPrtition.RamFree(pData);
+        pData = NULL;
+        gPrtition.Printf("@@@Erase Bad Block: %d\r\n",block);
+        return -1; 
+    }
+
+    for(j = 0; j < g_nand_phy_info.page_per_blk; j++)
+    {
+        if(-1 == Prod_NandWritePage(block, j, pData, (unsigned char *)&spare, 4))
+        {
+            gPrtition.RamFree(pData);
+            pData = NULL;
+            gPrtition.Printf("@@@Write Bad Block: %d\r\n", block);
+            return -1; 
+        }
+    }
+    
+
+    gPrtition.MemSet(pData, 0, page_size);
+    spare = 0;
+
+    gPrtition.Printf("\r\nbefore read\r\n");
+    /*
+       ʵֶnandblockдд
+      */
+    gPrtition.Printf("block:%d,", block);
+    for(j = 0; j < g_nand_phy_info.page_per_blk; j++)
+    {
+        if(-1 == Prod_NandReadPage(block, j, pData, (unsigned char *)&spare, 4))
+        {
+            gPrtition.RamFree(pData);
+            pData = NULL;
+            gPrtition.Printf("@@@Read Bad Block: %d\r\n", block);
+            return -1;  
+        }
+        else
+        {
+            
+            for(k = 0; k < 4; k++)
+            {
+                if(((spare >> k*8) & 0xFF) != mark)
+                {
+                    gPrtition.RamFree(pData);
+                    pData = NULL;
+                    gPrtition.Printf("@@@Spare Changed Bad Block: %d, %x, %x\r\n", block, (spare >> k*8) & 0xFF, mark);
+                    return -1; 
+                }
+            }
+            for(k = 0; k < page_size; k++)
+            {
+                if(pData[k] != mark)
+                {
+                    gPrtition.RamFree(pData);
+                    pData = NULL;
+                    gPrtition.Printf("@@@Data Changed Bad Block: %d\r\n", block);
+                    return -1; 
+                }
+            }
+        }
+        
+        spare = 0;
+        gPrtition.MemSet(pData, 0, page_size);
+        //break;
+    }   
+
+    gPrtition.RamFree(pData);
+    pData = NULL;
+    
+    return 0;
+}
+
+
+int spinand_check_isuse(unsigned long block)
+{
+    unsigned long i = 0, j = 0, k = 0, spare = 0;
+
+    unsigned char *pBuf = NULL;
+    
+    pBuf = gPrtition.RamAlloc(g_nand_phy_info.page_size);
+    if(pBuf == NULL)
+    {
+        gPrtition.Printf("malloc fail\r\n");
+        gPrtition.RamFree(pBuf);
+        return -1;
+    }
+    
+    for(i = 0; i < g_nand_phy_info.page_per_blk; i++)
+    {
+        gPrtition.Printf(".");
+        k = 0;
+        //check if block 0 is null or not
+        gPrtition.MemSet(pBuf, 0x0, g_nand_phy_info.page_size);
+        Prod_NandReadPage(block, i, pBuf, (unsigned char *)&spare, 4);
+       
+        for(j = 0; j < g_nand_phy_info.page_size; j++)
+        {
+            if(pBuf[j] != 0xFF)
+            {
+               k += count_bit0(pBuf[j]);
+                
+            }
+
+            if(k > 8)
+            {
+                gPrtition.Printf("the spinand is use\r\n");
+                gPrtition.RamFree(pBuf);
+                return -1;
+            }
+        }
+    }
+    
+    gPrtition.Printf("the spinand is not use\r\n");
+    gPrtition.RamFree(pBuf);
+    return 0;
+}
+
+
+//ûл½жϴ˿Ƿ񻵿
+//ɴ˴˽ӿڻждĲ
+//Դ˿ֻΪȫ¼ʱʹã
+int spinand_check_babblock(unsigned long block)
+{
+    //жϴnandǷʹù
+    if(spinand_check_isuse(block) == 0)
+    {
+        //жϴ˿Ƿ
+        if(spinand_check_Initial_babblock(block) == -1)
+        {
+            return 0;
+        }
+    }
+
+    //ǵĻв
+    //ǳɹ£д
+    //дɹ½ж
+    //طǻ
+    if(earse_write_check_badblock(block, 0x55) == -1)
+    {
+        return 0;
+    }
+    
+    gPrtition.Printf("spinand_check_babblock end\r\n");
+    return -1;
+}
+
+
+//˽ӿлж
+int  spinand_is_badblock(unsigned long block)
+{
+    unsigned char  pData[4] = {0};
+
+     if(1 == m_buf_stat && m_pBuf_BadBlk != NULL)
+    {
+        //gPrtition.Printf("g_nand_phy_info.blk_num:%d\r\n",g_nand_phy_info.blk_num);
+        asa_get_bad_block(0, m_pBuf_BadBlk, g_nand_phy_info.blk_num);
+        m_buf_stat = 2;
+    }
+
+    if(m_buf_stat > 1  && m_pBuf_BadBlk != NULL)
+    {
+        unsigned long byte_loc, byte_offset;
+
+        byte_loc = block / 8;
+        byte_offset = 7 - block % 8;
+        //gPrtition.Printf("byte_loc:%d, byte_offset:%d, %02x\r\n",byte_loc, byte_offset, m_pBuf_BadBlk[byte_loc]);
+        if(m_pBuf_BadBlk[byte_loc] & (1 << byte_offset))
+        {
+            return 0;
+        }
+    }
+    else
+    {
+        asa_get_bad_block(block, pData, 1);
+        //gPrtition.Printf("block:%d, %02x\r\n",block, pData[0]);
+        if ((pData[0] & (1 << 7)) != 0)
+        {
+            return 0;
+        }
+    }
+
+    return -1;
+}
+
+
+
+
+//ȡ
+int  spinand_get_badblock(unsigned long start_block, unsigned char pData[], unsigned long blk_cnt)
+{
+    if (asa_get_bad_block(start_block, pData, blk_cnt))
+    {
+        return 0; 
+    }
+    else
+    {
+        return -1;
+    }
+    
+    return 0;
+}
+
+
+
+
+//û
+int  spinand_set_badblock(unsigned long block)
+{
+    unsigned long byte_loc, byte_offset;
+    int ret = -1;
+    
+    ret = asa_set_bad_block(block);
+
+    if(NULL != m_pBuf_BadBlk)
+    {
+        byte_loc = block / 8;
+        byte_offset = 7 - block % 8;
+        m_pBuf_BadBlk[byte_loc] |= 1 << byte_offset;
+    }
+
+    return ret;
+}
+
+
+/************************************************************************
+ * NAME:     FHA_check_bad_block
+ * FUNCTION  check nand flash bad block
+ * PARAM:    [in] block -- need to check block item
+ * RETURN:   is bad block return 0, or else retuen -1
+**************************************************************************/
+
+//
+int spinand_babblock_tbl_creat(unsigned long type, unsigned long asa_start_block)
+{
+    unsigned long i, bad_offset_page = 0;
+    unsigned char *buf_badblock, *buf_other, *dummy_buf;
+    unsigned long block = 0;
+    unsigned long spare = 0;
+    T_ASA_HEAD *pHead = NULL;
+    T_ASA_ITEM *pItem = NULL;
+    unsigned long block_count = 0; 
+    unsigned long badblock_page_count = 0;
+    unsigned long block_get = 0;
+    unsigned long block_try = 0;
+    
+    
+    block_count = g_nand_phy_info.blk_num;
+    badblock_page_count = (block_count - 1) / (g_nand_phy_info.page_size * 8) + 1;
+
+    //alloc memory
+    buf_badblock = gPrtition.RamAlloc(badblock_page_count * g_nand_phy_info.page_size);
+    dummy_buf = gPrtition.RamAlloc(g_nand_phy_info.page_size);
+    
+    if((NULL == buf_badblock) || (NULL == dummy_buf))
+    {
+        return -1;
+    }
+
+    buf_other = gPrtition.RamAlloc(ASA_BUFFER_SIZE);
+    if( NULL == buf_other)
+    {
+        gPrtition.RamFree(buf_badblock);        
+        gPrtition.RamFree(dummy_buf);
+        return -1;
+    }
+    
+    
+    gPrtition.MemSet(buf_badblock, 0, badblock_page_count * g_nand_phy_info.page_size);
+    gPrtition.MemSet(dummy_buf, 0, g_nand_phy_info.page_size);//fill the dummy buf with 0x0
+
+    switch(type)
+    {
+        case ASA_FORMAT_NORMAL:
+            asa_scan_normal(buf_badblock, badblock_page_count * g_nand_phy_info.page_size, asa_start_block);
+            break;
+        case ASA_FORMAT_EWR:
+            asa_scan_ewr(buf_badblock, badblock_page_count * g_nand_phy_info.page_size, 0x55);
+            break;
+        default:
+            break;
+    }
+    //for test factory 
+#if 0
+    m_asafun.Printf("+++++++++++++for test");
+    while(1);
+#endif
+    //prepare for data in page 0
+    //head
+    pHead = (T_ASA_HEAD *)buf_other;
+
+    gPrtition.MemCpy(pHead->head_str, m_hinfo_data, HEAD_SIZE);
+    pHead->verify[0] = 0x0;
+    pHead->verify[1] = 0x0;
+    pHead->item_num = 2;
+    pHead->info_end = 1 + badblock_page_count * 2;
+
+    //initial bad block
+    pItem = (T_ASA_ITEM *)(buf_other + sizeof(T_ASA_HEAD));
+
+    pItem->page_start = 1;
+    pItem->page_count = (unsigned short)badblock_page_count;
+    pItem->info_start = 0;
+    pItem->info_len = 0;
+
+    //total bad block
+    pItem = (T_ASA_ITEM *)(buf_other + sizeof(T_ASA_HEAD) + sizeof(T_ASA_ITEM));
+
+    pItem->page_start = (unsigned short)(1 + badblock_page_count);
+    pItem->page_count = (unsigned short)badblock_page_count;
+    pItem->info_start = 0;
+    pItem->info_len = 0;
+
+    //write data
+    gPrtition.MemSet(m_fha_asa_block.asa_blocks, 0, ASA_BLOCK_COUNT);
+    m_fha_asa_block.write_time = 1;
+    block = asa_start_block;
+    block_try = 0;
+    block_get = 0;
+    block--;//Ϊ++
+    do
+    {
+        unsigned char ret;
+        #define CHECK(ret) if(-1 == ret){Prod_NandEraseBlock(block); buf_badblock[block/8] |= 1 << (7 - block%8);continue;}
+
+        block_try++;
+        block ++;
+        m_fha_asa_block.asa_block_cnt = (unsigned char)block + 1;
+
+        //ignore initial bad block
+        if((buf_badblock[block/8] & (1 << (7 - block%8))) != 0)
+        {
+            continue;
+        }
+        
+        ret = Prod_NandEraseBlock(block);
+        CHECK(ret);
+
+        //we use ASA_BLOCK_COUNT valid blocks as Secure Area and additional one after them as a tail block.
+        //the spare in tail block is "0x0".
+        spare = (m_fha_asa_block.write_time > ASA_BLOCK_COUNT) ? 0 : m_fha_asa_block.write_time;
+        
+        //write page 0
+        //ret = m_asafun.WritePage(0, block, 0, buf_other,(T_U8*)&spare, 4);
+        ret = Prod_NandWritePage(block, 0, buf_other,(unsigned char*)&spare, 4);
+        CHECK(ret);
+
+        //write initial bad block
+        for(i= 0; i < badblock_page_count; i++)
+        {
+            //ret = m_asafun.WritePage(0, block, 1+i, buf_badblock + i * m_asafun.BytesPerPage, (T_U8*)&spare, 4);
+           // gPrtition.Printf("0block:%d, page:%d, spare:%x\r\n", block, 1 + i, spare);
+            ret = Prod_NandWritePage(block, 1+i, buf_badblock + i * g_nand_phy_info.page_size, (unsigned char*)&spare, 4);
+            if(-1 == ret)
+            {
+                break;
+            }
+        }
+        CHECK(ret);
+
+        //write total bad block
+        for(i= 0; i < badblock_page_count; i++)
+        {
+            bad_offset_page = 1 + badblock_page_count + i;
+            //ret = m_asafun.WritePage(0, block, 1 + badblock_page_count + i, buf_badblock + i * m_asafun.BytesPerPage, (T_U8*)&spare, 4);
+            //gPrtition.Printf("1block:%d, page:%d, bad_offset_page:%d, spare:%x\r\n", block, 1 + badblock_page_count + i, bad_offset_page, spare);
+            ret = Prod_NandWritePage( block, 1 + badblock_page_count + i, buf_badblock + i * g_nand_phy_info.page_size, (unsigned char*)&spare, 4);
+            if(!ret)
+            {
+                break;
+            }
+            
+        }
+        CHECK(ret);
+
+        //fill the dummy data in gap-pages to keep pages from bit-flips  
+        //gPrtition.Printf("bad_offset_page + 1:%d, badblock_page_count:%d, i:%d, spare:%x\r\n", bad_offset_page + 1 ,badblock_page_count,i,   spare);
+        for (i = bad_offset_page + 1; i < (unsigned long)g_nand_phy_info.page_per_blk- 1; i++)
+        {
+            ret = Prod_NandWritePage(block, i, dummy_buf, (unsigned char*)&spare, 4);
+            if(-1 == ret)
+            {
+                break;
+            }
+        }
+        CHECK(ret);
+        
+        //write last page
+        //ret = m_asafun.WritePage(0, block, m_asafun.PagePerBlock-1, buf_other, (T_U8*)&spare, 4);
+
+       // gPrtition.Printf("block:%d, spare:%x\r\n", block, spare);
+        ret = Prod_NandWritePage(block, g_nand_phy_info.page_per_blk-1, buf_other, (unsigned char*)&spare, 4);
+        CHECK(ret);
+
+        if(m_fha_asa_block.write_time <= ASA_BLOCK_COUNT)
+        {
+            m_fha_asa_block.asa_head = (unsigned char)block_get;
+            m_fha_asa_block.asa_blocks[block_get++] = (unsigned char)block;
+            m_fha_asa_block.asa_count = (unsigned char)block_get;
+        }
+
+        m_fha_asa_block.write_time++;
+    }while(m_fha_asa_block.write_time <= (ASA_BLOCK_COUNT + 1) && block_try < ASA_MAX_BLOCK_TRY);
+
+    //free buffer
+    gPrtition.RamFree(buf_badblock);
+    //free buf_other
+    gPrtition.RamFree(buf_other);
+    //free dummy_buf
+    gPrtition.RamFree(dummy_buf);
+
+    /*
+    asa end block
+    */
+    gPrtition.Printf("creat asa_block_cnt:%d\r\n", m_fha_asa_block.asa_block_cnt);
+    fha_set_asa_end_block(m_fha_asa_block.asa_block_cnt);
+
+    return (block_try > ASA_MAX_BLOCK_TRY) ? -1 : 0;
+
+    
+    return 0;
+}
+
+
+
+//ɨ軵
+//Ĭϴӵ1鿪ʼΪȫ
+int  spinand_babblock_tbl_init(unsigned char new_burn_mode, unsigned char burn_flag, unsigned long asa_start_block)
+{
+    unsigned long wtime_primary;
+    unsigned char *pBuf;
+    unsigned long block, spare;
+    unsigned long block_try, block_get;
+    unsigned long block_end = 0;
+    unsigned long start_block = 0;
+    unsigned char bLastInfo = 0;
+    unsigned char bfirstInfo = 1;
+    int ret = 0;
+
+  //  asa_global_init();
+
+    gPrtition.Printf("spinand_babblock_tbl_init start\r\n");
+    if (burn_flag)
+    {
+        if (asa_BadBlBufInit() != 0)
+        {
+            gPrtition.Printf("asa_scan malloc fail\r\n");
+            return ret;
+        }
+    }
+
+    //alloc memory
+    pBuf = gPrtition.RamAlloc(ASA_BUFFER_SIZE);
+    if(NULL == pBuf)
+    {
+        return ret;
+    }
+
+    wtime_primary = 0;
+    m_fha_asa_block.asa_head = 0;
+
+    block_try = block_get = 0;
+    block = asa_start_block;
+    gPrtition.MemSet(m_fha_asa_block.asa_blocks, 0, ASA_BLOCK_COUNT);
+
+    block--;//Ϊ++
+    //scan
+    while(block_get <= ASA_BLOCK_COUNT && block_try < ASA_MAX_BLOCK_TRY)
+    {
+        T_ASA_HEAD *pHead = (T_ASA_HEAD *)pBuf;
+
+        block_try++;
+        block++;
+        m_fha_asa_block.asa_block_cnt = (unsigned char)block + 1;
+        
+        //gPrtition.Printf("block_get:%d, block_try:%d, m_fha_asa_block.asa_block_cnt:%d\r\n", block_get, block_try, m_fha_asa_block.asa_block_cnt);
+        //read page 0asa flag
+        if(-1 == Prod_NandReadPage(block, 0, pBuf, (unsigned char *)&spare, 4))
+        {
+            gPrtition.Printf("asa_init read block:%d flag fail\r\n", block);
+            continue;
+        }
+
+        //check head
+        if(gPrtition.MemCmp(pHead->head_str, m_hinfo_data, HEAD_SIZE) != 0)
+        {
+            //gFHAf.Printf("asa_init block:%d is not asa block\r\n", block);
+            continue;
+        }
+        //gPrtition.Printf("read asa block:%d\r\n", block);
+        //read time
+        if(-1 == Prod_NandReadPage(block, g_nand_phy_info.page_per_blk- 1, pBuf, (unsigned char *)&spare, 4))
+        {
+            gPrtition.Printf("asa_init read times at block:%d fail\r\n", block);
+            continue;
+        }
+
+        //spareΪȫ0xFF,пǲԺûдݵĿ,鲻ʹ
+        if(0xFFFFFFFF == spare)
+        {
+            gPrtition.Printf("asa_init times to max at block:%d\r\n", block);
+            continue;
+        }
+
+        if(bfirstInfo == 1)
+        {
+            bfirstInfo = 0;
+            start_block = block;
+        }
+        //gPrtition.Printf("asa block:%d, spare:%d, block_get:%d, block_try:%d\r\n", block, spare, block_get, block_try);
+        block_end = block;
+        if(0 == spare)
+        {
+            //spare0ǰȫʶ
+            gPrtition.Printf("asa_init times is zero at block:%d, %d\r\n", block, m_fha_asa_block.asa_block_cnt);
+            //m_fha_asa_block.asa_block_cnt--; 
+
+            bLastInfo = 1;
+            break;
+        }
+
+        //update spare
+        if(spare > wtime_primary)
+        {
+            //µĿ
+            wtime_primary = spare;
+            m_fha_asa_block.asa_head = (unsigned char)block_get;
+        }
+        
+        m_fha_asa_block.asa_blocks[block_get++] = (unsigned char)block;
+        m_fha_asa_block.asa_count = (unsigned char)block_get;
+
+        gPrtition.Printf("asa_init block:%d, times:%d\r\n", block, spare);
+    }
+
+    //ASA_MAX_BLOCK_TRY
+    if(ASA_MAX_BLOCK_TRY == block_try)
+    {
+        m_fha_asa_block.asa_block_cnt = ASA_MAX_BLOCK_TRY;
+    }
+    
+    if(0 == m_fha_asa_block.asa_blocks[m_fha_asa_block.asa_head])
+    {
+        gPrtition.Printf("asa_init cannot find a fit block\r\n");
+        if (bLastInfo)
+        {
+            //¹ȫ
+            if (-1 == asa_create_repair(start_block, block_end, pBuf))
+            {
+                ret = -1;
+            }
+            else
+            {
+                ret = 0;
+            }    
+        }
+        else
+        {
+            ret = -1;
+        }    
+    }
+    else
+    {
+
+        m_fha_asa_block.write_time = wtime_primary+1;
+
+        gPrtition.Printf("asa_init primary block:%d, times:%d\r\n", m_fha_asa_block.asa_blocks[m_fha_asa_block.asa_head], m_fha_asa_block.write_time);
+
+        //if asa blocks is not enough, fill with non-badblock
+        if(m_fha_asa_block.asa_count < ASA_BLOCK_COUNT)
+        {
+            gPrtition.Printf("m_fha_asa_block.asa_count:%d, block_end:%d\r\n", m_fha_asa_block.asa_count, block_end);
+
+        //if asa blocks is not enough, fill with non-badblock
+            asa_init_repair(start_block, block_end, pBuf);
+        }
+    }
+
+    gPrtition.RamFree(pBuf);
+    
+    if (0 == ret)
+    {
+        unsigned long m = 0;
+
+        #if 0
+        pBuf = gPrtition.RamAlloc(2048+64);
+        gPrtition.ReadNandBytes(0, 576, 0, pBuf, 2048+8);
+        for(m = 0; m < 2048+8; m++)
+        {
+            if(m%16 == 0)
+            {
+                gPrtition.Printf("\r\n");
+            }
+
+            gPrtition.Printf("%02x ", pBuf[m]);
+        }
+
+        gPrtition.Printf("\r\n");
+        gPrtition.Printf("\r\n");
+
+        gPrtition.ReadNandBytes(0, 642, 0, pBuf, 2048+8);
+        for(m = 0; m < 2048+8; m++)
+        {
+            if(m%16 == 0)
+            {
+                gPrtition.Printf("\r\n");
+            }
+
+            gPrtition.Printf("%02x ", pBuf[m]);
+        }
+
+        gPrtition.RamFree(pBuf);
+        #endif
+        
+        for (m=0; m<g_nand_phy_info.blk_num; m++)
+        {
+            if (spinand_is_badblock(m) == 0)
+            {
+                gPrtition.Printf("BB:%d ", m);
+            }    
+        } 
+        gPrtition.Printf("\r\n");
+        
+        //ֻȫ¼ʱŻи·λ
+       if(new_burn_mode)
+       {
+            gPrtition.Printf("m_fha_asa_block.asa_block_cnt:%d\r\n", (unsigned long)m_fha_asa_block.asa_block_cnt);
+           fha_set_asa_end_block((unsigned long)m_fha_asa_block.asa_block_cnt);
+           
+       }
+
+        
+    }    
+
+    return ret;
+}
+
+
+
+
+
+int spinand_write_block(T_ASA_HEAD* pHead, T_ASA_FILE_INFO *pFileInfo, unsigned long fileInfoOffset, const unsigned char* dataBuf)
+{
+    unsigned long block_next = 0;
+    unsigned long block_written = 0;
+    unsigned long i, j;
+    unsigned long bad_blocks[ASA_BLOCK_COUNT] = {0};
+    unsigned char bb_count = 0;
+    unsigned char *pTmp = NULL;
+    unsigned char *pTmpBuf = NULL;
+            
+    pTmpBuf = gPrtition.RamAlloc(ASA_BUFFER_SIZE);
+    if( NULL == pTmpBuf)
+    {
+    	gPrtition.Printf("pTmpBuf RamAlloc fail\r\n");
+        return -1;
+    }
+    
+    block_next = m_fha_asa_block.asa_head;
+ 
+    for(j= 0; j < m_fha_asa_block.asa_count; j++)
+    {
+        unsigned long ret;
+        unsigned long spare;
+        
+        spare = m_fha_asa_block.write_time;
+
+        //get next block
+        block_next = (block_next+1) % m_fha_asa_block.asa_count;
+
+		//gPrtition.Printf("block_next:%d, %d, %d\r\n", block_next, m_fha_asa_block.asa_blocks[block_next], spare);
+        if(0 == m_fha_asa_block.asa_blocks[block_next])
+        {
+            continue;
+        }
+
+		//gPrtition.Printf("m_fha_asa_block.asa_head:%d\r\n", m_fha_asa_block.asa_head);
+        //˰ȫп
+        if(block_next == m_fha_asa_block.asa_head)
+        {
+        	gPrtition.Printf("error: only one asa blcok\r\n");
+			gPrtition.RamFree(pTmpBuf);
+            return -1;
+        }
+
+        //erase block
+        if(-1 == Prod_NandEraseBlock(m_fha_asa_block.asa_blocks[block_next]))
+        {
+        	gPrtition.Printf("Prod_NandEraseBlock %d fail\r\n", m_fha_asa_block.asa_blocks[block_next]);
+            goto WRITE_FAIL;
+        }
+
+
+		//gPrtition.Printf("start_page:%d, end_page:%d info_end:%d\r\n", pFileInfo->start_page, pFileInfo->end_page, pHead->info_end);
+        //move page
+        for(i = 0; i < g_nand_phy_info.page_per_blk; i++)
+        {
+        	//gPrtition.Printf("page:%d\r\n", i);
+            //ûдҳҪжд
+            if(i > pHead->info_end && i < g_nand_phy_info.page_per_blk - 1)
+            {
+                continue;
+            }
+
+            if(i<pFileInfo->start_page|| i>=pFileInfo->end_page)
+            {
+                //дȫļֻĲֹƻȫ
+                if(-1 == asa_read_page(i, pTmpBuf, 2))
+                {
+                	gPrtition.Printf("error: spinand_write_block asa_read_page fail\r\n");
+                    gPrtition.RamFree(pTmpBuf);
+                    return -1;
+                }
+
+                
+                if(0 == i)
+                {
+                    gPrtition.MemCpy(pTmpBuf, pHead, sizeof(T_ASA_HEAD));
+                    gPrtition.MemCpy(pTmpBuf + fileInfoOffset, pFileInfo, sizeof(T_ASA_FILE_INFO));
+                }
+                
+                asa_update_page_data(i, pTmpBuf, bad_blocks, bb_count);
+
+                pTmp = pTmpBuf;
+            }
+            else
+            {
+                pTmp = (unsigned char*)(dataBuf + (i - pFileInfo->start_page) * g_nand_phy_info.page_size);
+            }
+
+            ret = Prod_NandWritePage(m_fha_asa_block.asa_blocks[block_next], i, pTmp, (unsigned char *)&spare, 4);
+            if(-1 == ret)
+            {
+            	gPrtition.Printf("error: Prod_NandWritePage fail\r\n");
+                goto WRITE_FAIL;
+            }
+        }
+
+        //update global variable
+        m_fha_asa_block.asa_head = (unsigned char)block_next;
+        
+        m_fha_asa_block.write_time++;
+        block_written++;
+
+        continue;
+
+		//gPrtition.Printf("e block_next:%d, %d\r\n",block_next,  m_fha_asa_block.asa_blocks[block_next]);
+WRITE_FAIL:
+        Prod_NandEraseBlock(m_fha_asa_block.asa_blocks[block_next]);
+        bad_blocks[bb_count++] = m_fha_asa_block.asa_blocks[block_next];
+        //дʧܣm_asa_blocksжӦΪ0ȥ
+        m_fha_asa_block.asa_blocks[block_next] = 0;
+
+		//gPrtition.Printf("e bb_count:%d\r\n",bb_count);
+
+        if (bb_count > 1)
+        {
+            gPrtition.Printf("error:spinand_write_block fail\r\n");
+            gPrtition.RamFree(pTmpBuf);
+            return -1;
+        }
+    }
+
+    gPrtition.RamFree(pTmpBuf);
+    return (block_written > 0) ? 0 : -1;
+
+}
+
+
+
+int spinand_write_asa_data(unsigned char *data, unsigned long data_len)
+{
+	unsigned char *file_name = "UPNAME";
+	unsigned char *pBuf = NULL;
+    T_ASA_HEAD HeadInfo;
+    T_ASA_FILE_INFO *pFileInfo = NULL;
+    T_ASA_FILE_INFO newFileInfo;
+    unsigned long file_info_offset = 0;
+    unsigned long i = 0,j = 0;
+    unsigned long file_num = 0;
+    unsigned char bMatch = 0; //must false
+    
+    unsigned short page_cnt = (unsigned short)(data_len-1)/g_nand_phy_info.page_size + 1;
+
+
+	//gPrtition.Printf("page_cnt:%d, data_len:%d\r\n", page_cnt, data_len);
+
+	if(m_fha_asa_block.asa_blocks[m_fha_asa_block.asa_head] == 0)
+	{
+		gPrtition.Printf("error: badblock tbl is not init or creat\r\n");
+		return -1;
+	}
+    
+    if(NULL == data || m_fha_asa_block.asa_head >= ASA_BLOCK_COUNT || data_len == 0)
+    {
+    	gPrtition.Printf("error: data = null or data_len == %d, m_fha_asa_block.asa_head = %d\r\n", data_len, m_fha_asa_block.asa_head);
+        return -1;
+    }
+    
+    pBuf = gPrtition.RamAlloc(ASA_BUFFER_SIZE);
+    if( NULL == pBuf)
+    {
+    	gPrtition.Printf("error: RamAlloc buf fail\r\n");
+        return -1;
+    }
+
+    //read page0 to get file info
+    //ȫļʼʱֻд飬Ҳֻȥ
+    if(asa_read_page(0, pBuf, 2) == - 1)
+    {
+    	gPrtition.Printf("error: asa_read_page fail\r\n");
+        goto EXIT;
+    }
+
+    //head info
+    gPrtition.MemCpy(&HeadInfo, pBuf, sizeof(T_ASA_HEAD));
+
+    file_info_offset = sizeof(T_ASA_HEAD) + 2 * sizeof(T_ASA_ITEM);
+
+	gPrtition.Printf("file_info_offset:%d\r\n", file_info_offset);
+
+    //asa file info
+    pFileInfo = (T_ASA_FILE_INFO *)(pBuf + file_info_offset);
+
+    file_num = HeadInfo.item_num - 2;
+
+
+	gPrtition.Printf("file_num:%d\r\n", file_num);
+
+
+	//ĿǰֻҪ¼һʱҪĸע
+	#if 1
+    //search asa file name
+    for(i=0; i<file_num; i++)
+    {
+        bMatch = 1;
+        for(j=0; file_name[j] && (pFileInfo->file_name)[j]; j++)
+        {
+            if(file_name[j] != (pFileInfo->file_name)[j])
+            {
+                bMatch = 0;
+                break;
+            }    
+        }
+
+        if(file_name[j] != (pFileInfo->file_name)[j])
+        {
+            bMatch = 0;
+        }
+
+        //exist
+        if(bMatch == 1)
+        {
+            //overflow page count
+            if(page_cnt > (pFileInfo->end_page - pFileInfo->start_page))
+            {
+            	gPrtition.Printf("error: page_cnt is more than src page num:%d, %d, %d \r\n",page_cnt, pFileInfo->end_page, pFileInfo->start_page);
+                goto EXIT;
+            }
+            else
+            {
+                break;
+            }
+        }    
+        else
+        {
+            //continue to search
+            pFileInfo++;
+            file_info_offset += sizeof(T_ASA_FILE_INFO);
+        }
+    }
+	#endif
+
+    if(bMatch == 0)
+    {
+        //new asa file
+        pFileInfo->start_page = HeadInfo.info_end;
+        pFileInfo->end_page = pFileInfo->start_page + page_cnt;
+        gPrtition.MemCpy(pFileInfo->file_name, file_name, 8);
+
+        //whether excess block size
+        if(pFileInfo->end_page > g_nand_phy_info.page_per_blk)
+        {
+        	gPrtition.Printf("error: data page is more than PagePerBlock:%d, %d\r\n",pFileInfo->end_page, g_nand_phy_info.page_per_blk);
+            goto EXIT;
+        }
+
+        //chenge head info if new file
+        HeadInfo.item_num++;
+        HeadInfo.info_end = pFileInfo->end_page;
+    }
+	
+	pFileInfo->file_length = data_len;
+    gPrtition.MemCpy(&newFileInfo, pFileInfo, sizeof(T_ASA_FILE_INFO));
+
+    gPrtition.RamFree(pBuf);
+
+    return spinand_write_block(&HeadInfo, &newFileInfo, file_info_offset, data);
+
+        
+EXIT:
+    gPrtition.RamFree(pBuf);
+    return -1;
+
+}
+
+
+int spinand_read_asa_data(unsigned char *data, unsigned long data_len)
+{
+	unsigned char *file_name = "UPNAME";
+	unsigned char *pBuf = NULL;
+    T_ASA_HEAD *pHead = NULL;
+    T_ASA_FILE_INFO *pFileInfo = NULL;
+    unsigned long i = 0,j = 0;
+    unsigned long file_num = 0;
+    unsigned char bMatch = 0; //must false
+//    unsigned long ret= -1;
+    unsigned long start_page = 0;
+    unsigned long end_page = 0;
+	
+    unsigned short page_cnt = (unsigned short)(data_len-1)/g_nand_phy_info.page_size + 1;
+
+
+	//gPrtition.Printf("spinand_read_asa_data, data_len:%d\r\n", data_len);
+
+	if(m_fha_asa_block.asa_blocks[m_fha_asa_block.asa_head] == 0)
+	{
+		gPrtition.Printf("error: badblock tbl is not init or creat\r\n");
+		return -1;
+	}
+
+    if(NULL == data || m_fha_asa_block.asa_head >= ASA_BLOCK_COUNT || data_len == 0)
+    {
+    	gPrtition.Printf("error: NULL == data or data_len == %d, m_fha_asa_block.asa_head==%d\r\n", data_len, m_fha_asa_block.asa_head);
+        return -1;
+    }
+
+    pBuf = gPrtition.RamAlloc(ASA_BUFFER_SIZE);
+    if( NULL == pBuf)
+    {
+    	gPrtition.Printf("error: pBuf RamAlloc fail\r\n");
+        return -1;
+    }
+
+    //ȫļʼʱֻд飬Ҳֻȥ
+    //read page0 to get file info
+    if(asa_read_page(0, pBuf, 2) == -1)
+    {
+    	gPrtition.Printf("error: asa_read_page fail\r\n");
+        goto EXIT;
+    }
+
+    //head info
+    pHead = (T_ASA_HEAD *)pBuf;
+
+    //asa file info
+    pFileInfo = (T_ASA_FILE_INFO *)(pBuf + sizeof(T_ASA_HEAD) + 2 * sizeof(T_ASA_ITEM));
+
+    file_num = pHead->item_num - 2;
+
+    //search asa file name
+    for(i=0; i<file_num; i++)
+    {
+        bMatch = 1;
+        for(j=0; file_name[j] && (pFileInfo->file_name)[j]; j++)
+        {
+            if(file_name[j] != (pFileInfo->file_name)[j])
+            {
+                bMatch = 0;
+                break;
+            }    
+        }
+
+        if(file_name[j] != (pFileInfo->file_name)[j])
+        {
+            bMatch = 0;
+        }
+
+        //exist
+        if(bMatch == 1)
+        {        
+            break;
+        }    
+        else
+        {
+            //continue to search
+            pFileInfo++;
+        }
+    }
+
+    if(bMatch == 0)
+    {
+    	gPrtition.Printf("error: no have the data\r\n");
+        goto EXIT;
+    }
+    else
+    {
+        start_page = pFileInfo->start_page;
+        end_page = pFileInfo->end_page;
+		//gPrtition.Printf("start_page:%d, end_page:%d\r\n", start_page, end_page);
+        if(page_cnt > (end_page - start_page))
+        {
+        	gPrtition.Printf("error: read data page_cnt too long, %d, %d, %d \r\n", page_cnt, end_page, start_page);
+            goto EXIT;
+        }
+        
+        
+        for(i=0; i < (data_len/g_nand_phy_info.page_size); i++)
+        {
+            //ȫļʼʱֻд飬Ҳֻȥ
+            if(asa_read_page(start_page+i, data+i*g_nand_phy_info.page_size, 2) == -1)
+            {
+            	gPrtition.Printf("error: asa_read_page fail\r\n");
+                goto EXIT;
+            }    
+        }
+
+        if(0 != data_len%g_nand_phy_info.page_size)
+        {
+        	//gPrtition.Printf("start_page:%d, i:%d\r\n", start_page, i);
+            if(asa_read_page(start_page+i, pBuf, 2) == -1)
+            {
+            	gPrtition.Printf("error: asa_read_page2 fail\r\n");
+                goto EXIT;
+            }
+            else
+            {
+                gPrtition.MemCpy(data+i*g_nand_phy_info.page_size, pBuf, data_len%g_nand_phy_info.page_size);
+            }
+        }    
+    }
+
+   gPrtition.RamFree(pBuf);
+   return 0;
+            
+EXIT:
+    gPrtition.RamFree(pBuf);
+    return -1;
+}
+
+
+
+#endif
+
+
diff --git a/drivers/mtd/partition/spinand_badblock.h b/drivers/mtd/partition/spinand_badblock.h
new file mode 100755
index 0000000..a396e7a
--- /dev/null
+++ b/drivers/mtd/partition/spinand_badblock.h
@@ -0,0 +1,163 @@
+#ifndef _SPINAND_BADBLOCK_H_
+#define _SPINAND_BADBLOCK_H_
+
+
+
+#include "partition_lib.h"
+
+
+#define HEAD_SIZE 8               //asa head info size
+
+
+#define ASA_MAX_BLOCK_TRY 50    //define asa block max try use
+#define ASA_BLOCK_COUNT 10       //define asa block max count
+
+#define ASA_FORMAT_NORMAL   0
+#define ASA_FORMAT_EWR      1
+#define ASA_FORMAT_RESTORE  2
+
+typedef enum
+{
+//nand flash
+    NAND_TYPE_UNKNOWN,
+    NAND_TYPE_SAMSUNG,
+    NAND_TYPE_HYNIX,
+    NAND_TYPE_TOSHIBA,
+    NAND_TYPE_TOSHIBA_EXT,
+    NAND_TYPE_MICRON,
+    NAND_TYPE_ST,
+    NAND_TYPE_MICRON_4K,
+    NAND_TYPE_MIRA,
+
+//  spi nand flash
+    SPINAND_TYPE_MIRA=128,
+    SPINAND_TYPE_GD,
+}E_NAND_TYPE;
+
+
+
+
+typedef struct {
+ unsigned char head_str[8];
+ unsigned long verify[2];
+ unsigned long item_num;
+ unsigned long info_end;
+}
+T_ASA_HEAD;
+
+typedef struct
+{
+    unsigned short page_start;
+    unsigned short page_count;
+    unsigned short info_start;
+    unsigned short info_len;
+ }T_ASA_ITEM;
+
+
+ typedef struct
+{
+    unsigned char file_name[8];
+    unsigned long file_length;
+    unsigned long start_page;
+    unsigned long end_page;
+}T_ASA_FILE_INFO;
+
+
+typedef struct tag_ASA_Param
+{
+    unsigned short   PagePerBlock;       
+    unsigned short   BytesPerPage;
+    unsigned short   BlockNum;           //blocks of one chip 
+}T_ASA_PARAM;
+
+typedef struct tag_ASA_Block
+{
+    unsigned char  asa_blocks[ASA_BLOCK_COUNT];   //氲ȫ
+    unsigned char  asa_count;                     //ʼԺڰȫblockָȫÿ
+    unsigned char  asa_head;                      //ȫµĿ 
+    unsigned char  asa_block_cnt;                 //ȫп
+    unsigned long write_time;                    //鱻д
+}T_ASA_BLOCK;
+
+
+
+/************************************************************************
+ * NAME:     spinand_babblock_tbl_init
+ * FUNCTION  bad block table init
+ * PARAM:    [in] unsigned char burn_flag   
+                   [in] unsigned long asa_start_block
+ * RETURN:    success return 0, fail retuen -1
+**************************************************************************/
+int  spinand_babblock_tbl_init(unsigned char new_burn_mode, unsigned char burn_flag, unsigned long asa_start_block);
+
+
+/************************************************************************
+ * NAME:     spinand_babblock_tbl_creat
+ * FUNCTION  bad block table creat
+ * PARAM:    [in] unsigned long type
+                   [in] unsigned long asa_start_block
+ * RETURN:    success return 0, fail retuen -1
+**************************************************************************/
+int spinand_babblock_tbl_creat(unsigned long type, unsigned long asa_start_block);
+
+/************************************************************************
+ * NAME:     spinand_set_badblock
+ * FUNCTION  set bad block table
+ * PARAM:    [in] unsigned long block
+ * RETURN:    success return 0, fail retuen -1
+**************************************************************************/
+int  spinand_set_badblock(unsigned long block);
+
+/************************************************************************
+ * NAME:     spinand_get_badblock
+ * FUNCTION  get bad block table data
+ * PARAM:    [in] unsigned long start_block
+                   [out] unsigned char pData[]  -------- buffer used to store bad blocks information data
+                   [in] unsigned long blk_cnt
+ * RETURN:    success return 0, fail retuen -1
+**************************************************************************/
+int  spinand_get_badblock(unsigned long start_block, unsigned char pData[], unsigned long blk_cnt);
+
+/************************************************************************
+ * NAME:     spinand_is_badblock
+ * FUNCTION  check is or not bad block 
+ * PARAM:    [in] unsigned long block
+ * RETURN:    is return 0, fail retuen -1
+**************************************************************************/
+int  spinand_is_badblock(unsigned long block);
+
+
+/************************************************************************
+ * NAME:     spinand_check_babblock
+ * FUNCTION  check is or not bad block 
+ * PARAM:    [in] unsigned long block
+ * RETURN:    is return 0, fail retuen -1
+**************************************************************************/
+//ûл½жϴ˿Ƿ񻵿
+//ɴ˴˽ӿڻждĲ
+//Դ˿ֻΪȫ¼ʱʹã
+int spinand_check_babblock(unsigned long block);
+int spinand_check_Initial_babblock(unsigned long block);
+
+/************************************************************************
+ * NAME:     spinand_read_asa_data
+ * FUNCTION  read asa data
+ * PARAM:    [in]unsigned char *data, unsigned long data_len
+ * RETURN:    is return 0, fail retuen -1
+**************************************************************************/
+int spinand_read_asa_data(unsigned char *data, unsigned long data_len);
+
+
+/************************************************************************
+ * NAME:     spinand_write_asa_data
+ * FUNCTION  write asa data
+ * PARAM:    unsigned char *data, unsigned long data_len
+ * RETURN:    is return 0, fail retuen -1
+**************************************************************************/
+int spinand_write_asa_data(unsigned char *data, unsigned long data_len);
+
+
+
+
+#endif
+
diff --git a/drivers/mtd/partition/spinand_burn.c b/drivers/mtd/partition/spinand_burn.c
new file mode 100755
index 0000000..775b5b1
--- /dev/null
+++ b/drivers/mtd/partition/spinand_burn.c
@@ -0,0 +1,3241 @@
+/**
+ * @FILENAME: spiburn.c
+ * @BRIEF xx
+ * Copyright (C) 2011 Anyka (GuangZhou) Software Technology Co., Ltd.
+ * @AUTHOR luqiliu
+ * @DATE 2009-11-19
+ * @VERSION 1.0
+ * @modified lu 2011-11-03
+ * Ҫ֧޸SPIĴ洢ṹblockΪλ洢ļ
+ * @REF
+ */
+
+#include "spinand_burn.h"
+#include "public_info.h"
+#include "spinand_driver.h"
+#include "spinand_badblock.h"
+
+
+
+#ifdef SUPPORT_SPINAND
+
+
+///////////////////////////////////////////////////////////////////////////////////////////////
+//ʾ
+//1.spinand_init()
+//2.spinand_babblock_tbl_init()
+//3.spinand_creat()/spinand_open()/spinand_write()/spinand_read()/spinand_close()
+
+extern T_FHA_LIB_CALLBACK  gPrtition;
+
+T_PARTITION  g_partition = {0};
+T_SPINAND_INIT_INFO m_spinand_burn = {0};
+T_BIN_NAND_INFO  m_bin_nand_info  = {0};
+T_NAND_PHY_INFO    g_nand_phy_info = {0};
+unsigned long   g_partition_file_max_num = 0;
+
+
+extern unsigned long sflash_str_len(const unsigned char *string);
+
+
+
+int spinand_check_name_is_exist(unsigned char *dst_name, unsigned char *buf, unsigned long file_num, unsigned long *name_idex)
+{
+    unsigned long i = 0, j = 0;
+    unsigned long src_name_len = 0, dst_name_len = 0;
+    unsigned char *name = NULL;
+    unsigned char name_dst[PARTITION_NAME_LEN + 1];
+    unsigned char name_src[PARTITION_NAME_LEN + 1];
+
+    for(i = 0; i < file_num; i++)
+    {
+        unsigned long offset = 4 + i*sizeof(T_PARTITION_TABLE_INFO) + 2;//T_PARTITION_CONFIGǰֽ
+        //gPrtition.Printf("partition name:%d, %d, %d\r\n", offset, sizeof(T_PARTITION_TABLE_INFO));
+        name = &buf[offset];
+
+        gPrtition.MemSet(name_dst, 0, PARTITION_NAME_LEN + 1);
+        gPrtition.MemSet(name_src, 0, PARTITION_NAME_LEN + 1);
+        gPrtition.MemCpy(name_dst, dst_name, PARTITION_NAME_LEN );
+        gPrtition.MemCpy(name_src, name, PARTITION_NAME_LEN );
+        src_name_len = sflash_str_len(name_src);
+        dst_name_len = sflash_str_len(name_dst);
+        //gPrtition.Printf("partition name:%s, %s\r\n", name, dst_name);
+        //gPrtition.Printf("name len:%d, %d\r\n", dst_name_len, src_name_len);
+        if(src_name_len == dst_name_len)
+        {
+            for(j=0; j < src_name_len; j++)
+            {
+                //gPrtition.Printf("partition name:%02x, %02x\r\n", name[j], dst_name[j]);
+                if(name_src[j] != name_dst[j])
+                {
+                    break;
+                }    
+            }
+
+            if(j == src_name_len)
+            {
+                //gPrtition.Printf("partition name is exist:%s, %s\r\n", name_src, name_dst);
+                break;
+            }
+        }
+    }
+
+    if(i == file_num)
+    {
+        //gPrtition.Printf("partition name is not exist:%s \r\n",  name_dst);
+        return -1;
+    }
+
+    *name_idex = i;
+
+    return 0;
+}
+
+int spinand_check_partition_startpage(unsigned long startpage_in, unsigned long *startpage_out, unsigned long *startpage_backup)
+{
+    unsigned long block = startpage_in/m_spinand_burn.pages_per_block;
+    unsigned long check_idex = 0, block_idex = 0;
+
+    //gPrtition.Printf("m_spinand_burn.pages_per_block:%d\r\n", m_spinand_burn.pages_per_block);
+    while(1)
+    {
+        gPrtition.Printf("block:%d, block_idex:%d\r\n", block, block_idex);
+        if(spinand_check_babblock(block) == 0)
+        {
+            block++;
+        }
+        else
+        {
+            if(0 == check_idex)
+            {
+                *startpage_out = block*m_spinand_burn.pages_per_block;
+                check_idex = 1;
+                block++;
+            }
+            else if(check_idex == 1)
+            {
+                *startpage_backup = block*m_spinand_burn.pages_per_block;
+                break;
+            }
+        }
+        block_idex++;
+
+        if(block_idex > 50)
+        {
+             return -1; 
+        }
+    }
+
+    gPrtition.Printf("*startpage_out:%d, *startpage_backup:%d\r\n", *startpage_out, *startpage_backup);
+
+    return 0;
+}
+
+
+int spinand_get_partition_startpage_from_boot(unsigned long *startpage, unsigned long *startpage_backup)
+{
+//    unsigned long boot_len = 0;//
+    unsigned char in_startpage = 0;//
+    unsigned char in_startpage_backup = 0;//
+    unsigned char *buf = NULL;
+    unsigned long offset = 0;
+//    unsigned long i=0;
+    unsigned char spare[4] = {0};
+
+    buf =  (unsigned char *)gPrtition.RamAlloc(sizeof(unsigned char)*m_bin_nand_info.bin_page_size);
+    if(NULL == buf)
+    {
+        gPrtition.Printf("update burn buf malloc fail\n");
+        return -1;
+    }
+
+    gPrtition.MemSet(buf, 0, sizeof(unsigned char)*m_bin_nand_info.bin_page_size);
+    
+    //ȡһҳĴС
+    if (Prod_NandReadPage(0, 0, buf, spare, 4) == -1)//
+	{
+        gPrtition.RamFree(buf);
+        gPrtition.Printf("update burn spi_flash_read fail\n");
+		return -1;
+	}
+
+    offset = SPINAND_PARAM_OFFSET;
+
+    // unsigned char   row_cycle;//¼Ŀʼλ
+    // unsigned char   delay_cnt;//¼ݵķĿʼλ
+    //SPINANDеĵ17͵18ֽڵĳԱֱ
+    //¼ĿʼλúͱĿʼλ
+    //gPrtition.Printf("boot block num offset:%d\n", offset + 17);
+    gPrtition.MemCpy(&in_startpage, buf + offset + 17, 1);//ȡֵǿ
+    gPrtition.MemCpy(&in_startpage_backup, buf + offset + 18, 1);//ȡֵǿ
+    gPrtition.RamFree(buf);
+
+	//gPrtition.Printf("in_startpage:%d, in_startpage_backup:%d\r\n", in_startpage, in_startpage_backup);
+    
+    *startpage = in_startpage*m_spinand_burn.pages_per_block;//ȡҳ
+    *startpage_backup = in_startpage_backup*m_spinand_burn.pages_per_block;//ȡҳ
+    //gPrtition.Printf("Sflash_Get_Partition_Startpage g_boot_len:%d, %d\n", *startpage, *startpage_backup);
+
+    return 0;
+}
+
+
+int write_partition_table(unsigned char *buf)
+{
+    unsigned char spare[4] = {0};
+    unsigned long block = 0;//, i = 0;
+    //unsigned char oobbuf[2048+64+1] = {0};
+ 
+    //Դݿ
+    block = m_spinand_burn.partition_table_start/m_spinand_burn.pages_per_block;
+    //gPrtition.Printf("block:%d, %d, %d\r\n", block, m_spinand_burn.partition_table_start,m_spinand_burn.pages_per_block);
+    if(spinand_is_badblock(block) == 0)//
+    {
+        //û
+       // spinand_set_badblock(block);
+        gPrtition.Printf("part: the src partition table block is bad block:%d\r\n", m_spinand_burn.partition_table_start);
+        //ݿ
+        block = m_spinand_burn.partition_table_start_backup/m_spinand_burn.pages_per_block;
+        if(spinand_is_badblock(block) == 0)
+        {
+            //û
+            //spinand_set_badblock(block);
+            //鶼ǻ飬ʧ
+            gPrtition.Printf("part: the partition table block is bad block:%d\r\n", block);
+            return -1;
+        }
+
+        if(Prod_NandEraseBlock(block) == -1)
+        {
+            //û
+            spinand_set_badblock(block);
+            //鶼ǻ飬ʧ
+            gPrtition.Printf("part: the partition table block erase fail:%d\r\n", block);
+            return -1;
+        }
+
+        if(Prod_NandWritePage(block, 0, buf, spare, 4) == -1)
+        {
+            gPrtition.Printf("part: write backup partition table fail:%d\r\n", block);
+            return -1;
+        }
+    }
+    else
+    {
+        if(Prod_NandEraseBlock(block) == -1)
+        {
+            //ݿ
+            block = m_spinand_burn.partition_table_start_backup/m_spinand_burn.pages_per_block;
+            if(spinand_is_badblock(block) == 0)
+            {
+                //û
+                //spinand_set_badblock(block);
+                gPrtition.Printf("part: the partition table block is bad block:%d\r\n", block);
+                return -1;
+            }
+
+            if(Prod_NandEraseBlock(block) == -1)
+            {
+                //û
+                spinand_set_badblock(block);
+                //鶼ǻ飬ʧ
+                gPrtition.Printf("part: the partition table block erase fail:%d\r\n", block);
+                return -1;
+            }
+            
+            if(Prod_NandWritePage(block, 0, buf, spare, 4) == -1)
+            {
+                gPrtition.Printf("part: write backup partition table fail:%d\r\n", block);
+                return -1;
+            }
+        }   
+        #if 0
+        gPrtition.Printf("write read partition oob data:%d\r\n", block);
+        memset(oobbuf , 0 , 2048+64+1);
+        gPrtition.ReadNandBytes(0, block*64, 0,  oobbuf, 2048+64);
+        for(i = 0; i < 2048+64; i++)
+        {
+            if(i %16 == 0)
+            {
+                gPrtition.Printf("\r\n");
+            }
+
+            gPrtition.Printf("%02x ", oobbuf[i]);
+        }
+        #endif
+        
+        //дԴݿ
+        if(Prod_NandWritePage(block, 0, buf, spare, 4) == -1)
+        {
+            gPrtition.Printf("part: write partition table fail:%d\r\n", block);
+            //return -1;//ԴдɹʧܣҪԱݻд
+        }
+
+        //ݿ
+        block = m_spinand_burn.partition_table_start_backup/m_spinand_burn.pages_per_block;
+        //gPrtition.Printf("block:%d, %d, %d\r\n", block, m_spinand_burn.partition_table_start_backup,m_spinand_burn.pages_per_block);
+        if(spinand_is_badblock(block) == 0)
+        {
+            //û
+            //spinand_set_badblock(block);
+            gPrtition.Printf("part: the partition table backup block is bad block:%d\r\n", block);
+            return -1;
+        }
+
+        if(Prod_NandEraseBlock(block) == -1)
+        {
+            //û
+            spinand_set_badblock(block);
+            //鶼ǻ飬ʧ
+            gPrtition.Printf("part: the partition table backup block erase fail:%d\r\n", block);
+            return -1;
+        }
+        
+        if(Prod_NandWritePage(block, 0, buf, spare, 4) == -1)
+        {
+            gPrtition.Printf("part: write backup partition table fail:%d\r\n", block);
+            return -1;
+        }
+    }
+
+    
+    return 0;
+}
+
+
+int read_partition_table(unsigned char *buf)
+{
+    unsigned char spare[4] = {0};
+    unsigned long block = 0;//, i = 0;
+    unsigned char *buf_temp = NULL;
+   
+    buf_temp =  (unsigned char *)gPrtition.RamAlloc(sizeof(unsigned char)*m_bin_nand_info.bin_page_size);
+    if(NULL == buf_temp)
+    {
+        gPrtition.Printf("read_partition_table buf_temp malloc fail\n");
+        return -1;
+    }
+
+    gPrtition.MemSet(buf_temp, 0, sizeof(unsigned char)*m_bin_nand_info.bin_page_size);
+
+    //Դ
+    //жԴݿǷ񻵿
+    block = m_spinand_burn.partition_table_start/m_spinand_burn.pages_per_block;
+    if(spinand_is_badblock(block) == 0)//
+    {
+        gPrtition.Printf("part: the src partition table block is bad block:%d\r\n", m_spinand_burn.partition_table_start);
+        block = m_spinand_burn.partition_table_start_backup/m_spinand_burn.pages_per_block;
+        if(spinand_is_badblock(block) == 0)//
+        {
+            gPrtition.RamFree(buf_temp);
+            gPrtition.Printf("part: the partition table backup block is bad block:%d\r\n", m_spinand_burn.partition_table_start_backup);
+            return -1;
+        }
+        if(Prod_NandReadPage(block, 0, buf_temp, spare, 4) == -1)
+        {
+            gPrtition.RamFree(buf_temp);
+            gPrtition.Printf("part: read partition table fail:%d\r\n", block);
+            return -1;
+        }
+
+        gPrtition.MemCpy(buf, buf_temp, 512);
+       
+    }
+    else
+    {
+        gPrtition.Printf("read partition table block:%d, %d\r\n", block, m_spinand_burn.partition_table_start);
+        if(Prod_NandReadPage(block, 0, buf_temp, spare, 4) == -1)
+        {
+            block = m_spinand_burn.partition_table_start_backup/m_spinand_burn.pages_per_block;
+            gPrtition.Printf("part: read src partition table fail and start read backup table:%d\r\n", block);
+            if(spinand_is_badblock(block) == 0)//
+            {
+                gPrtition.RamFree(buf_temp);
+                gPrtition.Printf("part: read partition table backup block is bad blcok:%d\r\n", block);
+                return -1;
+            }
+            if(Prod_NandReadPage(block, 0, buf_temp, spare, 4) == -1)
+            {
+                gPrtition.RamFree(buf_temp);
+                gPrtition.Printf("part: read partition table fail:%d\r\n", block);
+                return -1;
+            }
+        }
+        gPrtition.MemCpy(buf, buf_temp, 512);
+        
+    }
+
+    gPrtition.RamFree(buf_temp);
+    
+    return 0;
+}
+
+
+int spinand_init(void *PhyInfo, unsigned long partition_tbl_start)
+{
+    T_NAND_PHY_INFO *pNandPhyInfo = (T_NAND_PHY_INFO *)PhyInfo;
+//    unsigned long   nFlag;
+    unsigned long partition_startpage = 0;
+    unsigned long partition_startpage_backup = 0;
+//    unsigned long badblocb_startpage = 0;
+    
+    if (NULL == pNandPhyInfo)
+    {
+        return -1;
+    }
+
+    gPrtition.MemCpy(&g_nand_phy_info, pNandPhyInfo, sizeof(T_NAND_PHY_INFO));
+
+    m_bin_nand_info.bin_page_size   = pNandPhyInfo->page_size;
+    //m_bin_nand_info.boot_page_size  = (pNandPhyInfo->page_size > 4096) ?  4096 : pNandPhyInfo->page_size;
+    m_bin_nand_info.page_per_block  = pNandPhyInfo->page_per_blk;
+    m_bin_nand_info.block_per_plane = pNandPhyInfo->plane_blk_num; 
+    m_bin_nand_info.total_block_num = pNandPhyInfo->blk_num;
+    m_spinand_burn.pages_per_block = pNandPhyInfo->page_per_blk;
+    m_spinand_burn.page_size = pNandPhyInfo->page_size;
+    m_spinand_burn.total_size = pNandPhyInfo->blk_num*pNandPhyInfo->page_per_blk*pNandPhyInfo->page_size;
+	
+	m_spinand_burn.oob_size = pNandPhyInfo->spare_size;
+	m_spinand_burn.initbad_offset = pNandPhyInfo->flag & 0xFF;
+
+    gPrtition.Printf("total_size:%d, page_size:%d, pages_per_block:%d, oob_size:%d, initbad_offset:%d\r\n", m_spinand_burn.total_size, m_spinand_burn.page_size, m_spinand_burn.pages_per_block, m_spinand_burn.oob_size, m_spinand_burn.initbad_offset);
+    g_partition_file_max_num = m_bin_nand_info.bin_page_size / sizeof(T_PARTITION_TABLE_INFO);
+    if (0 == g_partition_file_max_num)
+    {
+        gPrtition.Printf("spinand_init fail max file: %d\r\n", g_partition_file_max_num);
+        return -1;
+    }
+    
+    gPrtition.Printf("m_bin_nand_info.bin_page_size:  %d\r\n", m_bin_nand_info.bin_page_size);
+    //gPrtition.Printf("m_bin_nand_info.boot_page_size: %d\r\n", m_bin_nand_info.boot_page_size);
+    gPrtition.Printf("m_bin_nand_info.page_per_block: %d\r\n", m_bin_nand_info.page_per_block);
+    gPrtition.Printf("m_bin_nand_info.page_per_block: %d\r\n", m_bin_nand_info.page_per_block);
+    gPrtition.Printf("g_partition_file_max_num: %d\r\n", g_partition_file_max_num);
+
+    //spinandĲ϶ȡͱݷĿʼλ
+    if(partition_tbl_start == 0)
+    {
+        if(spinand_get_partition_startpage_from_boot(&partition_startpage, &partition_startpage_backup) == -1)
+        {
+            gPrtition.Printf("spinand_init spinand_get_partition_startpage fail\r\n");
+            return -1;
+        }
+    }
+    else
+    {
+        partition_startpage = partition_tbl_start;
+        partition_startpage_backup = partition_tbl_start + 1;
+        #if 0
+       gPrtition.Printf("partition_tbl_start:%d\r\n", partition_tbl_start);
+       if(spinand_check_partition_startpage(partition_tbl_start, &partition_startpage, &partition_startpage_backup) == -1)
+       {
+            gPrtition.Printf("spinand_init spinand_check_partition_startpage fail\r\n");
+            return -1;
+       }
+       #endif
+    }
+
+    //ʼ
+    m_spinand_burn.partition_table_start  = partition_startpage;
+
+    //жϱݷλ
+    m_spinand_burn.partition_table_start_backup  = partition_startpage_backup;
+
+    //ʼֵ,滹Ҫӻķ
+    m_spinand_burn.partition_start  = partition_startpage_backup + pNandPhyInfo->page_per_blk;//
+    
+    //ʼҪӦʹùУֵ仯
+    //ֵҪӺ滵Ŀ
+    g_partition.partition_start_page = m_spinand_burn.partition_start;//ֵ,
+
+    g_partition.write_table_flag = 0; 
+    g_partition.init_success_flag = 1;
+
+    g_partition.current_erase_block = 0xFFFFFFFF;
+    g_partition.open_time = 0; //򿪵Ĵ
+    g_partition.write_flag = 0;//д־,дĹ,ܶ
+    g_partition.read_flag = 0; //־ĹУд
+    
+    return 0;
+}
+
+
+T_PARTITION_TABLE_INFO *spinand_creat(T_CREAT_PARTITION_INFO *partition)
+{
+    T_PARTITION_TABLE_INFO *pFile = NULL;
+    unsigned long block_index = 0;
+//    unsigned long page = 0;
+    unsigned long page_size = m_bin_nand_info.bin_page_size;
+    unsigned long PagesPerBlock = m_bin_nand_info.page_per_block;
+    unsigned char *buf = NULL;
+//    unsigned char spare[4] = {0};
+    unsigned long file_num = 0;
+    T_BIN_CONFIG bin_config;
+    T_FS_CONFIG fs_config;
+    unsigned long page_cnt = 0;
+    unsigned long block_cnt = 0, block_num = 0;
+    unsigned long name_idex = 0;
+
+    if(1 != g_partition.init_success_flag)
+    {
+        if(gPrtition.Printf != NULL)
+        {
+            gPrtition.Printf("part: Sflash_Creat not Sflash_Init\r\n");
+        }
+        return NULL;
+    }
+        
+    if(g_partition.open_time == 1)
+    {
+        gPrtition.Printf("part: spinand_creat the other partition name is openning\r\n");
+        return NULL;
+    }
+
+    if(sflash_str_len(partition->name) > PARTITION_NAME_LEN)
+    {
+        gPrtition.Printf("part: spinand_creat the partition name len more than %d\r\n", PARTITION_NAME_LEN);
+        return NULL;
+    }
+    
+    //read the partition table to get the filecnt
+    buf = gPrtition.RamAlloc(page_size*sizeof(unsigned char));
+    if(NULL == buf)
+    {
+        gPrtition.Printf("part: spinand_creat buf malloc fail\r\n");
+        return NULL;
+    }
+
+    gPrtition.MemSet(buf, 0x0, page_size*sizeof(unsigned char));
+    gPrtition.Printf("read partition_table_start:%d\r\n", m_spinand_burn.partition_table_start);
+
+    //ȡһҳĴС
+    block_index = m_spinand_burn.partition_table_start/m_bin_nand_info.page_per_block;
+    if(read_partition_table(buf) == -1)
+    {
+        gPrtition.Printf("part: spinand_creat Prod_NandReadASAPage fail\r\n");
+        return NULL;
+    }
+
+    gPrtition.MemCpy(&file_num, buf, 4);
+    gPrtition.Printf("part: spinand_creat file_num:%d\r\n", file_num);
+   
+    if(file_num == 0 || file_num == 0xFFFFFFFF)
+    {
+        file_num = 0;
+    }
+
+    if(file_num >= g_partition_file_max_num)
+    {
+        gPrtition.RamFree(buf);
+        gPrtition.Printf("part: spinand_creat ile_num is more than the max:%d\r\n", g_partition_file_max_num);
+        return NULL;
+    }
+
+    //жϷǷ
+    if(spinand_check_name_is_exist(partition->name, buf, file_num, &name_idex) == 0)
+    {
+        gPrtition.RamFree(buf);
+        gPrtition.Printf("part: spinand_creat fail\r\n");
+        return NULL;
+    }
+
+    if(buf != NULL)
+    {
+        gPrtition.RamFree(buf);
+        buf = NULL;
+    }
+
+
+    pFile = (T_PARTITION_TABLE_INFO *)gPrtition.RamAlloc(sizeof(T_PARTITION_TABLE_INFO));
+    if(NULL == pFile)
+    {
+        gPrtition.Printf("part: spinand_creat buf malloc fail\r\n");
+        return NULL;
+    }
+    gPrtition.MemSet(pFile, 0, sizeof(T_PARTITION_TABLE_INFO));
+    gPrtition.MemCpy(pFile->partition_info.name, partition->name, PARTITION_NAME_LEN);
+    pFile->partition_info.type = partition->type;
+    pFile->partition_info.r_w_flag = partition->r_w_flag;
+    pFile->partition_info.hidden_flag = partition->hidden_flag;
+    if(partition->type == PART_BIN_TYPE || partition->type == PART_DATA_TYPE)
+    {
+        bin_config.check= partition->check;
+        bin_config.ld_addr= partition->ld_addr;
+        bin_config.mtd_idex = partition->mtd_idex;
+        bin_config.file_length = 0;//ʼ
+        bin_config.medium_flag = partition->medium_flag;
+		bin_config.medium_type = partition->medium_type;
+    }
+    else if(partition->type == PART_FS_TYPE)
+    {
+        fs_config.check = partition->check;
+        fs_config.fs_type = partition->fs_type;
+        fs_config.mtd_idex = partition->mtd_idex;
+        fs_config.file_length = 0;//ʼ
+        fs_config.medium_flag = partition->medium_flag;
+		fs_config.medium_type = partition->medium_type;
+    }
+    else
+    {
+        gPrtition.RamFree(pFile);
+        pFile = NULL;
+        gPrtition.Printf("part: spinand_creat type is error\r\n");
+        return NULL;
+    }
+    
+    page_cnt = (partition->Size*K_SIZE + page_size - 1)/page_size;
+    //Կ
+    block_cnt = (page_cnt + PagesPerBlock - 1)/PagesPerBlock;
+    //ҳ
+    page_cnt = block_cnt * PagesPerBlock;
+
+    if(partition->backup && partition->type != PART_FS_TYPE)
+    {
+        //бݣԷԿ󣬿Ƿƽ֣1
+        if(block_cnt%2 != 0)
+        {
+            block_cnt += 1;
+        }
+    }
+
+
+    block_index = g_partition.partition_start_page/m_bin_nand_info.page_per_block;
+    //ͳƷС,ṩһĿʼλ
+    while(1)
+    {
+        //Ŀѹ
+        if(block_num == block_cnt)
+        {
+            break;
+        }
+            
+        //жϷǷ񻵿
+        if(spinand_is_badblock(block_index) == 0)//
+        {
+            if(block_num == 0)
+            {
+                //ǻ飬ͳƷĿʼλ
+                g_partition.partition_start_page = g_partition.partition_start_page + m_bin_nand_info.page_per_block;
+                block_index = g_partition.partition_start_page/m_bin_nand_info.page_per_block;
+            }
+        }
+        else
+        {
+            block_num++;            
+        }
+        
+        block_index++;
+        //ܿ
+        if(block_index > m_bin_nand_info.total_block_num)
+        {
+           gPrtition.RamFree(pFile);
+            pFile = NULL;
+            gPrtition.Printf("part: spinand_creat the partition block num more max block num\r\n");
+            return NULL; 
+        }
+        
+    }
+    
+    pFile->partition_info.start_pos = g_partition.partition_start_page*page_size;
+    //gPrtition.Printf("part:partition start_pos:%d\r\n", pFile->partition_info.start_pos);
+
+    //
+    if(partition->backup && partition->type != PART_FS_TYPE)
+    {
+        bin_config.backup_pos = pFile->partition_info.start_pos + (block_num/2)*m_bin_nand_info.page_per_block*m_bin_nand_info.bin_page_size;
+    }
+    else
+    {
+        if(partition->type != PART_FS_TYPE)
+        {
+            bin_config.backup_pos = 0xFFFFFFFF;
+        }
+    }
+
+    //ĴС
+    pFile->partition_info.ksize = (block_num*m_bin_nand_info.page_per_block*m_bin_nand_info.bin_page_size/K_SIZE);
+
+    //һĿʼ
+    g_partition.partition_start_page = block_index*m_bin_nand_info.page_per_block;
+    //gPrtition.Printf("part: next partition_start_page:%d\r\n", g_partition.partition_start_page);
+
+    //¼binļչϢ
+    if(partition->type == PART_BIN_TYPE || partition->type == PART_DATA_TYPE)
+    {
+        //ṹԱȲһ򲻵16ֽڳ
+        if(sizeof(T_EX_PARTITION_CONFIG) != sizeof(T_BIN_CONFIG)  && sizeof(T_BIN_CONFIG) != 16)
+        {
+            gPrtition.RamFree(pFile);
+            pFile = NULL;
+            gPrtition.Printf("part: Sflash_Creat bin and ex parameter len is error\r\n");
+            return NULL;
+        }
+        gPrtition.MemSet(&pFile->ex_partition_info, 0, sizeof(T_EX_PARTITION_CONFIG));
+        gPrtition.MemCpy(&pFile->ex_partition_info, &bin_config, sizeof(T_EX_PARTITION_CONFIG));
+    }
+    else if(partition->type == PART_FS_TYPE)//¼ļϵͳ չϢ
+    {
+        if(sizeof(T_EX_PARTITION_CONFIG) != sizeof(T_FS_CONFIG) && sizeof(T_FS_CONFIG) != 16)
+        {
+            gPrtition.RamFree(pFile);
+            pFile = NULL;
+            gPrtition.Printf("part: Sflash_Creat fs and ex parameter len is error\r\n");
+            return NULL;
+        }
+        gPrtition.MemSet(&pFile->ex_partition_info, 0, sizeof(T_EX_PARTITION_CONFIG));
+        gPrtition.MemCpy(&pFile->ex_partition_info, &fs_config, sizeof(T_EX_PARTITION_CONFIG));
+    }
+    else
+    {
+        gPrtition.RamFree(pFile);
+        pFile = NULL;
+        gPrtition.Printf("part: Sflash_Creat type is error\r\n");
+        return NULL;
+    }
+
+    //ӡ
+    gPrtition.Printf("creat T:%d, R:%d, H:%d, K:%d, S:%d, N:%s \n"
+        , pFile->partition_info.type, pFile->partition_info.r_w_flag
+        , pFile->partition_info.hidden_flag, pFile->partition_info.ksize
+        , pFile->partition_info.start_pos, pFile->partition_info.name);
+    if(partition->type != PART_FS_TYPE)
+    {
+        gPrtition.Printf("creat ex_bin F:%d, L:%d, B:%d, C:%d, M:%d,fl:%d,ty:%d\r\n"
+            , bin_config.file_length, bin_config.ld_addr
+            , bin_config.backup_pos, bin_config.check
+            , bin_config.mtd_idex, bin_config.medium_flag,bin_config.medium_type);
+    }
+    else
+    {
+        gPrtition.Printf("creat ex_fs F:%d, C:%d, F:%d, M:%d,fl:%d,ty:%d\r\n"
+            , fs_config.file_length, fs_config.check
+            , fs_config.fs_type, fs_config.mtd_idex, fs_config.medium_flag,fs_config.medium_type);
+    }
+    
+    g_partition.write_table_flag = 1;
+    
+    g_partition.open_time = 1; //򿪵Ĵ
+    g_partition.write_flag = 0;//д־,дĹ,ܶ
+    g_partition.read_flag = 0; //־ĹУд
+    g_partition.r_w_data_size = 0;
+    g_partition.block_origin = (pFile->partition_info.start_pos/page_size)/m_spinand_burn.pages_per_block;
+    if(pFile->partition_info.type != PART_FS_TYPE && bin_config.backup_pos != 0xFFFFFFFF)
+    {
+       g_partition.block_backup = (bin_config.backup_pos/page_size)/m_spinand_burn.pages_per_block;;
+    }
+    else
+    {
+        g_partition.block_backup = 0xFFFFFFFF;
+    }
+    g_partition.read_block_num = 0;
+    g_partition.block_id = 0;
+	g_partition.set_attr_flag = 0;
+
+    return pFile;
+}
+
+int spinand_close(T_PARTITION_TABLE_INFO *pFile)
+{
+    unsigned char *buf = NULL;
+    //unsigned long page_cnt = 1, i = 0, block_index = 0, page = 0;
+	unsigned long file_num = 0, name_idex = 0;
+    unsigned long page_size = m_spinand_burn.page_size;
+    T_BIN_CONFIG *bin_config;
+    T_FS_CONFIG *fs_config;
+//    unsigned char spare[4]= {0};
+    
+    if(NULL == pFile)
+    {
+        gPrtition.Printf("part: spinand_close pFile == AK_NULL\r\n");
+        return -1;
+    }
+
+    if(1 != g_partition.init_success_flag)
+    {
+        gPrtition.RamFree(pFile);
+        pFile = NULL;
+        g_partition.open_time = 0; 
+        g_partition.write_flag = 0;
+        g_partition.read_flag = 0; 
+        
+        if(gPrtition.Printf != NULL)
+        {
+            gPrtition.Printf("part: spinand_close not Sflash_Init\r\n");
+        }
+        return -1;
+    }
+
+    if(g_partition.write_table_flag)
+    {
+        g_partition.write_table_flag = 0;
+
+        buf = gPrtition.RamAlloc(page_size*sizeof(unsigned char));
+        if(NULL == buf)
+        {
+            gPrtition.RamFree(pFile);
+            pFile = NULL;
+            g_partition.open_time = 0; 
+            g_partition.write_flag = 0;
+            g_partition.read_flag = 0; 
+            gPrtition.Printf("part: spinand_close buf malloc fail\r\n");
+            return -1;
+        }
+
+        gPrtition.MemSet(buf, 0xFF, page_size*sizeof(unsigned char));
+
+        //ȡһҳĴС
+        if(read_partition_table(buf) == -1)
+        {
+            gPrtition.RamFree(pFile);
+             pFile = NULL;
+            g_partition.open_time = 0; 
+            g_partition.write_flag = 0;
+            g_partition.read_flag = 0; 
+            gPrtition.Printf("part: spinand_close Prod_NandReadASAPage fail\r\n");
+            return -1;
+        }
+
+        //
+        gPrtition.MemCpy(&file_num, buf, 4);
+        gPrtition.Printf("part: Sflash_Close file_num:%d\r\n", file_num);
+       
+        if(file_num == 0 || file_num == 0xFFFFFFFF)
+        {
+            file_num = 0;
+        }
+
+        //жļĸǷ񳬹һҳļ
+        if(file_num >= g_partition_file_max_num)
+        {
+            gPrtition.RamFree(buf);
+            gPrtition.RamFree(pFile);
+             pFile = NULL;
+            g_partition.open_time = 0; 
+            g_partition.write_flag = 0;
+            g_partition.read_flag = 0; 
+            gPrtition.Printf("part: Sflash_Close file_num is more than the max(15)\r\n");
+            return -1;
+        }
+
+        if(pFile->partition_info.type == PART_BIN_TYPE || pFile->partition_info.type == PART_DATA_TYPE)
+        {
+            bin_config = (T_BIN_CONFIG *)(&pFile->ex_partition_info);
+        }
+        else if(pFile->partition_info.type == PART_FS_TYPE)
+        {
+            fs_config = (T_FS_CONFIG *)(&pFile->ex_partition_info);
+        }
+
+        gPrtition.Printf("close T:%d, R:%d, H:%d, K:%d, S:%d, N:%s\n"
+            , pFile->partition_info.type, pFile->partition_info.r_w_flag
+            , pFile->partition_info.hidden_flag, pFile->partition_info.ksize
+            , pFile->partition_info.start_pos, pFile->partition_info.name);
+        if(pFile->partition_info.type != PART_FS_TYPE)
+        {
+            gPrtition.Printf("close ex_bin F:%d, L:%d, B:%d, C:%d, M:%d\r\n"
+                , bin_config->mtd_idex, bin_config->ld_addr
+                , bin_config->backup_pos, bin_config->check, bin_config->mtd_idex);
+            
+        }
+        else
+        {
+            gPrtition.Printf("close ex_fs F:%d, C:%d, M:%d, F:%d\r\n"
+                , fs_config->fs_type, fs_config->check
+                , fs_config->mtd_idex, fs_config->fs_type);
+        }
+
+
+        if(spinand_check_name_is_exist(pFile->partition_info.name, buf, file_num, &name_idex) != 0)
+        {
+            name_idex = file_num;
+            file_num = file_num + 1;
+        }
+        //gPrtition.Printf("file_num:%d\r\n", file_num);
+        gPrtition.MemCpy(&buf[0], &file_num, 4);
+        gPrtition.MemCpy(&buf[name_idex*sizeof(T_PARTITION_TABLE_INFO) + 4], pFile, sizeof(T_PARTITION_TABLE_INFO));
+
+
+        //gPrtition.Printf("%02x, %02x, %02x, %02x\r\n", buf[0], buf[1], buf[2], buf[3]);
+        //дݵflash
+        if(write_partition_table(buf) == -1)
+        {
+            gPrtition.RamFree(pFile);
+            pFile = NULL;
+            g_partition.open_time = 0; 
+            g_partition.write_flag = 0;
+            g_partition.read_flag = 0; 
+            gPrtition.Printf("part: spinand_close write_partition_table fail\r\n");
+            return -1;
+        }
+
+        if(buf != NULL)
+        {
+            gPrtition.RamFree(buf);
+            buf = NULL;
+        }
+
+    }
+
+    if(pFile != NULL)
+    {
+        gPrtition.RamFree(pFile);
+        pFile = NULL;
+    }
+    
+    g_partition.open_time = 0; 
+    g_partition.write_flag = 0;
+    g_partition.read_flag = 0; 
+    g_partition.r_w_data_size = 0;
+    g_partition.block_origin = 0;
+    g_partition.block_backup = 0xFFFFFFFF;
+    g_partition.read_block_num = 0;
+    g_partition.block_id = 0;
+    
+    return 0;
+}
+
+T_PARTITION_TABLE_INFO *spinand_open(unsigned char *partition_name)
+{
+    unsigned char *buf = NULL;
+    unsigned long file_num = 0;
+    unsigned long page_cnt = 1;
+    unsigned long page_size = m_spinand_burn.page_size;
+    T_PARTITION_TABLE_INFO *pFile;
+    T_PARTITION_TABLE_INFO *pFile_temp;
+    unsigned long i = 0, j = 0;
+    unsigned long src_name_len = 0, dst_name_len = 0;
+    T_BIN_CONFIG bin_config;
+    T_FS_CONFIG fs_config;
+    unsigned char name_dst[PARTITION_NAME_LEN + 1];
+    unsigned char name_src[PARTITION_NAME_LEN + 1];
+    
+
+    if(NULL == partition_name)
+    {
+        gPrtition.Printf("part: Sflash_Open partition_name == AK_NULL\r\n");
+        return NULL;
+    }
+
+    if(1 != g_partition.init_success_flag)
+    {
+        if (NULL == gPrtition.Printf)
+        {
+        }
+        else
+        {
+            gPrtition.Printf("part: Sflash_Open not Sflash_Init\r\n");
+        }
+        return NULL;
+    }
+
+    if(g_partition.open_time == 1)
+    {
+        gPrtition.Printf("part: Sflash_Open the other partition name is openning\r\n");
+        return NULL;
+    }
+
+    if(sflash_str_len(partition_name) > PARTITION_NAME_LEN)
+    {
+        gPrtition.Printf("part: Sflash_Open the partition name len more than %d\r\n", PARTITION_NAME_LEN);
+        return NULL;
+    }
+    
+    buf = gPrtition.RamAlloc(page_size*page_cnt*sizeof(unsigned char));
+    if(NULL == buf)
+    {
+        gPrtition.Printf("part: Sflash_Open buf malloc fail\r\n");
+        return NULL;
+    }
+
+    gPrtition.MemSet(buf, 0x0, page_size*page_cnt*sizeof(unsigned char));
+    if(-1 == read_partition_table(buf))
+    {
+        gPrtition.RamFree(buf);
+        gPrtition.Printf("part: Sflash_Open read fail\r\n");
+        return NULL;
+    }
+   
+    gPrtition.MemCpy(&file_num, buf, 4);
+    gPrtition.Printf("part: Sflash_Open file_num:%d\r\n", file_num);
+   
+    if(file_num == 0 || file_num == 0xFFFFFFFF || file_num > g_partition_file_max_num)
+    {
+        gPrtition.RamFree(buf);
+        gPrtition.Printf("part: Sflash_Open file_num == 0 || file_num == T_U32_MAX || file_num > 15\r\n");
+        return NULL;
+    }
+
+    //жļǷ
+    pFile_temp = (T_PARTITION_TABLE_INFO *)&buf[4];
+    for(i = 0; i < file_num; i++)
+    {
+        gPrtition.MemSet(name_dst, 0, PARTITION_NAME_LEN + 1);
+        gPrtition.MemSet(name_src, 0, PARTITION_NAME_LEN + 1);
+        gPrtition.MemCpy(name_dst, partition_name, PARTITION_NAME_LEN );
+        gPrtition.MemCpy(name_src, pFile_temp->partition_info.name, PARTITION_NAME_LEN );
+        
+        src_name_len = sflash_str_len(name_src);
+        dst_name_len = sflash_str_len(name_dst);
+        
+        //gPrtition.Printf("partition name:%s, %s\r\n", partition_name, pFile_temp->partition_info.name);
+        //gPrtition.Printf("name len:%d, %d\r\n", dst_name_len, src_name_len);
+        if(src_name_len == dst_name_len)
+        {
+            for(j=0; j < src_name_len; j++)
+            {
+                if(name_src[j] != name_dst[j])
+                {
+                    break;
+                }    
+            }
+
+            if(j == src_name_len)
+            {
+                //gPrtition.Printf("partition name open success:%s, %s\r\n", name_dst, name_src);
+                break;
+            }
+        }
+        pFile_temp++;
+    }
+    
+    if(i == file_num)
+    {
+        gPrtition.RamFree(buf);
+        gPrtition.Printf("partition name is not exist, open fail\r\n");
+        return NULL;    
+    }
+
+    pFile = gPrtition.RamAlloc(sizeof(T_PARTITION_TABLE_INFO));
+    if(NULL == pFile)
+    {
+        gPrtition.RamFree(buf);
+        gPrtition.Printf("part: Sflash_Open buf malloc fail\r\n");
+        return NULL;
+    }
+    
+    gPrtition.MemSet(pFile, 0x0, sizeof(T_PARTITION_TABLE_INFO));
+    gPrtition.MemCpy(pFile, pFile_temp, sizeof(T_PARTITION_TABLE_INFO));
+
+    if(pFile->partition_info.type == PART_BIN_TYPE || pFile->partition_info.type == PART_DATA_TYPE)
+    {
+        gPrtition.MemCpy(&bin_config, &pFile->ex_partition_info, sizeof(T_BIN_CONFIG));
+    }
+    else if(pFile->partition_info.type == PART_FS_TYPE)
+    {
+        gPrtition.MemCpy(&fs_config, &pFile->ex_partition_info, sizeof(T_FS_CONFIG));
+    }
+
+    gPrtition.Printf("open T:%d, R:%d, H:%d, K:%d, S:%d, N:%s \n"
+        , pFile->partition_info.type, pFile->partition_info.r_w_flag
+        , pFile->partition_info.hidden_flag, pFile->partition_info.ksize
+        , pFile->partition_info.start_pos, pFile->partition_info.name);
+    if(pFile->partition_info.type != PART_FS_TYPE)
+    {
+        gPrtition.Printf("open ex_bin F:%d, L:%d, B:%d, C:%d\r\n"
+            , bin_config.file_length, bin_config.ld_addr
+            , bin_config.backup_pos, bin_config.check);
+    }
+    else
+    {
+        gPrtition.Printf("open ex_fs F:%d, C:%d\r\n"
+            , fs_config.file_length, fs_config.check);
+    }
+
+    if(buf != NULL)
+    {
+        gPrtition.RamFree(buf);
+        buf = NULL;
+    }
+
+    g_partition.r_w_data_size = 0;
+    
+    g_partition.block_origin = (pFile->partition_info.start_pos/page_size)/m_spinand_burn.pages_per_block;
+    if(pFile->partition_info.type != PART_FS_TYPE && bin_config.backup_pos != 0xFFFFFFFF)
+    {
+       g_partition.block_backup = (bin_config.backup_pos/page_size)/m_spinand_burn.pages_per_block;;
+    }
+    else
+    {
+        g_partition.block_backup = 0xFFFFFFFF;
+    }
+
+    g_partition.read_block_num = 0;
+    g_partition.block_id = 0;
+    g_partition.open_time = 1;
+	g_partition.set_attr_flag = 0;
+	g_partition.write_table_flag = 0;
+    
+    return pFile;
+}
+
+
+int write_page_data(unsigned long block_idex, unsigned long start_page, unsigned long page_cnt, unsigned char *data, unsigned long data_len, unsigned char check)
+{
+    unsigned long i = 0;
+    unsigned long block = block_idex;
+    unsigned long block_src = block_idex;
+    //unsigned long page = 0;
+    unsigned long spare = 0;
+    unsigned char *pBuf = NULL;
+    unsigned char *pmove_buf = NULL;
+    unsigned long page_size = m_spinand_burn.page_size;
+    unsigned long write_data_size = data_len;
+    unsigned long compare_data_size = 0, try_times = 0;
+    unsigned char bmove_data = 0;
+
+
+    if(start_page + page_cnt > m_spinand_burn.pages_per_block)
+    {
+        gPrtition.Printf("write_page_data fail more thae page per block \r\n");
+        return -1;
+    }
+
+    //Ƿ
+    if(check)
+    {
+        pBuf = (unsigned char *)gPrtition.RamAlloc(page_size);
+        if(NULL == pBuf)
+        {
+            gPrtition.Printf("write_page_data malloc fail \r\n");
+            return -1;
+        }
+    }
+    
+    do
+    {
+        if(block > m_spinand_burn.total_size/(m_spinand_burn.pages_per_block*page_size))
+        {
+            gPrtition.Printf("block more than the max block num block:%d, %d, %d,%d\r\n", block, m_spinand_burn.total_size, m_spinand_burn.pages_per_block, page_size);
+            return -1;
+        }
+
+        if(start_page == 0 || bmove_data == 1)
+        {
+            //жǷ񻵿
+            if(spinand_is_badblock(block) == 0)
+            {
+                goto WRITE_FAIL;
+            }
+
+            //˿
+            if(Prod_NandEraseBlock(block) == -1)
+            {
+                //û
+                spinand_set_badblock(block);
+                goto WRITE_FAIL;
+            }
+        }
+
+        //һҪ
+        if(bmove_data == 1)
+        {
+            pmove_buf = (unsigned char *)gPrtition.RamAlloc(page_size);
+            if(NULL == pmove_buf)
+            {
+                gPrtition.Printf("move data malloc fail \r\n");
+                return -1;
+            }
+            
+            for(i = 0; i < start_page; i++)
+            {
+                if(Prod_NandReadPage(block_src, i, pmove_buf, (unsigned char *)&spare, 4) == - 1)
+                {
+                    gPrtition.Printf("move data read page b:%d, p:%d fail \r\n", block_src, i);
+                    return -1;
+                }
+
+                if(Prod_NandWritePage(block, i, pmove_buf, (unsigned char *)&spare, 4) == - 1)
+                {
+                    bmove_data = 1;
+                    //û
+                    spinand_set_badblock(block);
+                    goto WRITE_FAIL;
+                }
+            }
+
+            if(pmove_buf != NULL)
+            {
+                gPrtition.RamFree(pmove_buf);
+            }
+        }
+        
+
+        //дԴ
+        for(i = 0; i < page_cnt; i++)
+        {
+            if(Prod_NandWritePage(block, start_page+i, data+i*page_size, (unsigned char *)&spare, 4) == - 1)
+            {
+                bmove_data = 1;
+                //û
+                spinand_set_badblock(block);
+                goto WRITE_FAIL;
+            }
+
+            //Ƿ
+            if(check)
+            {
+                const unsigned char*pTempData = NULL;
+
+                pTempData = data + i * page_size;
+
+                gPrtition.MemSet(pBuf, 0, page_size);
+                if(Prod_NandReadPage(block, start_page+i, pBuf, (unsigned char *)&spare, 4) == - 1)
+                {
+                    bmove_data = 1;
+                    //û
+                    spinand_set_badblock(block);
+                    goto WRITE_FAIL;
+                }
+
+                if(write_data_size >= page_size)
+                {
+                    compare_data_size = page_size;
+                }
+                else
+                {
+                    compare_data_size = write_data_size;
+                }
+
+                if(0 != gPrtition.MemCmp(pBuf, pTempData, compare_data_size))
+                {
+                    gPrtition.Printf("Compare fail \r\n");
+                    return -1;
+                } 
+
+                write_data_size = write_data_size - compare_data_size;
+            }
+        }
+
+
+        if(i >= page_cnt)//дɹ
+        {
+            //д˶ٸ
+            g_partition.block_id = block - block_src;
+            if(g_partition.block_id > 0)
+            {
+                gPrtition.Printf("wirte bad block:%d, %d, %d \r\n", g_partition.block_id, block, block_src);
+            }
+            break;
+        }
+        else//дʧ
+        {
+WRITE_FAIL:
+            block++;
+            if(try_times > 50)
+            {
+                if(check)
+                {
+                    if(pBuf != NULL)
+                    {
+                        gPrtition.RamFree(pBuf);
+                    }
+                }
+                gPrtition.Printf("write fail block num more than 50 \r\n");
+                return -1;
+            }
+            try_times++;
+        }
+    }while(1);
+
+    if(check)
+    {
+        if(pBuf != NULL)
+        {
+            gPrtition.RamFree(pBuf);
+        }
+    }
+    return 0;
+}
+
+
+int write_page_data_fs_img(unsigned long block_idex, unsigned long start_page, unsigned long page_cnt, unsigned char *data, unsigned long data_len, unsigned char check)
+{
+    unsigned long i = 0;
+	unsigned long ret = -1;
+    unsigned long block = block_idex;
+    unsigned long block_src = block_idex;
+//    unsigned long page = 0;
+    unsigned long spare = 0;
+    unsigned char *pBuf = NULL;
+	unsigned char *pBuf_oob = NULL;
+    unsigned char *pmove_buf = NULL;
+	unsigned char *pmove_oob_buf = NULL;
+    unsigned long page_size = m_spinand_burn.page_size;
+	unsigned long oob_size = m_spinand_burn.oob_size;
+//	unsigned long initbad_offset = m_spinand_burn.initbad_offset;
+    unsigned long write_data_size = data_len;
+    unsigned long compare_data_size = 0, try_times = 0;
+    unsigned char bmove_data = 0;
+
+
+    if(start_page + page_cnt > m_spinand_burn.pages_per_block)
+    {
+        gPrtition.Printf("write_page_data fail more thae page per block \r\n");
+        return -1;
+    }
+
+    //Ƿ
+    if(check)
+    {
+        pBuf = (unsigned char *)gPrtition.RamAlloc(page_size);
+        if(NULL == pBuf)
+        {
+            gPrtition.Printf("write_page_data malloc fail \r\n");
+            return -1;
+        }
+		pBuf_oob = (unsigned char *)gPrtition.RamAlloc(oob_size);
+        if(NULL == pBuf_oob)
+        {
+            gPrtition.Printf("write_page_data malloc fail \r\n");
+            return -1;
+        }
+    }
+    
+    do
+    {
+        if(block > m_spinand_burn.total_size/(m_spinand_burn.pages_per_block*page_size))
+        {
+            gPrtition.Printf("block more than the max block num block:%d, %d, %d,%d\r\n", block, m_spinand_burn.total_size, m_spinand_burn.pages_per_block, page_size);
+            return -1;
+        }
+
+        if(start_page == 0 || bmove_data == 1)
+        {
+            //жǷ񻵿
+            if(spinand_is_badblock(block) == 0)
+            {
+                goto WRITE_FAIL;
+            }
+
+            //˿
+            if(Prod_NandEraseBlock(block) == -1)
+            {
+                //û
+                spinand_set_badblock(block);
+                goto WRITE_FAIL;
+            }
+        }
+
+        //һҪ
+        if(bmove_data == 1)
+        {
+            pmove_buf = (unsigned char *)gPrtition.RamAlloc(page_size);
+            if(NULL == pmove_buf)
+            {
+                gPrtition.Printf("move data malloc fail \r\n");
+                goto WRITE_FAIL;
+            }
+			pmove_oob_buf = (unsigned char *)gPrtition.RamAlloc(oob_size);
+            if(NULL == pmove_oob_buf)
+            {
+                gPrtition.Printf("move pmove_oob_buf malloc fail \r\n");
+                goto WRITE_FAIL;
+            }
+            
+            for(i = 0; i < start_page; i++)
+            {
+                if(Prod_NandReadPage(block_src, i, pmove_buf, pmove_oob_buf, 28) == - 1)
+                {
+                    gPrtition.Printf("move data read page b:%d, p:%d fail \r\n", block_src, i);
+                    goto WRITE_FAIL;
+                }
+
+                if(Prod_NandWritePage(block, i, pmove_buf, pmove_oob_buf, 28) == - 1)
+                {
+                    bmove_data = 1;
+                    //û
+                    spinand_set_badblock(block);
+                    goto WRITE_FAIL;
+                }
+            }
+
+            if(pmove_buf != NULL)
+            {
+                gPrtition.RamFree(pmove_buf);
+				pmove_buf = NULL;
+            }
+			 if(pmove_oob_buf != NULL)
+            {
+				gPrtition.RamFree(pmove_oob_buf);
+				pmove_oob_buf = NULL;
+            }
+        }
+        
+
+        //дԴ
+        for(i = 0; i < page_cnt; i++)
+        {
+        	//gPrtition.Printf("data:%d, %02x, %02x, %02x, %02x, %02x \r\n", oob_size-initbad_offset, data[i*(page_size+oob_size)+ page_size], data[i*(page_size+oob_size)+ page_size+1], data[i*(page_size+oob_size)+ page_size+2], data[i*(page_size+oob_size)+ page_size+3], data[i*(page_size+oob_size)+ page_size+4]);
+            if(Prod_NandWritePage(block, start_page+i, &data[i*(page_size+oob_size)], &data[i*(page_size+oob_size)+ page_size], 28) == - 1)
+            {
+                bmove_data = 1;
+                //û
+                spinand_set_badblock(block);
+                goto WRITE_FAIL;
+            }
+
+            //Ƿ
+            if(check)
+            {
+                const unsigned char*pTempData = NULL;
+
+                pTempData = data + i * (page_size+oob_size);
+
+                gPrtition.MemSet(pBuf, 0, page_size);
+                if(Prod_NandReadPage(block, start_page+i, pBuf, (unsigned char *)&spare, 4) == - 1)
+                {
+                    bmove_data = 1;
+                    //û
+                    spinand_set_badblock(block);
+                    goto WRITE_FAIL;
+                }
+
+                if(write_data_size >= (page_size+oob_size))
+                {
+                    compare_data_size = page_size;
+                }
+                else
+                {
+                    compare_data_size = write_data_size;
+                }
+
+                if(0 != gPrtition.MemCmp(pBuf, pTempData, compare_data_size))
+                {
+                    gPrtition.Printf("Compare fail compare_data_size:%d\r\n", compare_data_size);
+                    goto WRITE_FAIL;
+                } 
+
+                write_data_size = write_data_size - compare_data_size;
+            }
+        }
+
+		ret = 0;
+
+        if(i >= page_cnt)//дɹ
+        {
+            //д˶ٸ
+            g_partition.block_id = block - block_src;
+            if(g_partition.block_id > 0)
+            {
+                gPrtition.Printf("wirte bad block:%d, %d, %d \r\n", g_partition.block_id, block, block_src);
+            }
+            break;
+        }
+        else//дʧ
+        {
+WRITE_FAIL:
+            block++;
+            if(try_times > 50)
+            {
+                if(check)
+                {
+                    if(pBuf != NULL)
+                    {
+                        gPrtition.RamFree(pBuf);
+                    }
+                }
+				if(pmove_buf != NULL)
+			    {
+			        gPrtition.RamFree(pmove_buf);
+			    }
+				 if(pmove_oob_buf != NULL)
+			    {
+					gPrtition.RamFree(pmove_oob_buf);
+			    }
+                gPrtition.Printf("write fail block num more than 50 \r\n");
+                return -1;
+            }
+            try_times++;
+        }
+    }while(1);
+
+    if(check)
+    {
+        if(pBuf != NULL)
+        {
+            gPrtition.RamFree(pBuf);
+        }
+		
+    }
+
+	if(pmove_buf != NULL)
+    {
+        gPrtition.RamFree(pmove_buf);
+    }
+	 if(pmove_oob_buf != NULL)
+    {
+		gPrtition.RamFree(pmove_oob_buf);
+    }
+			 
+    return ret;
+}
+
+
+int spinand_write_fs_img(T_PARTITION_TABLE_INFO *pFile, unsigned char *data, unsigned long data_len, unsigned long backup_page, unsigned char check)
+{
+    unsigned long page_size = m_spinand_burn.page_size;
+    unsigned long page_per_block = m_spinand_burn.pages_per_block;
+	unsigned long oob_size = m_spinand_burn.oob_size;
+	unsigned long total_page_cnt = 0;
+	unsigned long write_page = 0;
+	unsigned long page_cnt = 0;
+	unsigned long write_data_size = 0;
+	
+	
+	//fsļǴoob,дһҳʱҪoobҲһȥ
+	total_page_cnt = data_len/(page_size + oob_size);
+    
+    while(1)
+    {
+        //дҳ
+        write_page = pFile->partition_info.start_pos/page_size + g_partition.r_w_data_size/(page_size + oob_size);
+        
+        //дһ
+        //block_idex = write_page/m_spinand_burn.pages_per_block;
+
+        //ҳƫ
+        write_page = write_page%m_spinand_burn.pages_per_block;
+
+        gPrtition.Printf(".");
+        //дҳ
+        if(total_page_cnt != 0)
+        {
+            //gPrtition.Printf("page: b:%d, p:%d\r\n", g_partition.block_origin, write_page);
+            if(total_page_cnt + write_page > page_per_block)
+            {
+                page_cnt = page_per_block - write_page;
+            }
+            else
+            {
+                page_cnt = total_page_cnt;
+            }
+
+            //дԴ
+            if(-1 == write_page_data_fs_img(g_partition.block_origin, write_page, page_cnt, &data[write_data_size], page_cnt*(page_size + oob_size), check))
+            {
+                gPrtition.Printf("part: write_page_data fail b:%d, p:%d, p_cnt:%d\r\n", g_partition.block_origin, write_page, page_cnt);
+                return -1;
+            }
+
+            if(write_page + page_cnt == page_per_block)
+            {
+                g_partition.block_id++;
+                
+            }
+            g_partition.block_origin += g_partition.block_id; 
+            
+
+            
+            if(backup_page != 0xFFFFFFFF)
+            {
+                //gPrtition.Printf("backup page: b:%d, p:%d\r\n", g_partition.block_backup, write_page);
+                //д
+                if(-1 == write_page_data_fs_img(g_partition.block_backup, write_page, page_cnt, &data[write_data_size], page_cnt*(page_size + oob_size), check))
+                {
+                    gPrtition.Printf("part: backup write_page_data fail b:%d, p:%d, p_cnt:%d\r\n", g_partition.block_backup, write_page, page_cnt);
+                    return -1;
+                }
+
+                if(write_page + page_cnt == page_per_block)
+                {
+                    g_partition.block_id++;
+                    
+                }
+                g_partition.block_backup += g_partition.block_id; 
+            }
+            
+            g_partition.r_w_data_size = g_partition.r_w_data_size + page_cnt*(page_size + oob_size);
+            write_data_size = write_data_size +  + page_cnt*(page_size + oob_size);
+            total_page_cnt = total_page_cnt - page_cnt;
+        }
+        
+        if(total_page_cnt == 0)
+        {
+            //дҳ
+            break;
+        }
+        
+    }
+    
+            
+    //д󲻹һҳ
+    if(data_len%(page_size + oob_size) != 0)
+    {
+        unsigned char *pBuf = NULL;
+        pBuf = (unsigned char *)gPrtition.RamAlloc(page_size);
+        if(NULL == pBuf)
+        {
+            gPrtition.Printf("spinand write malloc fail \r\n");
+            return -1;
+        }
+
+        gPrtition.MemSet(pBuf, 0, page_size);
+        gPrtition.MemCpy(pBuf, &data[write_data_size], data_len%(page_size + oob_size));
+
+        //дҳ
+        write_page = pFile->partition_info.start_pos/page_size + g_partition.r_w_data_size/(page_size + oob_size);
+
+        //ҳƫ
+        write_page = write_page%m_spinand_burn.pages_per_block;
+        
+        //gPrtition.Printf("less page: b:%d, p:%d\r\n", block_idex, write_page);
+        //дԴ
+        if(-1 == write_page_data_fs_img(g_partition.block_origin, write_page, 1, pBuf, data_len%(page_size + oob_size), check))
+        {
+            gPrtition.RamFree(pBuf);
+            gPrtition.Printf("part: write_page_data fail b:%d, p:%d, p_cnt:%d\r\n", g_partition.block_origin, write_page, page_cnt);
+            return -1;
+        } 
+
+        //g_partition.block_origin += g_partition.block_id;
+
+        if(backup_page != 0xFFFFFFFF)
+        {
+            //gPrtition.Printf("backup less page: b:%d, p:%d\r\n", g_partition.block_backup, write_page);
+            if(-1 == write_page_data_fs_img(g_partition.block_backup, write_page, 1, pBuf, data_len%(page_size + oob_size), check))
+            {
+                gPrtition.RamFree(pBuf);
+                gPrtition.Printf("part: write_page_data fail b:%d, p:%d, p_cnt:%d\r\n", g_partition.block_backup, write_page, page_cnt);
+                return -1;
+            }
+
+            //g_partition.block_backup += g_partition.block_id; 
+        }
+
+        g_partition.r_w_data_size = g_partition.r_w_data_size + data_len%(page_size + oob_size);
+
+        gPrtition.RamFree(pBuf);
+        
+    }
+
+
+	g_partition.write_flag = 1;
+    g_partition.write_table_flag = 1;
+    
+    pFile->ex_partition_info.parameter1 = g_partition.r_w_data_size;
+
+	return data_len;
+
+}
+
+
+int spinand_write(T_PARTITION_TABLE_INFO *pFile, unsigned char *data, unsigned long data_len)
+{
+    unsigned long page_size = m_spinand_burn.page_size;
+    unsigned long page_per_block = m_spinand_burn.pages_per_block;
+    unsigned char check = 0;
+    unsigned long backup_page = 0xFFFFFFFF;
+    T_BIN_CONFIG bin_config;
+    T_FS_CONFIG fs_config;
+    unsigned long write_page = 0;
+    unsigned long write_data_size = 0;
+    unsigned long page_cnt = 0;
+    unsigned long total_page_cnt = 0;
+//    unsigned long last_data_size = 0;
+   // unsigned long block_idex = 0;
+   // unsigned long backup_block_idex = 0;
+	unsigned long block_size = m_spinand_burn.pages_per_block*m_spinand_burn.page_size;
+	unsigned long block_num = 0;
+	unsigned long oob_size = 0;
+
+    if(pFile == NULL || data == NULL || data_len == 0)
+    {
+        gPrtition.Printf("part: Sflash_Write fail, %x, %x, %d\r\n", pFile, data, data_len);
+        return -1;
+    }
+
+    if(1 != g_partition.init_success_flag)
+    {
+        if (NULL != gPrtition.Printf)
+        {
+            gPrtition.Printf("part: Sflash_Write not Sflash_Init\r\n");
+        }
+        return -1;
+    }
+    
+    if(g_partition.read_flag)
+    {
+        gPrtition.Printf("part: Sflash_Write read is running\r\n");
+        return -1;
+    }
+
+    if(pFile->partition_info.type == PART_BIN_TYPE || pFile->partition_info.type == PART_DATA_TYPE)
+    {
+        gPrtition.MemCpy(&bin_config, &pFile->ex_partition_info, sizeof(T_BIN_CONFIG));
+        check = bin_config.check;
+        backup_page = bin_config.backup_pos;
+        //gPrtition.Printf("backup_page:%d\r\n", backup_page);
+    }
+    else if(pFile->partition_info.type == PART_FS_TYPE)
+    {
+        gPrtition.MemCpy(&fs_config, &pFile->ex_partition_info, sizeof(T_FS_CONFIG));
+        check = fs_config.check;
+    }
+    else
+    {
+        gPrtition.Printf("part: Sflash_Write type IS error\r\n");
+        return -1;
+    }
+
+
+
+
+
+    if(backup_page != 0xFFFFFFFF)
+    {
+        //ΪpFile->partition_info.ksizeڴʱͳƿ˫
+        if(pFile->partition_info.type == PART_FS_TYPE)
+		{
+	        block_num = pFile->partition_info.ksize*K_SIZE/block_size;
+			block_num = block_num/2;
+			oob_size = block_num*m_spinand_burn.pages_per_block*m_spinand_burn.oob_size;
+	        if(g_partition.r_w_data_size + data_len > pFile->partition_info.ksize*K_SIZE/2 + oob_size)
+	        {
+	            gPrtition.Printf("part: error backup write data size more than partition ksize\r\n");
+	            return -1;
+	        }
+        }
+		else
+		{
+			if(g_partition.r_w_data_size + data_len > pFile->partition_info.ksize*K_SIZE/2)
+	        {
+	            gPrtition.Printf("part: error backup write data size more than partition ksize\r\n");
+	            return -1;
+	        }
+		}
+    }
+    else
+    {
+    	
+
+		if(pFile->partition_info.type == PART_FS_TYPE)
+		{
+			block_num = pFile->partition_info.ksize*K_SIZE/block_size;
+			oob_size = block_num*m_spinand_burn.pages_per_block*m_spinand_burn.oob_size;
+			if(g_partition.r_w_data_size + data_len > pFile->partition_info.ksize*K_SIZE + oob_size)
+	        {
+	            gPrtition.Printf("part: error write data size more than partition ksize\r\n");
+	            return -1;
+	        }
+		}
+		else
+		{
+	        if(g_partition.r_w_data_size + data_len > pFile->partition_info.ksize*K_SIZE)
+	        {
+	            gPrtition.Printf("part: error write data size more than partition ksize\r\n");
+	            return -1;
+	        }
+		}
+    }
+
+	//gPrtition.Printf("pFile->partition_info.type:%d\r\n", pFile->partition_info.type );
+	
+	if(pFile->partition_info.type == PART_FS_TYPE)
+	{
+		//gPrtition.Printf("data:%02x, %02x, %02x, %02x, %02x, %02x, %02x, %02x, %02x\r\n", data[0], data[1], data[2], data[3], data[4], data[5], data[6], data[7], data[8] );
+		return spinand_write_fs_img(pFile, data, data_len, backup_page, check);
+	}
+
+    total_page_cnt = data_len/page_size;
+    
+    while(1)
+    {
+        //дҳ
+        write_page = pFile->partition_info.start_pos/page_size + g_partition.r_w_data_size/page_size;
+        
+        //дһ
+        //block_idex = write_page/m_spinand_burn.pages_per_block;
+
+        //ҳƫ
+        write_page = write_page%m_spinand_burn.pages_per_block;
+
+        gPrtition.Printf(".");
+        //дҳ
+        if(total_page_cnt != 0)
+        {
+            //gPrtition.Printf("page: b:%d, p:%d\r\n", g_partition.block_origin, write_page);
+            if(total_page_cnt + write_page > page_per_block)
+            {
+                page_cnt = page_per_block - write_page;
+            }
+            else
+            {
+                page_cnt = total_page_cnt;
+            }
+
+            //дԴ
+            if(-1 == write_page_data(g_partition.block_origin, write_page, page_cnt, &data[write_data_size], page_cnt*page_size, check))
+            {
+                gPrtition.Printf("part: write_page_data fail b:%d, p:%d, p_cnt:%d\r\n", g_partition.block_origin, write_page, page_cnt);
+                return -1;
+            }
+
+            if(write_page + page_cnt == page_per_block)
+            {
+                g_partition.block_id++;
+                
+            }
+            g_partition.block_origin += g_partition.block_id; 
+            
+
+            
+            if(backup_page != 0xFFFFFFFF)
+            {
+                //gPrtition.Printf("backup page: b:%d, p:%d\r\n", g_partition.block_backup, write_page);
+                //д
+                if(-1 == write_page_data(g_partition.block_backup, write_page, page_cnt, &data[write_data_size], page_cnt*page_size, check))
+                {
+                    gPrtition.Printf("part: backup write_page_data fail b:%d, p:%d, p_cnt:%d\r\n", g_partition.block_backup, write_page, page_cnt);
+                    return -1;
+                }
+
+                if(write_page + page_cnt == page_per_block)
+                {
+                    g_partition.block_id++;
+                    
+                }
+                g_partition.block_backup += g_partition.block_id; 
+            }
+            
+            g_partition.r_w_data_size = g_partition.r_w_data_size + page_cnt*page_size;
+            write_data_size = write_data_size +  + page_cnt*page_size;
+            total_page_cnt = total_page_cnt - page_cnt;
+        }
+        
+        if(total_page_cnt == 0)
+        {
+            //дҳ
+            break;
+        }
+        
+    }
+    
+            
+    //д󲻹һҳ
+    if(data_len%page_size != 0)
+    {
+        unsigned char *pBuf = NULL;
+        pBuf = (unsigned char *)gPrtition.RamAlloc(page_size);
+        if(NULL == pBuf)
+        {
+            gPrtition.Printf("spinand write malloc fail \r\n");
+            return -1;
+        }
+
+        gPrtition.MemSet(pBuf, 0, page_size);
+        gPrtition.MemCpy(pBuf, &data[write_data_size], data_len%page_size);
+
+        //дҳ
+        write_page = pFile->partition_info.start_pos/page_size + g_partition.r_w_data_size/page_size;
+
+        //ҳƫ
+        write_page = write_page%m_spinand_burn.pages_per_block;
+        
+        //gPrtition.Printf("less page: b:%d, p:%d\r\n", block_idex, write_page);
+        //дԴ
+        if(-1 == write_page_data(g_partition.block_origin, write_page, 1, pBuf, data_len%page_size, check))
+        {
+            gPrtition.RamFree(pBuf);
+            gPrtition.Printf("part: write_page_data fail b:%d, p:%d, p_cnt:%d\r\n", g_partition.block_origin, write_page, page_cnt);
+            return -1;
+        } 
+
+        //g_partition.block_origin += g_partition.block_id;
+
+        if(backup_page != 0xFFFFFFFF)
+        {
+            //gPrtition.Printf("backup less page: b:%d, p:%d\r\n", g_partition.block_backup, write_page);
+            if(-1 == write_page_data(g_partition.block_backup, write_page, 1, pBuf, data_len%page_size, check))
+            {
+                gPrtition.RamFree(pBuf);
+                gPrtition.Printf("part: write_page_data fail b:%d, p:%d, p_cnt:%d\r\n", g_partition.block_backup, write_page, page_cnt);
+                return -1;
+            }
+
+            //g_partition.block_backup += g_partition.block_id; 
+        }
+
+        g_partition.r_w_data_size = g_partition.r_w_data_size + data_len%page_size;
+
+        gPrtition.RamFree(pBuf);
+        
+    }
+
+
+    g_partition.write_flag = 1;
+    g_partition.write_table_flag = 1;
+    
+    pFile->ex_partition_info.parameter1 = g_partition.r_w_data_size;
+       
+    return data_len;
+}
+
+
+int read_page_data(unsigned long start_page, unsigned long page_cnt, unsigned char *data, unsigned long data_len)
+{
+    unsigned long i = 0;
+    unsigned long spare = 0;
+    unsigned long page_size = m_spinand_burn.page_size;
+    unsigned long block_idex = g_partition.block_origin;
+    unsigned long backup_block_idex = g_partition.block_backup;
+    unsigned long backup_block_read = 0;
+    
+    do
+    {
+        if(start_page == 0)
+        {
+            //жǷ񻵿
+            if(spinand_is_badblock(block_idex) == 0)
+            {
+                gPrtition.Printf("read bb:%d\r\n", block_idex);
+                block_idex++;
+                continue;
+            }
+        }
+
+        //ȡ
+        for(i = 0; i < page_cnt; i++)
+        {
+            if(Prod_NandReadPage(block_idex, start_page+i, &data[i*page_size], (unsigned char *)&spare, 4) == - 1)
+            {
+                if(g_partition.block_backup != 0xFFFFFFFF)
+                {
+                    //Դʧܣж
+                    //ԿţֻҪҵӦƫҳݾͿ
+
+                    //ͨԴݿǻĸұݿӦ
+                    while(1)
+                    {
+                        if(spinand_is_badblock(backup_block_idex) == 0)
+                        {
+                            backup_block_idex++;
+                            continue;
+                        }
+                        else
+                        {
+                            //жǷԴݿǻǷһ
+                            if(g_partition.read_block_num == backup_block_read)
+                            {
+                                break;
+                            }
+                            backup_block_read++;//ȡǻĿ
+                            backup_block_idex++;//ȡܿ
+                        }
+                    }
+
+                    if(Prod_NandReadPage(backup_block_idex, start_page+i, &data[i*page_size], (unsigned char *)&spare, 4) == - 1)
+                    {
+                        gPrtition.Printf("part: read backup data fail fail b:%d, p:%d, p_cnt:%d\r\n", backup_block_idex, start_page+i, page_cnt);
+                        return -1;
+                    }
+                }
+                else
+                {
+                    
+                    gPrtition.Printf("part: read data fail fail b:%d, p:%d, p_cnt:%d\r\n", block_idex, start_page+i, page_cnt);
+                     return -1;
+                }
+            }
+        }
+        
+
+        if(i >= page_cnt)
+        {
+            g_partition.block_id = block_idex - g_partition.block_origin;
+            break;
+        }
+  
+    }while(1);
+    
+    return 0;
+}
+
+
+int read_page_data_fs_img(unsigned long start_page, unsigned long page_cnt, unsigned char *data, unsigned long data_len)
+{
+    unsigned long i = 0;
+//    unsigned long spare = 0;
+    unsigned long page_size = m_spinand_burn.page_size;
+    unsigned long block_idex = g_partition.block_origin;
+    unsigned long backup_block_idex = g_partition.block_backup;
+    unsigned long backup_block_read = 0;
+	unsigned long oob_size = m_spinand_burn.oob_size;
+//	unsigned long initbad_offset = m_spinand_burn.initbad_offset;
+    //gPrtition.Printf("read_page_data_fs_img b:%d, p:%d, p_cnt:%d\r\n", block_idex, start_page, page_cnt);
+    do
+    {
+        if(start_page == 0)
+        {
+            //жǷ񻵿
+            if(spinand_is_badblock(block_idex) == 0)
+            {
+                gPrtition.Printf("read bb:%d\r\n", block_idex);
+                block_idex++;
+                continue;
+            }
+        }
+
+        //ȡ
+        for(i = 0; i < page_cnt; i++)
+        {
+            if(Prod_NandReadPage(block_idex, start_page+i, &data[i*(page_size +oob_size)], &data[i*(page_size +oob_size)+page_size], 28) == - 1)
+            {
+                if(g_partition.block_backup != 0xFFFFFFFF)
+                {
+                    //Դʧܣж
+                    //ԿţֻҪҵӦƫҳݾͿ
+
+                    //ͨԴݿǻĸұݿӦ
+                    while(1)
+                    {
+                        if(spinand_is_badblock(backup_block_idex) == 0)
+                        {
+                            backup_block_idex++;
+                            continue;
+                        }
+                        else
+                        {
+                            //жǷԴݿǻǷһ
+                            if(g_partition.read_block_num == backup_block_read)
+                            {
+                                break;
+                            }
+                            backup_block_read++;//ȡǻĿ
+                            backup_block_idex++;//ȡܿ
+                        }
+                    }
+
+                    if(Prod_NandReadPage(backup_block_idex, start_page+i, &data[i*(page_size +oob_size)], &data[i*(page_size +oob_size)+page_size], 28) == - 1)
+                    {
+                        gPrtition.Printf("part: read backup data fail fail b:%d, p:%d, p_cnt:%d\r\n", backup_block_idex, start_page+i, page_cnt);
+                        return -1;
+                    }
+                }
+                else
+                {
+                    
+                    gPrtition.Printf("part: read data fail fail b:%d, p:%d, p_cnt:%d\r\n", block_idex, start_page+i, page_cnt);
+                     return -1;
+                }
+            }
+        }
+        
+
+        if(i >= page_cnt)
+        {
+            g_partition.block_id = block_idex - g_partition.block_origin;
+            break;
+        }
+  
+    }while(1);
+    
+    return 0;
+}
+
+
+
+int spinand_read_fs_img(T_PARTITION_TABLE_INFO *pFile, unsigned char *data, unsigned long data_len)
+{
+	unsigned long page_size = m_spinand_burn.page_size;
+	unsigned long page_per_block = m_spinand_burn.pages_per_block;
+	unsigned long oob_size = m_spinand_burn.oob_size;
+//	unsigned long initbad_offset = m_spinand_burn.initbad_offset;
+	unsigned long total_page_cnt = 0;
+	unsigned long write_page = 0;
+	unsigned long page_cnt = 0;
+	unsigned long write_data_size = 0;
+	
+	//
+	total_page_cnt = data_len/(page_size+oob_size);
+	//gPrtition.Printf("total_page_cnt:%d\r\n", total_page_cnt);	
+	while(1)
+	{
+		//Ѷҳ
+		write_page = pFile->partition_info.start_pos/page_size + g_partition.r_w_data_size/(page_size+oob_size);
+		//gPrtition.Printf("write_page:%d\r\n", write_page);	
+		//ҳƫ
+		write_page = write_page%m_spinand_burn.pages_per_block;
+		//gPrtition.Printf("write_page:%d\r\n", write_page);
+		gPrtition.Printf(".");
+		if(total_page_cnt != 0)
+		{
+			//gPrtition.Printf("read: b:%d, p:%d\r\n", g_partition.block_origin, write_page);
+			if(total_page_cnt + write_page > page_per_block)
+			{
+				page_cnt = page_per_block - write_page;
+			}
+			else
+			{
+				page_cnt = total_page_cnt;
+			}
+			//gPrtition.Printf("total_page_cnt:%d, page_cnt:%d, write_data_size:%d\r\n", total_page_cnt, page_cnt, write_data_size);
+			 if(read_page_data_fs_img(write_page, page_cnt, &data[write_data_size], page_cnt*(page_size+oob_size)) == -1)
+			 {
+				gPrtition.Printf("part: read_page_data fail b:%d, p:%d, p_cnt:%d\r\n", g_partition.block_origin, write_page, page_cnt);
+				return -1;
+			 }
+
+			 total_page_cnt -= page_cnt;
+			 write_data_size += page_cnt*(page_size+oob_size);
+			// gPrtition.Printf("total_page_cnt:%d, write_data_size:%d\r\n", total_page_cnt, write_data_size);	
+			 if(write_page + page_cnt == page_per_block)
+			 {
+				g_partition.read_block_num++;//
+				g_partition.block_id++;
+			 }
+			 g_partition.block_origin += g_partition.block_id;
+
+			 g_partition.r_w_data_size += page_cnt*(page_size+oob_size);
+			// gPrtition.Printf("g_partition.r_w_data_size :%d\r\n", g_partition.r_w_data_size );  
+		}
+		else
+		{
+			//дҳ
+			break;
+		}
+	}
+
+	//д󲻹һҳ
+	if(data_len%(page_size+oob_size) != 0)
+	{
+		unsigned char *pBuf = NULL;
+		pBuf = (unsigned char *)gPrtition.RamAlloc(page_size+oob_size);
+		if(NULL == pBuf)
+		{
+			gPrtition.Printf("spinand write malloc fail \r\n");
+			return -1;
+		}
+
+		gPrtition.MemSet(pBuf, 0, page_size+oob_size);
+		
+	  // gPrtition.Printf("write_page:%d, readsize:%d\r\n", write_page, data_len%page_size);  
+		if(read_page_data_fs_img(write_page, 1, pBuf, data_len%(page_size+oob_size)) == -1)
+		{
+			gPrtition.RamFree(pBuf);
+			return -1;
+		}
+		
+		gPrtition.MemCpy(&data[write_data_size], pBuf, data_len%(page_size+oob_size));
+
+		write_data_size += data_len%(page_size+oob_size);
+		g_partition.r_w_data_size += data_len%(page_size+oob_size);
+		//gPrtition.Printf("00g_partition.r_w_data_size :%d\r\n", g_partition.r_w_data_size );  
+		//gPrtition.Printf("page_size :%d\r\n", page_size);
+		//gPrtition.Printf("write_data_size :%d\r\n", write_data_size);
+		gPrtition.RamFree(pBuf);
+	}
+
+	//gPrtition.Printf("end data_len :%d\r\n", data_len);
+
+	 return data_len;
+}
+
+
+int spinand_read(T_PARTITION_TABLE_INFO *pFile, unsigned char *data, unsigned long data_len)
+{
+    unsigned long write_page = 0;
+    unsigned long page_cnt = 0;
+    unsigned long total_page_cnt = 0;
+    unsigned long page_size = m_spinand_burn.page_size;
+    unsigned long page_per_block = m_spinand_burn.pages_per_block;
+    unsigned long write_data_size = 0;
+    T_BIN_CONFIG bin_config;
+    T_FS_CONFIG fs_config;
+    unsigned long file_len = 0,backup_page = 0; 
+
+    if(pFile == NULL || data == NULL || data_len == 0)
+    {
+        gPrtition.Printf("part: Sflash_Read fail, %x, %x, %d\r\n", pFile, data, data_len);
+        return -1;
+    }
+
+    if(1 != g_partition.init_success_flag)
+    {
+        if (NULL != gPrtition.Printf)
+        {
+            gPrtition.Printf("part: Sflash_Read not Sflash_Init\r\n");
+        }
+        return -1;
+    }
+
+    if(g_partition.write_flag)
+    {
+         gPrtition.Printf("part: Sflash_Read write is running\r\n");
+        return -1;
+    }
+
+    if(pFile->partition_info.type == PART_BIN_TYPE || pFile->partition_info.type == PART_DATA_TYPE)
+    {
+        gPrtition.MemCpy(&bin_config, &pFile->ex_partition_info, sizeof(T_BIN_CONFIG));
+        file_len = bin_config.file_length;
+        backup_page = bin_config.backup_pos;
+    }
+    else if(pFile->partition_info.type == PART_FS_TYPE)
+    {
+        gPrtition.MemCpy(&fs_config, &pFile->ex_partition_info, sizeof(T_FS_CONFIG));
+        file_len = fs_config.file_length;
+    }
+    else
+    {
+        gPrtition.Printf("part: Sflash_Write type IS error\r\n");
+        return -1;
+    }
+    
+
+    if(file_len == 0)
+    {
+        gPrtition.Printf("part: Sflash_Read partition not have data\r\n");
+        return -1;
+    }
+
+	//ҪֻЧ,ΪпҪ,Ҫƴ
+    if(0)//g_partition.r_w_data_size == file_len && pFile->partition_info.type != PART_FS_TYPE)
+    {
+        //Ѷ
+        gPrtition.Printf("part: Sflash_Read read data finish,%d, %d\r\n", g_partition.r_w_data_size, file_len);
+        return -1;
+    }
+
+	if(pFile->partition_info.type == PART_FS_TYPE)
+	{
+		return spinand_read_fs_img(pFile, data, data_len);
+	}
+	
+    total_page_cnt = data_len/page_size;
+    
+    while(1)
+    {
+        //Ѷҳ
+        write_page = pFile->partition_info.start_pos/page_size + g_partition.r_w_data_size/page_size;
+
+        //ҳƫ
+        write_page = write_page%m_spinand_burn.pages_per_block;
+
+        gPrtition.Printf(".");
+        if(total_page_cnt != 0)
+        {
+            //gPrtition.Printf("read: b:%d, p:%d\r\n", g_partition.block_origin, write_page);
+            if(total_page_cnt + write_page > page_per_block)
+            {
+                page_cnt = page_per_block - write_page;
+            }
+            else
+            {
+                page_cnt = total_page_cnt;
+            }
+            //gPrtition.Printf("total_page_cnt:%d, page_cnt:%d, write_data_size:%d\r\n", total_page_cnt, page_cnt, write_data_size);
+             if(read_page_data(write_page, page_cnt, &data[write_data_size], page_cnt*page_size) == -1)
+             {
+                gPrtition.Printf("part: read_page_data fail b:%d, p:%d, p_cnt:%d\r\n", g_partition.block_origin, write_page, page_cnt);
+                return -1;
+             }
+
+             total_page_cnt -= page_cnt;
+             write_data_size += page_cnt*page_size;
+             //gPrtition.Printf("total_page_cnt:%d, write_data_size:%d\r\n", total_page_cnt, write_data_size);  
+             if(write_page + page_cnt == page_per_block)
+             {
+                g_partition.read_block_num++;//
+                g_partition.block_id++;
+             }
+             g_partition.block_origin += g_partition.block_id;
+
+             g_partition.r_w_data_size += page_cnt*page_size;
+             //gPrtition.Printf("g_partition.r_w_data_size :%d\r\n", g_partition.r_w_data_size );  
+        }
+        else
+        {
+            //дҳ
+            break;
+        }
+    }
+
+    //д󲻹һҳ
+    if(data_len%page_size != 0)
+    {
+        unsigned char *pBuf = NULL;
+        pBuf = (unsigned char *)gPrtition.RamAlloc(page_size);
+        if(NULL == pBuf)
+        {
+            gPrtition.Printf("spinand write malloc fail \r\n");
+            return -1;
+        }
+
+        gPrtition.MemSet(pBuf, 0, page_size);
+        
+       // gPrtition.Printf("write_page:%d, readsize:%d\r\n", write_page, data_len%page_size);  
+        if(read_page_data(write_page, 1, pBuf, data_len%page_size) == -1)
+        {
+            gPrtition.RamFree(pBuf);
+            return -1;
+        }
+        
+        gPrtition.MemCpy(&data[write_data_size], pBuf, data_len%page_size);
+
+        write_data_size += data_len%page_size;
+        g_partition.r_w_data_size += data_len%page_size;
+        //gPrtition.Printf("g_partition.r_w_data_size :%d\r\n", g_partition.r_w_data_size );  
+
+        gPrtition.RamFree(pBuf);
+    }
+
+    return data_len;
+}
+
+
+int spinand_set_attr(T_PARTITION_TABLE_INFO *pFile, T_EX_PARTITION_CONFIG *ex_arrt)
+{
+    if(pFile == NULL || ex_arrt == NULL)
+    {
+        gPrtition.Printf("part: spinand_set_attr phandle == NULL || ex_arrt == NULL\r\n");
+        return -1;
+    }
+    
+    gPrtition.MemCpy(&pFile->ex_partition_info, ex_arrt, sizeof(T_EX_PARTITION_CONFIG));
+    
+    g_partition.write_table_flag = 1;
+	g_partition.set_attr_flag = 1;
+    
+    return 0;
+}
+
+
+int spinand_get_attr(T_PARTITION_TABLE_INFO *pFile, T_EX_PARTITION_CONFIG *ex_arrt)
+{
+    
+    if(pFile == NULL || ex_arrt == NULL)
+    {
+        gPrtition.Printf("part: spinand_get_attr phandle == NULL || ex_arrt == NULL\r\n");
+        return -1;
+    }
+    
+    gPrtition.MemCpy(ex_arrt, &pFile->ex_partition_info, sizeof(T_EX_PARTITION_CONFIG));
+
+    return 0;
+}
+
+//
+int move_foward_partition_data(unsigned long start_block, unsigned long end_block, unsigned long dst_start_block, unsigned long *dst_end_block, unsigned long src_backupblcok, unsigned long *dst_backupblcok)
+{
+    unsigned long i = 0, j = 0;
+    unsigned long pages_per_block = m_spinand_burn.pages_per_block;
+    unsigned long dst_block_idex = dst_start_block;
+    unsigned char *buf = NULL;
+    unsigned long page_size = m_spinand_burn.page_size;
+    unsigned long  spare = 0;
+
+
+    buf = (unsigned char *)gPrtition.RamAlloc(page_size);
+    if(NULL == buf)
+    {
+        gPrtition.Printf("spinand write malloc fail \r\n");
+        return -1;
+    }
+
+    gPrtition.MemSet(buf, 0, page_size);
+        
+    for(i = start_block; i < end_block; i++)
+    {
+        //жҪƵĿǷ񻵿
+        if(spinand_is_badblock(i) == 0)
+        {
+            gPrtition.Printf("bb:%d\r\n", i);
+            continue;
+        }
+        
+        //ждĿǷ񻵿
+        while(1)
+        {
+            if(src_backupblcok != 0 && src_backupblcok == i)
+        {
+            *dst_backupblcok = dst_block_idex;
+        }
+            
+MOVE_DATA:         
+        
+            if(dst_block_idex >= i)
+            {
+                gPrtition.RamFree(buf);
+                gPrtition.Printf("dst block less than src block B:%d, db:%d\r\n", i, dst_block_idex);
+                return -1;
+            }
+            
+            if(spinand_is_badblock(dst_block_idex) == 0)
+            {
+                dst_block_idex++;
+                gPrtition.Printf("bb:%d\r\n", dst_block_idex);
+                continue;
+            }
+            else
+            {
+                //һ
+                if(Prod_NandEraseBlock(dst_block_idex) == -1)
+                {
+                    //û
+                    spinand_set_badblock(dst_block_idex);
+                    gPrtition.Printf("erase block fail B:%d, db:%d\r\n", i, dst_block_idex);
+                    dst_block_idex++;
+                    continue;
+                }
+                else
+                {
+                    break;
+                }
+            }
+        }
+        
+        //
+        for(j = 0; j < pages_per_block; j++)
+        {
+            gPrtition.MemSet(buf, 0, page_size);
+            if(Prod_NandReadPage(i, j, buf, (unsigned char *)&spare, 4) == - 1)
+            {
+                gPrtition.RamFree(buf);
+                gPrtition.Printf("move data and read fail b:%d, p:%d\r\n", i, j);
+                return -1;
+            }
+            
+            if(Prod_NandWritePage(dst_block_idex, j, buf, (unsigned char *)&spare, 4) == - 1)
+            {
+                //û
+                spinand_set_badblock(dst_block_idex);
+                break;
+            }
+        }
+
+        if(j < pages_per_block)
+        {
+            //дʧ
+            //ȡǰһд
+            dst_block_idex--;
+            goto MOVE_DATA;
+        }
+        
+    }
+
+    *dst_end_block = dst_block_idex;
+
+    gPrtition.RamFree(buf);
+    return 0;
+}
+
+
+//
+int move_backwards_partition_data(unsigned long start_block, unsigned long end_block, unsigned long dst_end_block, unsigned long *dst_start_block, unsigned long src_backupblcok, unsigned long *dst_backupblcok)
+{
+    unsigned long i = 0, j = 0;
+    unsigned long pages_per_block = m_spinand_burn.pages_per_block;
+    unsigned long dst_block_idex = dst_end_block;
+    unsigned char *buf = NULL;
+    unsigned long page_size = m_spinand_burn.page_size;
+    unsigned long  spare = 0;
+
+
+    buf = (unsigned char *)gPrtition.RamAlloc(page_size);
+    if(NULL == buf)
+    {
+        gPrtition.Printf("spinand write malloc fail \r\n");
+        return -1;
+    }
+
+    gPrtition.MemSet(buf, 0, page_size);
+        
+    for(i = end_block; i >= start_block; i--)
+    {
+        if(spinand_is_badblock(i) == 0)
+        {
+            gPrtition.Printf("bb:%d\r\n", i);
+            continue;
+        }
+
+        if(src_backupblcok != 0 && src_backupblcok == i)
+        {
+            *dst_backupblcok = dst_block_idex;
+        }
+
+MOVE_DATA: 
+        //ждĿǷ񻵿
+        while(1)
+        {
+            if(dst_block_idex < i)
+            {
+                gPrtition.RamFree(buf);
+                gPrtition.Printf("dst block less than src block B:%d, db:%d\r\n", i, dst_block_idex);
+                return -1;
+            }
+            
+            if(spinand_is_badblock(dst_block_idex) == 0)
+            {
+                dst_block_idex--;
+                gPrtition.Printf("bb:%d\r\n", dst_block_idex);
+                continue;
+            }
+            else
+            {
+                //һ
+                if(Prod_NandEraseBlock(dst_block_idex) == -1)
+                {
+                    //û
+                    spinand_set_badblock(dst_block_idex);
+                    gPrtition.Printf("erase block fail B:%d, db:%d\r\n", i, dst_block_idex);
+                    dst_block_idex--;
+                    continue;
+                }
+                else
+                {
+                    break;
+                }
+            }
+        }
+
+
+        //ǻа
+        for(j = 0; j < pages_per_block; j++)
+        {
+            gPrtition.MemSet(buf, 0, page_size);
+            if(Prod_NandReadPage(i, j, buf, (unsigned char *)&spare, 4) == - 1)
+            {
+                gPrtition.RamFree(buf);
+                gPrtition.Printf("move data and read fail b:%d, p:%d\r\n", i, j);
+                return -1;
+            }
+            
+            if(Prod_NandWritePage(dst_block_idex, j, buf, (unsigned char *)&spare, 4) == - 1)
+            {
+                //û
+                spinand_set_badblock(dst_block_idex);
+                break;
+            }
+        }
+
+        if(j < pages_per_block)
+        {
+            //дʧ
+            //ȡǰһд
+            dst_block_idex--;
+            goto MOVE_DATA;
+            
+        }
+        
+    }
+
+    *dst_start_block = dst_block_idex;
+    
+    gPrtition.RamFree(buf);
+    return 0;
+}
+int get_partition_endblock(unsigned long start_block, unsigned long block_num, unsigned long *end_block)
+{
+    unsigned long start_block_idex = start_block;
+    unsigned long block_idex = 0;
+    unsigned long page_size = m_spinand_burn.page_size;
+    unsigned long page_per_block = m_spinand_burn.pages_per_block;
+    unsigned long total_block = m_spinand_burn.total_size/page_size/page_per_block;
+    
+    while(1)
+    {
+        if(start_block_idex > total_block)
+        {
+            gPrtition.Printf("block more than total block:%d, %d\r\n", start_block_idex, total_block);
+            return -1;
+        }   
+        
+        if(spinand_is_badblock(start_block_idex) == 0)
+        {
+            gPrtition.Printf("bb:%d\r\n", start_block_idex);
+            start_block_idex++;
+            continue;
+        }
+        start_block_idex++;
+        block_idex++;
+        if(block_idex == block_num)
+        {
+            *end_block = start_block_idex;
+            break;
+        }
+
+        
+    }
+    
+    return 0;
+}
+
+//С
+int spinand_resize(unsigned char *partition_name, unsigned long partition_size)
+{
+    unsigned char *buf = NULL;
+    unsigned long page_size = m_spinand_burn.page_size;
+    unsigned long page_per_block = m_spinand_burn.pages_per_block;
+    //unsigned long total_block = m_spinand_burn.total_size/page_size/page_per_block;
+    unsigned long  i = 0;
+    unsigned long file_num = 0;
+    unsigned long name_idex = 0;
+    T_PARTITION_TABLE_INFO *partition_temp;
+    T_PARTITION_TABLE_INFO partition;
+    T_PARTITION_TABLE_INFO last_partition;
+    unsigned long src_partition_size = 0;
+   // unsigned long start_page = 0;
+    //unsigned long move_page_cnt = 0;
+    //unsigned long next_start_page = 0;
+   // unsigned long last_page = 0;
+    unsigned long partition_size_block = 0;
+    unsigned long last_start_block = 0;
+    unsigned long last_block_num = 0;
+    unsigned long block_idex = 0;
+    unsigned long add_block_num = 0;
+    unsigned long add_end_block = 0;
+   // unsigned char add_start_flag = 0;
+    unsigned long move_start_block = 0;
+    unsigned long move_end_block = 0;
+    unsigned long move_dst_end_block = 0;
+    unsigned long  move_dst_start_block = 0;
+    unsigned long src_backupblock = 0, dst_backupblock = 0;
+    
+    
+    if(NULL == partition_name)
+    {
+       gPrtition.Printf("part: spinand_resize AK_NULL == partition_name\r\n");
+        return -1; 
+    }
+
+    if(sflash_str_len(partition_name) > PARTITION_NAME_LEN)
+    {
+        gPrtition.Printf("part: spinand_resize the partition name len more than %d\r\n", PARTITION_NAME_LEN);
+        return -1;
+    }
+
+    if(partition_size == 0)//ɾ
+    {
+         gPrtition.Printf("part: spinand_resize partition_size ==0\r\n");
+        return -1; 
+    }
+    
+    if(1 != g_partition.init_success_flag)
+    {
+        if (NULL != gPrtition.Printf)
+        {
+            gPrtition.Printf("part: spinand_resize not Sflash_Init\r\n");
+        }
+        return -1;
+    }
+
+    if(g_partition.open_time == 1)
+    {
+        gPrtition.Printf("part: spinand_resize the other partition name is openning\r\n");
+        return -1;
+    }
+    
+    //ͨķжϷǷ
+     buf = gPrtition.RamAlloc(page_size*sizeof(unsigned char));
+    if(NULL == buf)
+    {
+        gPrtition.Printf("part: spinand_resize buf malloc fail\r\n");
+        return -1;
+    }
+
+    gPrtition.MemSet(buf, 0x0, page_size*sizeof(unsigned char));
+    //gPrtition.Printf("read partition_table_start:%d\r\n", m_spi_burn.partition_table_start);
+    if(-1 == read_partition_table(buf))
+    {
+        gPrtition.RamFree(buf);
+        gPrtition.Printf("part: spinand_resize read_partition_table fail\r\n");
+        return -1;
+    }
+
+    gPrtition.MemCpy(&file_num, buf, 4);
+    gPrtition.Printf("part: spinand_resize file_num:%d\r\n", file_num);
+   
+    if(file_num == 0 || file_num == 0xFFFFFFFF || file_num >= g_partition_file_max_num)
+    {
+        gPrtition.RamFree(buf);
+        gPrtition.Printf("part: spinand_resize file_num:%d error\r\n", file_num);
+        return -1;
+    }
+    
+    //жϷǷ
+    if(0 != spinand_check_name_is_exist(partition_name, buf, file_num, &name_idex))
+    {
+        gPrtition.RamFree(buf);
+        gPrtition.Printf("part: spinand_resize partition_name :%s is not exist\r\n", partition_name);
+        return -1;
+    }
+    
+    //ȡ
+    gPrtition.MemCpy(&partition, &buf[name_idex*sizeof(T_PARTITION_TABLE_INFO) + 4], sizeof(T_PARTITION_TABLE_INFO));
+    gPrtition.Printf("change type:%d \n", partition.partition_info.type);
+    gPrtition.Printf("change r_w_flag:%d \n", partition.partition_info.r_w_flag);
+    gPrtition.Printf("change page_cnt:%d \n", partition.partition_info.ksize);
+    gPrtition.Printf("change start_page:%d \n", partition.partition_info.start_pos);
+    gPrtition.Printf("change name:%s \n", partition.partition_info.name);
+    
+    gPrtition.MemCpy(&last_partition, &buf[(file_num - 1)*sizeof(T_PARTITION_TABLE_INFO) + 4], sizeof(T_PARTITION_TABLE_INFO));
+    
+    gPrtition.Printf("last change type:%d \n", last_partition.partition_info.type);
+    gPrtition.Printf("last change r_w_flag:%d \n", last_partition.partition_info.r_w_flag);
+    gPrtition.Printf("last change page_cnt:%d \n", last_partition.partition_info.ksize);
+    gPrtition.Printf("last change start_page:%d \n", last_partition.partition_info.start_pos);
+    gPrtition.Printf("last change name:%s \n", last_partition.partition_info.name);
+    
+    src_partition_size = partition.partition_info.ksize*K_SIZE;
+
+    //С룬ƽ̨ĴСȽ
+    partition_size_block = (partition_size*K_SIZE + m_spinand_burn.page_size - 1)/m_spinand_burn.page_size;
+    partition_size_block = (partition_size_block + m_spinand_burn.pages_per_block - 1)/m_spinand_burn.pages_per_block;
+    partition_size_block = partition_size_block * m_spinand_burn.pages_per_block*m_spinand_burn.page_size;
+    gPrtition.Printf("part: partition_size_block:%d, src_partition_size:%d\r\n", partition_size_block, src_partition_size);
+    
+    
+    //жϷǱǱС
+    if(partition_size_block == src_partition_size)
+    {
+        gPrtition.RamFree(buf);
+        gPrtition.Printf("part: partition size is same, no need move data\r\n");
+        return -1; 
+    }
+    else if(partition_size_block > src_partition_size)//Ӵ
+    {
+        //жspinandǷ㹻ռ
+        last_start_block = last_partition.partition_info.start_pos/page_size/m_spinand_burn.pages_per_block;         
+        last_block_num = (last_partition.partition_info.ksize*K_SIZE)/page_size/m_spinand_burn.pages_per_block;
+        add_block_num = partition_size_block/page_size/m_spinand_burn.pages_per_block;
+
+        //ȡһĽ
+        if(get_partition_endblock(move_start_block, last_block_num, &move_end_block) == -1)
+        {
+            gPrtition.RamFree(buf);
+            gPrtition.Printf("part: get_partition_endblock fail\r\n");
+            return -1; 
+        }
+
+        //жҪӵĴСǷ㹻Ŀռ䣬ȡӵĽ
+        if(get_partition_endblock(move_end_block, add_block_num, &add_end_block) == -1)
+        {
+            gPrtition.RamFree(buf);
+            gPrtition.Printf("part: it is not have free \r\n");
+            return -1; 
+        }
+
+        //еĻͰ
+
+        //ǰÿһаƣ
+        //һգʱһҳдʧˣͰѴ˿Ϊ飬ǻᵼûпռʧܣӶҪ¼
+
+        //ÿһа
+        for(i = file_num - 1; i > name_idex; i--)
+        {
+            partition_temp = (T_PARTITION_TABLE_INFO *)&buf[i*sizeof(T_PARTITION_TABLE_INFO) + 4];
+            move_start_block = (partition_temp->partition_info.start_pos/page_size);
+            move_start_block = move_start_block/page_per_block;
+            last_block_num = ((partition_temp->partition_info.ksize*K_SIZE)/page_size);
+            last_block_num = last_block_num/page_per_block;
+
+            if(i == file_num - 1)
+            {
+                move_dst_end_block = add_end_block;
+            }
+            else
+            {
+                move_dst_end_block = move_dst_start_block - 1; 
+            }
+            //ȡ
+            if(get_partition_endblock(move_start_block, last_block_num, &move_end_block) == -1)
+            {
+                gPrtition.RamFree(buf);
+                gPrtition.Printf("part: get_partition_endblock fail\r\n");
+                return -1; 
+            }
+
+            if(move_dst_end_block <= move_end_block)
+            {
+                gPrtition.RamFree(buf);
+                gPrtition.Printf("part: not move free block %d, %d\r\n", move_dst_end_block, move_end_block);
+                return -1; 
+            }
+
+            if(partition_temp->partition_info.type == PART_BIN_TYPE || partition_temp->partition_info.type == PART_DATA_TYPE)
+            {
+                if(partition_temp->ex_partition_info.parameter3 != 0xFFFFFFFF)
+                {
+                    src_backupblock = (partition_temp->ex_partition_info.parameter3/page_per_block);
+                    src_backupblock = src_backupblock/page_size;
+                }
+            }
+
+            //Ʒ
+            if(-1 == move_backwards_partition_data(move_start_block, move_end_block-1, move_dst_end_block, &move_dst_start_block, src_backupblock, &dst_backupblock))
+            {
+                gPrtition.RamFree(buf);
+                gPrtition.Printf("part: move_partition_data fail\r\n");
+                return -1; 
+            }
+
+            partition_temp->partition_info.start_pos = move_dst_start_block*page_per_block*page_size;
+            if(partition_temp->partition_info.type == PART_BIN_TYPE || partition_temp->partition_info.type == PART_DATA_TYPE)
+            {
+                if(partition_temp->ex_partition_info.parameter3 != 0xFFFFFFFF)
+                {
+                    partition_temp->ex_partition_info.parameter3 = dst_backupblock*page_per_block*page_size;
+                }
+            }
+        }
+
+        
+    }
+    else//С
+    {
+        //
+
+        for(i = name_idex; i < file_num; i++)
+        {
+            partition_temp = (T_PARTITION_TABLE_INFO *)&buf[i*sizeof(T_PARTITION_TABLE_INFO) + 4];
+            move_start_block = (partition_temp->partition_info.start_pos/page_size);
+            move_start_block = move_start_block/page_per_block;
+            last_block_num = ((partition_temp->partition_info.ksize*K_SIZE)/page_size);
+            last_block_num = last_block_num/page_per_block;
+
+            //ȡ
+            if(get_partition_endblock(move_start_block, last_block_num, &move_end_block) == -1)
+            {
+                gPrtition.RamFree(buf);
+                gPrtition.Printf("part: get_partition_endblock fail\r\n");
+                return -1; 
+            }
+
+            //һֻҪ¼ϢͿ
+            if(i == name_idex)
+            {
+                last_block_num = (src_partition_size/page_size);
+                last_block_num = last_block_num/page_per_block;
+                block_idex = move_start_block;
+                while(1)
+                {
+                    if(block_idex > move_end_block)
+                    {
+                        gPrtition.RamFree(buf);
+                        gPrtition.Printf("part:error more than the partition end block \r\n");
+                        return -1; 
+                    }
+                    
+                    if(spinand_is_badblock(block_idex) == 0)
+                    {
+                        gPrtition.Printf("bb:%d\r\n", block_idex);
+                        block_idex++;
+                        continue;
+                    }
+                    else
+                    {
+                        if(block_idex >= last_block_num)
+                        {
+                            break;
+                        }
+                        block_idex++;
+                    }
+                }
+                
+                move_dst_end_block = block_idex;
+                partition_temp->partition_info.ksize = src_partition_size/K_SIZE;
+                continue;
+            }
+
+
+            //ǰһһ
+            move_dst_start_block = move_dst_end_block;
+
+            if(partition_temp->partition_info.type == PART_BIN_TYPE || partition_temp->partition_info.type == PART_DATA_TYPE)
+            {
+                if(partition_temp->ex_partition_info.parameter3 != 0xFFFFFFFF)
+                {
+                    src_backupblock = (partition_temp->ex_partition_info.parameter3/page_per_block);
+                    src_backupblock = src_backupblock/page_size;
+                }
+            }
+
+            
+            //
+            if(-1 == move_foward_partition_data(move_start_block, move_end_block - 1, move_dst_start_block, &move_dst_end_block, src_backupblock ,&dst_backupblock))
+            {
+                gPrtition.RamFree(buf);
+                gPrtition.Printf("part:move_foward_partition_data fail \r\n");
+                return -1; 
+            }
+
+            //¼Ϣ
+            partition_temp->partition_info.start_pos = move_dst_start_block*page_per_block*page_size;
+            if(partition_temp->partition_info.type == PART_BIN_TYPE || partition_temp->partition_info.type == PART_DATA_TYPE)
+            {
+                if(partition_temp->ex_partition_info.parameter3 != 0xFFFFFFFF)
+                {
+                    partition_temp->ex_partition_info.parameter3 = dst_backupblock*page_per_block*page_size;
+                }
+            }
+
+        }
+    }
+
+    //д
+    if(write_partition_table(buf) == -1)
+    {
+        gPrtition.RamFree(buf);
+        gPrtition.Printf("part: spinand_close write_partition_table fail\r\n");
+        return -1;
+    }
+
+    if(buf != NULL)
+    {
+        gPrtition.RamFree(buf);
+        buf = NULL;
+    }
+    
+    return 0;
+}
+
+
+int spinand_delete(unsigned char *partition_name)
+{
+    unsigned char *buf = NULL;
+    unsigned long page_size = m_spinand_burn.page_size;
+    unsigned long page_per_block = m_spinand_burn.pages_per_block;
+    //unsigned long total_block = m_spinand_burn.total_size/page_size/page_per_block;
+    unsigned long i = 0;
+    unsigned long file_num = 0;
+    unsigned long name_idex = 0;
+    T_PARTITION_TABLE_INFO *partition_temp = NULL;
+    T_PARTITION_TABLE_INFO *partition = NULL;
+
+   // unsigned long src_partition_size = 0;
+    //unsigned long start_page = 0;
+    //unsigned long move_page_cnt = 0;
+   // unsigned long next_start_page = 0;
+   // unsigned long last_page = 0;
+   // unsigned long partition_size_block = 0;
+   // unsigned long last_start_block = 0;
+    unsigned long last_block_num = 0;
+   // unsigned long block_idex = 0;
+   // unsigned long add_block_num = 0;
+   // unsigned long add_end_block = 0;
+   // unsigned char add_start_flag = 0;
+    unsigned long move_start_block = 0;
+    unsigned long move_end_block = 0;
+    unsigned long move_dst_end_block = 0;
+    unsigned long  move_dst_start_block = 0;
+    unsigned long src_backup_block= 0, dst_backup_block = 0;
+    T_BIN_CONFIG bin_config;
+    
+    
+    if(NULL == partition_name)
+    {
+       gPrtition.Printf("part: spinand_resize AK_NULL == partition_name\r\n");
+        return -1; 
+    }
+
+    if(sflash_str_len(partition_name) > PARTITION_NAME_LEN)
+    {
+        gPrtition.Printf("part: spinand_resize the partition name len more than %d\r\n", PARTITION_NAME_LEN);
+        return -1;
+    }
+
+    if(1 != g_partition.init_success_flag)
+    {
+        if (NULL != gPrtition.Printf)
+        {
+            gPrtition.Printf("part: spinand_resize not Sflash_Init\r\n");
+        }
+        return -1;
+    }
+
+    if(g_partition.open_time == 1)
+    {
+        gPrtition.Printf("part: spinand_resize the other partition name is openning\r\n");
+        return -1;
+    }
+    
+    //ͨķжϷǷ
+     buf = gPrtition.RamAlloc(page_size*sizeof(unsigned char));
+    if(NULL == buf)
+    {
+        gPrtition.Printf("part: spinand_resize buf malloc fail\r\n");
+        return -1;
+    }
+
+    gPrtition.MemSet(buf, 0x0, page_size*sizeof(unsigned char));
+    //gPrtition.Printf("read partition_table_start:%d\r\n", m_spi_burn.partition_table_start);
+    if(-1 == read_partition_table(buf))
+    {
+        gPrtition.RamFree(buf);
+        gPrtition.Printf("part: spinand_resize read_partition_table fail\r\n");
+        return -1;
+    }
+
+    gPrtition.MemCpy(&file_num, buf, 4);
+    gPrtition.Printf("part: spinand_resize file_num:%d\r\n", file_num);
+   
+    if(file_num == 0 || file_num == 0xFFFFFFFF || file_num >= g_partition_file_max_num)
+    {
+        gPrtition.RamFree(buf);
+        gPrtition.Printf("part: spinand_resize file_num:%d error\r\n", file_num);
+        return -1;
+    }
+    
+    //жϷǷ
+    if(0 != spinand_check_name_is_exist(partition_name, buf, file_num, &name_idex))
+    {
+        gPrtition.RamFree(buf);
+        gPrtition.Printf("part: spinand_resize partition_name :%s is not exist\r\n", partition_name);
+        return -1;
+    }
+
+    partition = gPrtition.RamAlloc(file_num*sizeof(T_PARTITION_TABLE_INFO) + 4 + 1);
+    if(partition == NULL)
+    {
+        gPrtition.RamFree(buf);
+        gPrtition.Printf("part: partition malloc fail\r\n");
+        return -1;
+    }
+    gPrtition.MemSet(partition, 0, file_num*sizeof(T_PARTITION_TABLE_INFO) + 4+1);
+    gPrtition.MemCpy(partition, buf, file_num*sizeof(T_PARTITION_TABLE_INFO) + 4);
+
+    //
+    if(name_idex == file_num - 1)
+    {
+        //һҪ
+    }
+    else
+    {
+        for(i = name_idex; i < file_num; i++)
+        {
+            partition_temp = (T_PARTITION_TABLE_INFO *)&buf[i*sizeof(T_PARTITION_TABLE_INFO) + 4];
+            move_start_block = (partition_temp->partition_info.start_pos/page_size)/page_per_block;
+            last_block_num = ((partition_temp->partition_info.ksize*K_SIZE)/page_size)/page_per_block;
+
+            //ȡ
+            if(get_partition_endblock(move_start_block, last_block_num, &move_end_block) == -1)
+            {
+                gPrtition.RamFree(partition);
+                gPrtition.RamFree(buf);
+                gPrtition.Printf("part: get_partition_endblock fail\r\n");
+                return -1; 
+            }
+
+            if(i == name_idex)
+            {
+                move_dst_start_block = move_start_block;
+            }
+            else
+            {
+                move_dst_start_block = move_dst_end_block;
+            }
+
+            if(partition_temp->partition_info.type == PART_BIN_TYPE || partition_temp->partition_info.type == PART_DATA_TYPE)
+            {
+                
+                gPrtition.MemCpy(&bin_config, &partition_temp->ex_partition_info, sizeof(T_BIN_CONFIG));
+                if(bin_config.backup_pos != 0xFFFFFFFF)
+                {
+                   src_backup_block = bin_config.backup_pos/page_size;
+                   src_backup_block = src_backup_block/page_per_block;
+                   gPrtition.Printf("part:src_backup_block:%d\r\n", src_backup_block);
+                }
+                else
+                {
+                    src_backup_block = 0;
+                }
+            }
+
+            
+            //
+            if(-1 == move_foward_partition_data(move_start_block, move_end_block - 1, move_dst_start_block, &move_dst_end_block, src_backup_block, &dst_backup_block))
+            {
+                gPrtition.RamFree(partition);
+                gPrtition.RamFree(buf);
+                gPrtition.Printf("part:move_foward_partition_data fail \r\n");
+                return -1; 
+            }
+
+            //¼ʼλ
+            partition->partition_info.start_pos = move_dst_start_block*page_per_block*page_size;
+            if(src_backup_block != 0)
+            {
+                partition->ex_partition_info.parameter3 = dst_backup_block*page_per_block*page_size;
+            }
+
+            
+        }
+            
+    }
+
+    //
+    gPrtition.MemCpy(&partition[name_idex*sizeof(T_PARTITION_TABLE_INFO) + 4], &partition[(name_idex + 1)*sizeof(T_PARTITION_TABLE_INFO) + 4], (file_num - 1 - name_idex)*sizeof(T_PARTITION_TABLE_INFO));
+    file_num--;
+    gPrtition.MemCpy(&partition[0], &file_num, 4);
+    //0
+    gPrtition.MemSet(&partition[file_num*sizeof(T_PARTITION_TABLE_INFO) + 4], 0xFF, sizeof(T_PARTITION_TABLE_INFO));
+
+
+    //дϢ?
+    if(write_partition_table((unsigned char *)partition) == -1)
+    {
+        gPrtition.RamFree(partition);
+        gPrtition.RamFree(buf);
+        gPrtition.Printf("part: spinand_close write_partition_table fail\r\n");
+        return -1;
+    }
+
+    if(buf != NULL)
+    {
+        gPrtition.RamFree(buf);
+    }
+
+    if(partition != NULL)
+    {
+        gPrtition.RamFree(partition);
+    }
+    return 0;
+}
+
+
+
+//ҳС2KspiflashҳһԶһ2K
+int spinand_get_partition_table(T_PARTITION_TABLE_CONFIG *part_talbe)
+{
+    if(NULL == part_talbe)
+    {
+       gPrtition.Printf("part: spinand_get_partition_table buf == AK_NULL\r\n");
+        return -1; 
+    }
+
+    if(1 != g_partition.init_success_flag)
+    {
+        if (NULL != gPrtition.Printf)
+        {
+            gPrtition.Printf("part: spinand_get_partition_table not Sflash_Init\r\n");
+        }
+        return -1;
+    }
+
+    gPrtition.MemSet(part_talbe->table, 0x0, 512);
+    if(-1 == read_partition_table(part_talbe->table))
+    {
+        gPrtition.Printf("part: spinand_get_partition_table read_partition_table fail\r\n");
+        return -1;
+    }
+
+    part_talbe->pos = m_spinand_burn.partition_table_start*m_spinand_burn.page_size;
+
+    return 0;
+}
+
+
+int spinand_get_partition_backup_table(T_PARTITION_TABLE_CONFIG *part_talbe)
+{
+	 if(NULL == part_talbe)
+    {
+       gPrtition.Printf("part: spinand_get_partition_table buf == AK_NULL\r\n");
+        return -1; 
+    }
+
+    if(1 != g_partition.init_success_flag)
+    {
+        if (NULL != gPrtition.Printf)
+        {
+            gPrtition.Printf("part: spinand_get_partition_table not Sflash_Init\r\n");
+        }
+        return -1;
+    }
+
+    gPrtition.MemSet(part_talbe->table, 0x0, 512);
+
+	
+	gPrtition.Printf("part: spinand_get_partition_backup_table no support\r\n");
+
+    return 0;
+}
+
+
+
+unsigned long spinand_get_partition_ksize(T_PARTITION_TABLE_INFO *phandle)
+{
+    if(phandle == NULL)
+    {
+        gPrtition.Printf("part: spinand_get_partition_ksize phandle == NULL\r\n");
+        return 0;
+    }
+
+    return phandle->partition_info.ksize;
+    
+    return 0;
+}
+
+
+unsigned long spinand_get_partition_data_size(T_PARTITION_TABLE_INFO *phandle)
+{
+    T_FS_CONFIG fs_config;
+    T_BIN_CONFIG bin_config;
+    unsigned long lenght = 0;
+	unsigned long block_size = 0;
+	unsigned long block_num = 0;
+
+    if(phandle == NULL)
+    {
+        gPrtition.Printf("part: spinand_get_partition_data_size phandle == NULL\r\n");
+        return 0;
+    }
+
+    if(phandle->partition_info.type == PART_BIN_TYPE || phandle->partition_info.type == PART_DATA_TYPE)
+    {
+        gPrtition.MemCpy(&bin_config, &phandle->ex_partition_info, sizeof(T_BIN_CONFIG));
+        lenght = bin_config.file_length;
+    }
+    else if(phandle->partition_info.type == PART_FS_TYPE)
+    {
+        gPrtition.MemCpy(&fs_config, &phandle->ex_partition_info, sizeof(T_FS_CONFIG));
+
+		//ΪoobҪOOBĳ
+		block_size = (m_spinand_burn.pages_per_block*m_spinand_burn.page_size);
+		block_num = phandle->partition_info.ksize*K_SIZE/block_size;
+        lenght = phandle->partition_info.ksize*K_SIZE + m_spinand_burn.oob_size *(block_size/m_spinand_burn.page_size)*block_num;//fs_config.file_length;
+    }
+    else
+    {
+        gPrtition.Printf("Partition_Get_DataSize type is error\r\n");
+        return 0;
+    }
+
+    gPrtition.Printf("spinand_get_partition_data_size:%d\r\n", lenght);
+
+    return lenght;
+    
+    return 0;
+}
+
+
+
+
+void spinand_set_partition_startpage(unsigned long start_page)
+{
+    m_spinand_burn.partition_table_start = start_page;
+    gPrtition.Printf("partition_table_start:%d\r\n", m_spinand_burn.partition_table_start);
+
+}
+
+
+void spinand_get_partition_startpage(unsigned long *start_page, unsigned long *backup_start_page)
+{
+    *start_page = m_spinand_burn.partition_table_start;
+    gPrtition.Printf("partition_table_start:%d\r\n", m_spinand_burn.partition_table_start);
+
+    
+    *backup_start_page = m_spinand_burn.partition_table_start_backup;
+    gPrtition.Printf("partition_table_start_backup:%d\r\n", m_spinand_burn.partition_table_start_backup);
+
+}
+
+#endif
+
+
+
+
+
+
+
+
+
diff --git a/drivers/mtd/partition/spinand_burn.h b/drivers/mtd/partition/spinand_burn.h
new file mode 100755
index 0000000..b85f53e
--- /dev/null
+++ b/drivers/mtd/partition/spinand_burn.h
@@ -0,0 +1,240 @@
+#ifndef _SPINAND_BURN_H_
+#define _SPINAND_BURN_H_
+
+
+//#include <stdio.h>
+//#include <stdlib.h>
+//#include <stdarg.h>
+//#include <string.h>
+#include "partition_lib.h"
+#include "partition_init.h"
+
+
+
+
+extern T_FHA_LIB_CALLBACK  gPrtition;
+
+//#define     PARTITION_TALBE_PAGE_NUM            1
+
+#define		SPINAND_PARAM_OFFSET	            0x200 
+
+
+
+typedef enum
+{
+    FHA_CHIP_10XX,      //snowbirdL
+    FHA_CHIP_39XX,      //AK39XX
+}E_CHIP_TYPE;
+
+
+typedef enum
+{
+    PLAT_RTOS,          //spot system
+    PLAT_LINUX          //linux system
+}E_PLATFORM_TYPE;
+
+typedef enum
+{
+    MEDIUM_SPIFLASH,            //spiflash
+    MEDIUM_SPI_NAND,                //nand
+}E_MEDIUM_TYPE;
+
+typedef enum
+{
+    MODE_NEWBURN = 1,           //new burn
+    MODE_UPDATE,                //update mode
+}E_BURN_MODE;
+
+#if 0
+typedef struct tag_FHA_Init_Info
+{
+    unsigned long   nChipCnt;                //Ƭѡ
+    unsigned long   nBlockStep;            //nand block stepֵ
+    E_CHIP_TYPE     eAKChip;    //AKоƬ
+    E_PLATFORM_TYPE ePlatform;  //ϵͳ
+    E_MEDIUM_TYPE   eMedium;    //洢
+    E_BURN_MODE     eMode;        //¼ģʽ
+}T_PART_INIT_INFO, *T_PPART_INIT_INFO;
+#endif
+
+/*
+typedef struct tag_NandConfig{
+    unsigned char  Resv[4];
+    unsigned long BinFileCount;
+    unsigned long ResvStartBlock;
+    unsigned long ResvBlockCount;
+    unsigned long BootLength;
+    unsigned long BinStartBlock;
+    unsigned long BinEndBlock;
+    unsigned long ASAStartBlock;
+    unsigned long ASAEndBlock;
+    unsigned char  Resv_ex[28];
+}T_NAND_CONFIG;
+*/
+
+typedef struct
+{
+    unsigned long block_origin; //origin block
+    unsigned long block_backup; //backup block
+}T_PROD_BLOCK;
+
+
+//burn bin file information
+/*
+typedef struct
+{
+    unsigned long BinStartBlock;    //bin data start block
+    unsigned long file_index;       //bin file count index
+    unsigned long BlockIndex;       //bin block index in bin map relation buffer    
+    unsigned long StartPage;        //bin startpage in a block
+    unsigned long totalpagecnt;     //bin total size
+    unsigned char bBackup;         //bin backup
+    unsigned char bCheck;          //bin check self
+    unsigned char bUpdateSelf;     //spotlight update self, gave bin reserve same space
+    unsigned char bWriteBoot;      //write nand boot flag
+    T_PROD_BLOCK EndBlock;  //origin and backup block when writing bin data
+}T_DOWNLOAD_BIN;
+*/
+
+
+
+
+//static T_NAND_CONFIG    m_nand_config = {0};
+//static T_DOWNLOAD_BIN   m_DloadBin = {0};
+
+
+/************************************************************************
+ * NAME:     spinand_init
+ * FUNCTION  partition init
+ * PARAM:    [in] T_pVOID SpiInfo
+ * RETURN:    success return 0, fail retuen -1
+**************************************************************************/
+int spinand_init(void *PhyInfo, unsigned long table_page);
+
+/************************************************************************
+ * NAME:     spinand_creat
+ * FUNCTION  partition creat
+ * PARAM:    [in] T_CREAT_PARTITION_INFO *partition
+ * RETURN:   success return T_PARTITION_TABLE_INFO *pFile, fail retuen AK_NULL
+**************************************************************************/
+T_PARTITION_TABLE_INFO *spinand_creat(T_CREAT_PARTITION_INFO *partition);
+
+/************************************************************************
+ * NAME:     spinand_close
+ * FUNCTION  partition close
+ * PARAM:    [in] T_PARTITION_TABLE_INFO *pFile
+ * RETURN:    success return 0, fail retuen -1
+**************************************************************************/
+int spinand_close(T_PARTITION_TABLE_INFO *pFile);
+
+/************************************************************************
+ * NAME:     spinand_open
+ * FUNCTION  partition open
+ * PARAM:    [in] T_U8 *partition_name
+ * RETURN:   success return T_PARTITION_TABLE_INFO *pFile, fail retuen AK_NULL
+**************************************************************************/
+T_PARTITION_TABLE_INFO *spinand_open(unsigned char *partition_name);
+
+/************************************************************************
+ * NAME:     spinand_write
+ * FUNCTION  partition write
+ * PARAM:    [in] T_PARTITION_TABLE_INFO *pFile, 
+                   [in] T_U8 *data, 
+                   [in]  T_U32 data_len
+ * RETURN:    success return 0, fail retuen -1
+**************************************************************************/
+int spinand_write(T_PARTITION_TABLE_INFO *pFile, unsigned char *data, unsigned long data_len);
+
+
+/************************************************************************
+ * NAME:     spinand_read
+ * FUNCTION  partition read
+ * PARAM:    [in] T_PARTITION_TABLE_INFO *pFile, 
+                   out] T_U8 *data, 
+                   [in]  T_U32 data_len
+ * RETURN:    success return 0, fail retuen -1
+**************************************************************************/
+int spinand_read(T_PARTITION_TABLE_INFO *pFile, unsigned char *data, unsigned long data_len);
+
+/************************************************************************
+ * NAME:     spinand_set_attr
+ * FUNCTION  spinand_set_attr
+ * PARAM:    
+                   out] T_PARTITION_TABLE_CONFIG *part_talbe; 
+ * RETURN:   success return 0, fail retuen -1
+**************************************************************************/
+
+int spinand_set_attr(T_PARTITION_TABLE_INFO *pFile, T_EX_PARTITION_CONFIG *ex_arrt);
+
+/************************************************************************
+ * NAME:     spinand_get_attr
+ * FUNCTION  spinand_get_attr
+ * PARAM:    
+                   out] T_PARTITION_TABLE_CONFIG *part_talbe; 
+ * RETURN:   success return 0, fail retuen -1
+**************************************************************************/
+
+int spinand_get_attr(T_PARTITION_TABLE_INFO *pFile, T_EX_PARTITION_CONFIG *ex_arrt);
+
+/************************************************************************
+ * NAME:     spinand_resize
+ * FUNCTION  spinand_resize
+ * PARAM:    unsigned char *partition_name,
+                   unsigned long partition_size  K
+ * RETURN:   success return 0, fail retuen -1
+**************************************************************************/
+
+int spinand_resize(unsigned char *partition_name, unsigned long partition_size);
+
+/************************************************************************
+ * NAME:     spinand_get_partition_table
+ * FUNCTION  spinand_get_partition_table
+ * PARAM:    
+                   out] T_PARTITION_TABLE_CONFIG *part_talbe; 
+ * RETURN:   success return 0, fail retuen -1
+**************************************************************************/
+int spinand_get_partition_table(T_PARTITION_TABLE_CONFIG *part_talbe);
+int spinand_get_partition_backup_table(T_PARTITION_TABLE_CONFIG *part_talbe);
+
+
+
+/************************************************************************
+ * NAME:     spinand_delete
+ * FUNCTION  spinand_delete
+ * PARAM:    
+                   [int]unsigned char *partition_name
+ * RETURN:   success return 0, fail retuen -1
+**************************************************************************/
+int spinand_delete(unsigned char *partition_name);
+
+
+/************************************************************************
+ * NAME:     spinand_get_partition_ksize
+ * FUNCTION  spinand_get_partition_ksize
+ * PARAM:    
+                   [int]unsigned char *partition_name
+ * RETURN:   success return 0, fail retuen -1
+**************************************************************************/
+unsigned long spinand_get_partition_ksize(T_PARTITION_TABLE_INFO *phandle);
+
+
+/************************************************************************
+ * NAME:     spinand_get_partition_data_size
+ * FUNCTION  spinand_get_partition_data_size
+ * PARAM:    
+                   [int]T_PARTITION_TABLE_INFO *phandle
+ * RETURN:   success return data_size, fail retuen -1
+**************************************************************************/
+unsigned long spinand_get_partition_data_size(T_PARTITION_TABLE_INFO *phandle);
+	
+
+
+
+void spinand_set_partition_startpage(unsigned long start_block);
+void spinand_get_partition_startpage(unsigned long *start_page, unsigned long *backup_start_page);
+
+
+
+
+#endif
+
diff --git a/drivers/mtd/partition/spinand_driver.c b/drivers/mtd/partition/spinand_driver.c
new file mode 100755
index 0000000..9cc9c50
--- /dev/null
+++ b/drivers/mtd/partition/spinand_driver.c
@@ -0,0 +1,215 @@
+/**
+ * @FILENAME: spiburn.c
+ * @BRIEF xx
+ * Copyright (C) 2011 Anyka (GuangZhou) Software Technology Co., Ltd.
+ * @AUTHOR luqiliu
+ * @DATE 2009-11-19
+ * @VERSION 1.0
+ * @modified lu 2011-11-03
+
+ * @REF
+ */
+
+#include "spinand_driver.h"
+#include "spinand_burn.h"
+#include "spinand_badblock.h"
+#include "public_info.h"
+#include "partition_lib.h"
+
+
+
+
+#ifdef SUPPORT_SPINAND 
+
+extern T_FHA_LIB_CALLBACK  gPrtition;
+extern T_FHA_LIB_CALLBACK  spinand_gPrtition;
+
+extern T_PARTITION  g_partition;
+extern T_SPINAND_INIT_INFO m_spinand_burn ;
+extern T_BIN_NAND_INFO  m_bin_nand_info;
+extern T_NAND_PHY_INFO    g_nand_phy_info;
+
+
+
+
+
+
+//logic block to physical block 
+unsigned long Prod_LB2PB(unsigned long LogBlock)
+{
+     //gFHAf.Printf("LogBlock B_%d, step:%d\r\n", LogBlock, g_burn_param.nBlockStep);
+      return  LogBlock;
+}
+
+//physical block to logic block
+
+unsigned long Prod_PB2LB(unsigned long PhyBlock)
+{
+      return PhyBlock;
+}
+
+/**
+ * @BREIF    Prod_NandEraseBlock
+ * @AUTHOR   luqiliu
+ * @DATE     2009-12-10
+ * @RETURN   T_U32 
+ * @retval   FHA_SUCCESS :  succeed
+ * @retval   FHA_FAIL :     fail
+ */
+
+int Prod_NandEraseBlock(unsigned long block_index)
+{
+    unsigned long phyBlock = Prod_LB2PB(block_index);
+    unsigned long page_addr;
+
+    //gFHAf.Printf("E B_%d\r\n", phyBlock);
+
+    page_addr = phyBlock;
+
+    //gPrtition.Printf("page_addr:%d,block_index:%d\r\n", page_addr, block_index);
+    return spinand_gPrtition.Erase(0, page_addr);       
+}
+
+/**
+ * @BREIF    Prod_NandWriteASAPage
+ * @AUTHOR   luqiliu
+ * @DATE     2009-12-10
+ * @RETURN   T_U32 
+ * @retval   FHA_SUCCESS :  succeed
+ * @retval   FHA_FAIL :     fail
+ */
+
+int Prod_NandWritePage(unsigned long block_index, unsigned long page, unsigned char data[], unsigned char spare[],  unsigned long spare_len)
+{
+    unsigned long phyBlock = Prod_LB2PB(block_index);
+    unsigned long page_addr;
+    int ret = -1;
+
+   
+
+    page_addr = phyBlock * g_nand_phy_info.page_per_blk + page;
+    
+   // gPrtition.Printf("W:%d, %d, %d, %d\r\n", page_addr,block_index, page, spare_len);
+    ret = spinand_gPrtition.Write(0, page_addr, data, g_nand_phy_info.page_size, spare, spare_len, FHA_DATA_ASA);
+
+    return ret;
+}
+    
+
+/**
+ * @BREIF    Prod_NandReadASAPage
+ * @AUTHOR   luqiliu
+ * @DATE     2009-12-10
+ * @RETURN   T_U32 
+ * @retval   FHA_SUCCESS :  succeed
+ * @retval   FHA_FAIL :     fail
+ */
+
+int Prod_NandReadPage(unsigned long block_index, unsigned long page, unsigned char data[], unsigned char spare[],  unsigned long spare_len)
+{
+    unsigned long phyBlock = Prod_LB2PB(block_index);
+    unsigned long page_addr;
+    int ret = -1;
+
+   // gPrtition.Printf("R B_%d,P_%d, %d\r\n", phyBlock, page, spare_len);
+
+    page_addr = phyBlock * g_nand_phy_info.page_per_blk + page;
+
+	ret = spinand_gPrtition.Read(0, page_addr, data, g_nand_phy_info.page_size, spare, spare_len, FHA_DATA_ASA);
+    
+    return ret;
+}
+
+int Prod_NandWriteBootPage(unsigned long page, unsigned char data[])
+{
+    unsigned long page_addr;
+    unsigned char spare[3] = {0};
+    unsigned long data_len;
+    unsigned long spare_len = 0;
+    int ret = -1;
+
+   // switch(g_burn_param.eAKChip)
+    //{
+        //default:  
+    //        spare_len = 0;
+           // break;   
+    //}   
+
+    data_len = m_bin_nand_info.boot_page_size;
+    page_addr = page;
+
+    ret = spinand_gPrtition.Write(0, page_addr, data, data_len, spare, spare_len, FHA_DATA_BOOT);
+    return ret;
+}
+
+int Prod_NandReadBootPage(unsigned long page, unsigned char data[])
+{
+    unsigned long page_addr;
+    unsigned char spare[3] = {0};
+    unsigned long data_len = 0;
+    unsigned long spare_len = 0;
+
+    //switch(g_burn_param.eAKChip)
+    //{
+    //    default:  
+    //        spare_len = 0;
+    //        break;
+    //}   
+
+    data_len = m_bin_nand_info.boot_page_size;
+
+    page_addr = page;
+
+    if(0 != spinand_gPrtition.Read(0, page_addr, data, data_len, spare, spare_len, FHA_DATA_BOOT))
+    {
+        return -1;
+    }  
+
+    return 0;
+}
+
+
+int Prod_IsBadBlock(unsigned long block_index)
+{
+//   unsigned char  pData[4] = {0};
+   unsigned long phyBlock = Prod_LB2PB(block_index);
+   
+   return spinand_check_babblock(phyBlock);
+}
+
+
+int fha_str_cmp(const char *s1, const char *s2)
+{
+    int i;
+
+    for(i=0; s1[i] && s2[i]; i++)
+    {
+        if (s1[i] != s2[i])
+        {
+            return -1;
+        }
+    }
+
+    if (s1[i] != s2[i])
+        return -1;
+    else
+        return 0;
+}
+
+unsigned long fha_str_len(const char *string)
+{
+    unsigned long i = 0;
+
+    while (string[i] != 0)
+    {
+        i++;
+        if (i>10000)
+            break;
+    }
+    return i;
+} 
+
+
+#endif
+
+
diff --git a/drivers/mtd/partition/spinand_driver.h b/drivers/mtd/partition/spinand_driver.h
new file mode 100755
index 0000000..f3923b3
--- /dev/null
+++ b/drivers/mtd/partition/spinand_driver.h
@@ -0,0 +1,77 @@
+#ifndef _SPINAND_DRIVER_H_
+#define _SPINAND_DRIVER_H_
+
+
+//#include <stdio.h>
+//#include <stdlib.h>
+//#include <stdarg.h>
+//#include <string.h>
+#include "partition_lib.h"
+#include "partition_init.h"
+
+
+
+
+//#define     PARTITION_TALBE_PAGE_NUM            2
+
+/*
+typedef enum
+{
+    FHA_CHIP_10XX,      //snowbirdL
+    FHA_CHIP_39XX,      //AK39XX
+}E_CHIP_TYPE;
+
+typedef enum
+{
+    PLAT_RTOS,          //spot system
+    PLAT_LINUX          //linux system
+}E_PLATFORM_TYPE;
+
+
+typedef enum
+{
+    MEDIUM_SPIFLASH,            //spiflash
+    MEDIUM_SPI_NAND,                //nand
+}E_MEDIUM_TYPE;
+
+
+typedef enum
+{
+    MODE_NEWBURN = 1,           //new burn
+    MODE_UPDATE,                //update mode
+}E_BURN_MODE;
+*/
+
+
+typedef enum
+{
+    FHA_DATA_BOOT,
+    FHA_DATA_ASA,
+    FHA_DATA_BIN,
+    FHA_DATA_FS,
+    FHA_GET_NAND_PARAM
+}E_FHA_DATA_TYPE;
+
+#if 0
+typedef struct tag_FHA_Init_Info
+{
+    unsigned long   nChipCnt;                //Ƭѡ
+    unsigned long   nBlockStep;            //nand block stepֵ
+    E_CHIP_TYPE     eAKChip;    //AKоƬ
+    E_PLATFORM_TYPE ePlatform;  //ϵͳ
+    E_MEDIUM_TYPE   eMedium;    //洢
+    E_BURN_MODE     eMode;        //¼ģʽ
+}T_PART_INIT_INFO, *T_PPART_INIT_INFO;
+#endif
+
+int Prod_NandEraseBlock(unsigned long block_index);
+int Prod_NandWritePage(unsigned long block_index, unsigned long page, unsigned char data[], unsigned char spare[], unsigned long spare_len);
+int Prod_NandReadPage(unsigned long block_index, unsigned long page, unsigned char data[], unsigned char spare[], unsigned long spare_len);
+
+unsigned long Prod_LB2PB(unsigned long LogBlock);
+unsigned long Prod_PB2LB(unsigned long PhyBlock);
+
+
+
+#endif
+
diff --git a/drivers/pinctrl/Kconfig b/drivers/pinctrl/Kconfig
old mode 100644
new mode 100755
index 073b6d1..d948103
--- a/drivers/pinctrl/Kconfig
+++ b/drivers/pinctrl/Kconfig
@@ -247,6 +247,7 @@ config PINCTRL_ZYNQ
 	help
 	  This selectes the pinctrl driver for Xilinx Zynq.
 
+source "drivers/pinctrl/anyka/Kconfig"
 source "drivers/pinctrl/bcm/Kconfig"
 source "drivers/pinctrl/berlin/Kconfig"
 source "drivers/pinctrl/freescale/Kconfig"
diff --git a/drivers/pinctrl/Makefile b/drivers/pinctrl/Makefile
old mode 100644
new mode 100755
index 738cb49..f0ffcdb
--- a/drivers/pinctrl/Makefile
+++ b/drivers/pinctrl/Makefile
@@ -40,6 +40,7 @@ obj-$(CONFIG_PINCTRL_TB10X)	+= pinctrl-tb10x.o
 obj-$(CONFIG_PINCTRL_ST) 	+= pinctrl-st.o
 obj-$(CONFIG_PINCTRL_ZYNQ)	+= pinctrl-zynq.o
 
+obj-y		        += anyka/
 obj-$(CONFIG_ARCH_BCM)		+= bcm/
 obj-$(CONFIG_ARCH_BERLIN)	+= berlin/
 obj-y				+= freescale/
diff --git a/drivers/pinctrl/anyka/Kconfig b/drivers/pinctrl/anyka/Kconfig
new file mode 100755
index 0000000..103af4b
--- /dev/null
+++ b/drivers/pinctrl/anyka/Kconfig
@@ -0,0 +1,21 @@
+#
+# Broadcom pinctrl drivers
+#
+
+config PINCTRL_AK39
+	bool "AK39 GPIO (with PINCONF) driver"
+	depends on OF_GPIO && ARCH_AK39
+	select GPIOLIB_IRQCHIP
+	select PINCONF
+	select PINMUX
+	help
+	  The Anyka AK39 GPIO driver.
+
+config PINCTRL_AK
+	bool "AK GPIO (with PINCONF) driver"
+	depends on OF_GPIO && ARCH_AK
+	select GPIOLIB_IRQCHIP
+	select PINCONF
+	select PINMUX
+	help
+	  The Anyka GPIO driver.
diff --git a/drivers/pinctrl/anyka/Makefile b/drivers/pinctrl/anyka/Makefile
new file mode 100755
index 0000000..92cd531
--- /dev/null
+++ b/drivers/pinctrl/anyka/Makefile
@@ -0,0 +1,4 @@
+# Broadcom pinctrl support
+
+obj-$(CONFIG_PINCTRL_AK39)		+= ak39_pinctrl.o
+obj-$(CONFIG_PINCTRL_AK)		+= ak_pinctrl.o
diff --git a/drivers/pinctrl/anyka/ak39_pinctrl.c b/drivers/pinctrl/anyka/ak39_pinctrl.c
new file mode 100755
index 0000000..69aaee3
--- /dev/null
+++ b/drivers/pinctrl/anyka/ak39_pinctrl.c
@@ -0,0 +1,1418 @@
+/*
+ * Driver for AK39 GPIO (pinctrl + GPIO)
+ *
+ * Copyright (C) 2018 Anyka(Guangzhou) Microelectronics Technology Co., Ltd.
+ *
+ * This driver is inspired by:
+ * pinctrl-bcm2835.c, please see original file for copyright information
+ * pinctrl-tegra.c, please see original file for copyright information
+ *
+ * Author: Feilong Dong <dong_feilong@anyka.com>
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#define pr_fmt(fmt) KBUILD_MODNAME ": " fmt
+
+#include <linux/bitmap.h>
+#include <linux/bug.h>
+#include <linux/delay.h>
+#include <linux/device.h>
+#include <linux/err.h>
+#include <linux/gpio.h>
+#include <linux/interrupt.h>
+#include <linux/io.h>
+#include <linux/irq.h>
+#include <linux/irqdesc.h>
+#include <linux/irqdomain.h>
+#include <linux/irqchip/chained_irq.h>
+#include <linux/module.h>
+#include <linux/of_address.h>
+#include <linux/of.h>
+#include <linux/of_irq.h>
+#include <linux/pinctrl/consumer.h>
+#include <linux/pinctrl/machine.h>
+#include <linux/pinctrl/pinconf.h>
+#include <linux/pinctrl/pinctrl.h>
+#include <linux/pinctrl/pinmux.h>
+#include <linux/platform_device.h>
+#include <linux/seq_file.h>
+#include <linux/slab.h>
+#include <linux/spinlock.h>
+#include <linux/types.h>
+#include <linux/clk.h>
+
+#include <mach/map.h>
+#include "../core.h"
+
+#define MODULE_NAME "ak39-pinctrl"
+#define AK39_NUM_GPIOS 86
+#define AK39_NUM_BANKS 1
+
+#define	AK_PULLUPDOWN_DISABLE	0
+#define	AK_PULLUPDOWN_ENABLE	1
+
+#define	ePIN_AS_GPIO_IN  0		// pin as gpio in
+#define	ePIN_AS_GPIO_OUT 1      // pin as gpio out
+
+#define	AK_GPIO_OUT_LOW			0
+#define	AK_GPIO_OUT_HIGH		1
+
+#define AK_GPIO_DIR1			0x00
+#define AK_GPIO_OUT1			0x0C
+#define AK_GPIO_INPUT1         	0x18
+#define AK_GPIO_INT_MASK1      	0x24
+#define AK_GPIO_INT_MODE1      	0x30
+#define AK_GPIO_INTP1         	0x3C
+#define AK_GPIO_EDGE_STATUS1	0x48
+
+#define AK_PPU_PPD1           	(AK_VA_SYSCTRL + 0x80)
+#define AK_PPU_PPD2           	(AK_VA_SYSCTRL + 0x84)
+#define AK_PPU_PPD3           	(AK_VA_SYSCTRL + 0x88)
+#define AK_PPU_PPD4           	(AK_VA_SYSCTRL + 0xE0)
+
+#define AK_SHAREPIN_CON1		(AK_VA_SYSCTRL + 0x74)
+#define AK_SHAREPIN_CON2		(AK_VA_SYSCTRL + 0x78)
+#define AK_SHAREPIN_CON3		(AK_VA_SYSCTRL + 0x7C)
+#define AK_SHAREPIN_CON4		(AK_VA_SYSCTRL + 0xDC)
+#define AK_PERIPLL_CTRL_REG1	(AK_VA_SYSCTRL + 0x14)
+#define AK_ALALOG_CTRL_REG3		(AK_VA_SYSCTRL + 0xA4)
+
+#define AK_SHAREPIN_CON2_AS_GPIO 0xEAAAAAD
+
+#define AK_GPIO_DIR_BASE(pin)			(((pin)>>5)*4 + AK_GPIO_DIR1)
+#define AK_GPIO_OUT_BASE(pin)			(((pin)>>5)*4 + AK_GPIO_OUT1)
+#define AK_GPIO_IN_BASE(pin)			(((pin)>>5)*4 + AK_GPIO_INPUT1)
+#define AK_GPIO_INTEN_BASE(pin)			(((pin)>>5)*4 + AK_GPIO_INT_MASK1)
+#define AK_GPIO_INTM_BASE(pin)			(((pin)>>5)*4 + AK_GPIO_INT_MODE1)
+#define AK_GPIO_INTPOL_BASE(pin)		(((pin)>>5)*4 + AK_GPIO_INTP1)
+#define AK_GPIO_INTEDGE_BASE(pin)		(((pin)>>5)*4 + AK_GPIO_EDGE_STATUS1)
+
+#define AK_GPIO_REG_SHIFT(pin)	((pin) % 32)
+
+typedef enum {
+	PUPD_CFG1 = 0,   // pupd cfg1
+	PUPD_CFG2,       // pupd cfg2
+	PUPD_CFG3,       // pupd cfg3
+	PUPD_CFG4,       // pupd cfg4	
+}ak39_pupdcfg;
+
+typedef enum {
+	 PULLUP = 0,
+	 PULLDOWN,
+	 PULLUPDOWN,
+	 UNDEFINED
+ }ak39_pupdtype;
+
+struct gpio_pupd_cfg {
+	int pin;
+	int index;
+	ak39_pupdcfg pupd_cfg;
+	ak39_pupdtype pupd_type;
+};
+
+struct gpio_sharepin_func {
+	int index;
+ 	char const * name;
+
+    u32 reg1_bit_mask;
+    u32 reg1_bit_value;
+    u32 reg2_bit_mask;
+    u32 reg2_bit_value;
+    u32 reg3_bit_mask;
+    u32 reg3_bit_value;
+    u32 reg4_bit_mask;
+    u32 reg4_bit_value;
+	void __iomem * extra_reg;
+	u32 extra_reg_bit;
+	u32 extra_reg_value;
+};
+
+struct ak39_pinctrl {
+	struct device *dev;
+	struct clk *clk;
+	void __iomem *base;
+	int irq;
+
+	unsigned int irq_type[AK39_NUM_GPIOS];
+	int fsel[AK39_NUM_GPIOS];
+
+	struct pinctrl_dev *pctl_dev;
+	struct irq_domain *irq_domain;
+	struct gpio_chip gc;
+	struct pinctrl_gpio_range gpio_range;
+
+	spinlock_t lock;
+};
+
+/* pins are just named gpio0..gpio85 */
+#define AK39_GPIO_PIN(a) PINCTRL_PIN(a, "gpio" #a)
+static struct pinctrl_pin_desc ak39_gpio_pins[] = {
+	AK39_GPIO_PIN(0),
+	AK39_GPIO_PIN(1),
+	AK39_GPIO_PIN(2),
+	AK39_GPIO_PIN(3),
+	AK39_GPIO_PIN(4),
+	AK39_GPIO_PIN(5),
+	AK39_GPIO_PIN(6),
+	AK39_GPIO_PIN(7),
+	AK39_GPIO_PIN(8),
+	AK39_GPIO_PIN(9),
+	AK39_GPIO_PIN(10),
+	AK39_GPIO_PIN(11),
+	AK39_GPIO_PIN(12),
+	AK39_GPIO_PIN(13),
+	AK39_GPIO_PIN(14),
+	AK39_GPIO_PIN(15),
+	AK39_GPIO_PIN(16),
+	AK39_GPIO_PIN(17),
+	AK39_GPIO_PIN(18),
+	AK39_GPIO_PIN(19),
+	AK39_GPIO_PIN(20),
+	AK39_GPIO_PIN(21),
+	AK39_GPIO_PIN(22),
+	AK39_GPIO_PIN(23),
+	AK39_GPIO_PIN(24),
+	AK39_GPIO_PIN(25),
+	AK39_GPIO_PIN(26),
+	AK39_GPIO_PIN(27),
+	AK39_GPIO_PIN(28),
+	AK39_GPIO_PIN(29),
+	AK39_GPIO_PIN(30),
+	AK39_GPIO_PIN(31),
+	AK39_GPIO_PIN(32),
+	AK39_GPIO_PIN(33),
+	AK39_GPIO_PIN(34),
+	AK39_GPIO_PIN(35),
+	AK39_GPIO_PIN(36),
+	AK39_GPIO_PIN(37),
+	AK39_GPIO_PIN(38),
+	AK39_GPIO_PIN(39),
+	AK39_GPIO_PIN(40),
+	AK39_GPIO_PIN(41),
+	AK39_GPIO_PIN(42),
+	AK39_GPIO_PIN(43),
+	AK39_GPIO_PIN(44),
+	AK39_GPIO_PIN(45),
+	AK39_GPIO_PIN(46),
+	AK39_GPIO_PIN(47),
+	AK39_GPIO_PIN(48),
+	AK39_GPIO_PIN(49),
+	AK39_GPIO_PIN(50),
+	AK39_GPIO_PIN(51),
+	AK39_GPIO_PIN(52),
+	AK39_GPIO_PIN(53),
+	AK39_GPIO_PIN(54),
+	AK39_GPIO_PIN(55),
+	AK39_GPIO_PIN(56),
+	AK39_GPIO_PIN(57),
+	AK39_GPIO_PIN(58),
+	AK39_GPIO_PIN(59),
+	AK39_GPIO_PIN(60),
+	AK39_GPIO_PIN(61),
+	AK39_GPIO_PIN(62),
+	AK39_GPIO_PIN(63),
+	AK39_GPIO_PIN(64),
+	AK39_GPIO_PIN(65),
+	AK39_GPIO_PIN(66),
+	AK39_GPIO_PIN(67),
+	AK39_GPIO_PIN(68),
+	AK39_GPIO_PIN(69),
+	AK39_GPIO_PIN(70),
+	AK39_GPIO_PIN(71),
+	AK39_GPIO_PIN(72),
+	AK39_GPIO_PIN(73),
+	AK39_GPIO_PIN(74),
+	AK39_GPIO_PIN(75),
+	AK39_GPIO_PIN(76),
+	AK39_GPIO_PIN(77),
+	AK39_GPIO_PIN(78),
+	AK39_GPIO_PIN(79),
+	AK39_GPIO_PIN(80),
+	AK39_GPIO_PIN(81),
+	AK39_GPIO_PIN(82),
+	AK39_GPIO_PIN(83),
+	AK39_GPIO_PIN(84),
+	AK39_GPIO_PIN(85),
+};
+
+/* one pin per group */
+static const char * const ak39_gpio_groups[] = {
+	"gpio0",
+	"gpio1",
+	"gpio2",
+	"gpio3",
+	"gpio4",
+	"gpio5",
+	"gpio6",
+	"gpio7",
+	"gpio8",
+	"gpio9",
+	"gpio10",
+	"gpio11",
+	"gpio12",
+	"gpio13",
+	"gpio14",
+	"gpio15",
+	"gpio16",
+	"gpio17",
+	"gpio18",
+	"gpio19",
+	"gpio20",
+	"gpio21",
+	"gpio22",
+	"gpio23",
+	"gpio24",
+	"gpio25",
+	"gpio26",
+	"gpio27",
+	"gpio28",
+	"gpio29",
+	"gpio30",
+	"gpio31",
+	"gpio32",
+	"gpio33",
+	"gpio34",
+	"gpio35",
+	"gpio36",
+	"gpio37",
+	"gpio38",
+	"gpio39",
+	"gpio40",
+	"gpio41",
+	"gpio42",
+	"gpio43",
+	"gpio44",
+	"gpio45",
+	"gpio46",
+	"gpio47",
+	"gpio48",
+	"gpio49",
+	"gpio50",
+	"gpio51",
+	"gpio52",
+	"gpio53",
+	"gpio54",
+	"gpio55",
+	"gpio56",
+	"gpio57",
+	"gpio58",
+	"gpio59",
+	"gpio60",
+	"gpio61",
+	"gpio62",
+	"gpio63",
+	"gpio64",
+	"gpio65",
+	"gpio66",
+	"gpio67",
+	"gpio68",
+	"gpio69",
+	"gpio70",
+	"gpio71",
+	"gpio72",
+	"gpio73",
+	"gpio74",
+	"gpio75",
+	"gpio76",
+	"gpio77",
+	"gpio78",
+	"gpio79",
+	"gpio80",
+	"gpio81",
+	"gpio82",
+	"gpio83",
+	"gpio84",
+	"gpio85",
+};
+
+//share pin func config in AK39xx
+struct gpio_sharepin_func ak39_sharepin_func[] = {
+	{0, "default as gpio", 0,0,0,0,0,0,0,0,0,0,0},
+	
+	/* gpio 1, 2*/
+	{1, "uart0", (0x3<<2),(0x3<<2),0,0,0,0,0,0,0,0,0},
+	/* gpio 0, 5 */
+	{2, "uart1_0", (0x1<<29)|(0x3<<6)|(0x3<<0),(0x1<<29)|(0x2<<6)|(0x2<<0),0,0,0,0,0,0,0,0,0},
+	/* gpio 9, 6*/
+	{3, "uart1_1", (0x1<<29),0,(0xFF<<7),(0xFF<<7),0,0,0,0,0,0,0},
+
+	/* gpio 15, 14, 13, 11, 10 */
+	{4, "i2s_0", (0x1<<24),(0x1<<24),0,0,\
+				(0x3<<10)|(0x3<<8)|(0x3<<5)|(0x3<<2)|(0x3<<0),\
+				(0x2<<10)|(0x2<<8)|(0x2<<5)|(0x2<<2)|(0x2<<0),0,0,0,0,0},
+	/* gpio 56, 55, 54, 53, 52 */
+	{5, "i2s_1", (0x1<<29)|(0x1<<24)|(0x1F<<15),(0x1F<<15),0,0,0,0,0,0,0,0,0},
+	/* gpio 5*/
+	{6, "ain1", (0x3<<6),0,0,0,0,0,0,0,AK_ALALOG_CTRL_REG3,29,1},
+
+    /* PWM0 are used by system timer,so it can't be used here.
+     * Reference to ak39_timer.c, please.
+     */
+	/* gpio 80 */
+	{7, "pwm0_0", (0x1<<22),(0x1<<22),0,0,0,0,0,0,0,0,0},
+	/* gpio 48 */
+	{8, "pwm0_1", (0x1<<12),(0x1<<12),0,0,0,0,0,0,AK_PERIPLL_CTRL_REG1,29,0},
+	/* gpio 3 */
+	{9, "pwm0_2", (0x1<<30)|(0x1<<4),(0x1<<4),0,0,0,0,0,0,0,0,0},
+	/* gpio 68 */
+	{10, "pwm0_3", 0,0,(0x3<<15),(0x3<<15),0,0,0,0,0,0,0},
+
+    
+	/* gpio 50 */
+	{11, "pwm1_0", (0x1<<13),(0x1<<13),0,0,0,0,0,0,AK_PERIPLL_CTRL_REG1,29,0},
+    /* gpio 4 */
+	{12, "pwm1_1", (0x1<<5),(0x1<<5),0,0,0,0,0,0,0,0,0},
+	/* gpio 69 */
+	{13, "pwm1_2", 0,0,(0x3<<17),(0x3<<17),0,0,0,0,0,0,0},
+	/*gpio 81 */
+	{14, "pwm2_0", (0x1<<23),(0x1<<23),0,0,0,0,0,0,0,0,0},
+	/* gpio 51 */
+	{15, "pwm2_1", (0x1<<14),(0x1<<14),0,0,0,0,0,0,AK_PERIPLL_CTRL_REG1,29,0},
+	/* gpio 5 */
+	{16, "pwm2_2", (0x3<<6),(0x1<<6),0,0,0,0,0,0,0,0,0},
+	/* gpio 10 */
+	{17, "pwm2_3", 0,0,0,0,(0x3<<0),(0x3<<0),0,0,0,0,0},
+	/* gpio 57 */
+	{18, "pwm3_0", (0x1<<20),(0x1<<20),0,0,0,0,0,0,AK_PERIPLL_CTRL_REG1,29,0},
+	/* gpio 66 */
+	{19, "pwm3_1", 0,0,(0x3<<3),(0x3<<3),0,0,0,0,0,0,0},
+	/* gpio 23 */
+	{20, "pwm3_2", 0,0,0,0,(0x3<<22),(0x3<<22),0,0,0,0,0},
+
+    /* PWM4 are used by system clocksource device,so it can't be used here.
+     * Reference to ak39_timer.c, please.
+     */
+	/* gpio 58 */
+	{21, "pwm4_0", (0x1<<21),(0x1<<21),0,0,0,0,0,0,AK_PERIPLL_CTRL_REG1,29,0},
+	/* gpio 47 */
+	{22, "pwm4_1", (0x3<<10),(0x3<<10),0,0,0,0,0,0,0,0,0},
+	/* gpio 67 */
+	{23, "pwm4_2", 0,0,(0x3<<5),(0x3<<5),0,0,0,0,0,0,0},
+	/* gpio 24 */
+	{24, "pwm4_3", 0,0,0,0,(0x3<<24),(0x3<<24),0,0,0,0,0},
+	/* gpio 4 */
+	{25, "pwm4_4", 0,0,0,0,0,0,(0x3<<4),(0x2<<4),0,0,0},
+
+    
+	/* gpio 64:67, 75:68, 9:6 */
+	{26, "cis0_12bits", 0,0,(0xFFFFFFF<<0),0,0,0,0,0,AK_PERIPLL_CTRL_REG1,26,0},
+	/* gpio 64:67, 75:68, 9:8 */
+	{27, "cis0_10bits", 0,0,(0x1FFFF<<11)|(0x7F<<0),0,0,0,0,0,AK_PERIPLL_CTRL_REG1,26,0},
+	/* gpio 64:67, 75:68*/
+	{28, "cis0_8bits", 0,0,(0x7FFF<<15)|(0x7F<<0),0,0,0,0,0,AK_PERIPLL_CTRL_REG1,26,0},
+
+	/* gpio 3, 48, 50:51, 63:52 */
+	{29, "cis1_12bits", (0x3<<30)|(0x1<<26)|(0x7F<<14)|(0x7<<11)|(0x1<<4),\
+						(0x3<<30)|(0x1<<26),0,0,0,0,0,0,AK_PERIPLL_CTRL_REG1,29,1<<29},
+	/* gpio 3, 48, 50:51, 63:54 */
+	{30, "cis1_10bits", (0x3<<30)|(0x1<<26)|(0x7F<<14)|(0x7<<11)|(0x1<<4),\
+						(0x3<<30),0,0,0,0,0,0,AK_PERIPLL_CTRL_REG1,29,1<<29},
+	/* gpio 3, 48, 50:51, 63:56 */
+	{31, "cis1_8bits", (0x3<<30)|(0x1<<26)|(0x7F<<14)|(0x7<<11)|(0x1<<4),\
+						(0x1<<30),0,0,0,0,0,0,AK_PERIPLL_CTRL_REG1,29,1<<29},
+
+	/* gpio 31:33 */
+	{32, "mci0_1line", 0,0,0,0,0,0,(0x7<<6),(0x7<<6),0,0,0},  //lhd check
+	/* gpio 31:33, 34:36 */
+	{33, "mci0_4line", 0,0,0,0,0,0,(0xF<<10)|(0x7<<6),(0x5<<10)|(0x7<<6),0,0,0},
+	/* gpio 31:33, 34:36, 37:40 */
+	{34, "mci0_8line", 0,0,0,0,0,0,((0xf<<6)|(0xf<<10)|(0xf<<14)),((0xe<<6)|(5<<10)|(0x5<<10)),0,0,0},  //lhd check
+
+	/* gpio 41:43 */
+	{35, "mci1_1line_0", (0x1<<28),(0x1<<28),0,0,0,0,(0xf<<20),(0x7<<20),0,0,0},
+	/* gpio 41:46 */
+	{36, "mci1_4line_0", (0x1<<28),(0x1<<28),0,0,0,0,(0xff<<20),(0x57<<20),0,0,0},
+	/* gpio 42:41, 24  */
+	{37, "mci1_1line_1", (0x1<<28),(0x0<<28),0,0,0,0,(0xf<<20),(0x7<<20),0,0,0},
+	/* gpio 42:41, 24:23, 20:19 */
+	{38, "mci1_4line_1", (1<<28), (1<<28),0,0,((0xf<<22)|(0xf<<16)), ((0xa<<22)|(0xa<<16)), (0x3<<20), (0x3<<20),0,0,0},  //lhd check
+
+	/* gpio 36:35, 26:25 */	
+	{39, "spi0_1line_0", (0x1<<25),(0x1<<25),0,0,0,0,(0x3<<12)|(0x3<<0),(0x3<<12)|0x3,0,0,0},
+	/* gpio  36:34, 26:25, 79 */
+	{40, "spi0_4line_0", (0x1<<25),(0x1<<25),0,0,0,0,(0x1F<<9)|(0x3<<0),(0x1F<<9)|0x3,0,0,0},
+	/* gpio 38:36, 26 */
+	{41, "spi0_1line_1", (0x1<<25),(0x0<<25),0,0,0,0,(0x3<<14)|(0x3<<0),(0x3<<14)|0x3,0,0,0},
+	/* gpio 40:36, 26 */
+	{42, "spi0_4line_1", (0x1<<25),(0x0<<25),0,0,0,0,(0x3F<<14)|(0x3<<0),(0x3F<<14)|0x3,0,0,0},
+
+	/* gpio 46:45, 30:29 */
+	{43, "spi1_1line_0", (0x1<<27),(0x0<<27),0,0,0,0,(0x3<<26)|(0xF<<2),(0x3<<26)|(0xF<<2),0,0,0},
+	/* gpio 46:43, 30:29 */
+	{44, "spi1_4line_0", (0x1<<27),(0x0<<27),0,0,0,0,(0x3F<<22)|(0xF<<2),(0x3F<<22)|(0xF<<2),0,0,0},
+	/* gpio 15:13, 11 */
+	{45, "spi1_1line_1", (0x1<<27),(0x1<<27),0,0,\
+						(0xF<<8)|(0x3<<5)|(0x3<<2),(0xF<<8)|(0x3<<5)|(0x3<<2),0,0,0,0,0},
+	/* gpio 20:19, 15:13, 11 */
+	{46, "spi1_4line_1", (0x1<<27),(0x1<<27),0,0,(0xF<<16)|(0xF<<8)|(0x3<<5)|(0x3<<2),\
+						(0xF<<16)|(0xF<<8)|(0x3<<5)|(0x3<<2),0,0,0,0,0},
+
+	/* gpio 10, 11, 76, 13, 14, 15, 16, 17, 77, 19, 20, 21, 22, 23, 24, 47, 18, 78 */
+	{47, "mii", (0x3<<10),(0x1<<10),0,0,(0x7FFFFFF<<0),(0x575f5a5<<0),0,0,0,0,0},
+	/* gpio 13, 14, 15, 19, 20, 23. 24, 47, 10, 11 */
+	{48, "rmii", (0x3<<10),(0x1<<10),0,0,(0xF<<22)|(0xF<<16)|(0xF<<8)|(0x3<<5)|(0xF<<0),\
+				  (0x5<<22)|(0x5<<16)|(0x5<<8)|(0x1<<5)|(0x5<<0),0,0,0,0,0},
+
+	/* gpio 27, 28 */
+	{49, "i2c0", (0x3<<8),(0x3<<8),0,0,0,0,0,0,0,0,0},
+	/* gpio 52, 53 */
+	{50, "i2c1", (0x1<<26)|(0x3<<15),(0x1<<26)|(0x3<<15),0,0,0,0,0,0,0,0,0},
+
+	/* gpio 29 */
+	{51, "irda", 0,0,0,0,0,0,(0x3<<2),(0x1<<2),0,0,0},
+
+	/* gpio 70:75 */
+	{52, "mipi", (0x1ff<<19),0,0,0,0,0,0,0,AK_PERIPLL_CTRL_REG1,26,1<<26},
+
+	/* gpio84 */
+	{53, "linein", 0,0,0,0,0,0,0,0,AK_ALALOG_CTRL_REG3,27,3},
+	/* gpio 83 */
+	{54, "micp", 0,0,0,0,0,0,0,0,AK_ALALOG_CTRL_REG3,25,3},
+	
+	/* gpio 0, 5, 64, 71, 70, 72 */
+	{55, "jtag", (0x3<<6)|(0x3<<0),(0x3<<6)|(0x1<<0),\
+				(0x3F<<19)|(0x3<<0),(0x2A<<19)|(0x3<<0),0,0,0,0,AK_PERIPLL_CTRL_REG1,26,0},
+};
+
+struct gpio_pupd_cfg pupd_cfg_info[] = {
+	{0, 0, 	 PUPD_CFG1, PULLUP},
+	{1, 1, 	 PUPD_CFG1, PULLUP},
+	{2, 2, 	 PUPD_CFG1, PULLUP},
+	{3, 3, 	 PUPD_CFG1, PULLDOWN},
+	{4, 4, 	 PUPD_CFG1, PULLUP},
+	{5, 5, 	 PUPD_CFG1, PULLUP},	
+	{6, 4, 	 PUPD_CFG2, PULLDOWN},
+	{7, 5, 	 PUPD_CFG2, PULLDOWN},
+	{8, 6, 	 PUPD_CFG2, PULLDOWN},
+	{9, 7, 	 PUPD_CFG2, PULLDOWN},
+	{10, 0,  PUPD_CFG3, PULLDOWN},
+	{11, 1,  PUPD_CFG3, PULLUP}, 
+	{12, 2,  PUPD_CFG3, PULLDOWN},
+	{13, 3,  PUPD_CFG3, PULLDOWN},
+	{14, 5,  PUPD_CFG3, PULLDOWN},
+	{15, 6,  PUPD_CFG3, PULLDOWN},
+	{16, 7,  PUPD_CFG3, PULLDOWN},
+	{17, 8,  PUPD_CFG3, PULLDOWN},
+	{18, 9,  PUPD_CFG3, PULLDOWN},
+	{19, 11, PUPD_CFG3, PULLDOWN},
+	{20, 12, PUPD_CFG3, PULLDOWN},
+	{21, 13, PUPD_CFG3, PULLDOWN},
+	{22, 14, PUPD_CFG3, PULLDOWN},
+	{23, 15, PUPD_CFG3, PULLDOWN},
+	{24, 16, PUPD_CFG3, PULLDOWN},
+	{25, 0,  PUPD_CFG4, PULLUP},
+	{26, 1,  PUPD_CFG4, PULLUP},
+	{27, 6,  PUPD_CFG1, PULLUP}, 
+	{28, 7,  PUPD_CFG1, PULLUP},
+	{29, 2,  PUPD_CFG4, PULLUP},
+	{30, 3,  PUPD_CFG4, PULLUP},
+	{31, 4,  PUPD_CFG4, PULLUP},
+	{32, 5,  PUPD_CFG4, PULLUP},
+	{33, 6,  PUPD_CFG4, PULLUP},
+	{34, 7,  PUPD_CFG4, PULLUP},
+	{35, 8,  PUPD_CFG4, PULLUP},
+	{36, 9,  PUPD_CFG4, PULLUP},
+	{37, 10, PUPD_CFG4, PULLUP},
+	{38, 11, PUPD_CFG4, PULLUP},
+	{39, 12, PUPD_CFG4, PULLUP},
+	{40, 13, PUPD_CFG4, PULLUP},
+	{41, 14, PUPD_CFG4, PULLUP},
+	{42, 15, PUPD_CFG4, PULLUP},
+	{43, 16, PUPD_CFG4, PULLUP},
+	{44, 17, PUPD_CFG4, PULLUP},
+	{45, 18, PUPD_CFG4, PULLUP},
+	{46, 19, PUPD_CFG4, PULLUP},
+	{47, 8,  PUPD_CFG1, PULLDOWN}, 
+	{48, 9,  PUPD_CFG1, PULLDOWN}, 
+	{49, 27, PUPD_CFG1, PULLDOWN},	
+	{50, 10, PUPD_CFG1, PULLUP}, 
+	{51, 11, PUPD_CFG1, PULLUP},
+	{52, 12, PUPD_CFG1, PULLUP},
+	{53, 13, PUPD_CFG1, PULLUP},
+	{54, 14, PUPD_CFG1, PULLDOWN},
+	{55, 15, PUPD_CFG1, PULLDOWN},
+	{56, 16, PUPD_CFG1, PULLUP},
+	{57, 17, PUPD_CFG1, PULLUP},
+	{58, 18, PUPD_CFG1, PULLUP},
+	{59, 19, PUPD_CFG1, PULLDOWN},
+	{60, 20, PUPD_CFG1, PULLDOWN},
+	{61, 21, PUPD_CFG1, PULLDOWN},
+	{62, 22, PUPD_CFG1, PULLUP},
+	{63, 23, PUPD_CFG1, PULLUP}, 
+	{64, 0,  PUPD_CFG2, PULLDOWN},
+	{65, 1,  PUPD_CFG2, PULLDOWN},
+	{66, 2,  PUPD_CFG2, PULLDOWN},
+	{67, 3,  PUPD_CFG2, PULLDOWN},
+	{68, 8,  PUPD_CFG2, PULLDOWN},
+	{69, 9,  PUPD_CFG2, PULLDOWN},
+	{76, 4,  PUPD_CFG3, PULLDOWN},
+	{77, 10, PUPD_CFG3, PULLDOWN},
+	{78, 17, PUPD_CFG3, PULLDOWN},		
+	{79, 20, PUPD_CFG4, PULLUP},
+	{80, 24, PUPD_CFG1, PULLUP},
+	{81, 25, PUPD_CFG1, PULLUP},
+	{82, 26, PUPD_CFG1, PULLUP},
+	{85, 28, PUPD_CFG1, PULLUP}, 
+};
+
+static const char * const irq_type_names[] = {
+	[IRQ_TYPE_NONE] = "none",
+	[IRQ_TYPE_EDGE_RISING] = "edge-rising",
+	[IRQ_TYPE_EDGE_FALLING] = "edge-falling",
+	[IRQ_TYPE_LEVEL_HIGH] = "level-high",
+	[IRQ_TYPE_LEVEL_LOW] = "level-low",
+};
+
+static inline unsigned int ak39_pinctrl_fsel_get(
+		struct ak39_pinctrl *pc, unsigned pin)
+{
+	int status = pc->fsel[pin];
+
+	dev_dbg(pc->dev, "get (%u => %s)\n", pin,
+			(status != -1) ? (ak39_sharepin_func[status].name) : "gpio_mode");
+
+	return status;
+}
+
+static inline void ak39_pinctrl_fsel_set(
+		struct ak39_pinctrl *pc, unsigned pin,
+		unsigned fsel)
+{
+	unsigned long flags;
+	u32 regval;
+	int cur = pc->fsel[pin];
+
+	dev_dbg(pc->dev, "read (%u %u => %s)\n", pin,fsel,
+			ak39_sharepin_func[cur].name);
+
+	if (cur == fsel)
+		return;
+	
+	local_irq_save(flags);
+	regval = __raw_readl(AK_SHAREPIN_CON1);
+	regval &= ~(ak39_sharepin_func[fsel].reg1_bit_mask);
+	regval |= (ak39_sharepin_func[fsel].reg1_bit_value);
+	__raw_writel(regval, AK_SHAREPIN_CON1);
+
+	regval = __raw_readl(AK_SHAREPIN_CON2);
+    regval &= ~(ak39_sharepin_func[fsel].reg2_bit_mask);
+	regval |= (ak39_sharepin_func[fsel].reg2_bit_value);
+    __raw_writel(regval, AK_SHAREPIN_CON2);
+                    
+	regval = __raw_readl(AK_SHAREPIN_CON3);
+	regval &= ~(ak39_sharepin_func[fsel].reg3_bit_mask);
+	regval |= (ak39_sharepin_func[fsel].reg3_bit_value);
+	__raw_writel(regval, AK_SHAREPIN_CON3);
+
+	regval = __raw_readl(AK_SHAREPIN_CON4);
+	regval &= ~(ak39_sharepin_func[fsel].reg4_bit_mask);
+	regval |= (ak39_sharepin_func[fsel].reg4_bit_value);
+	__raw_writel(regval, AK_SHAREPIN_CON4); 	
+
+	if (ak39_sharepin_func[fsel].extra_reg != NULL) {
+		regval = __raw_readl(ak39_sharepin_func[fsel].extra_reg);
+		regval &= ~(ak39_sharepin_func[fsel].extra_reg_bit);
+		regval |= (ak39_sharepin_func[fsel].extra_reg_value);
+		__raw_writel(regval, ak39_sharepin_func[fsel].extra_reg);
+	}
+	local_irq_restore(flags);
+
+	dev_dbg(pc->dev, "write (%u <= %s)\n", pin,
+			ak39_sharepin_func[fsel].name);
+	pc->fsel[pin] = fsel;
+}
+
+static inline void ak39_pinctrl_fsel_reset(
+		struct ak39_pinctrl *pc, unsigned pin,
+		unsigned fsel)
+{
+	unsigned long flags;
+	u32 regval;
+	int cur = pc->fsel[pin];
+
+	dev_dbg(pc->dev, "read (%u => %s)\n", pin,
+			ak39_sharepin_func[cur].name);
+
+	if (cur == -1)
+		return;
+
+	local_irq_save(flags);
+	regval = __raw_readl(AK_SHAREPIN_CON1);
+	regval &= ~(ak39_sharepin_func[fsel].reg1_bit_mask);
+	__raw_writel(regval, AK_SHAREPIN_CON1);
+
+	regval = __raw_readl(AK_SHAREPIN_CON2);
+    regval |= (ak39_sharepin_func[fsel].reg2_bit_mask & AK_SHAREPIN_CON2_AS_GPIO);
+    __raw_writel(regval, AK_SHAREPIN_CON2);
+                    
+	regval = __raw_readl(AK_SHAREPIN_CON3);
+	regval &= ~(ak39_sharepin_func[fsel].reg3_bit_mask);
+	__raw_writel(regval, AK_SHAREPIN_CON3);
+
+	regval = __raw_readl(AK_SHAREPIN_CON4);
+	regval &= ~(ak39_sharepin_func[fsel].reg4_bit_mask);
+	__raw_writel(regval, AK_SHAREPIN_CON4);
+
+	if (ak39_sharepin_func[fsel].extra_reg != NULL) {
+		regval = __raw_readl(ak39_sharepin_func[fsel].extra_reg);
+		regval &= ~(ak39_sharepin_func[fsel].extra_reg_bit);
+		__raw_writel(regval, ak39_sharepin_func[fsel].extra_reg);
+	}
+	local_irq_restore(flags);
+
+	pc->fsel[pin] = -1;
+}
+
+
+static int ak39_gpio_direction_input(struct gpio_chip *chip, unsigned offset)
+{
+	return pinctrl_gpio_direction_input(chip->base + offset);
+}
+
+static int ak39_gpio_get(struct gpio_chip *chip, unsigned offset)
+{
+	struct ak39_pinctrl *pc = dev_get_drvdata(chip->dev);
+	void __iomem * reg = pc->base + AK_GPIO_IN_BASE(offset);
+	unsigned int bit = AK_GPIO_REG_SHIFT(offset);
+
+	return (__raw_readl(reg) & (1<<bit)) ? 1:0;
+}
+
+static void ak39_gpio_set(struct gpio_chip *chip, unsigned offset, int value)
+{
+	struct ak39_pinctrl *pc = dev_get_drvdata(chip->dev);
+	void __iomem *reg = pc->base + AK_GPIO_OUT_BASE(offset);
+	unsigned int bit = AK_GPIO_REG_SHIFT(offset);
+	unsigned long flags;
+	u32 regval;
+
+	local_irq_save(flags);
+	if (AK_GPIO_OUT_LOW == value) {
+		regval = __raw_readl(reg);
+		regval &= ~(1<<bit);
+		__raw_writel(regval, reg);
+	} else if (AK_GPIO_OUT_HIGH == value) {
+		regval = __raw_readl(reg);
+		regval |= (1<<bit);
+		__raw_writel(regval, reg);		
+	}
+	local_irq_restore(flags);
+}
+
+static int ak39_gpio_direction_output(struct gpio_chip *chip,
+		unsigned offset, int value)
+{
+	ak39_gpio_set(chip, offset, value);
+	return pinctrl_gpio_direction_output(chip->base + offset);
+}
+
+static int ak39_gpio_to_irq(struct gpio_chip *chip, unsigned offset)
+{
+	struct ak39_pinctrl *pc = dev_get_drvdata(chip->dev);
+
+	return irq_linear_revmap(pc->irq_domain, offset);
+}
+
+static struct gpio_chip ak39_gpio_chip = {
+	.label = MODULE_NAME,
+	.owner = THIS_MODULE,
+	.request = gpiochip_generic_request,
+	.free = gpiochip_generic_free,
+	.direction_input = ak39_gpio_direction_input,
+	.direction_output = ak39_gpio_direction_output,
+	.get = ak39_gpio_get,
+	.set = ak39_gpio_set,
+	.to_irq = ak39_gpio_to_irq,
+	.base = 0,
+	.ngpio = AK39_NUM_GPIOS,
+	.can_sleep = false,
+};
+
+static void ak39_pinctrl_irq_handler(struct irq_desc *desc)
+{
+	struct irq_chip *chip = irq_desc_get_chip(desc);
+	struct ak39_pinctrl *pc = irq_desc_get_handler_data(desc);
+	unsigned long regval;
+	int i;
+
+	for (i = 0; i < 3; i++) {
+		int off = 0;
+		regval = __raw_readl(pc->base + AK_GPIO_INT_MASK1 + i * 4);
+		
+		chained_irq_enter(chip, desc);
+		for_each_set_bit(off, &regval, 32) {
+			/* check all int status and handle the Edge/level interrupt */
+			if (pc->irq_type[i * 32 + off] & IRQ_TYPE_EDGE_BOTH) {
+				if (1<<off & __raw_readl(pc->base + AK_GPIO_EDGE_STATUS1 + i * 4)) {
+					int pin_irq = irq_find_mapping(pc->irq_domain, i * 32 + off);
+					generic_handle_irq(pin_irq);
+				}
+			} else {
+				if ((1<<off & __raw_readl(pc->base + AK_GPIO_INTP1 + i * 4)) !=
+					(1<<off & __raw_readl(pc->base + AK_GPIO_INPUT1 + i * 4))) {
+					int pin_irq = irq_find_mapping(pc->irq_domain, i * 32 + off);
+					generic_handle_irq(pin_irq);
+				}
+			}
+		}
+		chained_irq_exit(chip, desc);
+	}
+}
+
+static void ak39_gpio_irq_enable(struct irq_data *data)
+{
+	struct ak39_pinctrl *pc = irq_data_get_irq_chip_data(data);
+	unsigned pin = irqd_to_hwirq(data);
+	void __iomem *reg = pc->base + AK_GPIO_INTEN_BASE(pin);
+	unsigned bit = AK_GPIO_REG_SHIFT(pin);
+	unsigned long flags;
+
+	u32 regval;
+
+	spin_lock_irqsave(&pc->lock, flags);
+	regval = __raw_readl(reg);
+	regval |= (1 << bit);
+	__raw_writel(regval, reg);
+	spin_unlock_irqrestore(&pc->lock, flags);
+}
+
+static void ak39_gpio_irq_disable(struct irq_data *data)
+{
+	struct ak39_pinctrl *pc = irq_data_get_irq_chip_data(data);
+	unsigned pin = irqd_to_hwirq(data);
+	void __iomem *reg = pc->base + AK_GPIO_INTEN_BASE(pin);
+	unsigned bit = AK_GPIO_REG_SHIFT(pin);
+	unsigned long flags;
+
+	u32 regval;
+
+	spin_lock_irqsave(&pc->lock, flags);
+	regval = __raw_readl(reg);
+	regval &= ~(1 << bit);
+	__raw_writel(regval, reg);
+	spin_unlock_irqrestore(&pc->lock, flags);
+}
+
+static int __ak39_gpio_irq_set_type_disabled(struct ak39_pinctrl *pc,
+	unsigned offset, unsigned int type)
+{
+	switch (type) {
+	case IRQ_TYPE_NONE:
+	case IRQ_TYPE_EDGE_RISING:
+	case IRQ_TYPE_EDGE_FALLING:
+	case IRQ_TYPE_LEVEL_HIGH:
+	case IRQ_TYPE_LEVEL_LOW:
+		pc->irq_type[offset] = type;
+		break;
+
+	default:
+		return -EINVAL;
+	}
+	return 0;
+}
+
+/* slower path for reconfiguring IRQ type */
+static int __ak39_gpio_irq_set_type_enabled(struct ak39_pinctrl *pc,
+	unsigned offset, unsigned int type)
+{
+	u32 regval;
+	void __iomem *reg_inten = pc->base + AK_GPIO_INTEN_BASE(offset);
+	void __iomem *reg_intm  = pc->base + AK_GPIO_INTM_BASE(offset);
+	void __iomem *reg_intp  = pc->base + AK_GPIO_INTPOL_BASE(offset);
+
+	int bit = AK_GPIO_REG_SHIFT(offset);
+ 	
+	switch (type) {
+	case IRQ_TYPE_NONE:
+		if (pc->irq_type[offset] != type) {
+			regval = __raw_readl(reg_inten);
+			regval &= ~(1<<bit);
+			__raw_writel(regval, reg_inten);
+			pc->irq_type[offset] = type;
+		}
+		break;
+
+	case IRQ_TYPE_EDGE_RISING:
+	case IRQ_TYPE_EDGE_FALLING:
+		if (pc->irq_type[offset] != type) {
+			regval = __raw_readl(reg_intm);
+			regval |= (1<<bit);
+			__raw_writel(regval, reg_intm);
+
+			regval = __raw_readl(reg_intp);
+			if (IRQ_TYPE_EDGE_RISING == type)
+				regval &= ~(1<<bit);
+			else
+				regval |= (1<<bit);
+			__raw_writel(regval, reg_intp);			
+			pc->irq_type[offset] = type;
+		}
+		break;
+
+	case IRQ_TYPE_LEVEL_HIGH:
+	case IRQ_TYPE_LEVEL_LOW:
+		if (pc->irq_type[offset] != type) {
+			regval = __raw_readl(reg_intm);
+			regval &= ~(1<<bit);
+			__raw_writel(regval, reg_intm);
+
+			regval = __raw_readl(reg_intp);
+			if (IRQ_TYPE_LEVEL_HIGH == type)
+				regval &= ~(1<<bit);
+			else
+				regval |= (1<<bit);
+			__raw_writel(regval, reg_intp);			
+			pc->irq_type[offset] = type;
+		}
+		break;
+
+	default:
+		return -EINVAL;
+	}
+	return 0;
+}
+
+static int ak39_gpio_irq_set_type(struct irq_data *data, unsigned int type)
+{
+	struct ak39_pinctrl *pc = irq_data_get_irq_chip_data(data);
+	unsigned pin = irqd_to_hwirq(data);
+	unsigned bit = AK_GPIO_REG_SHIFT(pin);
+
+	unsigned long flags;
+	int ret;
+
+	spin_lock_irqsave(&pc->lock, flags);
+	if ((1<<bit) & __raw_readl(pc->base + AK_GPIO_INTEN_BASE(pin)))
+		ret = __ak39_gpio_irq_set_type_enabled(pc, pin, type);
+	else
+		ret = __ak39_gpio_irq_set_type_disabled(pc, pin, type);
+
+	if (type & IRQ_TYPE_EDGE_BOTH)
+		irq_set_handler_locked(data, handle_edge_irq);
+	else
+		irq_set_handler_locked(data, handle_level_irq);
+	spin_unlock_irqrestore(&pc->lock, flags);
+
+	return ret;
+}
+
+static struct irq_chip ak39_gpio_irq_chip = {
+	.name = MODULE_NAME,
+	.irq_enable = ak39_gpio_irq_enable,
+	.irq_disable = ak39_gpio_irq_disable,
+	.irq_set_type = ak39_gpio_irq_set_type,
+	.irq_mask = ak39_gpio_irq_disable,
+	.irq_mask_ack = ak39_gpio_irq_disable,
+	.irq_unmask = ak39_gpio_irq_enable,
+};
+
+static int ak39_pctl_get_groups_count(struct pinctrl_dev *pctldev)
+{
+	return ARRAY_SIZE(ak39_gpio_groups);
+}
+
+static const char *ak39_pctl_get_group_name(struct pinctrl_dev *pctldev,
+		unsigned selector)
+{
+	return ak39_gpio_groups[selector];
+}
+
+static int ak39_pctl_get_group_pins(struct pinctrl_dev *pctldev,
+		unsigned selector,
+		const unsigned **pins,
+		unsigned *num_pins)
+{
+	*pins = &ak39_gpio_pins[selector].number;
+	*num_pins = 1;
+
+	return 0;
+}
+
+static void ak39_pctl_pin_dbg_show(struct pinctrl_dev *pctldev,
+		struct seq_file *s,
+		unsigned offset)
+{
+	struct ak39_pinctrl *pc = pinctrl_dev_get_drvdata(pctldev);
+	unsigned int fsel = ak39_pinctrl_fsel_get(pc, offset);
+	const char *fname = ak39_sharepin_func[fsel].name;
+	int irq = irq_find_mapping(pc->irq_domain, offset);
+
+	seq_printf(s, "function %s; irq %d (%s)",
+		fname, irq, irq_type_names[pc->irq_type[offset]]);
+}
+
+static void ak39_pctl_dt_free_map(struct pinctrl_dev *pctldev,
+		struct pinctrl_map *maps, unsigned num_maps)
+{
+	int i;
+
+	for (i = 0; i < num_maps; i++)
+		if (maps[i].type == PIN_MAP_TYPE_CONFIGS_PIN)
+			kfree(maps[i].data.configs.configs);
+
+	kfree(maps);
+}
+
+static int ak39_pctl_dt_node_to_map_func(struct ak39_pinctrl *pc,
+		struct device_node *np, u32 pin, u32 fnum,
+		struct pinctrl_map **maps)
+{
+	struct pinctrl_map *map = *maps;
+
+	if (fnum >= ARRAY_SIZE(ak39_sharepin_func)) {
+		dev_err(pc->dev, "%s: invalid anyka,function %d\n",
+			of_node_full_name(np), fnum);
+		return -EINVAL;
+	}
+
+	map->type = PIN_MAP_TYPE_MUX_GROUP;
+	map->data.mux.group = ak39_gpio_groups[pin];
+	map->data.mux.function = ak39_sharepin_func[fnum].name;
+	(*maps)++;
+
+	return 0;
+}
+
+static int ak39_pctl_dt_node_to_map_pull(struct ak39_pinctrl *pc,
+		struct device_node *np, u32 pin, u32 pull,
+		struct pinctrl_map **maps)
+{
+	struct pinctrl_map *map = *maps;
+	unsigned long *configs;
+
+	if (pull > 2) {
+		dev_err(pc->dev, "%s: invalid anyka,pull %d\n",
+			of_node_full_name(np), pull);
+		return -EINVAL;
+	}
+
+	configs = kzalloc(sizeof(*configs), GFP_KERNEL);
+	if (!configs)
+		return -ENOMEM;
+	configs[0] = pull;
+
+	map->type = PIN_MAP_TYPE_CONFIGS_PIN;
+	map->data.configs.group_or_pin = ak39_gpio_pins[pin].name;
+	map->data.configs.configs = configs;
+	map->data.configs.num_configs = 1;
+	(*maps)++;
+
+	return 0;
+}
+
+static int ak39_pctl_dt_node_to_map(struct pinctrl_dev *pctldev,
+		struct device_node *np,
+		struct pinctrl_map **map, unsigned *num_maps)
+{
+	struct ak39_pinctrl *pc = pinctrl_dev_get_drvdata(pctldev);
+	struct property *pins, *funcs, *pulls;
+	int num_pins, num_funcs, num_pulls, maps_per_pin;
+	struct pinctrl_map *maps, *cur_map;
+	int i, err;
+	u32 pin, func, pull;
+
+	pins = of_find_property(np, "anyka,pins", NULL);
+	if (!pins) {
+		dev_err(pc->dev, "%s: missing anyka,pins property\n",
+				of_node_full_name(np));
+		return -EINVAL;
+	}
+
+	funcs = of_find_property(np, "anyka,function", NULL);
+	pulls = of_find_property(np, "anyka,pull", NULL);
+
+	if (!funcs && !pulls) {
+		dev_err(pc->dev,
+			"%s: neither anyka,function nor anyka,pull specified\n",
+			of_node_full_name(np));
+		return -EINVAL;
+	}
+
+	num_pins = pins->length / 4;
+	num_funcs = funcs ? (funcs->length / 4) : 0;
+	num_pulls = pulls ? (pulls->length / 4) : 0;
+
+	if (num_funcs > 1 && num_funcs != num_pins) {
+		dev_err(pc->dev,
+			"%s: anyka,function must have 1 or %d entries\n",
+			of_node_full_name(np), num_pins);
+		return -EINVAL;
+	}
+
+	if (num_pulls > 1 && num_pulls != num_pins) {
+		dev_err(pc->dev,
+			"%s: anyka,pull must have 1 or %d entries\n",
+			of_node_full_name(np), num_pins);
+		return -EINVAL;
+	}
+
+	maps_per_pin = 0;
+	if (num_funcs)
+		maps_per_pin++;
+	if (num_pulls)
+		maps_per_pin++;
+	cur_map = maps = kzalloc(num_pins * maps_per_pin * sizeof(*maps),
+				GFP_KERNEL);
+	if (!maps)
+		return -ENOMEM;
+
+	for (i = 0; i < num_pins; i++) {
+		err = of_property_read_u32_index(np, "anyka,pins", i, &pin);
+		if (err)
+			goto out;
+		if (pin >= ARRAY_SIZE(ak39_gpio_pins)) {
+			dev_err(pc->dev, "%s: invalid anyka,pins value %d\n",
+				of_node_full_name(np), pin);
+			err = -EINVAL;
+			goto out;
+		}
+
+		if (num_funcs) {
+			err = of_property_read_u32_index(np, "anyka,function",
+					(num_funcs > 1) ? i : 0, &func);
+			if (err)
+				goto out;
+			err = ak39_pctl_dt_node_to_map_func(pc, np, pin,
+							func, &cur_map);
+			if (err)
+				goto out;
+		}
+		if (num_pulls) {
+			err = of_property_read_u32_index(np, "anyka,pull",
+					(num_pulls > 1) ? i : 0, &pull);
+			if (err)
+				goto out;
+			err = ak39_pctl_dt_node_to_map_pull(pc, np, pin,
+							pull, &cur_map);
+			if (err)
+				goto out;
+		}
+	}
+
+	*map = maps;
+	*num_maps = num_pins * maps_per_pin;
+	return 0;
+
+out:
+	kfree(maps);
+	return err;
+}
+
+static const struct pinctrl_ops ak39_pctl_ops = {
+	.get_groups_count = ak39_pctl_get_groups_count,
+	.get_group_name = ak39_pctl_get_group_name,
+	.get_group_pins = ak39_pctl_get_group_pins,
+	.pin_dbg_show = ak39_pctl_pin_dbg_show,
+	.dt_node_to_map = ak39_pctl_dt_node_to_map,
+	.dt_free_map = ak39_pctl_dt_free_map,
+};
+
+static int ak39_pmx_get_functions_count(struct pinctrl_dev *pctldev)
+{
+	return ARRAY_SIZE(ak39_sharepin_func);
+}
+
+static const char *ak39_pmx_get_function_name(struct pinctrl_dev *pctldev,
+		unsigned selector)
+{
+	struct ak39_pinctrl *pc = pinctrl_dev_get_drvdata(pctldev);
+	dev_dbg(pc->dev, "ak39_pmx_get_function_name %s\n", ak39_sharepin_func[selector].name);
+	return ak39_sharepin_func[selector].name;
+}
+
+static int ak39_pmx_get_function_groups(struct pinctrl_dev *pctldev,
+		unsigned selector,
+		const char * const **groups,
+		unsigned * const num_groups)
+{
+	*groups = ak39_gpio_groups;
+	*num_groups = ARRAY_SIZE(ak39_gpio_groups);
+
+	return 0;
+}
+
+static int ak39_pmx_set(struct pinctrl_dev *pctldev,
+		unsigned func_selector,
+		unsigned group_selector)
+{
+	struct ak39_pinctrl *pc = pinctrl_dev_get_drvdata(pctldev);
+
+	ak39_pinctrl_fsel_set(pc, group_selector, func_selector);
+	return 0;
+}
+
+static void ak39_pmx_gpio_disable_free(struct pinctrl_dev *pctldev,
+		struct pinctrl_gpio_range *range,
+		unsigned offset)
+{
+	struct ak39_pinctrl *pc = pinctrl_dev_get_drvdata(pctldev);
+
+	/* disable by setting sahrepin cfg to default value */
+	ak39_pinctrl_fsel_reset(pc, offset, pc->fsel[offset]);
+}
+
+static int ak39_pmx_gpio_set_direction(struct pinctrl_dev *pctldev,
+		struct pinctrl_gpio_range *range,
+		unsigned offset,
+		bool input)
+{
+	struct ak39_pinctrl *pc = pinctrl_dev_get_drvdata(pctldev);
+	unsigned long flags;
+	u32 regval;
+	void __iomem *reg = pc->base + AK_GPIO_DIR_BASE(offset);
+	unsigned int bit = AK_GPIO_REG_SHIFT(offset);
+	int gpio_cfg = input ?
+		ePIN_AS_GPIO_IN : ePIN_AS_GPIO_OUT;
+
+	local_irq_save(flags);
+    if (ePIN_AS_GPIO_IN == gpio_cfg){
+		regval = __raw_readl(reg);
+		regval &= ~(1<<bit);
+		__raw_writel(regval, reg);
+    }else if (ePIN_AS_GPIO_OUT == gpio_cfg){
+        regval = __raw_readl(reg);
+		regval |= (1<<bit);
+		__raw_writel(regval, reg);
+    }
+    local_irq_restore(flags);
+
+	return 0;
+}
+
+static const struct pinmux_ops ak39_pmx_ops = {
+	.get_functions_count = ak39_pmx_get_functions_count,
+	.get_function_name = ak39_pmx_get_function_name,
+	.get_function_groups = ak39_pmx_get_function_groups,
+	.set_mux = ak39_pmx_set,
+	.gpio_disable_free = ak39_pmx_gpio_disable_free,
+	.gpio_set_direction = ak39_pmx_gpio_set_direction,
+};
+
+static int ak39_pinconf_get(struct pinctrl_dev *pctldev,
+			unsigned pin, unsigned long *config)
+{
+	/* No way to read back config in HW */
+	return -ENOTSUPP;
+}
+
+static int ak39_pinconf_set(struct pinctrl_dev *pctldev,
+			unsigned pin, unsigned long *configs,
+			unsigned num_configs)
+{
+	//struct ak39_pinctrl *pc = pinctrl_dev_get_drvdata(pctldev);
+	void __iomem *reg;
+	u32 arg;
+	u32 regval;
+	int i;
+	unsigned long flags;
+
+	pr_debug("%s: pin:%u config: %lu enter!\n",__func__,pin, configs[0]);
+
+	for (i = 0; i < num_configs; i++) {
+		arg = configs[i];
+
+		if (arg != 0 && arg != 1)
+			return -EINVAL;
+
+		switch(pupd_cfg_info[pin].pupd_cfg) {
+			case PUPD_CFG1:
+				reg = AK_PPU_PPD1;
+				break;
+			case PUPD_CFG2:
+				reg = AK_PPU_PPD2;
+				break;
+			case PUPD_CFG3:
+				reg = AK_PPU_PPD3;
+				break;
+			case PUPD_CFG4:
+				reg = AK_PPU_PPD4;
+				break;							
+		}		
+
+		local_irq_save(flags);
+		/* write 0 to enable, write 1 to disable */
+		if (arg == AK_PULLUPDOWN_ENABLE){
+			regval = __raw_readl(reg);
+			regval &= ~(1<<pupd_cfg_info[pin].index);
+			__raw_writel(regval, reg);
+			
+		}else if (arg == AK_PULLUPDOWN_DISABLE){
+			regval = __raw_readl(reg);
+			regval |= (1<<pupd_cfg_info[pin].index);
+			__raw_writel(regval, reg);
+		}
+		local_irq_restore(flags);
+	} /* for each config */
+
+	return 0;
+}
+
+/* for gpio PU/PD config */
+static const struct pinconf_ops ak39_pinconf_ops = {
+	.pin_config_get = ak39_pinconf_get,
+	.pin_config_set = ak39_pinconf_set,
+};
+
+static struct pinctrl_desc ak39_pinctrl_desc = {
+	.name = MODULE_NAME,
+	.pins = ak39_gpio_pins,
+	.npins = ARRAY_SIZE(ak39_gpio_pins),
+	.pctlops = &ak39_pctl_ops,
+	.pmxops = &ak39_pmx_ops,
+	.confops = &ak39_pinconf_ops,
+	.owner = THIS_MODULE,
+};
+
+static struct pinctrl_gpio_range ak39_pinctrl_gpio_range = {
+	.name = MODULE_NAME,
+	.npins = AK39_NUM_GPIOS,
+};
+
+static int ak39_pinctrl_probe(struct platform_device *pdev)
+{
+	struct device *dev = &pdev->dev;
+	struct device_node *np = dev->of_node;
+	struct ak39_pinctrl *pc;
+	struct resource iomem;
+	int ret, i;
+
+	BUILD_BUG_ON(ARRAY_SIZE(ak39_gpio_pins) != AK39_NUM_GPIOS);
+
+	pc = devm_kzalloc(dev, sizeof(*pc), GFP_KERNEL);
+	if (!pc)
+		return -ENOMEM;
+
+	platform_set_drvdata(pdev, pc);
+	pc->dev = dev;
+
+	ret= of_address_to_resource(np, 0, &iomem);
+	if (ret) {
+		dev_err(dev, "could not get IO memory\n");
+		return ret;
+	}
+
+	pc->base = devm_ioremap_resource(dev, &iomem);
+	if (IS_ERR(pc->base))
+		return PTR_ERR(pc->base);
+
+	pc->gc = ak39_gpio_chip;
+	pc->gc.dev = dev;
+	pc->gc.of_node = np;
+
+	pc->clk = devm_clk_get(&pdev->dev, NULL);
+	if (IS_ERR(pc->clk)) {
+		ret = PTR_ERR(pc->clk);
+		return ret;
+	}
+
+	clk_prepare_enable(pc->clk);
+
+	pc->irq = platform_get_irq(pdev, 0);
+	if (pc->irq < 0) {
+		ret = pc->irq;
+		goto clk_err;
+	}
+	pr_err("ak39_pinctrl_probe irq: %d\n", pc->irq);
+
+	/* set default sharepin config as gpio */
+	__raw_writel(AK_SHAREPIN_CON2_AS_GPIO, AK_SHAREPIN_CON2);
+	
+	pc->irq_domain = irq_domain_add_linear(np, AK39_NUM_GPIOS,
+			&irq_domain_simple_ops, pc);
+	if (!pc->irq_domain) {
+		dev_err(dev, "could not create IRQ domain\n");
+		ret = -ENOMEM;
+		goto clk_err;
+	}
+
+	for (i = 0; i < AK39_NUM_GPIOS; i++) {
+		int irq = irq_create_mapping(pc->irq_domain, i);
+		//pr_err("i = %d irq = %d\n", i, irq);
+		pc->irq_type[i] = 0;
+		pc->fsel[i] = 0;
+		irq_set_chip_and_handler(irq, &ak39_gpio_irq_chip,
+				handle_level_irq);
+		irq_set_chip_data(irq, pc);
+	}
+
+	irq_set_chained_handler_and_data(pc->irq,
+						 ak39_pinctrl_irq_handler, pc);
+
+	ret = gpiochip_add(&pc->gc);
+	if (ret) {
+		dev_err(dev, "could not add GPIO chip\n");
+		goto clk_err;
+	}
+
+	pc->pctl_dev = pinctrl_register(&ak39_pinctrl_desc, dev, pc);
+	if (IS_ERR(pc->pctl_dev)) {
+		gpiochip_remove(&pc->gc);
+		ret = PTR_ERR(pc->pctl_dev);
+		goto clk_err;
+	}
+
+	pc->gpio_range = ak39_pinctrl_gpio_range;
+	pc->gpio_range.base = pc->gc.base;
+	pc->gpio_range.gc = &pc->gc;
+	pinctrl_add_gpio_range(pc->pctl_dev, &pc->gpio_range);
+
+	return 0;
+
+clk_err:
+	clk_disable_unprepare(pc->clk);
+	clk_put(pc->clk);
+
+	return ret;
+}
+
+static int ak39_pinctrl_remove(struct platform_device *pdev)
+{
+	struct ak39_pinctrl *pc = platform_get_drvdata(pdev);
+
+	pinctrl_unregister(pc->pctl_dev);
+	gpiochip_remove(&pc->gc);
+	clk_disable_unprepare(pc->clk);
+	clk_put(pc->clk);
+
+	return 0;
+}
+
+static const struct of_device_id ak39_pinctrl_match[] = {
+	{ .compatible = "anyka,ak3916ev300-gpio" },
+	{}
+};
+MODULE_DEVICE_TABLE(of, ak39_pinctrl_match);
+
+static struct platform_driver ak39_pinctrl_driver = {
+	.probe = ak39_pinctrl_probe,
+	.remove = ak39_pinctrl_remove,
+	.driver = {
+		.name = MODULE_NAME,
+		.of_match_table = ak39_pinctrl_match,
+	},
+};
+
+static int __init ak39_pinctrl_init(void)
+{
+	return platform_driver_register(&ak39_pinctrl_driver);
+}
+
+static void __exit ak39_pinctrl_exit(void)
+{
+	platform_driver_unregister(&ak39_pinctrl_driver);
+}
+
+subsys_initcall(ak39_pinctrl_init);
+module_exit(ak39_pinctrl_exit);
+
+MODULE_DESCRIPTION("AK39 sharepin control driver");
+MODULE_AUTHOR("Feilong Dong <dong_feilong@anyka.com>");
+MODULE_LICENSE("GPL");
diff --git a/drivers/pinctrl/anyka/ak_pinctrl.c b/drivers/pinctrl/anyka/ak_pinctrl.c
new file mode 100755
index 0000000..2e7b06b
--- /dev/null
+++ b/drivers/pinctrl/anyka/ak_pinctrl.c
@@ -0,0 +1,2540 @@
+/*
+ * Driver for AK37D GPIO (pinctrl + GPIO)
+ *
+ * Copyright (C) 2018 Anyka(Guangzhou) Microelectronics Technology Co., Ltd.
+ *
+ * This driver is inspired by:
+ * pinctrl-bcm2835.c, please see original file for copyright information
+ * pinctrl-tegra.c, please see original file for copyright information
+ *
+ * Author: Feilong Dong <dong_feilong@anyka.com>
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#define pr_fmt(fmt) KBUILD_MODNAME ": " fmt
+#include <linux/bitmap.h>
+#include <linux/bug.h>
+#include <linux/delay.h>
+#include <linux/device.h>
+#include <linux/err.h>
+#include <linux/gpio.h>
+#include <linux/interrupt.h>
+#include <linux/io.h>
+#include <linux/irq.h>
+#include <linux/irqdesc.h>
+#include <linux/irqdomain.h>
+#include <linux/irqchip/chained_irq.h>
+#include <linux/module.h>
+#include <linux/of_address.h>
+#include <linux/of.h>
+#include <linux/of_irq.h>
+#include <linux/pinctrl/consumer.h>
+#include <linux/pinctrl/machine.h>
+#include <linux/pinctrl/pinconf.h>
+#include <linux/pinctrl/pinctrl.h>
+#include <linux/pinctrl/pinmux.h>
+#include <linux/platform_device.h>
+#include <linux/seq_file.h>
+#include <linux/slab.h>
+#include <linux/spinlock.h>
+#include <linux/types.h>
+#include <linux/clk.h>
+
+#include <mach/map.h>
+
+#define MODULE_NAME "ak-pinctrl"
+#define AK37D_NUM_GPIOS 123
+#define AK37D_NUM_BANKS 1
+
+#define	AK_PULLUPDOWN_DISABLE	0
+#define	AK_PULLUPDOWN_ENABLE	1
+
+#define	ePIN_AS_GPIO_IN  0		// pin as gpio in
+#define	ePIN_AS_GPIO_OUT 1      // pin as gpio out
+
+#define	AK_GPIO_OUT_LOW			0
+#define	AK_GPIO_OUT_HIGH		1
+
+#define AK_GPIO_DIR1			0x00
+#define AK_GPIO_OUT1			0x14
+#define AK_GPIO_INPUT1         	0x28
+#define AK_GPIO_INT_MASK1      	0x3c
+#define AK_GPIO_INT_MODE1      	0x50
+#define AK_GPIO_INTP1         	0x64
+#define AK_GPIO_EDGE_STATUS1	0x78
+
+#define AK_GPIO_DIR_BASE(pin)			(((pin)>>5)*4 + AK_GPIO_DIR1)
+#define AK_GPIO_OUT_BASE(pin)			(((pin)>>5)*4 + AK_GPIO_OUT1)
+#define AK_GPIO_IN_BASE(pin)			(((pin)>>5)*4 + AK_GPIO_INPUT1)
+#define AK_GPIO_INTEN_BASE(pin)			(((pin)>>5)*4 + AK_GPIO_INT_MASK1)
+#define AK_GPIO_INTM_BASE(pin)			(((pin)>>5)*4 + AK_GPIO_INT_MODE1)
+#define AK_GPIO_INTPOL_BASE(pin)		(((pin)>>5)*4 + AK_GPIO_INTP1)
+#define AK_GPIO_INTEDGE_BASE(pin)		(((pin)>>5)*4 + AK_GPIO_EDGE_STATUS1)
+
+#define AK_GPIO_REG_SHIFT(pin)	((pin) % 32)
+
+/*Analog Control Register 3 (0x080000A4)*/
+#define AK_ANALOG_CTRL_REG3		(AK_VA_SYSCTRL + 0x0A4)
+
+#define AK_SHAREPIN_CON0		(AK_VA_SYSCTRL + 0x178)
+#define AK_SHAREPIN_CON1		(AK_VA_SYSCTRL + 0x17C)
+#define AK_SHAREPIN_CON2		(AK_VA_SYSCTRL + 0x180)
+#define AK_SHAREPIN_CON3		(AK_VA_SYSCTRL + 0x184)
+#define AK_SHAREPIN_CON4		(AK_VA_SYSCTRL + 0x188)
+#define AK_SHAREPIN_CON5		(AK_VA_SYSCTRL + 0x18C)
+
+#define AK_SHAREPIN_CON6		(AK_VA_SYSCTRL + 0x190)
+
+#define AK_GPIO_DRIVE_CON0		(AK_VA_SYSCTRL + 0x1D0)
+#define AK_GPIO_DRIVE_CON1		(AK_VA_SYSCTRL + 0x1D4)
+#define AK_GPIO_DRIVE_CON2		(AK_VA_SYSCTRL + 0x1D8)
+#define AK_GPIO_DRIVE_CON3		(AK_VA_SYSCTRL + 0x1DC)
+#define AK_GPIO_DRIVE_CON4		(AK_VA_SYSCTRL + 0x1E0)
+#define AK_GPIO_DRIVE_CON5		(AK_VA_SYSCTRL + 0x1E4)
+
+#define AK_PPU_PPD_EN0          (AK_VA_SYSCTRL + 0x194)
+#define AK_PPU_PPD_EN1        	(AK_VA_SYSCTRL + 0x198)
+#define AK_PPU_PPD_EN2        	(AK_VA_SYSCTRL + 0x19C)
+
+#define AK_PPU_PPD_SEL0         (AK_VA_SYSCTRL + 0x1A0)
+#define AK_PPU_PPD_SEL1         (AK_VA_SYSCTRL + 0x1A4)
+#define AK_PPU_PPD_SEL2         (AK_VA_SYSCTRL + 0x1E8)
+
+#define AK_PPU_PPD_EN_SEL       (AK_VA_SYSCTRL + 0x1F8)
+
+#define AK_GPIO_IE_CON0			(AK_VA_SYSCTRL + 0x1EC)
+#define AK_GPIO_IE_CON1			(AK_VA_SYSCTRL + 0x1F0)
+#define AK_GPIO_IE_CON2			(AK_VA_SYSCTRL + 0x1F4)
+
+#define AK_GPIO_SLEW_RATE		(AK_VA_SYSCTRL + 0x1FC)
+
+#define AK_INTERRUPT_STATUS		(AK_VA_SYSCTRL + 0x30)
+#define AK_ALWAYS_ON_PMU_CTRL0	(AK_VA_SYSCTRL + 0xDC)
+#define AK_ALWAYS_ON_PMU_CTRL1	(AK_VA_SYSCTRL + 0xE0)
+
+/* pins are just named gpio0..gpio85 */
+#define AK37D_GPIO_PIN(a) PINCTRL_PIN(a, "gpio" #a)
+
+/*
+ *H3D-B changed drive map
+ *00->10
+ *01->11
+ *10->00
+ *11->01
+ * */
+#define DRIVE_STRENGTH(strength)	((strength) ^ 0x2)
+//#define DRIVE_STRENGTH(strength)	(strength)
+
+/*
+ *	bit	8				7/6/5	4/3		2/1/0
+ *		pupd_enable_bit	value	width	AO,I,I/O
+ * */
+#define GPIO_CLASS_IO	(0x0)
+#define GPIO_CLASS_I	(0x1)
+#define GPIO_CLASS_O	(0x2)
+#define GPIO_CLASS_AO	(0x3)
+
+#define SET_GPIO_CLASS(c)			((c) & 0x7)
+#define SET_SHAREPIN_BITS_WIDTH(w)	(((w) & 0x3) << 3)
+#define SET_VALUE_TO_GPIO(v)		(((v) & 0x7) << 5)
+#define SET_PUPD_ENABLE_BIT(e)		(((e) & 0x1) << 8)
+
+#define GET_GPIO_CLASS(c)		((c) & 0x7)
+#define GET_SHAREPIN_WIDTH(c)	(((c) >> 3) & 0x3)
+#define GET_GPIO_SET_VALUE(c)	(((c) >> 5) & 0x7)
+#define GET_PUPD_ENABLE_BIT(c)	(((c) >> 8) & 0x1)
+
+/*
+ *GPIO_CFG - gpio
+ *GPI_CFG -  GPI
+ *GPO_CFG -  GPO
+ *AO_CFG -   GPIO_AO
+ * */
+#define GPIO_CFG(width, value)	(SET_VALUE_TO_GPIO(value) |\
+		SET_SHAREPIN_BITS_WIDTH(width) | SET_GPIO_CLASS(GPIO_CLASS_IO))
+#define GPI_CFG(width, value)	(SET_VALUE_TO_GPIO(value) |\
+		SET_SHAREPIN_BITS_WIDTH(width) | SET_GPIO_CLASS(GPIO_CLASS_I))
+#define GPO_CFG(width, value)	(SET_VALUE_TO_GPIO(value) |\
+		SET_SHAREPIN_BITS_WIDTH(width) | SET_GPIO_CLASS(GPIO_CLASS_O))
+#define AO_CFG(width, value)	(SET_VALUE_TO_GPIO(value) |\
+		SET_SHAREPIN_BITS_WIDTH(width) | SET_GPIO_CLASS(GPIO_CLASS_AO))
+
+/*all capacity can't cfg*/
+#define ALL_DIS			(0)
+/*expect drive fixed, pull up fixed*/
+#define DFIX_UP			(1)
+/*expect drive fixed, pull down fixed*/
+#define DFIX_DOWN		(2)
+/*expect drive fixed, pull up fixed, IE enable fixed*/
+#define DFIX_UP_IEEN	(3)
+/*expect drive fixed, pull down fixed, IE enable fixed*/
+#define DFIX_DOWN_IEEN	(4)
+/*expect IE enable fixed*/
+#define	IEEN			(5)
+/*expect drive fixed, IE enable fixed*/
+#define	DFIX_IEEN		(6)
+/*all capacity support*/
+#define ALL_EN			(0xf)
+
+struct pin_pos {
+	int offset;
+	int width;
+	int gpio0;
+	int func0;
+	int gpio1;
+	int func1;
+	int gpio2;
+	int func2;
+	int gpio3;
+	int func3;
+};
+
+struct gpio_sharepin {
+	int pin;
+	void __iomem * sharepin_reg;
+	void __iomem * drive_reg;
+	u32 reg_off;
+
+	void __iomem * pupd_en;
+	void __iomem * pupd_sel;
+	void __iomem * ie;
+	u32 sel_bit;
+
+	int slew_bit;
+	int gpio_config;
+	int capacity;
+};
+
+struct ak_pinctrl {
+	struct device *dev;
+	struct clk *clk;
+	void __iomem *gpio_base;
+	void __iomem *mipi0_base;
+	void __iomem *mipi1_base;
+	int irq;
+
+	unsigned int irq_type[AK37D_NUM_GPIOS];
+	int fsel[AK37D_NUM_GPIOS];
+
+	struct pinctrl_dev *pctl_dev;
+	struct irq_domain *irq_domain;
+	struct gpio_chip gc;
+	struct pinctrl_gpio_range gpio_range;
+
+	int GPI_MIPI0_pull_polarity;
+	int GPI_MIPI1_pull_polarity;
+	int mipi0_lanes_num;
+	int mipi1_lanes_num;
+	int ttl_io_voltage;
+
+	spinlock_t lock;
+};
+
+static struct pinctrl_pin_desc ak_gpio_pins[] = {
+	AK37D_GPIO_PIN(0),
+	AK37D_GPIO_PIN(1),
+	AK37D_GPIO_PIN(2),
+	AK37D_GPIO_PIN(3),
+	AK37D_GPIO_PIN(4),
+	AK37D_GPIO_PIN(5),
+	AK37D_GPIO_PIN(6),
+	AK37D_GPIO_PIN(7),
+	AK37D_GPIO_PIN(8),
+	AK37D_GPIO_PIN(9),
+	AK37D_GPIO_PIN(10),
+	AK37D_GPIO_PIN(11),
+	AK37D_GPIO_PIN(12),
+	AK37D_GPIO_PIN(13),
+	AK37D_GPIO_PIN(14),
+	AK37D_GPIO_PIN(15),
+	AK37D_GPIO_PIN(16),
+	AK37D_GPIO_PIN(17),
+	AK37D_GPIO_PIN(18),
+	AK37D_GPIO_PIN(19),
+	AK37D_GPIO_PIN(20),
+	AK37D_GPIO_PIN(21),
+	AK37D_GPIO_PIN(22),
+	AK37D_GPIO_PIN(23),
+	AK37D_GPIO_PIN(24),
+	AK37D_GPIO_PIN(25),
+	AK37D_GPIO_PIN(26),
+	AK37D_GPIO_PIN(27),
+	AK37D_GPIO_PIN(28),
+	AK37D_GPIO_PIN(29),
+	AK37D_GPIO_PIN(30),
+	AK37D_GPIO_PIN(31),
+	AK37D_GPIO_PIN(32),
+	AK37D_GPIO_PIN(33),
+	AK37D_GPIO_PIN(34),
+	AK37D_GPIO_PIN(35),
+	AK37D_GPIO_PIN(36),
+	AK37D_GPIO_PIN(37),
+	AK37D_GPIO_PIN(38),
+	AK37D_GPIO_PIN(39),
+	AK37D_GPIO_PIN(40),
+	AK37D_GPIO_PIN(41),
+	AK37D_GPIO_PIN(42),
+	AK37D_GPIO_PIN(43),
+	AK37D_GPIO_PIN(44),
+	AK37D_GPIO_PIN(45),
+	AK37D_GPIO_PIN(46),
+	AK37D_GPIO_PIN(47),
+	AK37D_GPIO_PIN(48),
+	AK37D_GPIO_PIN(49),
+	AK37D_GPIO_PIN(50),
+	AK37D_GPIO_PIN(51),
+	AK37D_GPIO_PIN(52),
+	AK37D_GPIO_PIN(53),
+	AK37D_GPIO_PIN(54),
+	AK37D_GPIO_PIN(55),
+	AK37D_GPIO_PIN(56),
+	AK37D_GPIO_PIN(57),
+	AK37D_GPIO_PIN(58),
+	AK37D_GPIO_PIN(59),
+	AK37D_GPIO_PIN(60),
+	AK37D_GPIO_PIN(61),
+	AK37D_GPIO_PIN(62),
+	AK37D_GPIO_PIN(63),
+	AK37D_GPIO_PIN(64),
+	AK37D_GPIO_PIN(65),
+	AK37D_GPIO_PIN(66),
+	AK37D_GPIO_PIN(67),
+	AK37D_GPIO_PIN(68),
+	AK37D_GPIO_PIN(69),
+	AK37D_GPIO_PIN(70),
+	AK37D_GPIO_PIN(71),
+	AK37D_GPIO_PIN(72),
+	AK37D_GPIO_PIN(73),
+	AK37D_GPIO_PIN(74),
+	AK37D_GPIO_PIN(75),
+	AK37D_GPIO_PIN(76),
+	AK37D_GPIO_PIN(77),
+	AK37D_GPIO_PIN(78),
+	AK37D_GPIO_PIN(79),
+	AK37D_GPIO_PIN(80),
+	AK37D_GPIO_PIN(81),
+	AK37D_GPIO_PIN(82),
+	AK37D_GPIO_PIN(83),
+	AK37D_GPIO_PIN(84),
+	AK37D_GPIO_PIN(85),
+	AK37D_GPIO_PIN(86),
+	AK37D_GPIO_PIN(87),
+	AK37D_GPIO_PIN(88),
+	AK37D_GPIO_PIN(89),
+	AK37D_GPIO_PIN(90),
+	AK37D_GPIO_PIN(91),
+	AK37D_GPIO_PIN(92),
+	AK37D_GPIO_PIN(93),
+	AK37D_GPIO_PIN(94),
+	AK37D_GPIO_PIN(95),
+	AK37D_GPIO_PIN(96),
+	AK37D_GPIO_PIN(97),
+	AK37D_GPIO_PIN(98),
+	AK37D_GPIO_PIN(99),
+	AK37D_GPIO_PIN(100),
+	AK37D_GPIO_PIN(101),
+	AK37D_GPIO_PIN(102),
+	AK37D_GPIO_PIN(103),
+	AK37D_GPIO_PIN(104),
+	AK37D_GPIO_PIN(105),
+	AK37D_GPIO_PIN(106),
+	AK37D_GPIO_PIN(107),
+	AK37D_GPIO_PIN(108),
+	AK37D_GPIO_PIN(109),
+	AK37D_GPIO_PIN(110),
+	AK37D_GPIO_PIN(111),
+	AK37D_GPIO_PIN(112),
+	AK37D_GPIO_PIN(113),
+	AK37D_GPIO_PIN(114),
+	AK37D_GPIO_PIN(115),
+	AK37D_GPIO_PIN(116),
+	AK37D_GPIO_PIN(117),
+	AK37D_GPIO_PIN(118),
+	AK37D_GPIO_PIN(119),
+	AK37D_GPIO_PIN(120),
+	AK37D_GPIO_PIN(121),
+	AK37D_GPIO_PIN(122),
+};
+
+/* one pin per group */
+static const char * const ak_gpio_groups[] = {
+	"gpio0",
+	"gpio1",
+	"gpio2",
+	"gpio3",
+	"gpio4",
+	"gpio5",
+	"gpio6",
+	"gpio7",
+	"gpio8",
+	"gpio9",
+	"gpio10",
+	"gpio11",
+	"gpio12",
+	"gpio13",
+	"gpio14",
+	"gpio15",
+	"gpio16",
+	"gpio17",
+	"gpio18",
+	"gpio19",
+	"gpio20",
+	"gpio21",
+	"gpio22",
+	"gpio23",
+	"gpio24",
+	"gpio25",
+	"gpio26",
+	"gpio27",
+	"gpio28",
+	"gpio29",
+	"gpio30",
+	"gpio31",
+	"gpio32",
+	"gpio33",
+	"gpio34",
+	"gpio35",
+	"gpio36",
+	"gpio37",
+	"gpio38",
+	"gpio39",
+	"gpio40",
+	"gpio41",
+	"gpio42",
+	"gpio43",
+	"gpio44",
+	"gpio45",
+	"gpio46",
+	"gpio47",
+	"gpio48",
+	"gpio49",
+	"gpio50",
+	"gpio51",
+	"gpio52",
+	"gpio53",
+	"gpio54",
+	"gpio55",
+	"gpio56",
+	"gpio57",
+	"gpio58",
+	"gpio59",
+	"gpio60",
+	"gpio61",
+	"gpio62",
+	"gpio63",
+	"gpio64",
+	"gpio65",
+	"gpio66",
+	"gpio67",
+	"gpio68",
+	"gpio69",
+	"gpio70",
+	"gpio71",
+	"gpio72",
+	"gpio73",
+	"gpio74",
+	"gpio75",
+	"gpio76",
+	"gpio77",
+	"gpio78",
+	"gpio79",
+	"gpio80",
+	"gpio81",
+	"gpio82",
+	"gpio83",
+	"gpio84",
+	"gpio85",
+	"gpio86",
+	"gpio87",
+	"gpio88",
+	"gpio89",
+	"gpio90",
+	"gpio91",
+	"gpio92",
+	"gpio93",
+	"gpio94",
+	"gpio95",
+	"gpio96",
+	"gpio97",
+	"gpio98",
+	"gpio99",
+	"gpio100",
+	"gpio101",
+	"gpio102",
+	"gpio103",
+	"gpio104",
+	"gpio105",
+	"gpio106",
+	"gpio107",
+	"gpio108",
+	"gpio109",
+	"gpio110",
+	"gpio111",
+	"gpio112",
+	"gpio113",
+	"gpio114",
+	"gpio115",
+	"gpio116",
+	"gpio117",
+	"gpio118",
+	"gpio119",
+	"gpio120",
+	"gpio121",
+	"gpio122",
+};
+
+static const char * const ak_funcs[5] = {
+	[0] = "default func",
+	[1] = "func1",
+	[2] = "func2",
+	[3] = "func3",
+	[4] = "func4",
+};
+
+//share pin func config in AK37Dxx
+static struct gpio_sharepin ak_sharepin[] = {
+	/* goio, uart3_rx */
+	{0, AK_SHAREPIN_CON3, AK_GPIO_DRIVE_CON3, 8, AK_PPU_PPD_EN1, AK_PPU_PPD_SEL1, AK_GPIO_IE_CON1, 20, -1, GPIO_CFG(2, 0B00), ALL_EN},
+	/* gpio, uart0_rx, pwm4 */
+	{1, AK_SHAREPIN_CON0, AK_GPIO_DRIVE_CON0, 0, AK_PPU_PPD_EN0, AK_PPU_PPD_SEL0, AK_GPIO_IE_CON0, 0, -1, GPIO_CFG(2, 0B00), ALL_EN},
+	/* gpio, uart0_tx, pwm3 */
+	{2, AK_SHAREPIN_CON0, AK_GPIO_DRIVE_CON0, 2, AK_PPU_PPD_EN0, AK_PPU_PPD_SEL0, AK_GPIO_IE_CON0, 1, -1, GPIO_CFG(2, 0B00), ALL_EN},
+	/* gpio, pwm0, mci2_d0 */
+	{3, AK_SHAREPIN_CON0, AK_GPIO_DRIVE_CON0, 4, AK_PPU_PPD_EN0, 0, AK_GPIO_IE_CON0, 2, -1, GPIO_CFG(2, 0B00), DFIX_UP},
+	/* gpio, pwm1, uart3_tx, mci2_cmd */
+	{4, AK_SHAREPIN_CON0, AK_GPIO_DRIVE_CON0, 6, AK_PPU_PPD_EN0, 0, AK_GPIO_IE_CON0, 3, -1, GPIO_CFG(2, 0B00), DFIX_DOWN},
+	/* gpio, pwm2, uart3_rx, mci2_clk */
+	{5, AK_SHAREPIN_CON0, AK_GPIO_DRIVE_CON0, 8, AK_PPU_PPD_EN0, 0, AK_GPIO_IE_CON0, 4, -1, GPIO_CFG(2, 0B00), DFIX_DOWN},
+	/* gpio, uart1_rx, pwm0, i2c3_scl */
+	{6, AK_SHAREPIN_CON0, AK_GPIO_DRIVE_CON0, 10, AK_PPU_PPD_EN0, AK_PPU_PPD_SEL0, AK_GPIO_IE_CON0, 5, -1, GPIO_CFG(2, 0B00), ALL_EN},
+	/* gpio, pwm1, i2c3_sda */
+	{7, AK_SHAREPIN_CON0, AK_GPIO_DRIVE_CON0, 12, AK_PPU_PPD_EN0, AK_PPU_PPD_SEL0, AK_GPIO_IE_CON0, 6, -1, GPIO_CFG(2, 0B00), ALL_EN},
+	/* gpio, uart1_cts, irda_rx */
+	{8, AK_SHAREPIN_CON0, AK_GPIO_DRIVE_CON0, 14, AK_PPU_PPD_EN0, AK_PPU_PPD_SEL0, AK_GPIO_IE_CON0, 7, -1, GPIO_CFG(2, 0B00), ALL_EN},
+	/* gpio, uart1_rts */
+	{9, AK_SHAREPIN_CON0, AK_GPIO_DRIVE_CON0, 16, AK_PPU_PPD_EN0, AK_PPU_PPD_SEL0, AK_GPIO_IE_CON0, 8, 28, GPIO_CFG(2, 0B00), ALL_EN},
+	/* gpio, rmii_mdc, i2c3_scl, pwm0 */
+	{10, AK_SHAREPIN_CON0, AK_GPIO_DRIVE_CON0, 18, AK_PPU_PPD_EN0, AK_PPU_PPD_SEL0, AK_GPIO_IE_CON0, 9, 28, GPIO_CFG(2, 0B00), ALL_EN},
+	/* gpio, rmii_mdio, i2c3_sda */
+	{11, AK_SHAREPIN_CON0, AK_GPIO_DRIVE_CON0, 20, AK_PPU_PPD_EN0, AK_PPU_PPD_SEL0, AK_GPIO_IE_CON0, 10, 28, GPIO_CFG(2, 0B00), ALL_EN},
+	/* spi0_cs, gpio */
+	{12, AK_SHAREPIN_CON3, AK_GPIO_DRIVE_CON3, 28, AK_PPU_PPD_EN1, AK_PPU_PPD_SEL1, AK_GPIO_IE_CON1, 30, -1, GPIO_CFG(2, 0B01), ALL_EN},
+	/* gpio, rmii_txen */
+	{13, AK_SHAREPIN_CON0, AK_GPIO_DRIVE_CON0, 22, AK_PPU_PPD_EN0, AK_PPU_PPD_SEL0, AK_GPIO_IE_CON0, 11, 28, GPIO_CFG(2, 0B00), ALL_EN},
+	/* gpio, rmii_txd0, mci2_d3 */
+	{14, AK_SHAREPIN_CON0, AK_GPIO_DRIVE_CON0, 24, AK_PPU_PPD_EN0, AK_PPU_PPD_SEL0, AK_GPIO_IE_CON0, 12, 28, GPIO_CFG(2, 0B00), ALL_EN},
+	/* gpio, rmii_txd1,mci2_d2 */
+	{15, AK_SHAREPIN_CON0, AK_GPIO_DRIVE_CON0, 26, AK_PPU_PPD_EN0, AK_PPU_PPD_SEL0, AK_GPIO_IE_CON0, 13, 28, GPIO_CFG(2, 0B00), ALL_EN},
+	/* gpio, gpo0_ao */
+	{16, 0, 0, 0, 0, 0, 0, 0, -1, AO_CFG(0, 0B0), ALL_DIS},
+	/* gpio, gpo1_ao */
+	{17, 0, 0, 1, 0, 0, 0, 0, -1, AO_CFG(0, 0B0), ALL_DIS},
+	/* gpio, uart3_txd */
+	{18, AK_SHAREPIN_CON3, AK_GPIO_DRIVE_CON3, 6, AK_PPU_PPD_EN1, AK_PPU_PPD_SEL1, AK_GPIO_IE_CON1, 19, -1, GPIO_CFG(2, 0B00), ALL_EN},
+	/* gpio, rmii_rxd0, mci2_clk */
+	{19, AK_SHAREPIN_CON0, AK_GPIO_DRIVE_CON0, 28, AK_PPU_PPD_EN0, AK_PPU_PPD_SEL0, AK_GPIO_IE_CON0, 14, 28, GPIO_CFG(2, 0B00), ALL_EN},
+	/* gpio, rmii_rxd1, mci2_cmd */
+	{20, AK_SHAREPIN_CON0, AK_GPIO_DRIVE_CON0, 30, AK_PPU_PPD_EN0, AK_PPU_PPD_SEL0, AK_GPIO_IE_CON0, 15, 28, GPIO_CFG(2, 0B00), ALL_EN},
+	/* gpio, gpo2_ao */
+	{21, 0, 0, 2, 0, 0, 0, 0, -1, AO_CFG(0, 0B0), ALL_DIS},
+	/* gpio, gpo3_ao */
+	{22, 0, 0, 3, 0, 0, 0, 0, -1, AO_CFG(0, 0B0), ALL_DIS},
+	/* gpio, rmii_rxer, mci2_d1, pwm3 */
+	{23, AK_SHAREPIN_CON1, AK_GPIO_DRIVE_CON1, 0, AK_PPU_PPD_EN0, AK_PPU_PPD_SEL0, AK_GPIO_IE_CON0, 16, 28, GPIO_CFG(2, 0B00), DFIX_DOWN_IEEN},
+	/* gpio, rmii_rxdv, mci2_d0, pwm4 */
+	{24, AK_SHAREPIN_CON1, AK_GPIO_DRIVE_CON1, 2, AK_PPU_PPD_EN0, AK_PPU_PPD_SEL0, AK_GPIO_IE_CON0, 17, 28, GPIO_CFG(2, 0B00), ALL_EN},
+	/* gpio, cis1_sclk */
+	{25, AK_SHAREPIN_CON1, AK_GPIO_DRIVE_CON1, 6, AK_PPU_PPD_EN0, AK_PPU_PPD_SEL0, AK_GPIO_IE_CON0, 19, -1, GPIO_CFG(2, 0B00), ALL_EN},
+	/* gpio, cis_pclk, cis1_sclk */
+	{26, AK_SHAREPIN_CON1, AK_GPIO_DRIVE_CON1, 8, AK_PPU_PPD_EN0, AK_PPU_PPD_SEL0, AK_GPIO_IE_CON0, 20, -1, GPIO_CFG(2, 0B00), ALL_EN},
+	/* gpio, cis_hsync, pwm3, i2c1_scl */
+	{27, AK_SHAREPIN_CON1, AK_GPIO_DRIVE_CON1, 10, AK_PPU_PPD_EN0, AK_PPU_PPD_SEL0, AK_GPIO_IE_CON0, 21, -1, GPIO_CFG(2, 0B00), ALL_EN},
+	/* gpio, cis_vsync, pwm4, i2c1_sda */
+	{28, AK_SHAREPIN_CON1, AK_GPIO_DRIVE_CON1, 12, AK_PPU_PPD_EN0, AK_PPU_PPD_SEL0, AK_GPIO_IE_CON0, 22, -1, GPIO_CFG(2, 0B00), ALL_EN},
+	/* gpio, pwm0 */
+	{29, AK_SHAREPIN_CON3, AK_GPIO_DRIVE_CON3, 10, AK_PPU_PPD_EN1, AK_PPU_PPD_SEL1, AK_GPIO_IE_CON1, 21, -1, GPIO_CFG(2, 0B00), ALL_EN},
+	/* gpio, pwm1 */
+	{30, AK_SHAREPIN_CON3, AK_GPIO_DRIVE_CON3, 12, AK_PPU_PPD_EN1, AK_PPU_PPD_SEL1, AK_GPIO_IE_CON1, 22, -1, GPIO_CFG(2, 0B00), ALL_EN},
+	/* gpio, i2c0_scl */
+	{31, AK_SHAREPIN_CON1, AK_GPIO_DRIVE_CON1, 14, AK_PPU_PPD_EN0, AK_PPU_PPD_SEL0, AK_GPIO_IE_CON0, 23, -1, GPIO_CFG(2, 0B00) | SET_PUPD_ENABLE_BIT(1), DFIX_UP},
+	/* gpio, i2c0_sda */
+	{32, AK_SHAREPIN_CON1, AK_GPIO_DRIVE_CON1, 16, AK_PPU_PPD_EN0, AK_PPU_PPD_SEL0, AK_GPIO_IE_CON0, 24, -1, GPIO_CFG(2, 0B00) | SET_PUPD_ENABLE_BIT(1), DFIX_UP},
+	/* gpio, mci0_cmd */
+	{33, AK_SHAREPIN_CON1, AK_GPIO_DRIVE_CON1, 18, AK_PPU_PPD_EN0, AK_PPU_PPD_SEL0, AK_GPIO_IE_CON0, 25, 29, GPIO_CFG(2, 0B00), ALL_EN},
+	/* gpio, mci0_clk, uart2_tx */
+	{34, AK_SHAREPIN_CON1, AK_GPIO_DRIVE_CON1, 20, AK_PPU_PPD_EN0, AK_PPU_PPD_SEL0, AK_GPIO_IE_CON0, 26, 29, GPIO_CFG(2, 0B00), ALL_EN},
+	/* gpio, mci0_d0, uart2_rx, jtag_rstn */
+	{35, AK_SHAREPIN_CON1, AK_GPIO_DRIVE_CON1, 22, AK_PPU_PPD_EN0, AK_PPU_PPD_SEL0, AK_GPIO_IE_CON0, 27, 29, GPIO_CFG(2, 0B00), ALL_EN},
+	/* gpio, mci0_d1, uart1_rx, jtag_rtck */
+	{36, AK_SHAREPIN_CON1, AK_GPIO_DRIVE_CON1, 24, AK_PPU_PPD_EN0, AK_PPU_PPD_SEL0, AK_GPIO_IE_CON0, 28, 29, GPIO_CFG(2, 0B00), ALL_EN},
+	/* gpio, mci0_d2, pwm1, uart1_tx */
+	{37, AK_SHAREPIN_CON1, AK_GPIO_DRIVE_CON1, 26, AK_PPU_PPD_EN0, AK_PPU_PPD_SEL0, AK_GPIO_IE_CON0, 29, 29, GPIO_CFG(2, 0B00), ALL_EN},
+	/* gpio, mci0_d3, pwm1, jtag_tck */
+	{38, AK_SHAREPIN_CON1, AK_GPIO_DRIVE_CON1, 28, AK_PPU_PPD_EN0, AK_PPU_PPD_SEL0, AK_GPIO_IE_CON0, 30, 29, GPIO_CFG(2, 0B00), ALL_EN},
+	/* gpio, mci0_d4, pwm2, jtag_tms */
+	{39, AK_SHAREPIN_CON1, AK_GPIO_DRIVE_CON1, 30, AK_PPU_PPD_EN0, AK_PPU_PPD_SEL0, AK_GPIO_IE_CON0, 31, 29, GPIO_CFG(2, 0B00), ALL_EN},
+	/* gpio, mci0_d5, pwm3, jtag_tdi */
+	{40, AK_SHAREPIN_CON2, AK_GPIO_DRIVE_CON2, 0, AK_PPU_PPD_EN1, AK_PPU_PPD_SEL1, AK_GPIO_IE_CON1, 0, 29, GPIO_CFG(2, 0B00), ALL_EN},
+	/* gpio, mci0_d6, pwm4, jtag_tdout */
+	{41, AK_SHAREPIN_CON2, AK_GPIO_DRIVE_CON2, 2, AK_PPU_PPD_EN1, AK_PPU_PPD_SEL1, AK_GPIO_IE_CON1, 1, 29, GPIO_CFG(2, 0B00), ALL_EN},
+	/* gpio, mci0_d7 */
+	{42, AK_SHAREPIN_CON2, AK_GPIO_DRIVE_CON2, 4, AK_PPU_PPD_EN1, AK_PPU_PPD_SEL1, AK_GPIO_IE_CON1, 2, 29, GPIO_CFG(2, 0B00), ALL_EN},
+
+	/* gpio, mci1_cmd, spi1_cs */
+	{43, AK_SHAREPIN_CON2, AK_GPIO_DRIVE_CON2, 6, AK_PPU_PPD_EN1, AK_PPU_PPD_SEL1, AK_GPIO_IE_CON1, 3, -1, GPIO_CFG(2, 0B00), DFIX_UP},
+	/* gpio, mci1_clk, spi1_sclk */
+	{44, AK_SHAREPIN_CON2, AK_GPIO_DRIVE_CON2, 8, AK_PPU_PPD_EN1, AK_PPU_PPD_SEL1, AK_GPIO_IE_CON1, 4, -1, GPIO_CFG(2, 0B00), DFIX_DOWN},
+	/* gpio, mci1_d0, spi1_hold */
+	{45, AK_SHAREPIN_CON2, AK_GPIO_DRIVE_CON2, 10, AK_PPU_PPD_EN1, AK_PPU_PPD_SEL1, AK_GPIO_IE_CON1, 5, -1, GPIO_CFG(2, 0B00), DFIX_UP},
+
+	
+	/* gpio, mci1_d1, spi1_wp */
+	{46, AK_SHAREPIN_CON2, AK_GPIO_DRIVE_CON2, 12, AK_PPU_PPD_EN1, AK_PPU_PPD_SEL1, AK_GPIO_IE_CON1, 6, -1, GPIO_CFG(2, 0B00), DFIX_UP},
+	/* gpio, mci1_d2, spi1_dout */
+	{47, AK_SHAREPIN_CON2, AK_GPIO_DRIVE_CON2, 14, AK_PPU_PPD_EN1, AK_PPU_PPD_SEL1, AK_GPIO_IE_CON1, 7, -1, GPIO_CFG(2, 0B00), DFIX_UP},
+	/* gpio, mci1_d3, spi1_din */
+	{48, AK_SHAREPIN_CON2, AK_GPIO_DRIVE_CON2, 16, AK_PPU_PPD_EN1, AK_PPU_PPD_SEL1, AK_GPIO_IE_CON1, 8, -1, GPIO_CFG(2, 0B00), DFIX_UP},
+	/* gpio, opclk, mci2_d0, pwm1 */
+	{49, AK_SHAREPIN_CON1, AK_GPIO_DRIVE_CON1, 4, AK_PPU_PPD_EN0, AK_PPU_PPD_SEL0, AK_GPIO_IE_CON0, 18, 28, GPIO_CFG(2, 0B00), IEEN},
+	/* gpio, pwm0, uart1_tx */
+	{50, AK_SHAREPIN_CON2, AK_GPIO_DRIVE_CON2, 18, AK_PPU_PPD_EN1, AK_PPU_PPD_SEL1, AK_GPIO_IE_CON1, 9, -1, GPIO_CFG(2, 0B00), ALL_EN},
+	/* gpio, pwm1, uart1_cts */
+	{51, AK_SHAREPIN_CON2, AK_GPIO_DRIVE_CON2, 20, AK_PPU_PPD_EN1, AK_PPU_PPD_SEL1, AK_GPIO_IE_CON1, 10, -1, GPIO_CFG(2, 0B00), ALL_EN},
+	/* gpio, pwm2, uart1_rx */
+	{52, AK_SHAREPIN_CON2, AK_GPIO_DRIVE_CON2, 22, AK_PPU_PPD_EN1, AK_PPU_PPD_SEL1, AK_GPIO_IE_CON1, 11, -1, GPIO_CFG(2, 0B00), ALL_EN},
+	/* gpio, i2s_dout, uart1_rts*/
+	{53, AK_SHAREPIN_CON2, AK_GPIO_DRIVE_CON2, 24, AK_PPU_PPD_EN1, AK_PPU_PPD_SEL1, AK_GPIO_IE_CON1, 12, -1, GPIO_CFG(2, 0B00), ALL_EN},
+	/* gpio, i2s_mclk */
+	{54, AK_SHAREPIN_CON2, AK_GPIO_DRIVE_CON2, 26, AK_PPU_PPD_EN1, AK_PPU_PPD_SEL1, AK_GPIO_IE_CON1, 13, -1, GPIO_CFG(2, 0B00), ALL_EN},
+	/* gpio, i2s_bclk */
+	{55, AK_SHAREPIN_CON2, AK_GPIO_DRIVE_CON2, 28, AK_PPU_PPD_EN1, AK_PPU_PPD_SEL1, AK_GPIO_IE_CON1, 14, -1, GPIO_CFG(2, 0B00), ALL_EN},
+	/* gpio, i2s_lrclk */
+	{56, AK_SHAREPIN_CON2, AK_GPIO_DRIVE_CON2, 30, AK_PPU_PPD_EN1, AK_PPU_PPD_SEL1, AK_GPIO_IE_CON1, 15, -1, GPIO_CFG(2, 0B00), ALL_EN},
+	/* gpio, i2s_din */
+	{57, AK_SHAREPIN_CON3, AK_GPIO_DRIVE_CON3, 0, AK_PPU_PPD_EN1, AK_PPU_PPD_SEL1, AK_GPIO_IE_CON1, 16, -1, GPIO_CFG(2, 0B00), ALL_EN},
+	/* gpio, pwm3, i2c2_sda */
+	{58, AK_SHAREPIN_CON3, AK_GPIO_DRIVE_CON3, 2, AK_PPU_PPD_EN1, AK_PPU_PPD_SEL1, AK_GPIO_IE_CON1, 17, -1, GPIO_CFG(2, 0B00), ALL_EN},
+	/* gpio, pwm4, i2c2_scl */
+	{59, AK_SHAREPIN_CON3, AK_GPIO_DRIVE_CON3, 4, AK_PPU_PPD_EN1, AK_PPU_PPD_SEL1, AK_GPIO_IE_CON1, 18, -1, GPIO_CFG(2, 0B00), ALL_EN},
+	/* gpio, pwm0, ain1 */
+	{60, AK_SHAREPIN_CON3, AK_GPIO_DRIVE_CON3, 14, AK_PPU_PPD_EN1, AK_PPU_PPD_SEL1, AK_GPIO_IE_CON1, 23, -1, GPIO_CFG(2, 0B00), DFIX_DOWN_IEEN},
+	/* gpio, pwm2 */
+	{61, AK_SHAREPIN_CON3, AK_GPIO_DRIVE_CON3, 16, AK_PPU_PPD_EN1, AK_PPU_PPD_SEL1, AK_GPIO_IE_CON1, 24, -1, GPIO_CFG(2, 0B00), DFIX_UP},
+	/* gpio, pwm1 */
+	{62, AK_SHAREPIN_CON3, AK_GPIO_DRIVE_CON3, 18, AK_PPU_PPD_EN1, AK_PPU_PPD_SEL1, AK_GPIO_IE_CON1, 25, -1, GPIO_CFG(2, 0B00), ALL_EN},
+	/* gpio */
+	{63, AK_SHAREPIN_CON3, AK_GPIO_DRIVE_CON3, 20, AK_PPU_PPD_EN1, AK_PPU_PPD_SEL1, AK_GPIO_IE_CON1, 26, -1, GPIO_CFG(2, 0B00), ALL_EN},
+	/* gpio */
+	{64, AK_SHAREPIN_CON3, AK_GPIO_DRIVE_CON3, 22, AK_PPU_PPD_EN1, AK_PPU_PPD_SEL1, AK_GPIO_IE_CON1, 27, -1, GPIO_CFG(2, 0B00), ALL_EN},
+	/* gpio */
+	{65, AK_SHAREPIN_CON3, AK_GPIO_DRIVE_CON3, 24, AK_PPU_PPD_EN1, AK_PPU_PPD_SEL1, AK_GPIO_IE_CON1, 28, -1, GPIO_CFG(2, 0B00), ALL_EN},
+	/* gpio */
+	{66, AK_SHAREPIN_CON3, AK_GPIO_DRIVE_CON3, 26, AK_PPU_PPD_EN1, AK_PPU_PPD_SEL1, AK_GPIO_IE_CON1, 29, -1, GPIO_CFG(2, 0B00), ALL_EN},
+	/* spi0_din, gpio */
+	{67, AK_SHAREPIN_CON3, AK_GPIO_DRIVE_CON3, 30, AK_PPU_PPD_EN1, AK_PPU_PPD_SEL1, AK_GPIO_IE_CON1, 31, -1, GPIO_CFG(2, 0B01), DFIX_UP},
+	/* spi0_dout, gpio */
+	{68, AK_SHAREPIN_CON4, AK_GPIO_DRIVE_CON4, 0, AK_PPU_PPD_EN2, AK_PPU_PPD_SEL2, AK_GPIO_IE_CON2, 0, -1, GPIO_CFG(2, 0B01), DFIX_UP},
+	/* spi0_wp, gpio */
+	{69, AK_SHAREPIN_CON4, AK_GPIO_DRIVE_CON4, 2, AK_PPU_PPD_EN2, AK_PPU_PPD_SEL2, AK_GPIO_IE_CON2, 1, -1, GPIO_CFG(2, 0B01), DFIX_UP},
+	/* spi0_hold, gpio */
+	{70, AK_SHAREPIN_CON4, AK_GPIO_DRIVE_CON4, 4, AK_PPU_PPD_EN2, AK_PPU_PPD_SEL2, AK_GPIO_IE_CON2, 2, -1, GPIO_CFG(2, 0B01), DFIX_UP},
+	/* gpio, rgb_vogate/mpu_rd */
+	{71, AK_SHAREPIN_CON4, AK_GPIO_DRIVE_CON4, 6, AK_PPU_PPD_EN2, AK_PPU_PPD_SEL2, AK_GPIO_IE_CON2, 3, 0, GPIO_CFG(2, 0B00), ALL_EN},
+	/* gpio, rgb_vovsync/mpu_a0 */
+	{72, AK_SHAREPIN_CON4, AK_GPIO_DRIVE_CON4, 8, AK_PPU_PPD_EN2, AK_PPU_PPD_SEL2, AK_GPIO_IE_CON2, 4, 1, GPIO_CFG(2, 0B00), ALL_EN},
+	/* gpio, rgb_vohsync/mpu_cs */
+	{73, AK_SHAREPIN_CON4, AK_GPIO_DRIVE_CON4, 10, AK_PPU_PPD_EN2, AK_PPU_PPD_SEL2, AK_GPIO_IE_CON2, 5, 2, GPIO_CFG(2, 0B00), ALL_EN},
+	/* gpio, rgb_vopclk/mpu_wr,rgb_pclk */
+	{74, AK_SHAREPIN_CON4, AK_GPIO_DRIVE_CON4, 12, AK_PPU_PPD_EN2, AK_PPU_PPD_SEL2, AK_GPIO_IE_CON2, 6, 3, GPIO_CFG(2, 0B00), ALL_EN},
+	/* gpio, rgb_d0/mpu_d0 */
+	{75, AK_SHAREPIN_CON4, AK_GPIO_DRIVE_CON4, 14, AK_PPU_PPD_EN2, AK_PPU_PPD_SEL2, AK_GPIO_IE_CON2, 7, 4, GPIO_CFG(2, 0B00), ALL_EN},
+	/* gpio, rgb_d1/mpu_d1 */
+	{76, AK_SHAREPIN_CON4, 0/*Note:b[17:18] drive_gpio76_92_cfg*/, 16, AK_PPU_PPD_EN2, AK_PPU_PPD_SEL2, AK_GPIO_IE_CON2, 8, 5, GPIO_CFG(2, 0B00), ALL_EN},
+	/* gpio, rgb_d2/mpu_d2 */
+	{77, AK_SHAREPIN_CON4, AK_GPIO_DRIVE_CON4, 18, AK_PPU_PPD_EN2, AK_PPU_PPD_SEL2, AK_GPIO_IE_CON2, 9, 6, GPIO_CFG(2, 0B00), ALL_EN},
+	/* gpio, rgb_d3/mpu_d3 */
+	{78, AK_SHAREPIN_CON4, AK_GPIO_DRIVE_CON4, 20, AK_PPU_PPD_EN2, AK_PPU_PPD_SEL2, AK_GPIO_IE_CON2, 10, 7, GPIO_CFG(2, 0B00), ALL_EN},
+	/* gpio, rgb_d4/mpu_d4 */
+	{79, AK_SHAREPIN_CON4, AK_GPIO_DRIVE_CON4, 22, AK_PPU_PPD_EN2, AK_PPU_PPD_SEL2, AK_GPIO_IE_CON2, 11, 8, GPIO_CFG(2, 0B00), ALL_EN},
+	/* gpio, rgb_d5/mpu_d5 */
+	{80, AK_SHAREPIN_CON4, AK_GPIO_DRIVE_CON4, 24, AK_PPU_PPD_EN2, AK_PPU_PPD_SEL2, AK_GPIO_IE_CON2, 12, 9, GPIO_CFG(2, 0B00), ALL_EN},
+	/* gpio, rgb_d6/mpu_d6 */
+	{81, AK_SHAREPIN_CON4, AK_GPIO_DRIVE_CON4, 26, AK_PPU_PPD_EN2, AK_PPU_PPD_SEL2, AK_GPIO_IE_CON2, 13, 10, GPIO_CFG(2, 0B00), ALL_EN},
+	/* gpio, rgb_d7/mpu_d7 */
+	{82, AK_SHAREPIN_CON4, AK_GPIO_DRIVE_CON4, 28, AK_PPU_PPD_EN2, AK_PPU_PPD_SEL2, AK_GPIO_IE_CON2, 14, 11, GPIO_CFG(2, 0B00), ALL_EN},
+	/* gpio, rgb_d8/mpu_d8, i2c2_scl */
+	{83, AK_SHAREPIN_CON4, AK_GPIO_DRIVE_CON4, 30, AK_PPU_PPD_EN2, AK_PPU_PPD_SEL2, AK_GPIO_IE_CON2, 15, 12, GPIO_CFG(2, 0B00), ALL_EN},
+	/* gpio, rgb_d9/mpu_d9, i2c2_sda */
+	{84, AK_SHAREPIN_CON5, AK_GPIO_DRIVE_CON5, 0, AK_PPU_PPD_EN2, AK_PPU_PPD_SEL2, AK_GPIO_IE_CON2, 16, 13, GPIO_CFG(2, 0B00), ALL_EN},
+	/* gpio, rgb_d10/mpu_d10, i2s_din */
+	{85, AK_SHAREPIN_CON5, AK_GPIO_DRIVE_CON5, 2, AK_PPU_PPD_EN2, AK_PPU_PPD_SEL2, AK_GPIO_IE_CON2, 17, 14, GPIO_CFG(2, 0B00), ALL_EN},
+	/* gpio, rgb_d11/mpu_d11, i2s_lrclk */
+	{86, AK_SHAREPIN_CON5, AK_GPIO_DRIVE_CON5, 4, AK_PPU_PPD_EN2, AK_PPU_PPD_SEL2, AK_GPIO_IE_CON2, 18, 15, GPIO_CFG(2, 0B00), ALL_EN},
+	/* gpio, rgb_d12/mpu_d12, i2s_bclk */
+	{87, AK_SHAREPIN_CON5, AK_GPIO_DRIVE_CON5, 6, AK_PPU_PPD_EN2, AK_PPU_PPD_SEL2, AK_GPIO_IE_CON2, 19, 16, GPIO_CFG(2, 0B00), ALL_EN},
+	/* gpio, rgb_d13/mpu_d13, i2s_mclk */
+	{88, AK_SHAREPIN_CON5, AK_GPIO_DRIVE_CON5, 8, AK_PPU_PPD_EN2, AK_PPU_PPD_SEL2, AK_GPIO_IE_CON2, 20, 17, GPIO_CFG(2, 0B00), ALL_EN},
+	/* gpio, rgb_d14/mpu_d14, i2s_dout */
+	{89, AK_SHAREPIN_CON5, AK_GPIO_DRIVE_CON5, 10, AK_PPU_PPD_EN2, AK_PPU_PPD_SEL2, AK_GPIO_IE_CON2, 21, 18, GPIO_CFG(2, 0B00), ALL_EN},
+	/* gpio, rgb_d15/mpu_d15, pwm5 */
+	{90, AK_SHAREPIN_CON5, AK_GPIO_DRIVE_CON5, 12, AK_PPU_PPD_EN2, AK_PPU_PPD_SEL2, AK_GPIO_IE_CON2, 22, 19, GPIO_CFG(2, 0B00), ALL_EN},
+	/* gpio, rgb_d16/mpu_d16, mci2_d2 */
+	{91, AK_SHAREPIN_CON5, AK_GPIO_DRIVE_CON5, 14, AK_PPU_PPD_EN2, AK_PPU_PPD_SEL2, AK_GPIO_IE_CON2, 23, 20, GPIO_CFG(2, 0B00), ALL_EN},
+	/* gpio, rgb_d17/mpu_d17, mci2_d3 */
+	{92, AK_SHAREPIN_CON5, 0/*Note:b[17]&[6] drive_gpio76_92_cfg*/, 16, AK_PPU_PPD_EN2, AK_PPU_PPD_SEL2, AK_GPIO_IE_CON2, 24, 21, GPIO_CFG(2, 0B00), ALL_EN},
+	/* gpio, rgb_d18, spi1_cs, mci2_cmd */
+	{93, AK_SHAREPIN_CON5, AK_GPIO_DRIVE_CON5, 18, AK_PPU_PPD_EN2, AK_PPU_PPD_SEL2, AK_GPIO_IE_CON2, 25, 22, GPIO_CFG(2, 0B00), ALL_EN},
+	/* gpio, rgb_d19, spi1_sclk, mci2_clk */
+	{94, AK_SHAREPIN_CON5, AK_GPIO_DRIVE_CON5, 20, AK_PPU_PPD_EN2, AK_PPU_PPD_SEL2, AK_GPIO_IE_CON2, 26, 23, GPIO_CFG(2, 0B00), ALL_EN},
+	/* gpio, rgb_d20, spi1_dout, mci2_d0 */
+	{95, AK_SHAREPIN_CON5, AK_GPIO_DRIVE_CON5, 22, AK_PPU_PPD_EN2, AK_PPU_PPD_SEL2, AK_GPIO_IE_CON2, 27, 24, GPIO_CFG(2, 0B00), ALL_EN},
+	/* gpio, rgb_d21, spi1_din, mci2_d1 */
+	{96, AK_SHAREPIN_CON5, AK_GPIO_DRIVE_CON5, 24, AK_PPU_PPD_EN2, AK_PPU_PPD_SEL2, AK_GPIO_IE_CON2, 28, 25, GPIO_CFG(2, 0B00), ALL_EN},
+	/* gpio, rgb_d22, spi1_hold, i2c2_sda */
+	{97, AK_SHAREPIN_CON5, AK_GPIO_DRIVE_CON5, 26, AK_PPU_PPD_EN2, AK_PPU_PPD_SEL2, AK_GPIO_IE_CON2, 29, 26, GPIO_CFG(2, 0B00), ALL_EN},
+	/* gpio, rgb_d23, spi1_wp, i2c2_scl, spi1_din */
+	{98, AK_SHAREPIN_CON5, AK_GPIO_DRIVE_CON5, 28, AK_PPU_PPD_EN2, AK_PPU_PPD_SEL2, AK_GPIO_IE_CON2, 30, 27, GPIO_CFG(3, 0B000), ALL_EN},
+	/* gpio */
+	{99, 0, AK_GPIO_DRIVE_CON5, 30, AK_PPU_PPD_EN2, AK_PPU_PPD_SEL2, AK_GPIO_IE_CON2, 31, -1, GPIO_CFG(0, 0B0), ALL_EN},
+	/* gpio */
+	{100, 0, AK_PPU_PPD_EN_SEL, 0, AK_PPU_PPD_EN_SEL, 0/*Note: ie_reg3_gpio100_103_cfg*/, 0/*Note: ie_reg3_gpio100_103_cfg*/, 10, -1, GPIO_CFG(2, 0B0), ALL_EN},
+	/* gpio */
+	{101, 0, AK_PPU_PPD_EN_SEL, 2, AK_PPU_PPD_EN_SEL, 0/*Note: ie_reg3_gpio100_103_cfg*/, 0/*Note: ie_reg3_gpio100_103_cfg*/, 11, -1, GPIO_CFG(2, 0B0), ALL_EN},
+	/* gpio */
+	{102, 0, AK_PPU_PPD_EN_SEL, 4, AK_PPU_PPD_EN_SEL, 0/*Note: ie_reg3_gpio100_103_cfg*/, 0/*Note: ie_reg3_gpio100_103_cfg*/, 12, -1, GPIO_CFG(2, 0B0), ALL_EN},
+	/* gpio */
+	{103, 0, AK_PPU_PPD_EN_SEL, 6, AK_PPU_PPD_EN_SEL, 0/*Note: ie_reg3_gpio100_103_cfg*/, 0/*Note: ie_reg3_gpio100_103_cfg*/, 13, -1, GPIO_CFG(2, 0B0), ALL_EN},
+	/* gpio, gpi4_ao */
+	{104, 0, 0, 0, 0, 0, 0, 0, -1, AO_CFG(0, 0B0), ALL_DIS},
+	/* gpio, gpi3_ao */
+	{105, 0, 0, 0, 0, 0, 0, 0, -1, AO_CFG(0, 0B0), ALL_DIS},
+	/* gpio, gpi2_ao */
+	{106, 0, 0, 0, 0, 0, 0, 0, -1, AO_CFG(0, 0B0), ALL_DIS},
+	/* gpio, gpi1_ao */
+	{107, 0, 0, 0, 0, 0, 0, 0, -1, AO_CFG(0, 0B0), ALL_DIS},
+	/* gpio, gpi0_ao */
+	{108, 0, 0, 0, 0, 0, 0, 0, -1, AO_CFG(0, 0B0), ALL_DIS},
+	/* gpi13 */
+	{109, AK_SHAREPIN_CON5, 0, 31, 0, 0, 0, 0, -1, GPI_CFG(1, 0B0), DFIX_IEEN},
+	/* gpi12 */
+	{110, AK_SHAREPIN_CON5, 0, 31, 0, 0, 0, 0, -1, GPI_CFG(1, 0B0), DFIX_IEEN},
+	/* gpi11 */
+	{111, AK_SHAREPIN_CON5, 0, 31, 0, 0, 0, 0, -1, GPI_CFG(1, 0B0), DFIX_IEEN},
+	/* gpi10 */
+	{112, AK_SHAREPIN_CON5, 0, 31, 0, 0, 0, 0, -1, GPI_CFG(1, 0B0), DFIX_IEEN},
+	/* gpi9 */
+	{113, AK_SHAREPIN_CON5, 0, 31, 0, 0, 0, 0, -1, GPI_CFG(1, 0B0), DFIX_IEEN},
+	/* gpi8 */
+	{114, AK_SHAREPIN_CON5, 0, 31, 0, 0, 0, 0, -1, GPI_CFG(1, 0B0), DFIX_IEEN},
+	/* gpi7 */
+	{115, AK_SHAREPIN_CON6, 0, 31, 0, 0, 0, 0, -1, GPI_CFG(1, 0B0), DFIX_IEEN},
+	/* gpi6 */
+	{116, AK_SHAREPIN_CON6, 0, 31, 0, 0, 0, 0, -1, GPI_CFG(1, 0B0), DFIX_IEEN},
+	/* gpi5 */
+	{117, AK_SHAREPIN_CON6, 0, 29, 0, 0, 0, 0, -1, GPI_CFG(1, 0B0), DFIX_IEEN},
+	/* gpi4 */
+	{118, AK_SHAREPIN_CON6, 0, 29, 0, 0, 0, 0, -1, GPI_CFG(1, 0B0), DFIX_IEEN},
+	/* gpi3 */
+	{119, AK_SHAREPIN_CON6, 0, 30, 0, 0, 0, 0, -1, GPI_CFG(1, 0B0), DFIX_IEEN},
+	/* gpi2 */
+	{120, AK_SHAREPIN_CON6, 0, 30, 0, 0, 0, 0, -1, GPI_CFG(1, 0B0), DFIX_IEEN},
+	/* gpi1 */
+	{121, AK_ANALOG_CTRL_REG3, 0, 27, 0, 0, 0, 0, -1, GPI_CFG(1, 0B1), ALL_DIS},
+	/* gpi0 */
+	{122, AK_ANALOG_CTRL_REG3, 0, 25, 0, 0, 0, 0, -1, GPI_CFG(1, 0B1), ALL_DIS},
+}; 
+
+static struct pin_pos ak_pin_pos[] = {
+	/*offset,width,	gpio0,	func0,	gpio1,	func1,	gpio2,	func2	gpio3,	func3*/
+	{22,	2,		58,		2,		97,		3,		84,		2,		-1,		-1},	/*TWI2_SDA*/
+	{21,	1,		85,		2,		57,		1,		-1,		-1,		-1,		-1},	/*I2S_DIN*/
+	{20,	1,		86,		2,		56,		1,		-1,		-1,		-1,		-1},	/*I2C_LRCLK*/
+	{19,	1,		87,		2,		55,		1,		-1,		-1,		-1,		-1},	/*I2S_BCLK*/
+	{18,	1,		8,		1,		51,		2,		-1,		-1,		-1,		-1},	/*UART1_CTS*/
+	{16,	2,		6,		1,		36,		2,		52,		2,		-1,		-1},	/*UART1_RXD*/
+	{15,	1,		5,		2,		0,		1,		-1,		-1,		-1,		-1},	/*UART3_RXD*/
+	{14,	1,		7,		3,		11,		2,		-1,		-1,		-1,		-1},	/*TWI3_SDA*/
+	{12,	2,		48,		2,		96,		2,		98,		4,		-1,		-1},	/*SPI1_DIN*/
+	{11,	1,		47,		2,		95,		2,		-1,		-1,		-1,		-1},	/*SPI1_DOUT*/
+	{10,	1,		46,		2,		98,		2,		-1,		-1,		-1,		-1},	/*SPI1_WP*/
+	{9,		1,		45,		2,		97,		2,		-1,		-1,		-1,		-1},	/*SPI1_HOLD*/
+	{8,		1,		44,		2,		94,		2,		-1,		-1,		-1,		-1},	/*SPI1_SCLK*/
+	{7,		1,		43,		2,		93,		2,		-1,		-1,		-1,		-1},	/*SPI1_CS*/
+	{6,		1,		14,		2,		92,		2,		-1,		-1,		-1,		-1},	/*MCI2_D[3]*/
+	{5,		1,		15,		2,		91,		2,		-1,		-1,		-1,		-1},	/*MCI2_D[2]*/
+	{4,		1,		23,		2,		96,		3,		-1,		-1,		-1,		-1},	/*MCI2_D[1]*/
+	{2,		2,		3,		2,		24,		2,		49,		2,		95,		3},		/*MCI2_D[0]*/
+	{0,		2,		4,		3,		20,		2,		93,		3,		-1,		-1},	/*MCI2_CMD*/
+};
+
+static const char * const irq_type_names[] = {
+	[IRQ_TYPE_NONE] = "none",
+	[IRQ_TYPE_EDGE_RISING] = "edge-rising",
+	[IRQ_TYPE_EDGE_FALLING] = "edge-falling",
+	[IRQ_TYPE_LEVEL_HIGH] = "level-high",
+	[IRQ_TYPE_LEVEL_LOW] = "level-low",
+};
+
+static int pin_check_capacity_input_enable(int pin, int enable)
+{
+	if (!enable) {
+		switch (ak_sharepin[pin].capacity) {
+			case ALL_DIS:
+			case DFIX_UP_IEEN:
+			case DFIX_DOWN_IEEN:
+			case IEEN:
+			case DFIX_IEEN:
+				//pr_err("%s can't set pin:%d ie disable\n", __func__, pin);
+				break;
+
+			default:
+				break;
+		}
+	}
+	return 0;
+}
+
+static int pin_check_capacity_drive(int pin, int strength)
+{
+	switch (ak_sharepin[pin].capacity) {
+		case ALL_DIS:
+		case DFIX_UP:
+		case DFIX_DOWN:
+		case DFIX_UP_IEEN:
+		case DFIX_DOWN_IEEN:
+		case DFIX_IEEN:
+			//pr_err("%s can't set pin:%d drive, drive fixed\n", __func__, pin);
+			break;
+
+		default:
+			break;
+	}
+	return 0;
+}
+
+static int pin_check_capacity_pull_polarity(int pin, int pullup)
+{
+	if (pullup) {
+		switch (ak_sharepin[pin].capacity) {
+			case ALL_DIS:
+			case DFIX_DOWN:
+			case DFIX_DOWN_IEEN:
+				//pr_err("%s can't set pin:%d pull-up polarity, fixed\n", __func__, pin);
+				break;
+
+			default:
+				break;
+		}
+	} else {
+		switch (ak_sharepin[pin].capacity) {
+			case ALL_DIS:
+			case DFIX_UP:
+			case DFIX_UP_IEEN:
+				//pr_err("%s can't set pin:%d pull-down polarity, fixed\n", __func__, pin);
+				break;
+
+			default:
+				break;
+		}
+	}
+	return 0;
+}
+
+static int pin_check_capacity_pull_enable(int pin, int enable)
+{
+	if (enable) {
+		switch (ak_sharepin[pin].capacity) {
+			case ALL_DIS:
+				//pr_err("%s can't set pin:%d pull enable\n", __func__, pin);
+				break;
+
+			default:
+				break;
+		}
+	} else {
+		switch (ak_sharepin[pin].capacity) {
+			case ALL_DIS:
+				//pr_err("%s can't set pin:%d pull disable\n", __func__, pin);
+				break;
+
+			default:
+				break;
+		}
+	}
+
+	return 0;
+}
+
+static int pin_check_capacity_slew_rate(int pin, int fast)
+{
+	if (ak_sharepin[pin].slew_bit < 0)
+		;//pr_err("%s can't set pin:%d slew rate\n", __func__, pin);
+
+	return 0;
+}
+
+static int pin_check_capacity_direction(int pin, int input)
+{
+	int gpio_class = GET_GPIO_CLASS(ak_sharepin[pin].gpio_config);
+
+	if (input) {
+		switch (gpio_class) {
+			case GPIO_CLASS_O:
+			case GPIO_CLASS_AO:
+				//pr_err("%s can't set pin:%d as input\n", __func__, pin);
+				break;
+
+			default:
+				break;
+		}
+	} else {
+		switch (gpio_class) {
+			case GPIO_CLASS_I:
+			case GPIO_CLASS_AO:
+				//pr_err("%s can't set pin:%d as output\n", __func__, pin);
+				break;
+
+			default:
+				break;
+		}
+	}
+
+	return 0;
+}
+
+static int gpi_and_mipi_pins_set_share_ex(struct ak_pinctrl *pc, int pin, int sel)
+{
+	u32 regval;
+	int mipi_lanes_num;
+	void __iomem *mipi_base;
+
+	switch (pin) {
+		case 23:
+			if (sel == 4) {
+				/*here set AIN1 mux to pin GPIO23*/
+				regval = __raw_readl(AK_ANALOG_CTRL_REG3);
+				regval |= 1<<29;
+				__raw_writel(regval, AK_ANALOG_CTRL_REG3);
+			} else {
+				regval = __raw_readl(AK_ANALOG_CTRL_REG3);
+				regval &= ~(1<<29);
+				__raw_writel(regval, AK_ANALOG_CTRL_REG3);
+			}
+			break;
+
+		case 60:
+			if (sel == 4) {
+				/*here set AIN1 mux to pin GPIO60*/
+				regval = __raw_readl(AK_ANALOG_CTRL_REG3);
+				regval |= 1<<28;
+				__raw_writel(regval, AK_ANALOG_CTRL_REG3);
+			} else {
+				regval = __raw_readl(AK_ANALOG_CTRL_REG3);
+				regval &= ~(1<<28);
+				__raw_writel(regval, AK_ANALOG_CTRL_REG3);
+			}
+			break;
+
+		case 109:
+		case 110:
+		case 111:
+		case 112:
+		case 113:
+		case 114:
+		case 115:
+		case 116:
+		case 117:
+		case 118:
+		case 119:
+		case 120:
+			/*here set mipi-gpi pins extern paramters*/
+			if (pin >= 115 && pin <= 120) {
+				mipi_base = pc->mipi0_base;
+				mipi_lanes_num = pc->mipi0_lanes_num;
+			} else {
+				mipi_base = pc->mipi1_base;
+				mipi_lanes_num = pc->mipi1_lanes_num;
+			}
+
+			if (sel == 1) {
+				/*dvp mode*/
+				__raw_writeb(0x7d, mipi_base);
+				__raw_writeb(0x3f, mipi_base + 0x20);
+				__raw_writeb(0x01, mipi_base + 0xb3);
+				__raw_writeb(pc->ttl_io_voltage & 0xff, mipi_base + 0xb8);
+			} else if (sel == 2) {
+				/*mipi mode*/
+				__raw_writeb(0x7d, mipi_base);
+				if (mipi_lanes_num == 1)
+					__raw_writeb(0xf8, mipi_base + 0xe0);
+				else if (mipi_lanes_num == 2) {
+					/*2lanes mode is default, but I don't know default value*/
+					__raw_writeb(0xf9, mipi_base + 0xe0);
+				} else {
+					pr_err("%s err mipi_lanes_num:%d, pin:%d\n", __func__, mipi_lanes_num, pin);
+					return -1;
+				}
+			} else if (sel == 0) {
+				/*GPI mode*/
+				__raw_writeb(0x7d, mipi_base);
+				__raw_writeb(0x3f, mipi_base + 0x20);
+				__raw_writeb(0x01, mipi_base + 0xb3);
+			} else {
+				pr_err("%s don't support sel:%d, pin:%d\n", __func__, sel, pin);
+				return -1;
+			}
+			break;
+
+		case 121:
+		case 122:
+			/*had cfg in ak_sharepin*/
+			break;
+
+		default:
+			return -1;
+			break;
+	}
+
+	return 0;
+}
+
+static int gpi_and_mipi_pins_set_pull_polarity(struct ak_pinctrl *pc, int pin, int pullup)
+{
+	int done = 0;
+	int *p_pull_polarity;
+	void __iomem *mipi_base;
+
+	if (pin >= 109 && pin <= 120) {
+		/* GPI 2~13 */
+		if (pin >= 115 && pin <= 120) {
+			/* GPI-mipi0 */
+			mipi_base = pc->mipi0_base;
+			p_pull_polarity = &pc->GPI_MIPI0_pull_polarity;
+		} else {
+			/* GPI-mipi1 */
+			mipi_base = pc->mipi1_base;
+			p_pull_polarity = &pc->GPI_MIPI1_pull_polarity;
+		}
+
+		if (pullup) {
+			__raw_writeb(0x80, mipi_base + 0x0d);//enable pullup
+			__raw_writeb(0x02, mipi_base + 0xb8);//disable pulldown
+			*p_pull_polarity = 1;
+		} else {
+			__raw_writeb(0xb0, mipi_base + 0x0d);//disable pullup
+			__raw_writeb(0x04, mipi_base + 0xb8);//enable pulldown
+			*p_pull_polarity = 0;
+		}
+		done = 1;
+	} else if (pin >= 121 && pin <= 122) {
+		/* GPI0~1 */
+		done = 1;
+	}
+
+	return (done ? 0:-1);
+}
+
+static int gpi_and_mipi_pins_get_pull_polarity(struct ak_pinctrl *pc, int pin, int *polarity)
+{
+	if (pin >= 109 && pin <= 120) {
+		int *p_pull_polarity;
+
+		if (pin >= 115 && pin <= 120) {
+			/* GPI-mipi0 */
+			p_pull_polarity = &pc->GPI_MIPI0_pull_polarity;
+		} else {
+			/* GPI-mipi1 */
+			p_pull_polarity = &pc->GPI_MIPI1_pull_polarity;
+		}
+
+		*polarity = (*p_pull_polarity) ? 1:0;
+		return 0;
+	} else if (pin >= 121 && pin <= 122) {
+		/* GPI0~1 */
+		*polarity = 0;
+		return 0;
+	}
+
+	return -1;
+}
+
+static int gpi_and_mipi_pins_set_pull_enable(struct ak_pinctrl *pc, int pin, int enable)
+{
+	int done = 0;
+
+	if (pin >= 109 && pin <= 120) {
+		int *p_pull_polarity;
+		void __iomem *mipi_base;
+
+		if (pin >= 115 && pin <= 120) {
+			/* GPI-mipi0 */
+			mipi_base = pc->mipi0_base;
+			p_pull_polarity = &pc->GPI_MIPI0_pull_polarity;
+		} else {
+			/* GPI-mipi1 */
+			mipi_base = pc->mipi1_base;
+			p_pull_polarity = &pc->GPI_MIPI1_pull_polarity;
+		}
+
+		if (enable) {
+			if (*p_pull_polarity) {
+				__raw_writeb(0x80, mipi_base + 0x0d);//enable pullup
+				__raw_writeb(0x02, mipi_base + 0xb8);//disable pulldown
+			} else {
+				__raw_writeb(0xb0, mipi_base + 0x0d);//disable pullup
+				__raw_writeb(0x04, mipi_base + 0xb8);//enable pulldown
+			}
+		} else {
+			__raw_writeb(0xb0, mipi_base + 0x0d);//disable pullup
+			__raw_writeb(0x02, mipi_base + 0xb8);//disable pulldown
+		}
+
+		done = 1;
+	} else if (pin >= 121 && pin <= 122) {
+		/* GPI0~1 */
+		done = 1;
+	}
+
+	return (done ? 0:-1);
+}
+
+static int gpi_and_mipi_pins_get_pull_enable(struct ak_pinctrl *pc, int pin, int *enable)
+{
+	if (pin >= 109 && pin <= 120) {
+		u8 valup, valdown;
+		int *p_pull_polarity;
+		void __iomem *mipi_base;
+
+		if (pin >= 115 && pin <= 120) {
+			/* GPI-mipi0 */
+			mipi_base = pc->mipi0_base;
+			p_pull_polarity = &pc->GPI_MIPI0_pull_polarity;
+		} else {
+			/* GPI-mipi1 */
+			mipi_base = pc->mipi1_base;
+			p_pull_polarity = &pc->GPI_MIPI1_pull_polarity;
+		}
+
+		valup = __raw_readb(mipi_base + 0x0d);
+		valdown = __raw_readb(mipi_base + 0xb8);
+
+		if (*p_pull_polarity) {
+			*enable = (valup == 0x80) ? 1:0;
+			return 0;
+		} else {
+
+			*enable = (valdown == 0x04) ? 1:0;
+			return 0;
+		}
+	} else if (pin >= 121 && pin <= 122) {
+		/* GPI0~1 */
+		*enable = 0;
+		return 0;
+	}
+
+	return -1;
+}
+
+static int drive_gpio76_92_cfg(int gpio, int drive)
+{
+	u32 regval;
+
+	switch (gpio) {
+		case 76:
+			/*AK_GPIO_DRIVE_CON4 Note:b[17:18]*/
+			regval =__raw_readl(AK_GPIO_DRIVE_CON4);
+			regval &= ~(0x3<<17);
+			regval |= ((drive >> 1) & 0x1) << 17;
+			regval |= (drive & 0x1) << 18;
+			__raw_writel(regval, AK_GPIO_DRIVE_CON4);
+
+			break;
+
+		case 92:
+			/*AK_GPIO_DRIVE_CON5 Note:b[17]&[6]*/
+			regval =__raw_readl(AK_GPIO_DRIVE_CON5);
+			regval &= ~(0x1<<17);
+			regval &= ~(0x1<<6);
+			regval |= ((drive >> 1) & 0x1) << 17;
+			regval |= (drive & 0x1) << 6;
+			__raw_writel(regval, AK_GPIO_DRIVE_CON5);
+			break;
+
+		default:
+			return -1;
+			break;
+	}
+
+	return 0;
+}
+
+static int ie_reg3_gpio100_103_cfg(int gpio, int ie_enable)
+{
+	int offset = 15;
+	u32 regval;
+
+	if ((gpio >= 100) && (gpio <= 103))
+		offset += gpio - 100;
+	else
+		return -1;
+
+	regval =__raw_readl(AK_PPU_PPD_EN_SEL);
+	if (ie_enable)
+		regval |= 1 << offset;
+	else
+		regval &= ~(1 << offset);
+	__raw_writel(regval, AK_PPU_PPD_EN_SEL);
+
+	return 0;
+}
+
+static int pupd_sel_reg3_gpio100_103_cfg(int gpio, int pu_enable)
+{
+	int offset = 20;
+	u32 regval;
+
+	if ((gpio >= 100) && (gpio <= 103))
+		offset += gpio - 100;
+	else
+		return -1;
+
+	regval =__raw_readl(AK_PPU_PPD_EN_SEL);
+	if (pu_enable)
+		regval &= ~(1 << offset);
+	else
+		regval |= 1 << offset;
+	__raw_writel(regval, AK_PPU_PPD_EN_SEL);
+
+	return 0;
+}
+
+static int pin_pos_cfg(int gpio, int fsel)
+{
+	int i;
+	int num;
+	int bits = 0;
+	u32 regval;
+
+	num = sizeof(ak_pin_pos) / sizeof(ak_pin_pos[0]);
+	for (i = 0; i < num; i++) {
+		if (gpio == ak_pin_pos[i].gpio0 && fsel == ak_pin_pos[i].func0) {
+			bits = 0;
+			break;
+		}
+
+		if (gpio == ak_pin_pos[i].gpio1 && fsel == ak_pin_pos[i].func1) {
+			bits = 0x1;
+			break;
+		}
+
+		if (gpio == ak_pin_pos[i].gpio2 && fsel == ak_pin_pos[i].func2) {
+			bits = 0x2;
+			break;
+		}
+
+		if (gpio == ak_pin_pos[i].gpio3 && fsel == ak_pin_pos[i].func3) {
+			bits = 0x3;
+			break;
+		}
+	}
+
+	if (i < num) {
+		regval = __raw_readl(AK_SHAREPIN_CON6);
+		regval &= ~((~((~(unsigned long)0) << ak_pin_pos[i].width)) << ak_pin_pos[i].offset);
+		regval |= bits << ak_pin_pos[i].offset;
+		__raw_writel(regval, AK_SHAREPIN_CON6);
+
+		return 0;
+	}
+
+	return -1;
+}
+
+static void pmu_reg_write(u32 reg, u32 value)
+{
+	u32 regval;
+	
+	/*wait bit 17 pmu ready int status to be 1*/
+	do {
+	} while (!(__raw_readl(AK_INTERRUPT_STATUS) & (1<<17)));
+
+	regval = (0x1<<21)|(0x2<<18)|(0x0<<17)
+		|((reg&0x7)<<14)|(value&0x3FFF);
+	__raw_writel(regval, AK_ALWAYS_ON_PMU_CTRL0);
+
+	/*wait bit 17 pmu ready int status to be 1*/
+	do {
+	} while (!(__raw_readl(AK_INTERRUPT_STATUS) & (1<<17)));
+}
+
+static u32 pmu_reg_read(u32 reg)
+{
+	u32 regval;
+
+	/*wait bit 17 pmu ready int status to be 1*/
+	do {
+	} while (!(__raw_readl(AK_INTERRUPT_STATUS) & (1<<17)));
+
+	regval = (0x1<<21)|(0x2<<18)|(0x1<<17)
+		|((reg&0x7)<<14);
+	__raw_writel(regval, AK_ALWAYS_ON_PMU_CTRL0);
+
+	/*wait bit 17 pmu ready int status to be 1*/
+	do {
+	} while (!(__raw_readl(AK_INTERRUPT_STATUS) & (1<<17)));
+
+	return (__raw_readl(AK_ALWAYS_ON_PMU_CTRL1))&0x3FFF;
+}
+
+static int pin_set_share(struct ak_pinctrl *pc, int pin, int sel)
+{
+	int sharepin_bits = GET_SHAREPIN_WIDTH(ak_sharepin[pin].gpio_config);
+	int gpio_class = GET_GPIO_CLASS(ak_sharepin[pin].gpio_config);
+	int cur = pc->fsel[pin];
+	u32 regval;
+
+	if (cur == sel)
+		return 0;
+
+	if (gpio_class == GPIO_CLASS_AO) {
+		/* Always on gpio, do some special config here */
+		u8 bit;
+		if (pin == 16)
+			bit = 0;
+		else if (pin == 17)
+			bit = 1;
+		else if (pin == 21)
+			bit = 2;
+		else if (pin == 22)
+			bit = 3;
+		else if (pin == 104)
+			bit = 4;
+		else if (pin == 105)
+			bit = 5;
+		else if (pin == 106)
+			bit = 6;
+		else if (pin == 107)
+			bit = 7;
+		else if (pin == 108)
+			bit = 8;
+		else {
+			pr_err("%s error pin:%d, sel:%d\n", __func__, pin, sel);
+			return -1;
+		}
+
+		if (sel == 0) {
+			regval = pmu_reg_read(0x4);
+			regval |= 0x1;
+			pmu_reg_write(0x4, regval);
+			/* just config reg0_1 for function select */
+			/* keep the default value of reg0_0 */
+
+			regval = pmu_reg_read(0x0);
+			regval &= ~(0x1<<bit);
+			pmu_reg_write(0x0, regval);
+		}else if (sel == 1) {
+			regval = pmu_reg_read(0x4);
+			regval |= 0x1;
+			pmu_reg_write(0x4, regval);
+			/* just config reg0_1 for function select */
+			/* keep the default value of reg0_0 */
+
+			regval = pmu_reg_read(0x0);
+			regval |= (0x1<<bit);
+			pmu_reg_write(0x0, regval);
+		}
+	} else {
+		if (ak_sharepin[pin].sharepin_reg != 0 &&
+				sel <= (~(0xffffffff << sharepin_bits))) {
+			regval = __raw_readl(ak_sharepin[pin].sharepin_reg);
+			regval &= ~((~(0xffffffff << sharepin_bits)) << ak_sharepin[pin].reg_off);
+			regval |= (sel << ak_sharepin[pin].reg_off);
+			__raw_writel(regval, ak_sharepin[pin].sharepin_reg);
+		}
+
+		gpi_and_mipi_pins_set_share_ex(pc, pin, sel);
+		pin_pos_cfg(pin, sel);
+	}
+
+	pc->fsel[pin] = sel;
+	return 0;
+}
+
+static int pin_set_input_enable(int pin, int enable)
+{
+	int done = 0;
+	int ie = enable ? 1:0;
+	int gpio_class = GET_GPIO_CLASS(ak_sharepin[pin].gpio_config);
+	u32 regval;
+
+	pin_check_capacity_input_enable(pin, enable);
+
+	if (gpio_class == GPIO_CLASS_AO) {
+		/* Always on gpio, do some special config here */
+		/* keep the default IE/PU config value of reg0_0 */
+		done = 1;
+	} else {
+		if (ak_sharepin[pin].ie) {
+			regval = __raw_readl(ak_sharepin[pin].ie);
+			regval &= ~(0x1<<ak_sharepin[pin].sel_bit);
+			regval |= (ie<<ak_sharepin[pin].sel_bit);
+			__raw_writel(regval, ak_sharepin[pin].ie);
+			done = 1;
+		}
+
+		if (!ie_reg3_gpio100_103_cfg(pin, ie))
+			done = 1;
+	}
+
+	if (!done)
+		;//pr_err("%s can't set pin:%d input enable\n", __func__, pin);
+	return 0;
+}
+
+static int pin_get_input_enable(int pin)
+{
+	int gpio_class = GET_GPIO_CLASS(ak_sharepin[pin].gpio_config);
+	u32 regval;
+
+	if (gpio_class == GPIO_CLASS_AO) {
+		/* Always on gpio, do some special config here */
+		/* keep the default IE/PU config value of reg0_0 */
+		return 0;
+	} else {
+		if (ak_sharepin[pin].ie) {
+			regval = __raw_readl(ak_sharepin[pin].ie);
+			regval &= (0x1<<ak_sharepin[pin].sel_bit);
+			return (regval ? 1:0);
+		}
+	}
+	pr_err("%s can't get pin:%d input enable\n", __func__, pin);
+	return 0;
+}
+
+static int pin_set_drive(int pin, int strength)
+{
+	int done = 0;
+	int gpio_class = GET_GPIO_CLASS(ak_sharepin[pin].gpio_config);
+	u32 regval;
+
+	strength = DRIVE_STRENGTH(strength);
+
+	pin_check_capacity_drive(pin, strength);
+
+	if (gpio_class == GPIO_CLASS_AO) {
+		/* Always on gpio, do some special config here */
+		/* keep the default IE/PU config value of reg0_0 */
+		done = 1;
+	} else {
+		if (ak_sharepin[pin].drive_reg) {
+			regval = __raw_readl(ak_sharepin[pin].drive_reg);
+			regval &= ~(0x3<<ak_sharepin[pin].reg_off);
+			regval |= ((strength&0x3)<<ak_sharepin[pin].reg_off);
+			__raw_writel(regval, ak_sharepin[pin].drive_reg);
+			done = 1;
+		}
+
+		if (!drive_gpio76_92_cfg(pin, strength))
+			done = 1;
+	}
+
+	if (!done)
+		;//pr_err("%s can't set pin:%d drive\n", __func__, pin);
+	return 0;
+}
+
+static int pin_get_drive(int pin)
+{
+	int gpio_class = GET_GPIO_CLASS(ak_sharepin[pin].gpio_config);
+	u32 regval;
+
+	if (gpio_class == GPIO_CLASS_AO) {
+		/* Always on gpio, do some special config here */
+		/* keep the default IE/PU config value of reg0_0 */
+		return 0;
+	} else {
+		if (ak_sharepin[pin].drive_reg) {
+			regval = __raw_readl(ak_sharepin[pin].drive_reg);
+			regval &= 0x3<<ak_sharepin[pin].reg_off;
+			regval >>= ak_sharepin[pin].reg_off;
+			return DRIVE_STRENGTH(regval);
+		}
+	}
+	pr_err("%s can't get pin:%d drive\n", __func__, pin);
+	return 0;
+}
+
+static int pin_set_pull_polarity(struct ak_pinctrl *pc, int pin, int pullup)
+{
+	int done = 0;
+	int gpio_class = GET_GPIO_CLASS(ak_sharepin[pin].gpio_config);
+	u32 regval;
+
+	pin_check_capacity_pull_polarity(pin, pullup);
+
+	if (gpio_class == GPIO_CLASS_AO) {
+		/* Always on gpio, do some special config here */
+		/* keep the default IE/PU config value of reg0_0 */
+		done = 1;
+	} else {
+		if (ak_sharepin[pin].pupd_sel) {
+			if (!pullup) {
+				regval = __raw_readl(ak_sharepin[pin].pupd_sel);
+				regval |= (1<<ak_sharepin[pin].sel_bit);
+				__raw_writel(regval, ak_sharepin[pin].pupd_sel);
+			} else {
+				regval = __raw_readl(ak_sharepin[pin].pupd_sel);
+				regval &= ~(1<<ak_sharepin[pin].sel_bit);
+				__raw_writel(regval, ak_sharepin[pin].pupd_sel);
+			}
+			done = 1;
+		}
+
+		if (!gpi_and_mipi_pins_set_pull_polarity(pc, pin, pullup))
+			done = 1;
+
+		if (!pupd_sel_reg3_gpio100_103_cfg(pin, pullup))
+			done = 1;
+	}
+
+	if (!done)
+		;//pr_err("%s can't set pin:%d pull polarity\n", __func__, pin);
+	return 0;
+}
+
+static int pin_get_pull_polarity(struct ak_pinctrl *pc, int pin)
+{
+	int polarity;
+	int gpio_class = GET_GPIO_CLASS(ak_sharepin[pin].gpio_config);
+	u32 regval;
+
+	if (gpio_class == GPIO_CLASS_AO) {
+		/* Always on gpio, do some special config here */
+		/* keep the default IE/PU config value of reg0_0 */
+		return 0;
+	} else {
+		if (ak_sharepin[pin].pupd_sel) {
+			regval = __raw_readl(ak_sharepin[pin].pupd_sel);
+			regval &= (1<<ak_sharepin[pin].sel_bit);
+			return (regval ? 0:1);
+		}
+
+		if (!gpi_and_mipi_pins_get_pull_polarity(pc, pin, &polarity))
+			return polarity;
+	}
+
+	pr_err("%s can't get pin:%d pull polarity\n", __func__, pin);
+	return 0;
+}
+
+static int pin_set_open_drain(struct ak_pinctrl *pc, int pin, int enable)
+{
+	int bit = -1;
+	u32 regval;
+
+	if (pin == 31)
+		bit = 30;
+	else if (pin == 32)
+		bit = 31;
+
+	if (bit >= 0) {
+		pr_debug("%s pin:%d, enable:%d\n", __func__, pin, enable);
+		regval = __raw_readl(AK_PPU_PPD_EN_SEL);
+		if (enable)
+			regval |= (1<<bit);
+		else
+			regval &= ~(1<<bit);
+		__raw_writel(regval, AK_PPU_PPD_EN_SEL);
+	}
+
+	return 0;
+}
+
+static int pin_set_pull_enable(struct ak_pinctrl *pc, int pin, int enable)
+{
+	int done = 0;
+	int gpio_class = GET_GPIO_CLASS(ak_sharepin[pin].gpio_config);
+	int pupd_enable_value = GET_PUPD_ENABLE_BIT(ak_sharepin[pin].gpio_config);
+	u32 regval;
+
+	pin_check_capacity_pull_enable(pin, enable);
+
+	if (gpio_class == GPIO_CLASS_AO) {
+		/* Always on gpio, do some special config here */
+		/* keep the default IE/PU config value of reg0_0 */
+		done = 1;
+	} else {
+		/* enable PU/PD function */
+		if (ak_sharepin[pin].pupd_en) {
+			int set_value;
+			if (enable) {
+				set_value = pupd_enable_value;
+			} else {
+				set_value = !pupd_enable_value;
+			}
+			regval = __raw_readl(ak_sharepin[pin].pupd_en);
+			regval &= ~(1<<ak_sharepin[pin].sel_bit);
+			regval |= (set_value<<ak_sharepin[pin].sel_bit);
+			__raw_writel(regval, ak_sharepin[pin].pupd_en);
+			done = 1;
+		}
+
+		return gpi_and_mipi_pins_set_pull_enable(pc, pin, enable);
+	}
+
+	if (!done)
+		;//pr_err("%s can't set pin:%d pull enable\n", __func__, pin);
+	return 0;
+}
+
+static int pin_get_pull_enable(struct ak_pinctrl *pc, int pin)
+{
+	int enable;
+	int gpio_class = GET_GPIO_CLASS(ak_sharepin[pin].gpio_config);
+	u32 regval;
+
+	if (gpio_class == GPIO_CLASS_AO) {
+		/* Always on gpio, do some special config here */
+		/* keep the default IE/PU config value of reg0_0 */
+		return 0;
+	} else {
+		if (ak_sharepin[pin].pupd_en) {
+			regval = __raw_readl(ak_sharepin[pin].pupd_en);
+			regval &= (1<<ak_sharepin[pin].sel_bit);
+			return (regval ? 0:1);
+		}
+
+		if (!gpi_and_mipi_pins_get_pull_enable(pc, pin, &enable))
+			return enable;
+	}
+
+	pr_err("%s can't get pin:%d pull enable\n", __func__, pin);
+	return 0;
+}
+
+static int pin_set_slew_rate(int pin, int fast)
+{
+	int gpio_class = GET_GPIO_CLASS(ak_sharepin[pin].gpio_config);
+	u32 regval;
+
+	pin_check_capacity_slew_rate(pin, fast);
+
+	if (gpio_class == GPIO_CLASS_AO) {
+		/* Always on gpio, do some special config here */
+		/* keep the default IE/PU config value of reg0_0 */
+	} else {
+		if (ak_sharepin[pin].slew_bit != -1) {
+			regval = __raw_readl(AK_GPIO_SLEW_RATE);
+			regval &= ~(0x1<<ak_sharepin[pin].slew_bit);
+			regval |= ((fast ? 1:0)<<ak_sharepin[pin].slew_bit);
+			__raw_writel(regval, AK_GPIO_SLEW_RATE);
+		} else {
+			//pr_err("%s can't set pin:%d slew\n", __func__, pin);
+		}
+	}
+
+	return 0;
+}
+
+static int pin_get_slew_rate(int pin)
+{
+	int gpio_class = GET_GPIO_CLASS(ak_sharepin[pin].gpio_config);
+	u32 regval;
+
+	if (gpio_class == GPIO_CLASS_AO) {
+		/* Always on gpio, do some special config here */
+		/* keep the default IE/PU config value of reg0_0 */
+	} else {
+		if (ak_sharepin[pin].slew_bit != -1) {
+			regval = __raw_readl(AK_GPIO_SLEW_RATE);
+			regval &= (0x1<<ak_sharepin[pin].slew_bit);
+			return (regval ? 1:0);
+		} else {
+			pr_err("%s cann't get pin:%d slew\n", __func__, pin);
+		}
+	}
+	return 0;
+}
+
+static int gpio_set_share(struct ak_pinctrl *pc, unsigned offset)
+{
+	int sel;
+	unsigned long flags;
+
+	sel = GET_GPIO_SET_VALUE(ak_sharepin[offset].gpio_config);
+	local_irq_save(flags);
+	pin_set_share(pc, offset, sel);
+	local_irq_restore(flags);
+
+	return 0;
+}
+
+static inline unsigned int ak_pinctrl_fsel_get(
+		struct ak_pinctrl *pc, unsigned pin)
+{
+	int status = pc->fsel[pin];
+
+	return status;
+}
+
+static inline void ak_pinctrl_fsel_set(
+		struct ak_pinctrl *pc, unsigned pin,
+		unsigned sel)
+{
+	unsigned long flags;
+	
+	local_irq_save(flags);
+	pin_set_share(pc, pin, sel);
+	local_irq_restore(flags);
+}
+
+static int ak_gpio_set_drive(struct gpio_chip *chip, unsigned offset, int strength)
+{
+	pin_set_drive(offset, strength);
+	return 0;
+}
+
+static int ak_gpio_get_drive(struct gpio_chip *chip, unsigned offset)
+{
+	return pin_get_drive(offset);
+}
+
+static int ak_gpio_set_pull_polarity(struct gpio_chip *chip, unsigned offset, int pullup)
+{
+	struct ak_pinctrl *pc = dev_get_drvdata(chip->dev);
+	pin_set_pull_polarity(pc, offset, pullup);
+
+	return 0;
+}
+
+static int ak_gpio_get_pull_polarity(struct gpio_chip *chip, unsigned offset)
+{
+	struct ak_pinctrl *pc = dev_get_drvdata(chip->dev);
+	return pin_get_pull_polarity(pc, offset);
+}
+
+static int ak_gpio_set_pull_enable(struct gpio_chip *chip, unsigned offset, int enable)
+{
+	struct ak_pinctrl *pc = dev_get_drvdata(chip->dev);
+	pin_set_pull_enable(pc, offset, enable);
+	return 0;
+}
+
+static int ak_gpio_get_pull_enable(struct gpio_chip *chip, unsigned offset)
+{
+	struct ak_pinctrl *pc = dev_get_drvdata(chip->dev);
+	return pin_get_pull_enable(pc, offset);
+}
+
+static int ak_gpio_set_input_enable(struct gpio_chip *chip, unsigned offset, int enable)
+{
+	pin_set_input_enable(offset, enable);
+	return 0;
+}
+
+static int ak_gpio_get_input_enable(struct gpio_chip *chip, unsigned offset)
+{
+	return pin_get_input_enable(offset);
+}
+
+static int ak_gpio_set_slew_rate(struct gpio_chip *chip, unsigned offset, int fast)
+{
+	pin_set_slew_rate(offset, fast);
+	return 0;
+}
+
+static int ak_gpio_get_slew_rate(struct gpio_chip *chip, unsigned offset)
+{
+	return pin_get_slew_rate(offset);
+}
+
+static inline void ak_pinctrl_fsel_reset(
+		struct ak_pinctrl *pc, unsigned pin,
+		unsigned fsel)
+{
+	unsigned long flags;
+	u32 regval;
+	int cur = pc->fsel[pin];
+
+	if (cur == -1)
+		return;
+
+	local_irq_save(flags);
+	if (ak_sharepin[pin].sharepin_reg) {
+		regval = __raw_readl(ak_sharepin[pin].sharepin_reg);
+		regval &= ~(0x3 << ak_sharepin[pin].reg_off);
+		__raw_writel(regval, ak_sharepin[pin].sharepin_reg);
+	}
+	local_irq_restore(flags);
+
+	pc->fsel[pin] = -1;
+}
+
+
+static int ak_gpio_direction_input(struct gpio_chip *chip, unsigned offset)
+{
+	return pinctrl_gpio_direction_input(chip->base + offset);
+}
+
+static int ak_gpio_get(struct gpio_chip *chip, unsigned offset)
+{
+	struct ak_pinctrl *pc = dev_get_drvdata(chip->dev);
+	void __iomem * reg = pc->gpio_base + AK_GPIO_IN_BASE(offset);
+	unsigned int bit = AK_GPIO_REG_SHIFT(offset);
+
+	if (offset <= 108) {
+		return (__raw_readl(reg) & (1<<bit)) ? 1:0;
+	} else {
+		u32 val;
+
+		val = __raw_readl(pc->gpio_base + 0x34) >> 13;
+
+		return (val & (1 << ((122 - 109) - (offset - 109)))) ? 1:0;
+	}
+}
+
+static void ak_gpio_set(struct gpio_chip *chip, unsigned offset, int value)
+{
+	struct ak_pinctrl *pc = dev_get_drvdata(chip->dev);
+	void __iomem *reg = pc->gpio_base + AK_GPIO_OUT_BASE(offset);
+	unsigned int bit = AK_GPIO_REG_SHIFT(offset);
+	unsigned long flags;
+	u32 regval;
+
+	local_irq_save(flags);
+	if (AK_GPIO_OUT_LOW == value) {
+		regval = __raw_readl(reg);
+		regval &= ~(1<<bit);
+		__raw_writel(regval, reg);
+	} else if (AK_GPIO_OUT_HIGH == value) {
+		regval = __raw_readl(reg);
+		regval |= (1<<bit);
+		__raw_writel(regval, reg);		
+	}
+	local_irq_restore(flags);
+}
+
+static int ak_gpio_direction_output(struct gpio_chip *chip,
+		unsigned offset, int value)
+{
+	ak_gpio_set(chip, offset, value);
+	return pinctrl_gpio_direction_output(chip->base + offset);
+}
+
+static int ak_gpio_to_irq(struct gpio_chip *chip, unsigned offset)
+{
+	struct ak_pinctrl *pc = dev_get_drvdata(chip->dev);
+
+	return irq_linear_revmap(pc->irq_domain, offset);
+}
+
+static struct gpio_chip ak_gpio_chip = {
+	.label = MODULE_NAME,
+	.owner = THIS_MODULE,
+	.request = gpiochip_generic_request,
+	.free = gpiochip_generic_free,
+	.direction_input = ak_gpio_direction_input,
+	.direction_output = ak_gpio_direction_output,
+	.get = ak_gpio_get,
+	.set = ak_gpio_set,
+	.set_drive = ak_gpio_set_drive,
+	.get_drive = ak_gpio_get_drive,
+	.set_pull_polarity = ak_gpio_set_pull_polarity,
+	.get_pull_polarity = ak_gpio_get_pull_polarity,
+	.set_pull_enable = ak_gpio_set_pull_enable,
+	.get_pull_enable = ak_gpio_get_pull_enable,
+	.set_input_enable = ak_gpio_set_input_enable,
+	.get_input_enable = ak_gpio_get_input_enable,
+	.set_slew_rate = ak_gpio_set_slew_rate,
+	.get_slew_rate = ak_gpio_get_slew_rate,
+	.to_irq = ak_gpio_to_irq,
+	.base = 0,
+	.ngpio = AK37D_NUM_GPIOS,
+	.can_sleep = false,
+};
+
+static void ak_pinctrl_irq_handler(struct irq_desc *desc)
+{
+	struct irq_chip *chip = irq_desc_get_chip(desc);
+	struct ak_pinctrl *pc = irq_desc_get_handler_data(desc);
+	unsigned long irq_status;
+	int i;
+
+	for (i = 0; i < 3; i++) {
+		int off = 0;
+		
+		chained_irq_enter(chip, desc);
+        irq_status = __raw_readl(pc->gpio_base + AK_GPIO_EDGE_STATUS1 + i * 4);
+		for_each_set_bit(off, &irq_status, 32) {
+		    /* check all int status and handle the Edge/level interrupt */
+		    int pin_irq = irq_find_mapping(pc->irq_domain, i * 32 + off);
+
+            generic_handle_irq(pin_irq);
+
+		}
+		chained_irq_exit(chip, desc);
+	}
+}
+
+static void ak_gpio_irq_enable(struct irq_data *data)
+{
+	struct ak_pinctrl *pc = irq_data_get_irq_chip_data(data);
+	unsigned pin = irqd_to_hwirq(data);
+	void __iomem *reg = pc->gpio_base + AK_GPIO_INTEN_BASE(pin);
+	unsigned bit = AK_GPIO_REG_SHIFT(pin);
+	unsigned long flags;
+
+	u32 regval;
+
+	spin_lock_irqsave(&pc->lock, flags);
+	regval = __raw_readl(reg);
+	regval |= (1 << bit);
+	__raw_writel(regval, reg);
+	spin_unlock_irqrestore(&pc->lock, flags);
+}
+
+static void ak_gpio_irq_disable(struct irq_data *data)
+{
+	struct ak_pinctrl *pc = irq_data_get_irq_chip_data(data);
+	unsigned pin = irqd_to_hwirq(data);
+	void __iomem *reg = pc->gpio_base + AK_GPIO_INTEN_BASE(pin);
+	unsigned bit = AK_GPIO_REG_SHIFT(pin);
+	unsigned long flags;
+
+	u32 regval;
+
+	spin_lock_irqsave(&pc->lock, flags);
+	regval = __raw_readl(reg);
+	regval &= ~(1 << bit);
+	__raw_writel(regval, reg);
+	spin_unlock_irqrestore(&pc->lock, flags);
+}
+
+/* slower path for reconfiguring IRQ type */
+static int __ak_gpio_irq_set_type_enabled(struct ak_pinctrl *pc,
+	unsigned offset, unsigned int type)
+{
+	u32 regval;
+	void __iomem *reg_inten = pc->gpio_base + AK_GPIO_INTEN_BASE(offset);
+	void __iomem *reg_intm  = pc->gpio_base + AK_GPIO_INTM_BASE(offset);
+	void __iomem *reg_intp  = pc->gpio_base + AK_GPIO_INTPOL_BASE(offset);
+
+	int bit = AK_GPIO_REG_SHIFT(offset);
+ 	
+	switch (type) {
+	case IRQ_TYPE_NONE:
+		if (pc->irq_type[offset] != type) {
+			regval = __raw_readl(reg_inten);
+			regval &= ~(1<<bit);
+			__raw_writel(regval, reg_inten);
+			pc->irq_type[offset] = type;
+		}
+		break;
+
+	case IRQ_TYPE_EDGE_RISING:
+	case IRQ_TYPE_EDGE_FALLING:
+		if (pc->irq_type[offset] != type) {
+			regval = __raw_readl(reg_intm);
+			regval |= (1<<bit);
+			__raw_writel(regval, reg_intm);
+
+			regval = __raw_readl(reg_intp);
+			if (IRQ_TYPE_EDGE_RISING == type)
+				regval &= ~(1<<bit);
+			else
+				regval |= (1<<bit);
+			__raw_writel(regval, reg_intp);			
+			pc->irq_type[offset] = type;
+		}
+		break;
+
+	case IRQ_TYPE_LEVEL_HIGH:
+	case IRQ_TYPE_LEVEL_LOW:
+		if (pc->irq_type[offset] != type) {
+			regval = __raw_readl(reg_intm);
+			regval &= ~(1<<bit);
+			__raw_writel(regval, reg_intm);
+
+			regval = __raw_readl(reg_intp);
+			if (IRQ_TYPE_LEVEL_HIGH == type)
+				regval &= ~(1<<bit);
+			else
+				regval |= (1<<bit);
+			__raw_writel(regval, reg_intp);			
+			pc->irq_type[offset] = type;
+		}
+		break;
+
+	default:
+		return -EINVAL;
+	}
+	return 0;
+}
+
+static int ak_gpio_irq_set_type(struct irq_data *data, unsigned int type)
+{
+	struct ak_pinctrl *pc = irq_data_get_irq_chip_data(data);
+	unsigned pin = irqd_to_hwirq(data);
+	
+
+	unsigned long flags;
+	int ret;
+
+	spin_lock_irqsave(&pc->lock, flags);
+
+    /* 
+    *  First irq_set_type called by __setup_irq,
+    *  and then irq_enable  called by __setup_irq.
+    *  refer to kernel/irq/manage.c.  fixed by zhang zhipeng (2019/5/3)
+    */
+	ret = __ak_gpio_irq_set_type_enabled(pc, pin, type);
+
+	if (type & IRQ_TYPE_EDGE_BOTH)
+		irq_set_handler_locked(data, handle_edge_irq);
+	else
+		irq_set_handler_locked(data, handle_level_irq);
+	spin_unlock_irqrestore(&pc->lock, flags);
+
+	return ret;
+}
+
+
+/* 
+ *  irq_ack called by handle_edge_irq when using edge trigger mode. 
+ *  Author:zhang zhipeng
+ *  date: 2019-5-3
+ */
+static void ak_gpio_irq_ack(struct irq_data *d)
+{
+	struct ak_pinctrl *pc = irq_data_get_irq_chip_data(d);
+	unsigned pin = irqd_to_hwirq(d);
+	
+
+	/* Clear the IRQ status*/
+    __raw_readl(pc->gpio_base + AK_GPIO_INTEDGE_BASE(pin));
+    //__raw_writel(0 << bit,pc->gpio_base + AK_GPIO_INTEDGE_BASE(pin));
+
+}
+
+static struct irq_chip ak_gpio_irq_chip = {
+	.name = "ak_gpio_edge",
+    .irq_ack	= ak_gpio_irq_ack,
+	.irq_enable = ak_gpio_irq_enable,
+	.irq_disable = ak_gpio_irq_disable,
+	.irq_set_type = ak_gpio_irq_set_type,
+	.irq_mask = ak_gpio_irq_disable,
+	.irq_mask_ack = ak_gpio_irq_disable,
+	.irq_unmask = ak_gpio_irq_enable,
+};
+
+static int ak_pctl_get_groups_count(struct pinctrl_dev *pctldev)
+{
+	return ARRAY_SIZE(ak_gpio_groups);
+}
+
+static const char *ak_pctl_get_group_name(struct pinctrl_dev *pctldev,
+		unsigned selector)
+{
+	return ak_gpio_groups[selector];
+}
+
+static int ak_pctl_get_group_pins(struct pinctrl_dev *pctldev,
+		unsigned selector,
+		const unsigned **pins,
+		unsigned *num_pins)
+{
+	*pins = &ak_gpio_pins[selector].number;
+	*num_pins = 1;
+
+	return 0;
+}
+
+static void ak_pctl_pin_dbg_show(struct pinctrl_dev *pctldev,
+		struct seq_file *s,
+		unsigned offset)
+{
+	struct ak_pinctrl *pc = pinctrl_dev_get_drvdata(pctldev);
+	unsigned int fsel = ak_pinctrl_fsel_get(pc, offset);
+	const char *fname = ak_funcs[fsel];
+	int irq = irq_find_mapping(pc->irq_domain, offset);
+
+	seq_printf(s, "function %s; irq %d (%s)",
+		fname, irq, irq_type_names[pc->irq_type[offset]]);
+}
+
+static void ak_pctl_dt_free_map(struct pinctrl_dev *pctldev,
+		struct pinctrl_map *maps, unsigned num_maps)
+{
+	int i;
+
+	for (i = 0; i < num_maps; i++)
+		if (maps[i].type == PIN_MAP_TYPE_CONFIGS_PIN)
+			kfree(maps[i].data.configs.configs);
+
+	kfree(maps);
+}
+
+static int ak_pctl_dt_node_to_map_func(struct ak_pinctrl *pc,
+		struct device_node *np, u32 pin, u32 fnum,
+		struct pinctrl_map **maps)
+{
+	struct pinctrl_map *map = *maps;
+
+	if (fnum >= ARRAY_SIZE(ak_funcs)) {
+		dev_err(pc->dev, "%s: invalid anyka,function %d\n",
+			of_node_full_name(np), fnum);
+		return -EINVAL;
+	}
+
+	map->type = PIN_MAP_TYPE_MUX_GROUP;
+	map->data.mux.group = ak_gpio_groups[pin];
+	map->data.mux.function = ak_funcs[fnum];
+	(*maps)++;
+
+	return 0;
+}
+
+static int ak_pctl_dt_node_to_map_pull(struct ak_pinctrl *pc,
+		struct device_node *np, u32 pin, u32 pull,
+		struct pinctrl_map **maps)
+{
+	struct pinctrl_map *map = *maps;
+	unsigned long *configs;
+
+	configs = kzalloc(sizeof(*configs), GFP_KERNEL);
+	if (!configs)
+		return -ENOMEM;
+	configs[0] = pull;
+
+	map->type = PIN_MAP_TYPE_CONFIGS_PIN;
+	map->data.configs.group_or_pin = ak_gpio_pins[pin].name;
+	map->data.configs.configs = configs;
+	map->data.configs.num_configs = 1;
+	(*maps)++;
+
+	return 0;
+}
+
+static int ak_pctl_dt_node_to_map(struct pinctrl_dev *pctldev,
+		struct device_node *np,
+		struct pinctrl_map **map, unsigned *num_maps)
+{
+	struct ak_pinctrl *pc = pinctrl_dev_get_drvdata(pctldev);
+	struct property *pins, *funcs, *pulls;
+	int num_pins, num_funcs, num_pulls, maps_per_pin;
+	struct pinctrl_map *maps, *cur_map;
+	int i, err;
+	u32 pin, func, pull;
+
+	pins = of_find_property(np, "anyka,pins", NULL);
+	if (!pins) {
+		dev_err(pc->dev, "%s: missing anyka,pins property\n",
+				of_node_full_name(np));
+		return -EINVAL;
+	}
+
+	funcs = of_find_property(np, "anyka,function", NULL);
+	pulls = of_find_property(np, "anyka,pull", NULL);
+
+	if (!funcs && !pulls) {
+		dev_err(pc->dev,
+			"%s: neither anyka,function nor anyka,pull specified\n",
+			of_node_full_name(np));
+		return -EINVAL;
+	}
+
+	num_pins = pins->length / 4;
+	num_funcs = funcs ? (funcs->length / 4) : 0;
+	num_pulls = pulls ? (pulls->length / 4) : 0;
+
+	if (num_funcs > 1 && num_funcs != num_pins) {
+		dev_err(pc->dev,
+			"%s: anyka,function must have 1 or %d entries\n",
+			of_node_full_name(np), num_pins);
+		return -EINVAL;
+	}
+
+	if (num_pulls > 1 && num_pulls != num_pins) {
+		dev_err(pc->dev,
+			"%s: anyka,pull must have 1 or %d entries\n",
+			of_node_full_name(np), num_pins);
+		return -EINVAL;
+	}
+
+	maps_per_pin = 0;
+	if (num_funcs)
+		maps_per_pin++;
+	if (num_pulls)
+		maps_per_pin++;
+	cur_map = maps = kzalloc(num_pins * maps_per_pin * sizeof(*maps),
+				GFP_KERNEL);
+	if (!maps)
+		return -ENOMEM;
+
+	for (i = 0; i < num_pins; i++) {
+		err = of_property_read_u32_index(np, "anyka,pins", i, &pin);
+		if (err)
+			goto out;
+		if (pin >= ARRAY_SIZE(ak_gpio_pins)) {
+			dev_err(pc->dev, "%s: invalid anyka,pins value %d\n",
+				of_node_full_name(np), pin);
+			err = -EINVAL;
+			goto out;
+		}
+
+		if (num_funcs) {
+			err = of_property_read_u32_index(np, "anyka,function",
+					(num_funcs > 1) ? i : 0, &func);
+			if (err)
+				goto out;
+			err = ak_pctl_dt_node_to_map_func(pc, np, pin,
+							func, &cur_map);
+			if (err)
+				goto out;
+		}
+		if (num_pulls) {
+			err = of_property_read_u32_index(np, "anyka,pull",
+					(num_pulls > 1) ? i : 0, &pull);
+			if (err)
+				goto out;
+			err = ak_pctl_dt_node_to_map_pull(pc, np, pin,
+							pull, &cur_map);
+			if (err)
+				goto out;
+		}
+	}
+
+	*map = maps;
+	*num_maps = num_pins * maps_per_pin;
+	return 0;
+
+out:
+	kfree(maps);
+	return err;
+}
+
+static const struct pinctrl_ops ak_pctl_ops = {
+	.get_groups_count = ak_pctl_get_groups_count,
+	.get_group_name = ak_pctl_get_group_name,
+	.get_group_pins = ak_pctl_get_group_pins,
+	.pin_dbg_show = ak_pctl_pin_dbg_show,
+	.dt_node_to_map = ak_pctl_dt_node_to_map,
+	.dt_free_map = ak_pctl_dt_free_map,
+};
+
+static int ak_pmx_get_functions_count(struct pinctrl_dev *pctldev)
+{
+	return ARRAY_SIZE(ak_funcs);
+}
+
+static const char *ak_pmx_get_function_name(struct pinctrl_dev *pctldev,
+		unsigned selector)
+{
+	return ak_funcs[selector];
+}
+
+static int ak_pmx_get_function_groups(struct pinctrl_dev *pctldev,
+		unsigned selector,
+		const char * const **groups,
+		unsigned * const num_groups)
+{
+	*groups = ak_gpio_groups;
+	*num_groups = ARRAY_SIZE(ak_gpio_groups);
+
+	return 0;
+}
+
+static int ak_pmx_set(struct pinctrl_dev *pctldev,
+		unsigned func_selector,
+		unsigned group_selector)
+{
+	struct ak_pinctrl *pc = pinctrl_dev_get_drvdata(pctldev);
+
+	ak_pinctrl_fsel_set(pc, group_selector, func_selector);
+	return 0;
+}
+
+static void ak_pmx_gpio_disable_free(struct pinctrl_dev *pctldev,
+		struct pinctrl_gpio_range *range,
+		unsigned offset)
+{
+	struct ak_pinctrl *pc = pinctrl_dev_get_drvdata(pctldev);
+
+	/* disable by setting sahrepin cfg to default value */
+	ak_pinctrl_fsel_reset(pc, offset, pc->fsel[offset]);
+}
+
+static int ak_pmx_gpio_set_direction(struct pinctrl_dev *pctldev,
+		struct pinctrl_gpio_range *range,
+		unsigned offset,
+		bool input)
+{
+	struct ak_pinctrl *pc = pinctrl_dev_get_drvdata(pctldev);
+	unsigned long flags;
+	u32 regval;
+	void __iomem *reg = pc->gpio_base + AK_GPIO_DIR_BASE(offset);
+	unsigned int bit = AK_GPIO_REG_SHIFT(offset);
+	int gpio_cfg = input ?
+		ePIN_AS_GPIO_IN : ePIN_AS_GPIO_OUT;
+
+	pin_check_capacity_direction(offset, input);
+
+	local_irq_save(flags);
+
+	if (ePIN_AS_GPIO_IN == gpio_cfg){
+		regval = __raw_readl(reg);
+		regval &= ~(1<<bit);
+		__raw_writel(regval, reg);
+	}else if (ePIN_AS_GPIO_OUT == gpio_cfg){
+		regval = __raw_readl(reg);
+		regval |= (1<<bit);
+		__raw_writel(regval, reg);
+	}
+
+	gpio_set_share(pc, offset);
+	if (ePIN_AS_GPIO_IN == gpio_cfg)
+		pin_set_input_enable(offset, 1);
+
+	local_irq_restore(flags);
+
+	return 0;
+}
+
+static const struct pinmux_ops ak_pmx_ops = {
+	.get_functions_count = ak_pmx_get_functions_count,
+	.get_function_name = ak_pmx_get_function_name,
+	.get_function_groups = ak_pmx_get_function_groups,
+	.set_mux = ak_pmx_set,
+	.gpio_disable_free = ak_pmx_gpio_disable_free,
+	.gpio_set_direction = ak_pmx_gpio_set_direction,
+};
+
+static int ak_pinconf_get(struct pinctrl_dev *pctldev,
+			unsigned pin, unsigned long *config)
+{
+	/* No way to read back config in HW */
+
+	return -ENOTSUPP;
+}
+
+static int ak_pinconf_set(struct pinctrl_dev *pctldev,
+			unsigned pin, unsigned long *configs,
+			unsigned num_configs)
+{
+	unsigned long flags;
+	u8 pupd, drive, ie, slew;
+	struct ak_pinctrl *pc = pinctrl_dev_get_drvdata(pctldev);
+
+	if (num_configs != 1)
+		return -EINVAL;
+
+	/* for config value bit[31:24]--slew rate, bit[23:16]--ie, bit[15:8]--drive, bit[7:0]--pupd */
+	pupd = (configs[0] & 0xFF);
+	drive = ((configs[0]>>8) & 0xFF);
+	ie = ((configs[0]>>16) & 0xFF);
+	slew = ((configs[0]>>24) & 0xFF);
+
+	local_irq_save(flags);
+	pin_set_open_drain(pc, pin, (pupd & 0x80) ? 1:0);
+	pin_set_pull_enable(pc, pin, (pupd & 0x10) ? 1:0);
+	pin_set_pull_polarity(pc, pin, (pupd & 0x01) ? 0:1);
+	pin_set_drive(pin, drive & 0x3);
+	pin_set_input_enable(pin, ie & 0x1);
+	pin_set_slew_rate(pin, slew & 0x1);
+	local_irq_restore(flags);
+
+	return 0;
+}
+
+/* for gpio PU/PD config */
+static const struct pinconf_ops ak_pinconf_ops = {
+	.pin_config_get = ak_pinconf_get,
+	.pin_config_set = ak_pinconf_set,
+};
+
+static struct pinctrl_desc ak_pinctrl_desc = {
+	.name = MODULE_NAME,
+	.pins = ak_gpio_pins,
+	.npins = ARRAY_SIZE(ak_gpio_pins),
+	.pctlops = &ak_pctl_ops,
+	.pmxops = &ak_pmx_ops,
+	.confops = &ak_pinconf_ops,
+	.owner = THIS_MODULE,
+};
+
+static struct pinctrl_gpio_range ak_pinctrl_gpio_range = {
+	.name = MODULE_NAME,
+	.npins = AK37D_NUM_GPIOS,
+};
+
+static int ak_pinctrl_probe(struct platform_device *pdev)
+{
+	struct device *dev = &pdev->dev;
+	struct device_node *np = dev->of_node;
+	struct ak_pinctrl *pc;
+	struct resource iomem;
+	int ret, i;
+
+	BUILD_BUG_ON(ARRAY_SIZE(ak_gpio_pins) != AK37D_NUM_GPIOS);
+
+	dev_err(dev, "%s %d\n",__func__,__LINE__);
+
+	pc = devm_kzalloc(dev, sizeof(*pc), GFP_KERNEL);
+	if (!pc)
+		return -ENOMEM;
+
+	platform_set_drvdata(pdev, pc);
+	pc->dev = dev;
+
+	/* gpio registers */
+	ret= of_address_to_resource(np, 0, &iomem);
+	if (ret) {
+		dev_err(dev, "could not get IO memory\n");
+		return ret;
+	}
+
+	pc->gpio_base = devm_ioremap_resource(dev, &iomem);
+	if (IS_ERR(pc->gpio_base))
+		return PTR_ERR(pc->gpio_base);
+
+	/* mipi0 registers */
+	ret= of_address_to_resource(np, 1, &iomem);
+	if (ret) {
+		dev_err(dev, "could not get mipi0 memory\n");
+		return ret;
+	}
+
+	pc->mipi0_base = devm_ioremap_resource(dev, &iomem);
+	if (IS_ERR(pc->mipi0_base))
+		return PTR_ERR(pc->mipi0_base);
+
+	/* mipi1 registers */
+	ret= of_address_to_resource(np, 2, &iomem);
+	if (ret) {
+		dev_err(dev, "could not get mipi1 memory\n");
+		return ret;
+	}
+
+	pc->mipi1_base = devm_ioremap_resource(dev, &iomem);
+	if (IS_ERR(pc->mipi1_base))
+		return PTR_ERR(pc->mipi1_base);
+
+	pc->gc = ak_gpio_chip;
+	pc->gc.dev = dev;
+	pc->gc.of_node = np;
+
+	pc->clk = devm_clk_get(&pdev->dev, NULL);
+	if (IS_ERR(pc->clk)) {
+		ret = PTR_ERR(pc->clk);
+		return ret;
+	}
+
+	clk_prepare_enable(pc->clk);
+
+	pc->irq = platform_get_irq(pdev, 0);
+	if (pc->irq < 0) {
+		ret = pc->irq;
+		goto clk_err;
+	}
+	pr_err("ak_pinctrl_probe irq: %d\n", pc->irq);
+	
+	pc->irq_domain = irq_domain_add_linear(np, AK37D_NUM_GPIOS,
+			&irq_domain_simple_ops, pc);
+	if (!pc->irq_domain) {
+		dev_err(dev, "could not create IRQ domain\n");
+		ret = -ENOMEM;
+		goto clk_err;
+	}
+
+	for (i = 0; i < AK37D_NUM_GPIOS; i++) {
+		int irq = irq_create_mapping(pc->irq_domain, i);
+		//pr_debug("i = %d irq = %d\n", i, irq);
+		pc->irq_type[i] = 0;
+		pc->fsel[i] = -1;
+		irq_set_chip_and_handler(irq, &ak_gpio_irq_chip,
+				handle_level_irq);
+		irq_set_chip_data(irq, pc);
+	}
+
+	irq_set_chained_handler_and_data(pc->irq,
+						 ak_pinctrl_irq_handler, pc);
+
+	ret = gpiochip_add(&pc->gc);
+	if (ret) {
+		dev_err(dev, "could not add GPIO chip\n");
+		goto clk_err;
+	}
+
+	pc->pctl_dev = pinctrl_register(&ak_pinctrl_desc, dev, pc);
+	if (IS_ERR(pc->pctl_dev)) {
+		gpiochip_remove(&pc->gc);
+		ret = PTR_ERR(pc->pctl_dev);
+		goto clk_err;
+	}
+
+	pc->gpio_range = ak_pinctrl_gpio_range;
+	pc->gpio_range.base = pc->gc.base;
+	pc->gpio_range.gc = &pc->gc;
+	pinctrl_add_gpio_range(pc->pctl_dev, &pc->gpio_range);
+
+	return 0;
+
+clk_err:
+	clk_disable_unprepare(pc->clk);
+	clk_put(pc->clk);
+
+	return ret;
+}
+
+static int ak_pinctrl_remove(struct platform_device *pdev)
+{
+	struct ak_pinctrl *pc = platform_get_drvdata(pdev);
+
+	pinctrl_unregister(pc->pctl_dev);
+	gpiochip_remove(&pc->gc);
+	clk_disable_unprepare(pc->clk);
+	clk_put(pc->clk);
+
+	return 0;
+}
+
+static const struct of_device_id ak_pinctrl_match[] = {
+	{ .compatible = "anyka,ak3790d-gpio" },
+	{}
+};
+MODULE_DEVICE_TABLE(of, ak_pinctrl_match);
+
+static struct platform_driver ak_pinctrl_driver = {
+	.probe = ak_pinctrl_probe,
+	.remove = ak_pinctrl_remove,
+	.driver = {
+		.name = MODULE_NAME,
+		.of_match_table = ak_pinctrl_match,
+	},
+};
+
+static int __init ak_pinctrl_init(void)
+{
+	return platform_driver_register(&ak_pinctrl_driver);
+}
+
+static void __exit ak_pinctrl_exit(void)
+{
+	platform_driver_unregister(&ak_pinctrl_driver);
+}
+
+subsys_initcall(ak_pinctrl_init);
+module_exit(ak_pinctrl_exit);
+
+MODULE_DESCRIPTION("AK37d sharepin control driver");
+MODULE_AUTHOR("Feilong Dong <dong_feilong@anyka.com>");
+MODULE_LICENSE("GPL");
+MODULE_VERSION("1.0.00");
diff --git a/drivers/spi/Kconfig b/drivers/spi/Kconfig
old mode 100644
new mode 100755
index 8b9c2a3..b1efd2e
--- a/drivers/spi/Kconfig
+++ b/drivers/spi/Kconfig
@@ -654,6 +654,13 @@ config SPI_NUC900
 	help
 	  SPI driver for Nuvoton NUC900 series ARM SoCs
 
+config SPI_AK
+     tristate "ANYKA SPI controller"
+     depends on SPI_MASTER && (ARCH_AK || ARCH_AK39)
+     help
+       SPI driver for anyka ARM SoCs
+       
+
 #
 # Add new SPI master controllers in alphabetical order above this line
 #
@@ -705,5 +712,12 @@ config SPI_TLE62X0
 endif # SPI_MASTER
 
 # (slave support would go here)
+config SPI_AK_SLAVE
+	tristate "ANYKA SPI slave controller "
+    depends on (ARCH_AK98 || ARCH_AK39) && !SPI_AK
+    help
+    	This is the SPI slave controller driver for anyka platform
+
+# (slave support would go here)
 
 endif # SPI
diff --git a/drivers/spi/Makefile b/drivers/spi/Makefile
old mode 100644
new mode 100755
index 31fb7fb..45db0fd
--- a/drivers/spi/Makefile
+++ b/drivers/spi/Makefile
@@ -93,3 +93,5 @@ obj-$(CONFIG_SPI_XILINX)		+= spi-xilinx.o
 obj-$(CONFIG_SPI_XLP)			+= spi-xlp.o
 obj-$(CONFIG_SPI_XTENSA_XTFPGA)		+= spi-xtensa-xtfpga.o
 obj-$(CONFIG_SPI_ZYNQMP_GQSPI)		+= spi-zynqmp-gqspi.o
+obj-$(CONFIG_SPI_AK) 			+= spi-anyka.o
+obj-$(CONFIG_SPI_AK_SLAVE) 	+= spi-anyka-slave.o
diff --git a/drivers/spi/ak39_spi.h b/drivers/spi/ak39_spi.h
new file mode 100755
index 0000000..9feaff7
--- /dev/null
+++ b/drivers/spi/ak39_spi.h
@@ -0,0 +1,84 @@
+/*
+ * include/asm-arm/arch-ak37/spi.h
+ */
+
+#ifndef __SPI_H__
+#define __SPI_H__
+
+
+enum akspi_cs_num {	
+	AKSPI_ONCHIP_CS = 0,	/*on chip control cs index*/
+	/*AKSPI_CS1,*/
+	/*AKSPI_CS2,*/
+	AKSPI_CS_NUM, 		
+};
+
+enum akspi_bus_num {
+	AKSPI_BUS_NUM1,
+	AKSPI_BUS_NUM2,
+	AKSPI_MAX_BUS_NUM,
+};
+
+
+#define AKSPI_1DATAWIRE 	(0b00<<16)
+#define AKSPI_2DATAWIRE 	(0b01<<16)
+#define AKSPI_4DATAWIRE 	(0b10<<16)
+
+#define AKSPI_XFER_MODE_DMA 	(1)
+#define AKSPI_XFER_MODE_CPU 	(2)
+
+
+#define AK_SPICON		(0x00)
+#define AK_SPICON_WIRE		(0x3<<16)
+#define AK_SPICON_CLKDIV	(0x7F<<8)
+#define AK_SPICON_EN	(1<<6)
+#define AK_SPICON_CS	(1<<5)
+#define AK_SPICON_MS	(1<<4)
+#define AK_SPICON_CPHA	(1<<3)
+#define AK_SPICON_CPOL	(1<<2)
+#define AK_SPICON_ARRM	(1<<1)
+#define AK_SPICON_TGDM	(1<<0)
+
+#define AK_SPISTA		(0x04)
+#define AK_SPISTA_TIMEOUT	(1<<10)
+#define AK_SPISTA_MPROC	(1<<9)
+#define AK_SPISTA_TRANSF	(1<<8)
+#define AK_SPISTA_RXOVER	(1<<7)
+#define AK_SPISTA_RXHFULL	(1<<6)
+#define AK_SPISTA_RXFULL	(1<<5)
+#define AK_SPISTA_RXEMP	(1<<4)
+#define AK_SPISTA_TXUNDER	(1<<3)
+#define AK_SPISTA_TXHEMP	(1<<2)
+#define AK_SPISTA_TXFULL	(1<<1)
+#define AK_SPISTA_TXEMP	(1<<0)
+
+#define AK_SPIINT		(0x08)
+#define AK_SPIINT_TIMEOUT	(1<<10)
+#define AK_SPIINT_MPROC	(1<<9)
+#define AK_SPIINT_TRANSF	(1<<8)
+#define AK_SPIINT_RXOVER	(1<<7)
+#define AK_SPIINT_RXHFULL	(1<<6)
+#define AK_SPIINT_RXFULL	(1<<5)
+#define AK_SPIINT_RXEMP	(1<<4)
+#define AK_SPIINT_TXUNDER	(1<<3)
+#define AK_SPIINT_TXHEMP	(1<<2)
+#define AK_SPIINT_TXFULL	(1<<1)
+#define AK_SPIINT_TXEMP	(1<<0)
+
+#define AK_SPICNT		(0x0C)
+
+#define AK_SPIEXTX		(0x10)
+#define AK_SPIEXTX_BUFEN	(1<<0)
+#define AK_SPIEXTX_DMAEN	(1<<16)
+
+
+#define AK_SPIEXRX		(0x14)
+#define AK_SPIEXRX_BUFEN	(1<<0)
+#define AK_SPIEXRX_DMAEN	(1<<16)
+
+#define AK_SPIOUT		(0x18)
+
+#define AK_SPIIN		(0x1C)
+
+#endif
+
diff --git a/drivers/spi/spi-anyka-slave.c b/drivers/spi/spi-anyka-slave.c
new file mode 100755
index 0000000..ec17db3
--- /dev/null
+++ b/drivers/spi/spi-anyka-slave.c
@@ -0,0 +1,1050 @@
+/*
+ *  spi_anyka_slave.c - Anyka SPI slave controller driver
+ *  based on spi_anyka.c
+ *
+ *  Copyright (C) Anyka 2012
+ *  Wangsheng Gao <gao_wangsheng@anyka.oa>
+ *
+ * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+ *
+ */
+
+/*
+ * Note:
+ *
+ * Supports interrupt programmed transfers.
+ * 
+ */
+
+ /*
+  * Usage:
+  * 	1. set one device as master:
+  *		1. register spidev board info in platform file;
+  *		2. select spidev and anyka spi controler in menuconfig.
+  *	2. set one device as slave: select anyka spi slave controler in menuconfig
+  *	3. run make command in Documentation/spi/ directory
+  *	4. copy Documentation/spi/spi_master_test and Documentation/spi/spi_slave_test to Your_rootfs_dir
+  *	5. firstly run spi_slave_test in slave and then run spi_master_test in master
+  */
+
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/device.h>
+#include <linux/ioport.h>
+#include <linux/errno.h>
+#include <linux/interrupt.h>
+#include <linux/platform_device.h>
+#include <linux/cdev.h>
+#include <linux/workqueue.h>
+#include <linux/delay.h>
+#include <linux/clk.h>
+#include <linux/gpio.h>
+#include <linux/fs.h>
+#include <linux/types.h>
+#include <linux/fcntl.h>
+#include <linux/poll.h>
+#include <asm/io.h>
+#include <asm/irq.h>
+#include <mach/gpio.h>
+#include <mach/regs-comm.h>
+#include <linux/slab.h>
+#include <linux/sched.h>
+
+#include <plat-anyka/spi-anyka-slave.h>
+#include <plat/spi.h>
+#include <linux/spi/spidev.h>
+#include <asm/uaccess.h>
+#include <mach/clock.h>
+
+/**
+*  @brief       	slave data: devices, lock, wait_queue, io resource...
+*  @author     gao wangsheng
+*  @date        2012-10-16
+*  @param[out]  void
+*  @param[in]   void
+*  @param[in]   void
+*  @return      void
+*/
+struct spi_anyka_slave {
+	/* Driver model hookup */
+	struct platform_device *pdev;
+	struct ak_spi_info *pdata;
+	struct cdev cdev;
+	struct fasync_struct *async_queue; /* asynchronous readers */
+
+	struct clk		*clk;
+
+	/* Lock */
+	struct mutex	slave_lock;
+	spinlock_t regs_lock;
+
+	/* wait queue */
+	wait_queue_head_t readq;
+	wait_queue_head_t writeq;
+
+	/* read and write buffer */
+	char *rdbuf, *rdend;
+	char *recvp, *readp;
+	int rdsize;
+	char *wrbuf, *wrend;
+	char *sentp, *writep;
+	int wrsize;
+	
+	/* Spi controler register addresses */
+	void *ioarea;
+	void *regs;
+	int irq;
+
+	/* flag */
+	u8 mode;
+	u8 bits_per_word;
+	u32 max_speed_hz;
+	int openers;
+};
+
+static struct class *slave_class;
+static int slave_major;
+static int slave_minor = 0;
+#define SLAVE_MAX_MINOR	(8)
+#define DFT_DIV				(255)
+#define DFT_CON 			AK_SPICON_EN
+#define BUF_LEN				(512)
+#define DCNT				(0xffff)
+#define SET_CLK				(1 << 0)
+#define SET_MODE			(1 << 1)
+#define SPI_MODE_MASK (SPI_CPOL | SPI_CPHA )
+#define SLAVE_MASK	(AK_SPISTA_RXHFULL|AK_SPIINT_TIMEOUT |AK_SPIINT_RXFULL)
+
+#define sdbug(fmt...)	//printk(fmt)
+
+static int akspi_slave_fasync(int fd, struct file *filp, int mode);
+
+
+/**
+*  @Copyright (C) 	Anyka 2012
+*  @brief       		How much space is free?
+*  @author   		Gao wangsheng
+*  @email		gao_wangsheng@anyka.oa
+*  @date        	2012-10-23
+*  @param[out]  	void
+*  @param[in]   	*slave
+*  @return      	free space in buffer
+*/
+static int akspi_slave_space_free(struct spi_anyka_slave *slave)
+{
+	if (slave->readp == slave->recvp){
+		return slave->rdsize - 1;
+	}
+	return ((slave->readp + slave->rdsize - slave->recvp) % slave->rdsize) - 1;
+}
+
+/**
+*  @Copyright (C) 	Anyka 2012
+*  @brief       		store data into buffer
+*  @author   		Gao wangsheng
+*  @email		gao_wangsheng@anyka.oa
+*  @date        	2012-10-23
+*  @param[out]  	slave->recvp
+*  @param[in]   	*slave
+*  @param[in]   	*buf
+*  @param[in]   	count
+*  @return      	How much data has been stored
+*/
+static int akspi_slave_reveive_data(struct spi_anyka_slave *slave,
+			char *buf, size_t count)
+{
+//	sdbug("%s\n", __func__);
+	
+	/* ok, space is there, accept something */
+	count = min(count, (size_t)akspi_slave_space_free(slave));
+	if (slave->recvp >= slave->readp){
+		/* to end-of-buf */	
+		count = min(count, (size_t)(slave->rdend - slave->recvp)); 
+	}
+	else {
+		/* the write pointer has wrapped, fill up to rp-1 */
+		count = min(count, (size_t)(slave->readp - slave->recvp - 1));
+	}
+
+	memcpy(slave->recvp, buf, count);
+	slave->recvp += count;
+	if (slave->recvp == slave->rdend){
+		slave->recvp = slave->rdbuf; /* wrapped */
+	}
+
+	return count;
+}
+
+/**
+*  @Copyright (C) 	Anyka 2012
+*  @brief       		Enable or disable irq
+*  @author   		Gao wangsheng
+*  @email		gao_wangsheng@anyka.oa
+*  @date        	2012-10-23
+*  @param[out]  	void
+*  @param[in]   	*slave
+*  @param[in]   	is enable?
+*  @return      	void
+*/
+static void akspi_slave_set_irq(struct spi_anyka_slave *slave, int enable)
+{
+	u32 spiint = SLAVE_MASK; 
+	if (enable)
+		iowrite32(spiint, slave->regs + AK_SPIINT);
+	else
+		iowrite32(0, slave->regs + AK_SPIINT);
+}
+
+/**
+*  @Copyright (C) 	Anyka 2012
+*  @brief       		receive data int interupt
+*  @author   		Gao wangsheng
+*  @email		gao_wangsheng@anyka.oa
+*  @date        	2012-10-23
+*  @param[out]  	void
+*  @param[in]   	*slave
+*  @param[in]   	irq
+*  @return      	irqreturn_t
+*/
+static irqreturn_t akspi_slave_int(int irq, void *dev_id)
+{
+	struct spi_anyka_slave *slave = (struct spi_anyka_slave *)dev_id;
+	u32 status, val;
+	u16 count;
+	int i;
+	
+	spin_lock(&slave->regs_lock);
+	status = ioread32(slave->regs + AK_SPISTA);
+	sdbug("%s: status=0x%08x\n", __func__, status);
+
+	if (((status & AK_SPISTA_TIMEOUT) == AK_SPISTA_TIMEOUT)
+		&& ((status & AK_SPISTA_RXEMP) != AK_SPISTA_RXEMP))
+	{
+		char temp;
+		u16 cnt =0;
+	
+		count = ioread32(slave->regs + AK_SPICNT);
+		cnt = (DCNT - count)%4;
+		val = ioread32(slave->regs + AK_SPIIN);
+		sdbug("%s: AK_SPISTA_TIMEOUT, val=0x%08x, cnt=%u\n", __func__, val, cnt);
+		
+		for (i=0; i<cnt; i++)
+		{
+			temp = (val >> i*8) & 0xff;
+			akspi_slave_reveive_data(slave, &temp, 1);
+		}
+
+		iowrite32(DCNT, slave->regs + AK_SPICNT);
+	}
+	else if ((status & AK_SPISTA_RXFULL) == AK_SPISTA_RXFULL)
+	{
+		val = ioread32(slave->regs + AK_SPIIN);
+		sdbug("%s: AK_SPISTA_RXFULL, val=0x%08x\n", __func__, val);
+		akspi_slave_reveive_data(slave, (char *)&val, 4);
+		val = ioread32(slave->regs + AK_SPIIN);
+		sdbug("%s: AK_SPISTA_RXFULL, val=0x%08x\n", __func__, val);
+		akspi_slave_reveive_data(slave, (char *)&val, 4);
+	}
+	
+	else if ((status & AK_SPISTA_RXHFULL) == AK_SPISTA_RXHFULL)
+	{
+		val = ioread32(slave->regs + AK_SPIIN);
+		sdbug("%s: AK_SPISTA_RXHFULL, val=0x%08x\n", __func__, val);
+		akspi_slave_reveive_data(slave, (char *)&val, 4);
+	}
+	
+	wake_up_interruptible(&slave->readq);
+	if (slave->async_queue){
+		kill_fasync(&slave->async_queue, SIGIO, POLL_IN);
+	}
+	spin_unlock(&slave->regs_lock);
+	return IRQ_HANDLED;
+}
+
+/**
+*  @Copyright (C) 	Anyka 2012
+*  @brief       		prepare receive data from master
+*  @author   		Gao wangsheng
+*  @email		gao_wangsheng@anyka.oa
+*  @date        	2012-10-23
+*  @param[out]  	void
+*  @param[in]   	*slave
+*  @return      	void
+*/
+static  void akspi_slave_prepare_read(struct spi_anyka_slave *slave)
+{
+	u32 val;
+ 	unsigned long flags; 
+
+	spin_lock_irqsave(&slave->regs_lock, flags);
+	
+	val = ioread32(slave->regs + AK_SPICON);
+	val &= ~(AK_SPICON_ARRM);
+	val |= AK_SPICON_TGDM;
+	iowrite32(val, slave->regs + AK_SPICON);
+	iowrite32(DCNT, slave->regs + AK_SPICNT);
+	akspi_slave_set_irq(slave, 1);
+
+	spin_unlock_irqrestore(&slave->regs_lock, flags);
+}
+
+/**
+*  @Copyright (C) 	Anyka 2012
+*  @brief       		open slave device
+*  @author   		Gao wangsheng
+*  @email		gao_wangsheng@anyka.oa
+*  @date        	2012-10-23
+*  @param[out]  	void
+*  @param[in]   	*node
+*  @param[in]   	*filp
+*  @return      	fail or not
+*/
+static int akspi_slave_open(struct inode *node, struct file *filp)
+{
+	struct spi_anyka_slave *slave = container_of(node->i_cdev, struct spi_anyka_slave, cdev);
+
+	if (mutex_lock_interruptible(&slave->slave_lock)){
+		return -ERESTARTSYS;
+	}
+
+	nonseekable_open(node, filp);
+
+	if (!slave->rdbuf){
+		/* Alloc memory for receive data  */
+		slave->rdbuf = kzalloc(BUF_LEN, GFP_KERNEL);
+		if (!slave->rdbuf){
+			mutex_unlock(&slave->slave_lock);
+			printk("%s: %d\n", __func__, __LINE__);
+			return -ENOMEM;
+		}
+		akspi_slave_prepare_read(slave);
+	}
+
+	slave->rdsize = BUF_LEN;
+	slave->rdend = slave->rdbuf + slave->rdsize;
+	slave->readp = slave->recvp = slave->rdbuf; /* rd and wr from the beginning */
+	slave->openers++;
+	filp->private_data = slave;
+	mutex_unlock(&slave->slave_lock);
+	sdbug("%s: openers=%d\n", __func__, slave->openers);
+	return 0;
+}
+
+/**
+*  @Copyright (C) 	Anyka 2012
+*  @brief       		relese slave device
+*  @author   		Gao wangsheng
+*  @email		gao_wangsheng@anyka.oa
+*  @date        	2012-10-23
+*  @param[out]  	void
+*  @param[in]   	*node
+*  @param[in]   	*filp
+*  @return      	fail or not
+*/
+static int akspi_slave_release(struct inode *node, struct file *filp)
+{
+	struct spi_anyka_slave *slave = container_of(node->i_cdev, struct spi_anyka_slave, cdev);
+
+	akspi_slave_fasync(-1, filp, 0);
+	mutex_lock(&slave->slave_lock);
+
+	slave->openers--;
+	if (!slave->openers){
+		/* close spi controler */
+		akspi_slave_set_irq(slave, 0);
+		kfree(slave->rdbuf);
+		slave->rdbuf = NULL;
+	}
+
+	filp->private_data = NULL;
+	mutex_unlock(&slave->slave_lock);
+	sdbug("%s: openers=%d\n", __func__, slave->openers);
+	return 0;
+}
+
+/**
+*  @Copyright (C) 	Anyka 2012
+*  @brief       		setup slave controler
+*  @author   		Gao wangsheng
+*  @email		gao_wangsheng@anyka.oa
+*  @date        	2012-10-23
+*  @param[out]  	void
+*  @param[in]   	*slave
+*  @param[in]   	*void
+*  @return      	fail or not
+*/
+static int akspi_slave_setmode(struct spi_anyka_slave *slave)
+{
+	u16 spicon;
+
+	sdbug("%s: set mode-------------.\n", __func__);
+	spin_lock(&slave->regs_lock);
+	spicon = ioread32(slave->regs + AK_SPICON);
+	
+	if (slave->mode & SPI_CPHA)
+		spicon |= AK_SPICON_CPHA;
+	else
+		spicon &= ~AK_SPICON_CPHA;
+	if (slave->mode & SPI_CPOL)
+		spicon |= AK_SPICON_CPOL;
+	else
+		spicon &= ~AK_SPICON_CPOL;
+		
+	iowrite32(spicon, slave->regs + AK_SPICON);
+	spin_unlock(&slave->regs_lock);
+	return 0;		
+}
+
+/**
+*  @Copyright (C) 	Anyka 2012
+*  @brief       		setup slave controler
+*  @author   		Gao wangsheng
+*  @email		gao_wangsheng@anyka.oa
+*  @date        	2012-10-23
+*  @param[out]  	void
+*  @param[in]   	*slave
+*  @param[in]   	*void
+*  @return      	fail or not
+*/
+static int akspi_slave_setclk(struct spi_anyka_slave *slave)
+{
+	unsigned int div;
+	unsigned int hz = slave->max_speed_hz;
+	unsigned long clk = ak_get_asic_clk();
+	u16 spicon;
+	
+	sdbug("%s: set clk-------------.\n", __func__);
+	spin_lock(&slave->regs_lock);
+	spicon = ioread32(slave->regs + AK_SPICON);
+	
+	div = clk / (hz*2) - 1;
+	if (div > 255){
+		div = 255;
+	}
+	else if (div < 3){
+		div = 3;
+	}
+
+	spicon &=~(0xff << 8);
+	spicon |= div << 8;
+	iowrite32(spicon, slave->regs + AK_SPICON);
+	spin_unlock(&slave->regs_lock);
+	return 0;
+}
+
+
+/**
+*  @Copyright (C) 	Anyka 2012
+*  @brief       		ioctl slave device
+*  @author   		Gao wangsheng
+*  @email		gao_wangsheng@anyka.oa
+*  @date        	2012-10-23
+*  @param[out]  	void
+*  @param[in]   	*node
+*  @param[in]   	*filp, cmd, arg
+*  @return      	fail or not
+*/
+static long akspi_slave_ioctl(struct file *filp,	unsigned int cmd, unsigned long arg)
+{
+	int retval = 0;
+	int err = 0;
+	u32	tmp;
+	struct spi_anyka_slave *slave;
+
+	sdbug("%s: cmd=%u\n", __func__, cmd);
+	
+	/* Check type and command number */
+	if (_IOC_TYPE(cmd) != SPI_IOC_MAGIC)
+		return -ENOTTY;
+
+	/* Check access direction once here; don't repeat below.
+	 * IOC_DIR is from the user perspective, while access_ok is
+	 * from the kernel perspective; so they look reversed.
+	 */
+	if (_IOC_DIR(cmd) & _IOC_READ){
+		err = !access_ok(VERIFY_WRITE, (void __user *)arg, _IOC_SIZE(cmd));
+	}
+	
+	if (err == 0 && _IOC_DIR(cmd) & _IOC_WRITE){
+		err = !access_ok(VERIFY_READ,	(void __user *)arg, _IOC_SIZE(cmd));
+	}
+	
+	if (err){
+		return -EFAULT;
+	}
+
+	slave = filp->private_data;
+	if (!slave){
+		return -ESHUTDOWN;
+	}
+
+	mutex_lock(&slave->slave_lock);
+
+	switch (cmd){
+	 /* read requests */
+	 case SPI_IOC_RD_MODE:
+		 retval = __put_user(slave->mode & SPI_MODE_MASK, (__u8 __user *)arg);
+		 break;
+	 case SPI_IOC_RD_LSB_FIRST:
+		 retval = __put_user((slave->mode & SPI_LSB_FIRST) ?	1 : 0, (__u8 __user *)arg);
+		 break;
+	 case SPI_IOC_RD_BITS_PER_WORD:
+		 retval = __put_user(slave->bits_per_word, (__u8 __user *)arg);
+		 break;
+	 case SPI_IOC_RD_MAX_SPEED_HZ:
+		 retval = __put_user(slave->max_speed_hz, (__u32 __user *)arg);
+		 break;
+ 
+	 /* write requests */
+	 case SPI_IOC_WR_MODE:
+		 retval = __get_user(tmp, (u8 __user *)arg);
+		 if (retval == 0) {
+			 u8  save = slave->mode;
+ 
+			 if (tmp & ~SPI_MODE_MASK) {
+				 retval = -EINVAL;
+				 break;
+			 }
+ 
+			 tmp |= slave->mode & ~SPI_MODE_MASK;
+			 slave->mode = (u8)tmp;
+			 retval = akspi_slave_setmode(slave);
+			 if (retval < 0)
+				 slave->mode = save;
+			 else
+				 dev_dbg(&slave->pdev->dev, "spi mode %02x\n", tmp);
+		 }
+		 break;
+	 case SPI_IOC_WR_LSB_FIRST:
+		 retval = -EINVAL;
+		 break;
+	 case SPI_IOC_WR_BITS_PER_WORD:
+		 retval = -EINVAL;
+		 break;
+	 case SPI_IOC_WR_MAX_SPEED_HZ:
+		 retval = __get_user(tmp, (__u32 __user *)arg);
+		 if (retval == 0) {
+			 u32 save = slave->max_speed_hz;
+ 
+			 slave->max_speed_hz = tmp;
+			 retval = akspi_slave_setclk(slave);
+			 if (retval < 0)
+				 slave->max_speed_hz = save;
+			 else
+				 dev_dbg(&slave->pdev->dev, "%d Hz (max)\n", tmp);
+		 }
+		 break;
+ 
+	 default:
+		 retval = -EINVAL;
+		 break;
+	 }
+	 
+	 mutex_unlock(&slave->slave_lock);
+	 return retval;
+ }
+
+/**
+*  @Copyright (C) 	Anyka 2012
+*  @brief       		read slave device
+*  @author   		Gao wangsheng
+*  @email		gao_wangsheng@anyka.oa
+*  @date        	2012-10-23
+*  @param[out]  	void
+*  @param[in]   	*buf
+*  @param[in]   	*filp
+*  @return      	read data count
+*/
+static ssize_t akspi_slave_read(struct file *filp, char __user *buf, size_t count, loff_t *f_pos)
+{
+	struct spi_anyka_slave *slave = filp->private_data;
+
+	if (mutex_lock_interruptible(&slave->slave_lock)){
+		return -ERESTARTSYS;
+	}
+
+	sdbug("%s: %d\n", __func__, __LINE__);
+	while (slave->recvp == slave->readp){
+		mutex_unlock(&slave->slave_lock);
+		if (filp->f_flags & O_NONBLOCK){
+			return -EAGAIN;
+		}
+		if (wait_event_interruptible(slave->readq, (slave->recvp != slave->readp))){
+			return -ERESTARTSYS;
+		}
+		if (mutex_lock_interruptible(&slave->slave_lock)){
+			return -ERESTARTSYS;
+		}
+		sdbug("%s: %d\n", __func__, __LINE__);
+	}
+	sdbug("%s: %d\n", __func__, __LINE__);
+
+	if (slave->recvp > slave->readp)	{
+		/* return the data */
+		count = min(count, (size_t)(slave->recvp - slave->readp));
+	}
+	else	{
+		/* the write pointer has wrapped, return data up to end */	
+		count = min (count, (size_t)(slave->rdend - slave->readp));
+	}
+	
+	if (copy_to_user(buf, slave->readp, count)) {
+		mutex_unlock(&slave->slave_lock);
+		return -EFAULT;
+	}
+
+	slave->readp += count;
+	if (slave->readp == slave->rdend){
+		slave->readp = slave->rdbuf;
+	}
+	
+	mutex_unlock(&slave->slave_lock);
+	sdbug("%s: %d\n", __func__, __LINE__);
+	return count;
+}
+
+/**
+*  @Copyright (C) 	Anyka 2012
+*  @brief       		write slave device
+*  @author   		Gao wangsheng
+*  @email		gao_wangsheng@anyka.oa
+*  @date        	2012-10-23
+*  @param[out]  	void
+*  @param[in]   	*buf
+*  @param[in]   	*filp, count, pos
+*  @return      	write data count
+*/
+static ssize_t akspi_slave_write(struct file *filp, const char __user *buf, size_t count, loff_t *f_pos)
+{
+	struct spi_anyka_slave *slave = filp->private_data;
+
+	sdbug("%s: %d\n", __func__, __LINE__);
+
+	return count;
+
+	if (mutex_lock_interruptible(&slave->slave_lock)){
+		return -ERESTARTSYS;
+	}
+
+	while (slave->sentp != slave->writep){
+		mutex_unlock(&slave->slave_lock);
+		if (filp->f_flags & O_NONBLOCK){
+			return -EAGAIN;
+		}
+		if (wait_event_interruptible(slave->writeq, slave->sentp != slave->writep)){
+			return -ERESTARTSYS;
+		}
+		if (mutex_lock_interruptible(&slave->slave_lock)){
+			return -ERESTARTSYS;
+		}
+	}
+
+	/* spi slave has something to write */
+
+	mutex_unlock(&slave->slave_lock);
+	sdbug("%s: %d\n", __func__, __LINE__);
+	return count;
+}
+
+/**
+*  @Copyright (C) 	Anyka 2012
+*  @brief       		poll slave device
+*  @author   		Gao wangsheng
+*  @email		gao_wangsheng@anyka.oa
+*  @date        	2012-10-23
+*  @param[out]  	void
+*  @param[in]   	*table
+*  @param[in]   	*filp
+*  @return      	fail or not
+*/
+unsigned int akspi_slave_poll (struct file *filp, struct poll_table_struct *table)
+{
+	struct spi_anyka_slave *slave = filp->private_data;
+	int mask = 0;
+
+	sdbug("%s: %d\n", __func__, __LINE__);
+	mutex_lock(&slave->slave_lock);
+	poll_wait(filp, &slave->readq, table);
+	poll_wait(filp, &slave->writeq, table);
+
+	if (slave->recvp != slave->readp){
+		mask |= POLLIN | POLLRDNORM;	/* readable */
+	}
+
+	if (slave->sentp != slave->writep){
+		mask |= POLLOUT | POLLWRNORM;	/* writable */
+	}
+	mutex_unlock(&slave->slave_lock);
+	sdbug("%s: %d\n", __func__, __LINE__);
+	return mask;
+}
+
+/**
+*  @Copyright (C) 	Anyka 2012
+*  @brief       		fasync slave device
+*  @author   		Gao wangsheng
+*  @email		gao_wangsheng@anyka.oa
+*  @date        	2012-10-23
+*  @param[out]  	void
+*  @param[in]   	*node
+*  @param[in]   	*filp, fd, mode
+*  @return      	fail or not
+*/
+static int akspi_slave_fasync(int fd, struct file *filp, int mode)
+{
+	struct spi_anyka_slave *slave = filp->private_data;
+
+	return fasync_helper(fd, filp, mode, &slave->async_queue);
+}
+
+/**
+*  @Copyright (C) 	Anyka 2012
+*  @brief       		initialize slave device
+*  @author   		Gao wangsheng
+*  @email		gao_wangsheng@anyka.oa
+*  @date        	2012-10-23
+*  @param[out]  	void
+*  @param[in]   	*slave
+*  @param[in]   	void
+*  @return      	void
+*/
+static void akspi_slave_initial_setup(struct spi_anyka_slave *slave)
+{
+	u32 value = 0;
+
+	sdbug("%s: %d\n", __func__, __LINE__);
+	clk_enable(slave->clk);
+
+	spin_lock(&slave->regs_lock);
+	value =  DFT_CON ;
+	iowrite32(value, slave->regs + AK_SPICON);
+	spin_unlock(&slave->regs_lock);
+	akspi_slave_setclk(slave);
+	akspi_slave_setmode(slave);
+	sdbug("value=%08x, reg=%08x\n",value, ioread32(slave->regs + AK_SPICON));
+	akspi_slave_set_irq(slave, 0);
+	
+	if (slave->pdata) {
+		if (slave->pdata->gpio_setup){
+			slave->pdata->gpio_setup(slave->pdata, 1);
+		}
+	}
+}
+
+static const struct file_operations slave_ops = {
+	.owner	= THIS_MODULE,
+	.open	= akspi_slave_open,
+	.release 	= akspi_slave_release,
+	.unlocked_ioctl = akspi_slave_ioctl,
+	.read	= akspi_slave_read,
+	.write	= akspi_slave_write,
+	.poll		= akspi_slave_poll,
+	.fasync	= akspi_slave_fasync,
+};
+
+/**
+*  @Copyright (C) 	Anyka 2012
+*  @brief       		probe slave device
+*  @author   		Gao wangsheng
+*  @email		gao_wangsheng@anyka.oa
+*  @date        	2012-10-23
+*  @param[out]  	slave
+*  @param[in]   	*pdev
+*  @param[in]   	*pdata
+*  @return      	fail or not
+*/
+static int ak_spi_slave_probe(struct platform_device *pdev)
+{
+	struct ak_spi_info *pdata;
+	struct spi_anyka_slave *slave = NULL;
+	struct resource *res;
+	int err = 0;
+
+	pdata = pdev->dev.platform_data;
+	if (pdata == NULL) 
+	{
+		dev_err(&pdev->dev, "No platform data supplied\n");
+		err = -ENOENT;
+		goto err_no_pdata;
+	}
+
+	/* Allocate Slave with space for drv_data and null dma buffer */
+	slave = kzalloc(sizeof(struct spi_anyka_slave), GFP_KERNEL);
+	if (!slave) {
+		dev_err(&pdev->dev, "cannot alloc mem\n");
+		err = -ENOMEM;
+		goto err_nomem;
+	}
+
+	slave->pdata = pdata;
+	slave->pdev 	= pdev;
+	cdev_init(&slave->cdev, &slave_ops);
+	slave->cdev.owner = THIS_MODULE;
+	
+	spin_lock_init(&slave->regs_lock);
+	mutex_init(&slave->slave_lock);
+	init_waitqueue_head(&slave->readq);
+	init_waitqueue_head(&slave->writeq);
+	slave->mode = SPI_MODE_0;
+	slave->bits_per_word = 8;
+	slave->max_speed_hz = 2147483647;
+
+	/* get basic io resource and map it */
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (res == NULL) {
+		dev_err(&pdev->dev, "Cannot get IORESOURCE_MEM\n");
+		err = -ENOENT;
+		goto err_no_iores;
+	}
+
+	slave->ioarea = request_mem_region(res->start, resource_size(res), pdev->name);
+	if (slave->ioarea == NULL) {
+		dev_err(&pdev->dev, "Cannot reserve region\n");
+		err = -ENXIO;
+		goto err_no_iores;
+	}
+
+	slave->regs = ioremap(res->start, resource_size(res));
+	if (!slave->regs) {
+		err = -ENOMEM;
+		goto err_no_iomap;
+	}
+	printk(KERN_INFO "SPI-Slave:map regs = %08x\n", (int)slave->regs);
+
+	/* Attach to IRQ */
+	slave->irq = platform_get_irq(pdev, 0);
+	if (slave->irq < 0) {
+		dev_err(&pdev->dev, "No IRQ specified\n");
+		err = -ENOENT;
+		goto err_no_irq;
+	}
+	printk(KERN_INFO "SPI-Slave:get irq = %04x\n", (int)slave->irq);
+	
+	err = request_irq(slave->irq, akspi_slave_int, IRQF_DISABLED, pdev->name, slave);
+	if (err < 0) {
+		dev_err(&pdev->dev, "can not get IRQ\n");
+		goto err_no_irq;
+	}
+	printk(KERN_INFO "SPI-Slave: request IRQ: %04x\n", slave->irq);
+
+	err = cdev_add(&slave->cdev, MKDEV(slave_major, slave_minor), 1);
+	if (err){
+		dev_err(&pdev->dev, "cannot add cdev\n");
+		err = -ENOMEM;
+		goto err_register;
+	}
+	printk(KERN_INFO "SPI-Slave: register with char device framework\n");
+
+	if (IS_ERR(device_create(slave_class, &pdev->dev,
+				MKDEV(slave_major, slave_minor),
+				slave, "spi_slave.%u", slave_minor))){
+		dev_err(&pdev->dev, "cannot device_create\n");
+	}
+
+	slave->clk = clk_get(&pdev->dev, pdata->clk_name);
+	sdbug("%s: %lu \n", slave->clk->name, clk_get_rate(slave->clk));
+	if (IS_ERR(slave->clk)) {
+		dev_err(&pdev->dev, "No clock for device\n");
+		err = PTR_ERR(slave->clk);
+		goto err_no_clk;
+	}
+	
+	akspi_slave_initial_setup(slave);
+	
+	platform_set_drvdata(pdev, slave);
+	printk("Ak spi slave initialized!\n");
+	return 0;
+
+ err_no_clk:
+	device_destroy(slave_class, MKDEV(slave_major, slave_minor));
+	cdev_del(&slave->cdev);
+ err_register:
+	free_irq(slave->irq, slave);
+ err_no_irq:
+	iounmap(slave->regs);
+ err_no_iomap:
+	release_resource(slave->ioarea);
+	kfree(slave->ioarea);
+ err_no_iores:
+ err_no_pdata: 
+ err_nomem:
+	return err;
+}
+
+/**
+*  @Copyright (C) 	Anyka 2012
+*  @brief       		remove slave device
+*  @author   		Gao wangsheng
+*  @email		gao_wangsheng@anyka.oa
+*  @date        	2012-10-23
+*  @param[out]  	void
+*  @param[in]   	*pdev
+*  @param[in]   	*slave
+*  @return      	void
+*/
+static void __devexit ak_spi_slave_remove(struct platform_device *pdev)
+{
+	struct spi_anyka_slave *slave = platform_get_drvdata(pdev);
+	int minor = MINOR(slave->cdev.dev);
+
+	if (!slave)
+		return;
+
+	platform_set_drvdata(pdev, NULL);
+	device_destroy(slave_class, MKDEV(slave_major, minor));
+	cdev_del(&slave->cdev);
+
+	/* Release IRQ */
+	free_irq(slave->irq, slave);
+	iounmap(slave->regs);
+	release_resource(slave->ioarea);
+	kfree(slave->ioarea);
+	kfree(slave);
+
+	return;
+}
+
+/**
+*  @Copyright (C) 	Anyka 2012
+*  @brief       		suspend and resume slave device
+*  @author   		Gao wangsheng
+*  @email		gao_wangsheng@anyka.oa
+*  @date        	2012-10-23
+*  @param[out]  	void
+*  @param[in]   	*dev
+*  @param[in]   	state
+*  @return      	fail or not
+*/
+#ifdef CONFIG_PM
+static int ak_spi_slave_suspend(struct device *dev, pm_message_t state)
+{
+	struct spi_anyka_slave *slave = dev_get_drvdata(dev);
+	
+	printk(KERN_ERR "%s: suspend\n", slave->pdev->name);
+	return 0;
+}
+
+static int ak_spi_slave_resume(struct device *dev)
+{
+	struct spi_anyka_slave *slave = dev_get_drvdata(dev);
+
+	printk(KERN_ERR "%s: resume\n",  slave->pdev->name);
+	return 0;
+}
+#else
+#define ak_spi_slave_suspend NULL
+#define ak_spi_slave_resume NULL
+#endif /* CONFIG_PM */
+
+static struct platform_driver akspi_slave_driver = {
+	.driver = {
+		.name	= "akspi-spi",
+		.owner	= THIS_MODULE,
+		.suspend = ak_spi_slave_suspend,
+		.resume 	= ak_spi_slave_resume,
+	},
+	.remove		= __exit_p(ak_spi_slave_remove),
+	.probe		= ak_spi_slave_probe,
+};
+
+static ssize_t slave_show_version(struct class *cls, struct class_attribute *attr, char *buf)
+{
+	return sprintf(buf, "spi-1.0.01\n");
+}
+static CLASS_ATTR(version, 0444, slave_show_version, NULL);
+
+/**
+*  @Copyright (C) 	Anyka 2012
+*  @brief       		init slave device
+*  @author   		Gao wangsheng
+*  @email		gao_wangsheng@anyka.oa
+*  @date        	2012-10-23
+*  @param[out]  	void
+*  @param[in]   	void
+*  @param[in]   	void
+*  @return      	fail or not
+*/
+static int __init ak_spi_slave_init(void)
+{
+	int ret;
+	dev_t dev;
+
+	slave_class = class_create(THIS_MODULE, "spi_slave");
+	if (IS_ERR(slave_class)){
+		ret = PTR_ERR(slave_class);
+		printk("%s:class create fail!\n", __func__);
+		goto err;
+	}
+
+	ret = class_create_file(slave_class, &class_attr_version);
+	if (ret){
+		printk("%s:class create file fail!\n", __func__);
+		goto err_class;
+	}
+
+	ret = alloc_chrdev_region(&dev, 0, SLAVE_MAX_MINOR, "spi_slave");
+	if (ret){
+		printk("%s:alloc chrdev fail!\n", __func__);
+		goto err_chrdev;
+	}
+	slave_major = MAJOR(dev);
+
+	ret = platform_driver_register(&akspi_slave_driver);
+	if (ret){
+		printk("%s:platform_driver_register fail!\n", __func__);
+		goto err_plat;
+	}
+
+	return 0;
+	
+err_plat:
+	unregister_chrdev_region(dev, SLAVE_MAX_MINOR);
+err_chrdev:
+	class_remove_file(slave_class, &class_attr_version);
+err_class:
+	class_destroy(slave_class);
+err:
+	return ret;
+}
+
+/**
+*  @Copyright (C) 	Anyka 2012
+*  @brief       		exit slave device
+*  @author   		Gao wangsheng
+*  @email		gao_wangsheng@anyka.oa
+*  @date        	2012-10-23
+*  @param[out]  	void
+*  @param[in]   	void
+*  @param[in]   	void
+*  @return      	void
+*/
+static void __exit ak_spi_slave_exit(void)
+{
+	platform_driver_unregister(&akspi_slave_driver);
+	unregister_chrdev_region(MKDEV(slave_major, 0), SLAVE_MAX_MINOR);
+	class_remove_file(slave_class, &class_attr_version);
+	class_destroy(slave_class);
+}
+
+MODULE_AUTHOR("Wangsheng Gao");
+MODULE_DESCRIPTION("Anyka SPI Slave Contoller");
+MODULE_LICENSE("GPL");
+MODULE_ALIAS("platform:AK-spi-slave");
+module_init(ak_spi_slave_init);
+module_exit(ak_spi_slave_exit);
diff --git a/drivers/spi/spi-anyka.c b/drivers/spi/spi-anyka.c
new file mode 100755
index 0000000..9699335
--- /dev/null
+++ b/drivers/spi/spi-anyka.c
@@ -0,0 +1,1746 @@
+/**
+*  /driver/spi/spi_anyka.c
+
+*  Copyright (C) 2018 Anyka(Guangzhou) Microelectronics Technology Co., Ltd.
+*  Author: Zhipeng Zhang <zhang_zhipeng@anyka.com>
+*
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License version 2 as
+* published by the Free Software Foundation.
+*/
+
+#include <linux/init.h>
+#include <linux/spinlock.h>
+#include <linux/workqueue.h>
+#include <linux/interrupt.h>
+#include <linux/delay.h>
+#include <linux/errno.h>
+#include <linux/err.h>
+#include <linux/clk.h>
+#include <linux/platform_device.h>
+#include <linux/of.h>
+#include <linux/of_device.h>
+#include <linux/of_platform.h>
+#include <linux/module.h>
+#include <linux/io.h>
+#include <asm-generic/gpio.h>
+#include <linux/gpio.h>
+#include <linux/of_gpio.h>
+#include <linux/spi/spi.h>
+
+#include <mach/anyka_types.h>
+#include <mach/ak_l2.h>
+#include <linux/dma-mapping.h>
+
+#include "ak39_spi.h"
+
+#define DRIVER_VERSION "0.1.0"
+
+/*usually use for spi keyboard or spi mouse.*/
+//#define SPI_CPU_MODE_USE_INTERRUPT
+
+#define MHz	(1000*1000)
+
+/**
+ * ak_spi_devstate - per device data
+ * @hz: Last frequency calculated for @sppre field.
+ * @mode: Last mode setting for the @spcon field.
+ * @spcon: Value to write to the SPCON register.
+ * @sppre: Value to write to the SPIINT register.
+ */
+struct ak_spi_devstate {
+	unsigned int	hz;
+	u16		mode;
+	u32		spcon;
+	u8		spint;
+	u8  	initialed;
+};
+
+struct ak_spi {
+	struct completion	 done;
+	struct spi_master	*master;
+	struct spi_device	*curdev;
+	struct device		*dev;
+
+	void __iomem		*regs;
+	struct clk			*clk;
+    struct clk			*bus_clk;
+	struct resource		*ioarea;
+	int			 		irq;
+	int			 		len; 	/*need transfer len*/
+	int			 		count;	/*have transferred len*/
+	
+	u8 					l2buf_tid;
+	u8 					l2buf_rid;
+
+	/* data buffers */
+	unsigned char		*tx;
+	unsigned char		*rx;
+	int 				xfer_dir;
+	int 				xfer_mode; /*use for dma or cpu*/
+};
+
+enum spi_xfer_dir {
+	SPI_DIR_TX,
+	SPI_DIR_RX,
+	SPI_DIR_TXRX, 
+	SPI_DIR_XFER_NUM,
+};
+#define TRANS_TIMEOUT 			(10000)
+#define MAX_XFER_LEN 			(8*1024)
+#define SPI_TRANS_TIMEOUT 		(5000)
+
+#define DFT_CON 			(AK_SPICON_EN | AK_SPICON_MS)
+#define DFT_DIV				(1) //5 /*127*/
+#define DFT_BIT_PER_WORD 	(8)
+#define FORCE_CS   			(1 << 5)
+#define SPPIN_DEFAULT 		(0)
+
+#define	CS_ACTIVE	1	/* normally nCS, active low */
+#define	CS_INACTIVE	0
+
+#if 1
+/**
+*  @brief       print the value of registers related spi bus.
+*  @author      zhou wenyong
+*  @date        2011-08-19
+*  @param[in]   *hw
+*  @return      void
+*/
+static void dbg_dumpregs(struct ak_spi *hw)
+{
+	pr_debug("\n");
+	pr_debug("CON: \t0x%x\n", ioread32(hw->regs + AK_SPICON));
+	pr_debug("STA: \t0x%x\n", ioread32(hw->regs + AK_SPISTA));
+	pr_debug("INT: \t0x%x\n", ioread32(hw->regs + AK_SPIINT));
+	pr_debug("CNT: \t0x%x\n", ioread32(hw->regs + AK_SPICNT));
+	pr_debug("DOUT: \t0x%x\n", ioread32(hw->regs + AK_SPIOUT));
+	pr_debug("DIN: \t0x%x\n", ioread32(hw->regs + AK_SPIIN));
+}
+
+static inline void dbg_dumpdata(struct ak_spi *hw,
+		void *data, int size)
+{
+	int ii;
+	int dsize = (size +3)/4;
+	u32 *dptr = data;
+	
+	printk("xfer data (size:%d):", size);
+	
+	for(ii = 0; ii < dsize; ii++) {
+		if((ii%10) == 0)
+			printk("\n");
+		
+		printk("%08x ", *(dptr + ii));
+	}
+	printk("\n");
+}
+#endif
+
+
+#define AKSPI_DATA_WIRE(mode) 	\
+	(((mode & SPI_NBITS_QUAD) == SPI_NBITS_QUAD) ?  \
+	SPI_NBITS_QUAD:((mode & SPI_NBITS_DUAL) == SPI_NBITS_DUAL) ?  \
+	SPI_NBITS_DUAL : SPI_NBITS_SINGLE)
+
+
+#define SPI_L2_TXADDR(m)   \
+	((m->bus_num == AKSPI_BUS_NUM1) ? ADDR_SPI1_TX : ADDR_SPI2_TX)
+
+#define SPI_L2_RXADDR(m)   \
+	((m->bus_num == AKSPI_BUS_NUM1) ? ADDR_SPI1_RX : ADDR_SPI2_RX)
+
+
+static inline struct ak_spi *to_hw(struct spi_device *sdev)
+{
+	return spi_master_get_devdata(sdev->master);
+}
+
+/**
+*  @brief       hw_txbyte
+*  TODO: send one bytes
+*  @author      lixinhai
+*  @date        2013-03-19
+*  @param[in]   *hw
+*  @param[in]   count
+*  @return      unsigned int
+*/
+static inline unsigned int hw_txbyte(struct ak_spi *hw, int len)
+{
+	u32 val = 0;
+	int i = 0;
+	
+	while (i < len)
+	{
+		val |= (hw->tx[hw->count+i] << i*8);
+		i++;
+	}						
+	return val;
+}
+
+/**
+*  @brief       hw_txdword
+*  TODO: send double words
+*  @author      lixinhai
+*  @date        2013-03-19
+*  @param[in]   *hw
+*  @param[in]   count
+*  @return      unsigned int
+*/
+static unsigned int hw_txdword(struct ak_spi *hw)
+{
+	u32 val = 0;
+	int l = 0;
+	
+	l = (hw->len - hw->count) > 4 ? 4 : (hw->len - hw->count);
+
+	val = hw_txbyte(hw, l);
+					
+	hw->count += l;
+	pr_debug("[%08x] ", val);
+	return val;
+}
+
+/**
+*  @brief       hw_rxbyte
+*  TODO: recv one bytes
+*  @author      lixinhai
+*  @date        2013-03-19
+*  @param[in]   count
+*  @return      unsigned int
+*/
+static inline void hw_rxbyte(struct ak_spi *hw, unsigned int val, int len)
+{
+	int i = 0;
+	
+	while (i < len)
+	{
+		hw->rx[hw->count + i] = (val >> i*8) & 0xff;
+		i++;
+	}
+}
+
+/**
+*  @brief       hw_rxbyte
+*  TODO: double words
+*  @author      lixinhai
+*  @date        2013-03-19
+*  @param[in]   count
+*  @return      unsigned int
+*/
+static void hw_rxdword(struct ak_spi *hw, unsigned int val)
+{
+	int l = 0;
+	
+	l = (hw->len - hw->count) > 4 ? 4 : (hw->len - hw->count);
+	
+	hw_rxbyte(hw, val, l);
+	hw->count += l;	
+	pr_debug("[%08x] ", val);
+}
+
+static inline u32 hw_remain_datalen(struct ak_spi *hw)
+{
+	return (hw->len - hw->count);
+}
+
+static inline bool ak_spi_use_dma(struct ak_spi *hw)
+{
+	return (hw->xfer_mode == AKSPI_XFER_MODE_DMA);
+}
+
+static inline int wait_for_spi_cnt_to_zero(struct ak_spi *hw, u32 timeout)
+{
+	do {			 
+		if (readl(hw->regs + AK_SPICNT) == 0)
+			break;
+		udelay(1);
+	}while(timeout--);
+	
+	return (timeout > 0) ? 0 : -EBUSY;
+}
+
+static void ak_spi_set_cs(struct ak_spi *hw, int cs, int pol)
+{
+	BUG_ON(cs >= 1);
+	
+	//ak_gpio_setpin(plat->pin_cs[cs], pol);
+}
+
+
+
+/**
+*  @brief       ak_spi_chipsel
+*  @author      zhou wenyong
+*  @date        2011-08-19
+*  @param[out]  *spi
+*  @param[in]   value
+*  @return      void
+*/
+static void ak_spi_chipsel(struct spi_device *spi, int value)
+{
+	struct ak_spi_devstate *cs = spi->controller_state;
+	struct ak_spi *hw = to_hw(spi);
+	unsigned int cspol = (spi->mode & SPI_CS_HIGH) ? 1 : 0;
+	
+	/* change the chipselect state and the state of the spi engine clock */	
+	switch (value) {
+		case CS_INACTIVE:
+			if(spi->chip_select == AKSPI_ONCHIP_CS) {
+				cs->spcon = ioread32(hw->regs + AK_SPICON);
+				cs->spcon &= ~FORCE_CS;
+				iowrite32(cs->spcon, hw->regs + AK_SPICON);
+			}
+			else
+				ak_spi_set_cs(hw, spi->chip_select, cspol^1);
+			
+			udelay(2);
+			break;
+		case CS_ACTIVE:
+			udelay(2);
+			
+			if(spi->chip_select == AKSPI_ONCHIP_CS) {
+				cs->spcon = ioread32(hw->regs + AK_SPICON);
+				cs->spcon |= FORCE_CS; //by Shaohua			
+				iowrite32(cs->spcon, hw->regs + AK_SPICON);
+			}
+			else
+				ak_spi_set_cs(hw, spi->chip_select, cspol);
+			break;
+		default:
+			break;
+	}
+}
+
+/**
+*  @brief       update the device's state
+*  @author      zhou wenyong
+*  @date        2011-08-19
+*  @param[in]   *spi
+*  @param[in]   *t
+*  @return      int
+*/
+static int ak_spi_update_state(struct spi_device *spi,
+				    struct spi_transfer *t)
+{
+	struct ak_spi_devstate *cs = spi->controller_state;
+	unsigned int bpw;
+	unsigned int hz, typical_hz;
+    unsigned int div = 0;	
+    unsigned long clk;
+	struct ak_spi *hw = to_hw(spi);
+
+	bpw = t ? t->bits_per_word : spi->bits_per_word;
+	typical_hz  = t ? t->speed_hz : spi->max_speed_hz;
+
+	if (!bpw)
+		bpw = DFT_BIT_PER_WORD;
+
+	if (bpw != DFT_BIT_PER_WORD) {
+		dev_err(&spi->dev, "invalid bits-per-word (%d)\n", bpw);
+		return -EINVAL;
+	}
+
+	/*spi mode change, config again*/
+	if (spi->mode != cs->mode) {
+		cs->spcon &= ~(AK_SPICON_CPHA|AK_SPICON_CPOL);
+		
+		if ((spi->mode & SPI_CPHA) == SPI_CPHA)
+			cs->spcon |= AK_SPICON_CPHA;
+
+		if ((spi->mode & SPI_CPOL) == SPI_CPOL)
+			cs->spcon |= AK_SPICON_CPOL;
+
+		cs->mode = spi->mode;
+	}
+
+    /*spi1 controller bus clock need this,but spi0 don't need. */
+	if ((cs->hz != typical_hz)&&(hw->master->bus_num == 1)) {
+
+		if (!typical_hz)
+			typical_hz = spi->max_speed_hz;
+
+        clk = 120000000;
+        div = clk / (typical_hz*2) - 1;
+
+        if (div > 255)
+              div = 255;
+
+
+        if (div < 0)
+              div = 0;
+
+        hz = clk /((div+1)*2);
+
+        /*when got clock greater than wanted clock, increase divider*/
+        if((hz - typical_hz) > 0)
+            div++;
+
+        cs->hz = hz;
+        cs->spcon &= ~AK_SPICON_CLKDIV;
+        cs->spcon |= div << 8;
+
+        pr_info("spi%d new hz is %u, div is %u(%s).\n", hw->master->bus_num, cs->hz, div, div ?"change":"not change");
+
+	}
+
+    return 0;
+}
+
+/**
+*  @brief       setup one transfer
+*  setup_transfer() changes clock and/or wordsize to match settings
+*  for this transfer; zeroes restore defaults from spi_device.
+*  @author      zhou wenyong
+*  @date        2011-08-19
+*  @param[in]   *spi
+*  @param[in]   *t
+*  @return      int
+*/
+static int ak_spi_setupxfer(struct spi_device *spi,
+				 struct spi_transfer *t)
+{
+	struct ak_spi_devstate *cs = spi->controller_state;
+	struct ak_spi *hw = to_hw(spi);
+	int ret=0;
+
+	/*spi device not change and has been initilize, return.*/
+	if(likely((cs->initialed == 1) && (spi == hw->curdev)))
+		return ret;
+
+	cs->spcon = readl(hw->regs + AK_SPICON);
+
+	ret = ak_spi_update_state(spi, t);
+	if (!ret)
+	{
+	    /*Add code to fix the issue that the SPICON register 
+	          was deranged. Shaohua @2012-3-23	           
+	     */
+		writel(cs->spcon, hw->regs + AK_SPICON);
+	    //printk("ak_spi_setupxfer,con:%08x.\n", cs->spcon);
+		cs->initialed = 1;
+		hw->curdev = spi;
+	}
+
+	return ret;
+}
+
+#define MODEBITS (SPI_CPOL | SPI_CPHA | SPI_CS_HIGH)
+
+/**
+*  setup and updates the device mode,state.
+*/
+static int ak_spi_setup(struct spi_device *spi)
+{
+	struct ak_spi_devstate *cs = spi->controller_state;
+	struct ak_spi *hw = to_hw(spi);
+	int ret;
+
+	//pr_info("ak_spi setup the master.\n");
+	
+	/* allocate settings on the first call */
+	if (!cs) {
+		cs = kzalloc(sizeof(struct ak_spi_devstate), GFP_KERNEL);
+		if (!cs) {
+			dev_err(&spi->dev, "no memory for controller state\n");
+			return -ENOMEM;
+		}
+
+		cs->spcon = DFT_CON;
+		cs->hz = -1;
+		spi->controller_state = cs;
+		cs->initialed = 0;
+	}
+
+	if (spi->mode & ~(hw->master->mode_bits)) {
+		dev_dbg(&spi->dev, "setup: unsupported mode bits %x\n",
+			spi->mode & ~(hw->master->mode_bits));
+		return -EINVAL;
+	}
+	/* initialise the state from the device,and spi bus clock. */
+	ret = ak_spi_update_state(spi, NULL);
+
+	if (!ret)
+	{
+		writel(cs->spcon, hw->regs + AK_SPICON);
+
+		cs->initialed = 1;
+		hw->curdev = spi;
+	}
+	return ret;
+}
+
+/**
+*  @brief       ak_spi_cleanup
+*  called on to free memory provided by spi_master 
+*  @author      zhou wenyong
+*  @date        2011-08-19
+*  @param[out]  *spi
+*  @return      void
+*/
+static void ak_spi_cleanup(struct spi_device *spi)
+{
+	kfree(spi->controller_state);
+}
+
+
+/**
+*  @brief       enable the irq mask.
+*  @author      lixinhai
+*  @date        2013-03-10
+*  @param[in]  *hw :akspi master dev.
+*  @param[in]   imask: interrupt bit mask.
+*  @return      new mask.
+*/
+static inline u32 enable_imask(struct ak_spi *hw, u32 imask)
+{
+	u32 newmask;
+
+	newmask = readl(hw->regs + AK_SPIINT);
+	newmask |= imask;
+
+	writel(newmask, hw->regs + AK_SPIINT);
+
+	return newmask;
+}
+
+
+/**
+*  @brief       disable the irq mask.
+*  @author      lixinhai
+*  @date        2013-03-10
+*  @param[in]  *hw :akspi master dev.
+*  @param[in]   imask: interrupt bit mask.
+*  @return      new mask.
+*/
+static inline u32 disable_imask(struct ak_spi *hw, u32 imask)
+{
+	u32 newmask;
+
+	newmask = readl(hw->regs + AK_SPIINT);
+	newmask &= ~imask;
+
+	writel(newmask, hw->regs + AK_SPIINT);
+
+	return newmask;
+}
+
+
+/**
+*  @brief       configure the master register when start transfer data.
+*  @author      lixinhai
+*  @date        2013-03-15
+*  @param[in]  *hw :akspi master dev.
+*  @param[in]   t: a read/write buffer pair.
+*  @return      void
+*/
+static void ak_spi_start_txrx(struct ak_spi *hw, struct spi_transfer *t)
+{
+    u32 reg_value;
+	//u32 reg_value_temp;
+	enum spi_xfer_dir dir = hw->xfer_dir;
+		
+	pr_debug("the spi transfer mode is %s.\n", (dir == SPI_DIR_TXRX) ? 
+				"txrx" : (dir == SPI_DIR_RX)? "rx":"tx");
+	
+    reg_value = readl(hw->regs + AK_SPICON);
+
+	switch(dir) {
+		case SPI_DIR_TX:
+		    reg_value &= ~AK_SPICON_TGDM;
+   			reg_value |= AK_SPICON_ARRM;
+			break;
+		case SPI_DIR_RX:
+		    reg_value |= AK_SPICON_TGDM;
+    		reg_value &= ~AK_SPICON_ARRM;
+			break;
+		case SPI_DIR_TXRX:
+			reg_value &= ~AK_SPICON_TGDM;
+			reg_value &= ~AK_SPICON_ARRM;
+			break;
+		default:
+			break;
+	}
+
+	/*configure the data wire*/
+	reg_value &= ~AK_SPICON_WIRE;
+	//reg_value |= AKSPI_DATA_WIRE(t->xfer_mode);
+#if 1
+	if(t->tx_nbits == SPI_NBITS_QUAD || t->rx_nbits == SPI_NBITS_QUAD)
+	{
+		reg_value |= 0x2<<16;
+	}
+	else if(t->tx_nbits == SPI_NBITS_DUAL || t->rx_nbits == SPI_NBITS_DUAL)
+	{
+		reg_value |= 0x1<<16;
+	}
+	else
+	{
+		reg_value |= 0x0<<16;
+	}
+#else
+	if(t->tx_nbits == 4 || (t->rx_nbits == 4))
+		reg_value |= 2<<16;
+#endif
+
+    writel(reg_value, hw->regs + AK_SPICON);
+}
+
+
+/**
+*  @brief       configure the master register when stop transfer data.
+*  @author      lixinhai
+*  @date        2013-03-15
+*  @param[in]  *hw :akspi master dev.
+*  @param[in]   t: a read/write buffer pair.
+*  @return      void
+*/
+static void ak_spi_stop_txrx(struct ak_spi *hw, struct spi_transfer *t)
+{
+	u32 reg_value;
+
+    reg_value = readl(hw->regs + AK_SPICON);
+	reg_value &= ~AK_SPICON_WIRE;	
+    writel(reg_value, hw->regs + AK_SPICON);
+}
+
+
+/**
+*  @brief       spi write data function by l2dma/l2cpu mode.
+*  @author      lixinhai
+*  @date        2013-03-15
+*  @param[in]  *hw :akspi master dev.
+*  @param[in]   buf: transfer data pointer.
+*  @param[in]   count: transfer data length.
+*  @return      transfer success result 0, otherwise result a negative value
+*/
+static int spi_dma_write(struct ak_spi *hw, unsigned char *buf, int count)
+{
+	int ret = 0;
+	bool flags = false;
+	u32 val;
+	dma_addr_t phyaddr = 0;
+
+	init_completion(&hw->done);	
+	enable_imask(hw, AK_SPIINT_TRANSF);
+	
+	val = AK_SPIEXTX_BUFEN|AK_SPIEXTX_DMAEN;
+	iowrite32(val, hw->regs + AK_SPIEXTX);
+	iowrite32(count, hw->regs + AK_SPICNT);
+
+	/*use for dma mode: greater than 256 bytes, align 4bytes of buf addr,
+		align 64 bytes of data count*/
+	if((count < 256) || ((unsigned long)buf & 0x3) || (count & (64 - 1))) {
+		l2_combuf_cpu((unsigned long)buf, hw->l2buf_tid, count, MEM2BUF);
+		
+	} else {
+		phyaddr = dma_map_single(hw->dev, buf, count, DMA_TO_DEVICE);
+		if (phyaddr == 0) {
+			printk("tx dma_map_single error!\n");
+			ret = -EINVAL;
+			goto wr_exit;
+		}
+	
+		//start l2 dma transmit
+		l2_combuf_dma(phyaddr, hw->l2buf_tid, count, MEM2BUF, AK_FALSE);
+		flags = true;
+	}
+	
+	ret = wait_for_completion_timeout(&hw->done, msecs_to_jiffies(SPI_TRANS_TIMEOUT));
+	if(ret <= 0) {
+		printk("wait for spi transfer interrupt timeout(%s).\n", __func__);
+		dbg_dumpregs(hw);
+		ret = -EINVAL;
+		goto xfer_fail;
+	}
+
+	if (flags && (l2_combuf_wait_dma_finish(hw->l2buf_tid) == AK_FALSE))	{
+		printk("%s: l2_combuf_wait_dma_finish failed!\n", __func__);
+		ret = -EINVAL;
+		goto xfer_fail;
+	}
+	
+	ret = wait_for_spi_cnt_to_zero(hw, TRANS_TIMEOUT);
+	if(ret)	{
+		printk("%s: wait_for_spi_cnt_to_zero failed!\n", __func__);
+		ret = -EINVAL;
+		goto xfer_fail;
+	}
+		
+	ret = count;
+xfer_fail:
+	if(phyaddr)
+		dma_unmap_single(hw->dev, phyaddr, count, DMA_TO_DEVICE);
+	
+wr_exit:
+	//disable l2 dma
+	iowrite32(0, hw->regs + AK_SPIEXTX);
+	l2_clr_status(hw->l2buf_tid);
+	return ret;
+}
+
+
+/**
+*  @brief       spi read data function by l2dma/l2cpu mode.
+*  @author      lixinhai
+*  @date        2013-03-15
+*  @param[in]  *hw :akspi master dev.
+*  @param[in]   buf: transfer data pointer.
+*  @param[in]   count: transfer data length.
+*  @return      transfer success result 0, otherwise result a negative value
+*/
+static int spi_dma_read(struct ak_spi *hw, unsigned char *buf, int count)
+{
+	int ret = 0;
+	bool flags = false;
+	u32 val;
+	dma_addr_t phyaddr = 0;
+	
+	//prepare spi read
+	init_completion(&hw->done);
+	enable_imask(hw, AK_SPIINT_TRANSF);
+	
+	val = AK_SPIEXTX_BUFEN|AK_SPIEXTX_DMAEN;
+	iowrite32(val, hw->regs + AK_SPIEXRX);
+	iowrite32(count, hw->regs + AK_SPICNT);	
+
+	if(count < 256 || ((unsigned long)buf & 0x3) || (count & (64 - 1))) {
+		l2_combuf_cpu((unsigned long)buf, hw->l2buf_rid, count, BUF2MEM);
+	} 
+	else {
+		phyaddr = dma_map_single(hw->dev, buf, count, DMA_FROM_DEVICE);
+		if (phyaddr == 0) {
+			printk("tx dma_map_single error!\n");
+			ret =  -EINVAL;
+			goto rd_exit;
+		}
+
+		//start L2 dma
+		l2_combuf_dma(phyaddr, hw->l2buf_rid, count, BUF2MEM, AK_FALSE);
+		flags = true;
+	}
+
+	ret = wait_for_completion_timeout(&hw->done, msecs_to_jiffies(SPI_TRANS_TIMEOUT));
+	if(ret <= 0) {
+		printk("wait for spi transfer interrupt timeout(%s).\n", __func__);
+		dbg_dumpregs(hw);
+		ret = -EINVAL;
+		goto xfer_fail;
+	}
+
+	//wait L2 dma finish, if need frac dma,start frac dma
+	if (flags && l2_combuf_wait_dma_finish(hw->l2buf_rid) ==  AK_FALSE)	{
+		ret = -EINVAL;
+		goto xfer_fail;
+	}
+
+	/*wait for spi count register value to zero.*/
+	ret = wait_for_spi_cnt_to_zero(hw, TRANS_TIMEOUT);
+	if(ret)	{
+		printk("%s: wait for spi count to zero failed!\n", __func__);
+		ret = -EINVAL;
+		goto xfer_fail;
+	}
+
+	ret = count;
+xfer_fail:
+	if(phyaddr)
+		dma_unmap_single(hw->dev, phyaddr, count, DMA_FROM_DEVICE);
+	
+rd_exit:
+	//disable l2 dma
+	iowrite32(0, hw->regs + AK_SPIEXRX);
+	l2_clr_status(hw->l2buf_rid);
+	return ret;
+}
+
+
+/**
+*  @brief       spi transfer function by l2dma/l2cpu mode.
+*  @author      lixinhai
+*  @date        2013-03-15
+*  @param[in]  *hw :akspi master dev.
+*  @param[in]   tx: send data pointer.
+*  @param[in]   rx: receive data pointer.
+*  @param[in]   count: transfer data length.
+*  @return      transfer success result 0, otherwise result a negative value
+*/
+static int spi_dma_duplex(struct ak_spi *hw, 
+			unsigned char *tx, unsigned char *rx, int count)
+{
+	int ret = 0;
+	bool flags = false;
+	dma_addr_t tx_phyaddr, rx_phyaddr;
+	u32 val;
+
+	init_completion(&hw->done);	
+	enable_imask(hw, AK_SPIINT_TRANSF);
+	
+	val = AK_SPIEXTX_BUFEN|AK_SPIEXTX_DMAEN;
+	iowrite32(val, hw->regs + AK_SPIEXTX);
+
+	val = AK_SPIEXRX_BUFEN|AK_SPIEXRX_DMAEN;
+	iowrite32(val, hw->regs + AK_SPIEXRX);
+
+	iowrite32(count, hw->regs + AK_SPICNT);
+
+	if((count < 512) || ((unsigned long)tx & 0x3)) {
+		//printk("write: l2_combuf_cpu\n");
+		l2_combuf_cpu((unsigned long)tx, hw->l2buf_tid, count, MEM2BUF);
+		l2_combuf_cpu((unsigned long)rx, hw->l2buf_rid, count, BUF2MEM);
+	}
+	else {
+		tx_phyaddr = dma_map_single(hw->dev, tx, count, DMA_TO_DEVICE);
+		if (tx_phyaddr == 0) {
+			printk("tx dma_map_single error!\n");
+			ret = -EINVAL;
+			goto wr_fail;
+		}
+	
+		//start l2 dma transmit
+		l2_combuf_dma(tx_phyaddr, hw->l2buf_tid, count, MEM2BUF, AK_FALSE);
+
+		rx_phyaddr = dma_map_single(hw->dev, rx, count, DMA_FROM_DEVICE);
+		if (rx_phyaddr == 0) {
+			printk("tx dma_map_single error!\n");
+			ret =  -EINVAL;
+			goto rd_fail;
+		}
+		
+		//start L2 dma
+		l2_combuf_dma(rx_phyaddr, hw->l2buf_rid, count, BUF2MEM, AK_FALSE); 
+	}
+	ret = wait_for_completion_timeout(&hw->done, msecs_to_jiffies(SPI_TRANS_TIMEOUT));
+	if(ret <= 0) {
+		printk("wait for spi transfer interrupt timeout(%s).\n", __func__);
+		dbg_dumpregs(hw);
+		ret = -EINVAL;
+		goto xfer_fail;
+	}
+
+	if (flags && ((AK_FALSE == l2_combuf_wait_dma_finish(hw->l2buf_tid)) || 
+		(AK_FALSE == l2_combuf_wait_dma_finish(hw->l2buf_rid))))
+	{
+		printk("%s: l2_combuf_wait_dma_finish failed!\n", __func__);
+		ret = -EINVAL;
+		goto xfer_fail;
+	}
+	
+	ret = wait_for_spi_cnt_to_zero(hw, TRANS_TIMEOUT);
+	if(ret)	{
+		printk("%s: wait for spi count to zero failed!\n", __func__);
+		ret = -EINVAL;
+		goto xfer_fail;
+	}
+
+	ret = 0;
+
+xfer_fail:
+	dma_unmap_single(hw->dev, rx_phyaddr, count, DMA_FROM_DEVICE);
+
+rd_fail:
+	dma_unmap_single(hw->dev, tx_phyaddr, count, DMA_TO_DEVICE);
+
+wr_fail:
+	//disable l2 dma
+	iowrite32(0, hw->regs + AK_SPIEXTX);
+	iowrite32(0, hw->regs + AK_SPIEXRX);
+	l2_clr_status(hw->l2buf_tid);
+	l2_clr_status(hw->l2buf_rid);
+	return ret;
+}
+
+
+/**
+*  @brief       spi transfer function by l2dma/l2cpu mode, actual worker 
+*  				spi_dma_read()/spi_dma_write() to be call.
+*  @author      lixinhai
+*  @date        2013-03-15
+*  @param[in]  *hw :akspi master dev.
+*  @param[in]   dir: transfer direction.
+*  @return      transfer success result 0, otherwise result a negative value
+*/
+static int ak_spi_dma_txrx(struct ak_spi *hw, struct spi_transfer *t)
+{
+	int ret = 0;
+	u32 retlen;
+	u32 count = t->len;
+	
+	hw->tx = (unsigned char*)t->tx_buf;
+	hw->rx = t->rx_buf;
+	hw->l2buf_tid = hw->l2buf_rid = BUF_NULL;
+	pr_debug("start the spi dma transfer.\n");
+
+	switch(hw->xfer_dir) {
+		case SPI_DIR_TXRX:
+		{	
+			//alloc L2 buffer
+			hw->l2buf_tid = l2_alloc(SPI_L2_TXADDR(hw->master));
+			hw->l2buf_rid = l2_alloc(SPI_L2_RXADDR(hw->master));
+
+			if ((BUF_NULL == hw->l2buf_tid) || (BUF_NULL == hw->l2buf_rid))
+			{
+				printk("%s: l2_alloc failed!\n", __func__);
+				ret = -EBUSY;
+				goto txrx_ret;
+			}
+			
+			while(count > 0) {
+				hw->count = 0;
+				hw->len = (count > MAX_XFER_LEN) ?	MAX_XFER_LEN : count;
+				
+				retlen = spi_dma_duplex(hw, hw->tx, hw->rx, hw->len);
+				if(unlikely(retlen < 0)) {
+					printk("spi master transfer data error!\n");
+					ret = -EBUSY;
+					goto txrx_ret;
+				}
+				hw->tx += retlen;
+				hw->rx += retlen;
+				count -= retlen;
+			}
+			break;
+		}
+		case SPI_DIR_TX:
+		{
+			//alloc L2 buffer
+			hw->l2buf_tid = l2_alloc(SPI_L2_TXADDR(hw->master));
+			if (unlikely(BUF_NULL == hw->l2buf_tid)) {
+				printk("%s: l2_alloc failed!\n", __func__);
+				return -EBUSY;
+			}
+
+			while(count > 0) {
+				hw->count = 0;
+				hw->len = (count > MAX_XFER_LEN) ? MAX_XFER_LEN : count;
+				
+				retlen = spi_dma_write(hw, hw->tx + hw->count, hw->len);
+				if(unlikely(retlen < 0)) {
+					printk("spi master read data error!\n");	
+					ret = -EBUSY;
+					goto txrx_ret;
+				}
+				hw->tx += retlen;
+				count -= retlen;
+			}
+			break;
+		}
+		case SPI_DIR_RX:
+		{
+			//alloc L2 buffer
+			hw->l2buf_rid = l2_alloc(SPI_L2_RXADDR(hw->master));
+			if (unlikely(BUF_NULL == hw->l2buf_rid))
+			{
+				return -EBUSY;
+			}
+			
+			while(count > 0) {
+				hw->count = 0;
+				hw->len = (count > MAX_XFER_LEN) ? MAX_XFER_LEN : count;
+				
+				retlen = spi_dma_read(hw, hw->rx, hw->len);
+				if(unlikely(retlen < 0)) {
+					printk("spi master read data error!\n");
+					ret = -EBUSY;
+					goto txrx_ret;
+				}
+				hw->rx += retlen;
+				count -= retlen;
+			}		
+			break;
+		}
+	}
+	pr_debug("finish the spi dma transfer.\n");
+txrx_ret:
+	if(hw->l2buf_tid != BUF_NULL)
+		l2_free(SPI_L2_TXADDR(hw->master));
+	if(hw->l2buf_rid != BUF_NULL)
+		l2_free(SPI_L2_RXADDR(hw->master));
+
+	return ret ? ret : t->len;
+}
+
+
+/**
+*  @brief       spi read/write data function by cpu mode, 
+*  @author      lixinhai
+*  @date        2013-03-15
+*  @param[in]  *hw :akspi master dev.
+*  @param[in]   t: a read/write buffer pair.
+*  @return      transfer success result 0, otherwise result a negative value
+*/
+static int ak_cpu_duplex(struct spi_device *spi, struct spi_transfer *t)
+{
+	struct ak_spi *hw = to_hw(spi);
+	u32 tran_4_nbr;
+	u32 frac_nbr;
+	u32 status, val;
+	u32 off_set_read = 0, off_set_write = 0;
+	const u8 *buff_tx;
+	u8 *buff_rx;
+	int i = 0, j;
+	u32 to_read = 0, to_write = 0;	//, to = 0;
+
+	hw->len = (t->len > MAX_XFER_LEN) ? MAX_XFER_LEN : t->len;
+	tran_4_nbr = hw->len/4;
+	frac_nbr = hw->len%4;
+
+	hw->tx = (unsigned char*)t->tx_buf;
+	hw->rx = t->rx_buf;
+
+	buff_tx = hw->tx;
+	buff_rx = hw->rx;
+
+	pr_debug("duplex transfer,tran_4_nbr:%u  frac_nbr:%u\n", tran_4_nbr, frac_nbr);
+	
+	if (hw->len >= MAX_XFER_LEN)
+	{
+		printk("Too much to be read and send...\n");
+		return -EINVAL;
+	}
+
+	//set data count, and the the master will rise clk
+	writel(hw->len, hw->regs + AK_SPICNT);
+	
+	while(1) {
+		//write 4 bytes first, and then read 4 bytes
+		if (i<tran_4_nbr) {
+			while(1) {
+				status = ioread32(hw->regs + AK_SPISTA);
+				if ((status & AK_SPISTA_TXHEMP) == AK_SPISTA_TXHEMP) {
+					pr_debug("TX HEMP...\n");
+					break;
+				} else {
+					if(to_write++ < TRANS_TIMEOUT) 
+						udelay(10);
+					else {
+						pr_debug("master transfer timeout...\n");
+						goto SPI_TRANS_FAIL;
+					}
+				}
+			}			
+			iowrite32(*(volatile u32 *)(buff_tx + off_set_write), hw->regs + AK_SPIOUT);
+			off_set_write += 4;
+			i++;
+		}
+		//write not finished
+		else if (off_set_write < hw->len) {			
+			pr_debug("write frac...\n");
+			to_write = 0;
+			val = 0;
+			if (frac_nbr != 0) {
+				while(1) {
+					status = ioread32(hw->regs + AK_SPISTA);
+					if ((status & AK_SPISTA_TXHEMP) == AK_SPISTA_TXHEMP)
+						break;
+					if (to_write++ < TRANS_TIMEOUT)	
+						udelay(10);
+					else {
+						printk("SPI master write timeout...\n");						
+						goto SPI_TRANS_FAIL;
+					}
+				}
+					
+				for (j=0; j<frac_nbr; j++)
+				{
+					pr_debug("[%d]:%x ", off_set_write+j, *(buff_tx+off_set_write+j));
+					val |= (*(buff_tx + off_set_write + j) << (j*8));
+				}
+				pr_debug("\nval: %x", val);
+				pr_debug("\n\n");
+
+				iowrite32(val, hw->regs + AK_SPIOUT); 
+				off_set_write += frac_nbr;
+			}
+		}
+		
+		//read
+		status = ioread32(hw->regs + AK_SPISTA);			
+		
+		if ((status & AK_SPISTA_TRANSF) == AK_SPISTA_TRANSF) {
+			if (status & AK_SPISTA_RXFULL) {
+				val = ioread32(hw->regs + AK_SPIIN);
+				*(volatile u32 *)(buff_rx + off_set_read) = val;
+				off_set_read += 4;
+
+				val = ioread32(hw->regs + AK_SPIIN);
+				*(volatile u32 *)(buff_rx + off_set_read) = val;
+				off_set_read += 4;
+
+			} else if (status & AK_SPISTA_RXHFULL) {
+
+				val = ioread32(hw->regs + AK_SPIIN);
+				*(volatile u32 *)(buff_rx + off_set_read) = val;
+				off_set_read += 4;
+			}
+			if (frac_nbr != 0) {
+				pr_debug("read frac...\n");
+				val = ioread32(hw->regs + AK_SPIIN);
+
+				for (j=0; j<frac_nbr; j++)
+				{
+					*(buff_rx+off_set_read+j) = (val >> j*8) & 0xff;
+					pr_debug("%x ", *(buff_rx+off_set_read+j));
+				}
+			}
+			break;
+		} else {
+			if ( (status & AK_SPISTA_RXHFULL) == AK_SPISTA_RXHFULL)	{
+				val = ioread32(hw->regs + AK_SPIIN);
+				*(volatile u32 *)(buff_rx + off_set_read) = val;
+				pr_debug("rx hfull .. %x\n", val);
+				pr_debug("[0]%x [1]%x [2]%x [3]%x\n", buff_rx[0], buff_rx[1], buff_rx[2], buff_rx[3]);
+				off_set_read += 4;
+			} else {
+				if (to_read++ < TRANS_TIMEOUT) 
+					udelay(10);
+				else {
+					pr_debug("master read timeout...\n");
+					goto SPI_READ_TIMEOUT;
+				}
+			}
+		}	
+	}
+	
+	return hw->len;
+	
+SPI_TRANS_FAIL:
+SPI_READ_TIMEOUT:
+	return off_set_read > off_set_write ? off_set_read: off_set_write;		
+	
+}
+
+
+#if defined(SPI_CPU_MODE_USE_INTERRUPT)
+static int pio_imasks[SPI_DIR_XFER_NUM] = {
+	AK_SPIINT_TRANSF | AK_SPIINT_TXHEMP,
+	AK_SPIINT_TRANSF | AK_SPIINT_RXHFULL,
+	AK_SPIINT_TXHEMP | AK_SPIINT_RXHFULL,
+};
+
+
+/**
+*  @brief       spi transfer function by cpu mode.
+*  @author      lixinhai
+*  @date        2013-03-15
+*  @param[in]  *hw :akspi master dev.
+*  @param[in]   dir: transfer direction.
+*  @return      transfer success result 0, otherwise result a negative value
+*/
+static int ak_spi_pio_txrx(struct ak_spi *hw, struct spi_transfer *t)
+{
+	int ret;
+
+	init_completion(&hw->done);
+
+	writel(hw->len, hw->regs + AK_SPICNT);
+	enable_imask(hw, pio_imasks[hw->xfer_dir]);
+
+	ret = wait_for_completion_timeout(&hw->done, msecs_to_jiffies(SPI_TRANS_TIMEOUT));
+	if(ret <= 0) {
+		printk("wait for spi transfer interrupt timeout(%s).\n", __func__);
+		dbg_dumpregs(hw);
+		return -EINVAL;
+	}
+	
+	return hw->count;
+}
+#else
+
+
+/**
+*  @brief       ak37_spi_writeCPU
+*  send message function with CPU mode and polling mode
+*  @author      zhou wenyong
+*  @date        2011-08-19
+*  @param[in]   *spi
+*  @param[in]   *t
+*  @return      int
+*/
+static int spi_pio_write(struct ak_spi *hw, unsigned char *buf, int count)
+{
+	u32 status;
+	u32 to = 0;
+
+	pr_debug("ak spi write by cpu mode\n");
+	if (count > 64*1024)
+	{
+		printk("too much to be send...\n");
+		return -EINVAL;
+	}
+	//set data count, and the the master will rise clk
+	writel(count, hw->regs + AK_SPICNT);
+	
+	while(hw_remain_datalen(hw) > 0) {
+		status = readl(hw->regs + AK_SPISTA);
+		if ((status & AK_SPISTA_TXHEMP) == AK_SPISTA_TXHEMP) {
+			writel(hw_txdword(hw), hw->regs + AK_SPIOUT);
+		}else {
+			if (to++ > 10 * 1000000) {
+				printk("master write data timeout.\n");	
+				return hw->count;
+			}
+		}
+	}
+
+	//wait transfer finish
+	while(1) {
+		status = readl(hw->regs + AK_SPISTA);		
+		if ((status & AK_SPISTA_TRANSF) == AK_SPISTA_TRANSF)
+			break;
+		
+		if (to++ > 10 * 1000000) {
+			printk("wait for write data finish timeout..\n");	
+			return hw->count;
+		}
+	}
+
+	if (hw_remain_datalen(hw) > 0)
+		printk("write wasn't finished.\n");
+
+	return hw->count;
+}
+
+/**
+*  @brief       spi_pio_read
+*  receiving message function with CPU mode and polling mode
+*  @author      zhou wenyong
+*  @date        2011-08-19
+*  @param[in]   *spi
+*  @param[in]   *t
+*  @return      int
+*/
+static int spi_pio_read(struct ak_spi *hw, unsigned char *buf, int count)
+{
+	u32 status;
+	u32 to=0;
+	
+	pr_debug("ak spi read by cpu mode\n");
+	if (count >= 64*1024)
+	{
+		printk("too much to be read...\n");
+		return -EINVAL;
+	}
+
+	//set data count, and the the master will rise clk
+	writel(count, hw->regs + AK_SPICNT);
+	
+	while(1) {
+		status = readl(hw->regs + AK_SPISTA);			
+		
+		if((status & AK_SPISTA_TRANSF) == AK_SPISTA_TRANSF)
+		{
+			if(status & AK_SPISTA_RXFULL) {
+				hw_rxdword(hw, readl(hw->regs + AK_SPIIN));
+				hw_rxdword(hw, readl(hw->regs + AK_SPIIN));
+			}else if (status & AK_SPISTA_RXHFULL) {
+				hw_rxdword(hw, readl(hw->regs + AK_SPIIN));
+			} 
+
+			if (hw_remain_datalen(hw) > 0) {
+				hw_rxdword(hw, readl(hw->regs + AK_SPIIN));
+			}
+			break;
+		} else {
+			if((status & AK_SPISTA_RXHFULL) == AK_SPISTA_RXHFULL) {
+				hw_rxdword(hw, readl(hw->regs + AK_SPIIN));
+			}
+			else {
+				if (to++ > 10 * 1000000) {
+					pr_debug("master read timeout.\n");
+					return hw->count;
+				}
+			}
+		}	
+	}
+	if (hw_remain_datalen(hw) > 0)
+		printk("read wasn't finished.\n");
+
+	return hw->count;	
+}
+
+
+/**
+*  @brief       spi transfer function by cpu mode.
+*  @author      lixinhai
+*  @date        2013-03-15
+*  @param[in]  *hw :akspi master dev.
+*  @param[in]   dir: transfer direction.
+*  @return      transfer success result 0, otherwise result a negative value
+*/
+static int ak_spi_pio_txrx(struct ak_spi *hw, struct spi_transfer *t)
+{
+	int retlen = -1;
+	u32 count = t->len;
+			
+	hw->tx = (unsigned char*)t->tx_buf;
+	hw->rx = t->rx_buf;
+	pr_debug("start the spi dma transfer.\n");
+
+	switch(hw->xfer_dir) {
+		case SPI_DIR_TX:
+		{
+			while(count > 0) {
+				hw->count = 0;
+				hw->len = (count > MAX_XFER_LEN) ? MAX_XFER_LEN : count;
+				
+				retlen = spi_pio_write(hw, hw->tx, hw->len);
+				if(unlikely(retlen < 0)) {
+					printk("spi master transfer data error!\n");
+					goto txrx_ret;
+				}
+				hw->tx += retlen;
+				count -= retlen;
+
+			}
+			break;
+		}
+		case SPI_DIR_RX:
+		{
+			while(count > 0) {
+				hw->count = 0;
+				hw->len = (count > MAX_XFER_LEN) ? MAX_XFER_LEN : count;
+
+				retlen = spi_pio_read(hw, hw->rx, hw->len);
+				if(unlikely(retlen < 0)) {
+					printk("spi master transfer data error!\n");
+					goto txrx_ret;
+				}
+				hw->rx += retlen;
+				count -= retlen;
+			}
+			break;
+		}
+	}
+	pr_debug("finish the spi dma transfer.\n");
+
+txrx_ret:
+	return (retlen<0) ? retlen : t->len;
+}
+
+#endif
+
+/**
+*  @brief       transfer a message
+*  call proper function to complete the transefer
+*  @author      zhou wenyong
+*  @date        2011-08-19
+*  @param[in]   *spi
+*  @param[in]   *t
+*  @return      int
+*/
+static int ak_spi_txrx(struct spi_device *spi, struct spi_transfer *t)
+{
+    int ret;
+	struct ak_spi *hw = to_hw(spi);
+
+	pr_debug("txrx: tx %p, rx %p, len %d\n",
+		t->tx_buf, t->rx_buf, t->len);
+	
+	dev_dbg(&spi->dev, "txrx: tx %p, rx %p, len %d\n",
+		t->tx_buf, t->rx_buf, t->len);
+
+	hw->xfer_mode = t->len < 256 ? AKSPI_XFER_MODE_CPU : AKSPI_XFER_MODE_DMA;
+
+	hw->xfer_dir = (t->tx_buf && t->rx_buf) ? SPI_DIR_TXRX : 
+				t->tx_buf ? SPI_DIR_TX : SPI_DIR_RX;
+
+	ak_spi_start_txrx(hw, t);
+	
+	if(hw->xfer_dir == SPI_DIR_TXRX) {		
+		ret = ak_cpu_duplex(spi, t);
+		return ret;
+	}	
+
+	if(ak_spi_use_dma(hw)) {
+		ret = ak_spi_dma_txrx(hw, t);
+	} else {
+		ret = ak_spi_pio_txrx(hw, t);
+	}
+
+	ak_spi_stop_txrx(hw, t);
+
+	return ret;
+}
+
+/**
+*  @brief       ak_spi_irq
+*  TODO: used by interrupt mode
+*  @author      zhou wenyong
+*  @date        2011-08-19
+*  @param[in]   irq
+*  @param[out]  *dev
+*  @return      irqreturn_t
+*/
+static irqreturn_t ak_spi_irq(int irq, void *dev)
+{
+	struct ak_spi *hw = dev;
+	unsigned int status;
+
+	status = readl(hw->regs + AK_SPISTA);
+
+	pr_debug("spi interrupt: status register value is %08x\n", status);
+
+	if(ak_spi_use_dma(hw)) {
+		if((status & AK_SPISTA_TRANSF) == AK_SPISTA_TRANSF ) {
+			pr_debug("spi transfer data have been finish.\n"); 
+
+			//printk("--->status:%d, cnt:%d\n", status, readl(hw->regs + AK_SPICNT));
+			disable_imask(hw, AK_SPIINT_TRANSF);
+			complete(&hw->done);
+		}
+	} else {
+		switch(hw->xfer_dir) {	
+			case SPI_DIR_RX:
+				if(status & (AK_SPISTA_RXHFULL | AK_SPISTA_TRANSF)) {
+					pr_debug("spi recv buffer half full or data transfer finish.\n");
+
+					if(status & (AK_SPISTA_RXFULL|AK_SPISTA_TRANSF))
+						hw_rxdword(hw, readl(hw->regs + AK_SPIIN));						
+					hw_rxdword(hw, readl(hw->regs + AK_SPIIN));
+
+					if (hw->count >= hw->len) {
+						disable_imask(hw, AK_SPIINT_RXHFULL|AK_SPIINT_TRANSF);
+						complete(&hw->done);
+					}				
+				}
+				break;
+			case SPI_DIR_TX:
+				if(status & (AK_SPISTA_TXHEMP | AK_SPISTA_TRANSF)) {
+					pr_debug("spi send buffer half empty or data transfer finish.\n");
+					
+					if (hw->count < hw->len) {
+						if((status & AK_SPISTA_TXEMP) && ((hw->count - hw->len)>4))
+							writel(hw_txdword(hw), hw->regs + AK_SPIOUT);
+						
+						writel(hw_txdword(hw), hw->regs + AK_SPIOUT);
+					} else {
+						disable_imask(hw, AK_SPIINT_TXHEMP|AK_SPIINT_TRANSF);
+						complete(&hw->done);
+					}
+				}
+				break;
+			case SPI_DIR_TXRX :
+			default:
+				BUG();
+				break;
+		}
+	}
+
+	return IRQ_HANDLED;
+}
+
+
+/**
+*  @brief       ak_spi_initialsetup
+*  set up gpio and spi master
+*  @author      zhou wenyong
+*  @date        2011-08-19
+*  @param[out]  *hw
+*  @return      void
+*/
+static void ak_spi_initialsetup(struct ak_spi *hw)
+{
+	//printk("Entering %s\n", __FUNCTION__);
+
+	BUG_ON(hw->master && hw->master->bus_num >= AKSPI_MAX_BUS_NUM);
+
+	/* program defaults into the registers */
+	writel(DFT_DIV<<8 | DFT_CON | (1<<1),hw->regs + AK_SPICON);
+
+	writel(0, hw->regs + AK_SPIINT);
+/*
+    printk("akpi regs: SPICON:%08x, SPISTA:%08x, SPIINT:%08x.\n", 
+		ioread32(hw->regs + AK_SPICON), 
+		ioread32(hw->regs + AK_SPISTA), 
+		ioread32(hw->regs + AK_SPIINT));
+*/
+
+}
+
+/* get rid of useless bitbang mode. */
+static int ak_spi_transfer_one(struct spi_master *master,
+				    struct spi_device *spi,
+				    struct spi_transfer *transfer)
+{	
+    int status = 0;
+
+    status = ak_spi_setupxfer(spi, transfer);
+	if (status < 0)
+		goto out;
+        
+    if (transfer->len)
+		status = ak_spi_txrx(spi, transfer);
+
+	if (status == transfer->len)
+		status = 0;
+	else if (status >= 0)
+		status = -EREMOTEIO;
+
+out:
+	spi_finalize_current_transfer(master);
+
+	return status;
+}
+
+static void ak_spi_set_chipsel(struct spi_device *spi, bool enable)
+{
+	enable = (!(spi->mode & SPI_CS_HIGH) == enable);
+
+	ndelay(100);
+	ak_spi_chipsel(spi, enable ? CS_ACTIVE :
+			    CS_INACTIVE);
+	ndelay(100);
+}
+
+/**
+*  @brief       ak_spi_probe
+*  @author      zhou wenyong
+*  @date        2011-08-19
+*  @param[out]  *pdev
+*  @return      int __init
+*/
+static int  ak_spi_probe(struct platform_device *pdev)
+{
+	struct ak_spi *hw;
+	struct spi_master *master;
+	struct resource *res;
+	int err = 0;
+    int rc;
+    unsigned int spi_bus_freq;
+	
+	//pr_info("spi controller probe...\n");
+	master = spi_alloc_master(&pdev->dev, sizeof(struct ak_spi));
+	if (master == NULL) 
+	{
+		dev_err(&pdev->dev, "No memory for spi_master\n");
+		err = -ENOMEM;
+		goto err_nomem;
+	}
+
+	hw = spi_master_get_devdata(master);
+	memset(hw, 0, sizeof(struct ak_spi));
+
+	hw->master = spi_master_get(master);
+	hw->dev = &pdev->dev;
+	hw->xfer_mode = AKSPI_XFER_MODE_DMA;
+
+	platform_set_drvdata(pdev, hw);
+
+	init_completion(&hw->done);
+
+	/* setup the master state. */
+	/* the spi->mode bits understood by this driver: */
+	master->mode_bits = SPI_CPOL | SPI_CPHA | SPI_CS_HIGH | SPI_LSB_FIRST;
+	master->num_chipselect = 1;
+    master->setup  = ak_spi_setup;
+    master->cleanup = ak_spi_cleanup;
+    master->set_cs = ak_spi_set_chipsel;
+    master->transfer_one = ak_spi_transfer_one;
+	master->dev.of_node = pdev->dev.of_node;
+	master->bus_num = of_alias_get_id(master->dev.of_node, "spi");
+
+	/* find and map our resources */
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (res == NULL) {
+		dev_err(&pdev->dev, "Cannot get IORESOURCE_MEM\n");
+		err = -ENOENT;
+		goto err_no_iores;
+	}
+
+	hw->ioarea = request_mem_region(res->start, resource_size(res),
+					pdev->name);
+
+	if (hw->ioarea == NULL) {
+		dev_err(&pdev->dev, "Cannot reserve region\n");
+		err = -ENXIO;
+		goto err_no_iores;
+	}
+
+	hw->regs = ioremap(res->start, resource_size(res));
+	if (hw->regs == NULL) {
+		dev_err(&pdev->dev, "Cannot map IO\n");
+		err = -ENXIO;
+		goto err_no_iomap;
+	}
+
+	hw->irq = platform_get_irq(pdev, 0);
+	if (hw->irq < 0) {
+		dev_err(&pdev->dev, "No IRQ specified\n");
+		err = -ENOENT;
+		goto err_no_irq;
+	}
+
+	err = request_irq(hw->irq, ak_spi_irq, 0, pdev->name, hw);
+	if (err) {
+		dev_err(&pdev->dev, "Cannot claim IRQ\n");
+		goto err_no_irq;
+	}
+    
+    /* spi0_bus CLOCK are generated by core_pll,spi1_bus CLOCK are generated by GCLK. */
+    if(master->bus_num == 0){
+        err = of_property_read_u32(pdev->dev.of_node, "spi-bus-frequency",
+				   &spi_bus_freq);
+	    if (err < 0) {
+		     dev_warn(&pdev->dev,
+			    "Could not read spi-bus-frequency property\n");
+	    }
+        
+        hw->bus_clk = devm_clk_get(&pdev->dev, "spi0_bus");
+	    if (IS_ERR(hw->bus_clk)) {
+		    err = PTR_ERR(hw->bus_clk);
+		    goto  err_no_clk;
+	    }
+        
+	    rc = clk_set_rate(hw->bus_clk, spi_bus_freq);
+	    if (rc) {
+		    dev_err(&pdev->dev, "%s: clk_set_rate returned %d\n",
+			__func__, rc);
+	    }
+    } 
+
+    
+    hw->clk = clk_get(&pdev->dev, NULL);
+	if (IS_ERR(hw->clk)) {
+		dev_err(&pdev->dev, "No clock for device\n");
+		err = PTR_ERR(hw->clk);
+		goto err_no_clk;
+	}
+    clk_prepare_enable(hw->clk);
+
+	/* setup any gpio we can */ 
+	ak_spi_initialsetup(hw);
+
+	/* register our spi controller */ 
+	err = devm_spi_register_master(&pdev->dev, master);
+	if (err) {
+		dev_err(&pdev->dev, "Failed to register SPI master\n");
+		goto err_register;
+	}
+
+	printk("akspi master SPI%d initialize success, use for %s mode.\n", 
+		master->bus_num, ak_spi_use_dma(hw)?"DMA":"PIO");
+
+	return 0;
+
+ err_register:
+	//if (hw->set_cs == ak_spi_gpiocs)
+	//	gpio_free(pdata->pin_cs);
+
+	clk_disable(hw->clk);
+	clk_put(hw->clk);
+
+ err_no_clk:
+	free_irq(hw->irq, hw);
+
+ err_no_irq:
+	iounmap(hw->regs);
+
+ err_no_iomap:
+	release_resource(hw->ioarea);
+
+ err_no_iores:
+	spi_master_put(hw->master);
+
+ err_nomem:
+	return err;
+}
+
+
+static int __exit ak_spi_remove(struct platform_device *dev)
+{
+	struct ak_spi *hw = platform_get_drvdata(dev);
+
+	platform_set_drvdata(dev, NULL);
+
+	spi_unregister_master(hw->master);
+
+	clk_disable(hw->clk);
+	clk_put(hw->clk);
+
+	free_irq(hw->irq, hw);
+	iounmap(hw->regs);
+
+	release_resource(hw->ioarea);
+
+	spi_master_put(hw->master);
+	return 0;
+}
+
+
+#ifdef CONFIG_PM
+
+
+static int ak_spi_suspend(struct device *dev)
+{
+	struct ak_spi *hw = platform_get_drvdata(to_platform_device(dev));
+
+	ak_spi_gpio_setup(hw, 0);
+
+	clk_disable(hw->clk);
+	return 0;
+}
+
+
+static int ak_spi_resume(struct device *dev)
+{
+	struct ak_spi *hw = platform_get_drvdata(to_platform_device(dev));
+
+	ak_spi_initialsetup(hw);
+	return 0;
+}
+
+static struct dev_pm_ops ak_spi_pmops = {
+	.suspend	= ak_spi_suspend,
+	.resume		= ak_spi_resume,
+};
+
+#define AK_SPI_PMOPS &ak_spi_pmops
+#else
+#define AK_SPI_PMOPS NULL
+#endif /* CONFIG_PM */
+
+
+static const struct of_device_id ak39_spi_match[] = {
+    { .compatible = "anyka,ak3916ev300-spi0", },
+	{ .compatible = "anyka,ak3790d-spi0", },
+	{ .compatible = "anyka,ak3790d-spi1", },
+	{}
+};
+MODULE_DEVICE_TABLE(of, ak39_spi_match);
+
+
+MODULE_ALIAS("platform:ak-spi");
+static struct platform_driver ak_spi_driver = {
+    .probe          = ak_spi_probe,
+	.remove		= __exit_p(ak_spi_remove),
+	.driver		= {
+		.name	= "ak-spi",
+        .of_match_table	= of_match_ptr(ak39_spi_match),
+		.owner	= THIS_MODULE,
+		.pm	= AK_SPI_PMOPS,
+	},
+};
+
+
+static int __init ak_spi_init(void)
+{
+		//pr_info("spi controller init...\n");
+        return platform_driver_register(&ak_spi_driver);
+}
+
+
+static void __exit ak_spi_exit(void)
+{
+        platform_driver_unregister(&ak_spi_driver);
+}
+
+module_init(ak_spi_init);
+module_exit(ak_spi_exit);
+
+MODULE_DESCRIPTION("Anyka On-Chip SPI controller driver");
+MODULE_AUTHOR("zhangzhipeng, <zhang_zhipeng@anyka.com>");
+MODULE_VERSION(DRIVER_VERSION);
+MODULE_LICENSE("GPL");
+
diff --git a/drivers/spi/spi.c b/drivers/spi/spi.c
old mode 100644
new mode 100755
index c132c67..9019cb7
--- a/drivers/spi/spi.c
+++ b/drivers/spi/spi.c
@@ -37,6 +37,10 @@
 #include <linux/kthread.h>
 #include <linux/ioport.h>
 #include <linux/acpi.h>
+#include <mach/map.h>
+
+
+
 
 #define CREATE_TRACE_POINTS
 #include <trace/events/spi.h>
@@ -478,7 +482,6 @@ static int spi_dev_check(struct device *dev, void *data)
 {
 	struct spi_device *spi = to_spi_device(dev);
 	struct spi_device *new_spi = data;
-
 	if (spi->master == new_spi->master &&
 	    spi->chip_select == new_spi->chip_select)
 		return -EBUSY;
@@ -499,8 +502,7 @@ int spi_add_device(struct spi_device *spi)
 	static DEFINE_MUTEX(spi_add_lock);
 	struct spi_master *master = spi->master;
 	struct device *dev = master->dev.parent;
-	int status;
-
+	int status; 
 	/* Chipselects are numbered 0..max; validate. */
 	if (spi->chip_select >= master->num_chipselect) {
 		dev_err(dev, "cs%d >= max %d\n",
@@ -517,7 +519,6 @@ int spi_add_device(struct spi_device *spi)
 	 * its configuration.  Lock against concurrent add() calls.
 	 */
 	mutex_lock(&spi_add_lock);
-
 	status = bus_for_each_dev(&spi_bus_type, NULL, spi, spi_dev_check);
 	if (status) {
 		dev_err(dev, "chipselect %d already in use\n",
@@ -666,15 +667,36 @@ int spi_register_board_info(struct spi_board_info const *info, unsigned n)
 	return 0;
 }
 
-/*-------------------------------------------------------------------------*/
 
+static inline struct ak_spi *to_hw(struct spi_device *sdev)
+{
+	return spi_master_get_devdata(sdev->master);
+}
+
+
+/*-------------------------------------------------------------------------*/
+//extern u8 flag;
 static void spi_set_cs(struct spi_device *spi, bool enable)
 {
+	//printk("spi->mode:%x, SPI_CS_HIGH:%x\n", spi->mode, SPI_CS_HIGH);
 	if (spi->mode & SPI_CS_HIGH)
 		enable = !enable;
 
 	if (gpio_is_valid(spi->cs_gpio))
-		gpio_set_value(spi->cs_gpio, !enable);
+	{
+		if(enable)
+		{
+			gpio_direction_output(spi->cs_gpio, 1);
+			gpio_set_value(spi->cs_gpio, !enable);
+		}
+		else
+		{
+			//printk("spi->cs_gpio:%d, enable:%d\n", spi->cs_gpio, enable);
+			gpio_direction_output(spi->cs_gpio, 1);
+			gpio_set_value(spi->cs_gpio, !enable);
+			//gpio_direction_output(spi->cs_gpio, 0);
+		}
+	}
 	else if (spi->master->set_cs)
 		spi->master->set_cs(spi, !enable);
 }
@@ -932,7 +954,7 @@ static int spi_transfer_one_message(struct spi_master *master,
 	unsigned long ms = 1;
 	struct spi_statistics *statm = &master->statistics;
 	struct spi_statistics *stats = &msg->spi->statistics;
-
+ 
 	spi_set_cs(msg->spi, true);
 
 	SPI_STATISTICS_INCREMENT_FIELD(statm, messages);
@@ -997,7 +1019,7 @@ static int spi_transfer_one_message(struct spi_master *master,
 				keep_cs = true;
 			} else {
 				spi_set_cs(msg->spi, false);
-				udelay(10);
+				udelay(10); 
 				spi_set_cs(msg->spi, true);
 			}
 		}
@@ -1006,8 +1028,11 @@ static int spi_transfer_one_message(struct spi_master *master,
 	}
 
 out:
+
 	if (ret != 0 || !keep_cs)
+	{
 		spi_set_cs(msg->spi, false);
+	}
 
 	if (msg->status == -EINPROGRESS)
 		msg->status = ret;
@@ -1461,6 +1486,7 @@ of_register_spi_device(struct spi_master *master, struct device_node *nc)
 			nc->full_name, rc);
 		goto err_out;
 	}
+	printk("value:%d\n", value);
 	spi->chip_select = value;
 
 	/* Mode (clock phase/polarity/etc.) */
@@ -1747,11 +1773,14 @@ static int of_spi_register_master(struct spi_master *master)
 		return -ENOMEM;
 
 	for (i = 0; i < master->num_chipselect; i++)
-		cs[i] = -ENOENT;
+		cs[i] = -ENOENT;	
 
 	for (i = 0; i < nb; i++)
+	{
 		cs[i] = of_get_named_gpio(np, "cs-gpios", i);
 
+	}
+
 	return 0;
 }
 #else
@@ -1805,7 +1834,7 @@ int spi_register_master(struct spi_master *master)
 		return -EINVAL;
 
 	if ((master->bus_num < 0) && master->dev.of_node)
-		master->bus_num = of_alias_get_id(master->dev.of_node, "spi");
+		master->bus_num = of_alias_get_id(master->dev.of_node, "spi"); 
 
 	/* convention:  dynamically assigned bus IDs count down from the max */
 	if (master->bus_num < 0) {
@@ -1827,8 +1856,9 @@ int spi_register_master(struct spi_master *master)
 
 	/* register the device, then userspace will see it.
 	 * registration fails if the bus ID is in use.
-	 */
-	dev_set_name(&master->dev, "spi%u", master->bus_num);
+	 */ 
+	dev_set_name(&master->dev, "spi%u", master->bus_num);	
+
 	status = device_add(&master->dev);
 	if (status < 0)
 		goto done;
@@ -1845,6 +1875,8 @@ int spi_register_master(struct spi_master *master)
 			goto done;
 		}
 	}
+	
+
 	/* add statistics */
 	spin_lock_init(&master->statistics.lock);
 
@@ -1856,7 +1888,8 @@ int spi_register_master(struct spi_master *master)
 
 	/* Register devices from the device tree and ACPI */
 	of_register_spi_devices(master);
-	acpi_register_spi_devices(master);
+	acpi_register_spi_devices(master);	
+
 done:
 	return status;
 }
@@ -1885,7 +1918,7 @@ int devm_spi_register_master(struct device *dev, struct spi_master *master)
 
 	ptr = devres_alloc(devm_spi_unregister, sizeof(*ptr), GFP_KERNEL);
 	if (!ptr)
-		return -ENOMEM;
+		return -ENOMEM;	
 
 	ret = spi_register_master(master);
 	if (!ret) {
@@ -1893,7 +1926,7 @@ int devm_spi_register_master(struct device *dev, struct spi_master *master)
 		devres_add(dev, ptr);
 	} else {
 		devres_free(ptr);
-	}
+	}	
 
 	return ret;
 }
@@ -2088,7 +2121,7 @@ int spi_setup(struct spi_device *spi)
 		spi->max_speed_hz = spi->master->max_speed_hz;
 
 	if (spi->master->setup)
-		status = spi->master->setup(spi);
+		status = spi->master->setup(spi);	
 
 	spi_set_cs(spi, false);
 
@@ -2355,10 +2388,10 @@ static int __spi_sync(struct spi_device *spi, struct spi_message *message,
 	DECLARE_COMPLETION_ONSTACK(done);
 	int status;
 	struct spi_master *master = spi->master;
-	unsigned long flags;
+	unsigned long flags;	
 
 	status = __spi_validate(spi, message);
-	if (status != 0)
+ 	if (status != 0)
 		return status;
 
 	message->complete = spi_complete;
@@ -2375,7 +2408,9 @@ static int __spi_sync(struct spi_device *spi, struct spi_message *message,
 	 * try to transfer in the calling context so special case.
 	 * This code would be less tricky if we could remove the
 	 * support for driver implemented message queues.
-	 */
+	 */	
+
+	
 	if (master->transfer == spi_queued_transfer) {
 		spin_lock_irqsave(&master->bus_lock_spinlock, flags);
 
@@ -2386,7 +2421,7 @@ static int __spi_sync(struct spi_device *spi, struct spi_message *message,
 		spin_unlock_irqrestore(&master->bus_lock_spinlock, flags);
 	} else {
 		status = spi_async_locked(spi, message);
-	}
+	}	
 
 	if (!bus_locked)
 		mutex_unlock(&master->bus_lock_mutex);
@@ -2406,7 +2441,7 @@ static int __spi_sync(struct spi_device *spi, struct spi_message *message,
 		wait_for_completion(&done);
 		status = message->status;
 	}
-	message->context = NULL;
+	message->context = NULL; 	
 	return status;
 }
 
diff --git a/drivers/staging/android/ion/ion.c b/drivers/staging/android/ion/ion.c
old mode 100644
new mode 100755
index 4adb113..0ec199c
--- a/drivers/staging/android/ion/ion.c
+++ b/drivers/staging/android/ion/ion.c
@@ -443,6 +443,7 @@ static struct ion_handle *ion_handle_get_by_id_nolock(struct ion_client *client,
 	struct ion_handle *handle;
 
 	handle = idr_find(&client->idr, id);
+	pr_debug("##ion_handle_get_by_id_nolock client=%p, handle=%p, buffer =%p, id=%d\n", client, handle, handle->buffer, id);
 	if (handle)
 		return ion_handle_get_check_overflow(handle);
 
@@ -1323,6 +1324,8 @@ static long ion_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)
 		data.allocation.handle = handle->id;
 
 		cleanup_handle = handle;
+		/* return physical addr and size of buffer that has allocated */
+		ret = ion_phys(client, handle,&(data.allocation.p_addr), &data.allocation.len);
 		break;
 	}
 	case ION_IOC_FREE:
diff --git a/drivers/staging/android/uapi/ion.h b/drivers/staging/android/uapi/ion.h
old mode 100644
new mode 100755
index 0a8e40f..df2383d
--- a/drivers/staging/android/uapi/ion.h
+++ b/drivers/staging/android/uapi/ion.h
@@ -96,6 +96,14 @@ struct ion_allocation_data {
 	unsigned int heap_id_mask;
 	unsigned int flags;
 	ion_user_handle_t handle;
+/*
+ * This should be removed some day when phys_addr_t's are fully
+ * plumbed in the kernel, and all instances of ion_phys_addr_t should
+ * be converted to phys_addr_t.  For the time being many kernel interfaces
+ * do not accept phys_addr_t's that would have to
+ */
+#define ion_phys_addr_t unsigned long
+	ion_phys_addr_t p_addr;
 };
 
 /**
diff --git a/drivers/tty/serial/Kconfig b/drivers/tty/serial/Kconfig
old mode 100644
new mode 100755
index f38beb2..8b5b160
--- a/drivers/tty/serial/Kconfig
+++ b/drivers/tty/serial/Kconfig
@@ -1478,6 +1478,20 @@ config SERIAL_EFM32_UART_CONSOLE
 	depends on SERIAL_EFM32_UART=y
 	select SERIAL_CORE_CONSOLE
 
+config SERIAL_AK_UART
+	tristate "AK serial port support"
+	select SERIAL_CORE
+	depends on (ARCH_AK39 || ARCH_AK)
+	help
+	AK Uart support.
+
+config SERIAL_AK_CONSOLE
+	bool "Console on AK serial port"
+	depends on SERIAL_AK_UART
+	select SERIAL_CORE_CONSOLE
+	help
+	Say Y here if you want enable console support on AK serial port.
+
 config SERIAL_TILEGX
 	tristate "TILE-Gx on-chip serial port support"
 	depends on TILEGX
diff --git a/drivers/tty/serial/Makefile b/drivers/tty/serial/Makefile
old mode 100644
new mode 100755
index 5ab4111..9c6d26c
--- a/drivers/tty/serial/Makefile
+++ b/drivers/tty/serial/Makefile
@@ -70,6 +70,7 @@ obj-$(CONFIG_SERIAL_KS8695) += serial_ks8695.o
 obj-$(CONFIG_SERIAL_OMAP) += omap-serial.o
 obj-$(CONFIG_SERIAL_ALTERA_UART) += altera_uart.o
 obj-$(CONFIG_SERIAL_ST_ASC) += st-asc.o
+obj-$(CONFIG_SERIAL_AK_UART)   += ak_uart.o
 obj-$(CONFIG_SERIAL_TILEGX) += tilegx.o
 obj-$(CONFIG_KGDB_SERIAL_CONSOLE) += kgdboc.o
 obj-$(CONFIG_SERIAL_QE) += ucc_uart.o
diff --git a/drivers/tty/serial/ak_uart.c b/drivers/tty/serial/ak_uart.c
new file mode 100755
index 0000000..345cbd6
--- /dev/null
+++ b/drivers/tty/serial/ak_uart.c
@@ -0,0 +1,1349 @@
+/*
+ * AKXX uart driver
+ *
+ * Copyright (C) 2018 Anyka(Guangzhou) Microelectronics Technology Co., Ltd.
+ *
+ * Author: Zhipeng Zhang <zhang_zhipeng@anyka.com>
+ * 		   Feilong_Dong   <dong_feilong@anyka.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#define pr_fmt(fmt) KBUILD_MODNAME ": " fmt
+
+#if defined(CONFIG_SERIAL_AK_CONSOLE) && defined(CONFIG_MAGIC_SYSRQ)
+#define SUPPORT_SYSRQ
+#endif
+
+#include <linux/module.h>
+#include <linux/ioport.h>
+#include <linux/platform_device.h>
+#include <linux/of.h>
+#include <linux/of_platform.h>
+#include <linux/init.h>
+#include <linux/sysrq.h>
+#include <linux/console.h>
+#include <linux/tty.h>
+#include <linux/tty_flip.h>
+#include <linux/serial_core.h>
+#include <linux/serial.h>
+#include <linux/delay.h>
+#include <linux/clk.h>
+#include <linux/cpufreq.h>
+
+#include <asm/io.h>
+#include <mach/irqs.h>
+#include <mach/map.h>
+
+#include "ak_uart.h"
+
+extern void printch(char);
+extern void printascii(const char *);
+
+
+#if 0
+#define dbg(x...)	printk(x)
+#else
+#define dbg(x...)	do {} while(0)
+#endif
+
+/* UART name definitions */
+#define NR_PORTS		2
+
+#define AK_SERIAL_NAME	"ttySAK"
+#define AK_SERIAL_MAJOR	204
+#define AK_SERIAL_MINOR	64
+
+
+#ifdef CONFIG_SERIAL_AK_CONSOLE
+
+static struct console ak_serial_console;
+
+#define AK_SERIAL_CONSOLE &ak_serial_console
+#else
+#define AK_SERIAL_CONSOLE NULL
+#endif
+
+struct ak_uart_port {
+	char			name[6];
+	struct uart_port	port;
+
+	unsigned char __iomem   *rxfifo_base;
+	unsigned char __iomem   *txfifo_base;
+
+	unsigned int		rxfifo_offset;
+	unsigned int		nbr_to_read;
+	unsigned int		timeout_cnt;
+
+	unsigned char		claimed;
+	struct clk		*clk;
+#ifdef CONFIG_CPU_FREQ
+	struct notifier_block freq_transition;
+#endif
+};
+
+/* macros to change one thing to another */
+#define tx_enabled(port)	((port)->unused[0])
+#define rx_enabled(port)	((port)->unused[1])
+
+static int uart_intevent_decode(unsigned long status, unsigned int maskbit, unsigned int statusbit)
+{
+	if ((status & 1<<maskbit) && (status & 1<<statusbit))
+		return 1;
+	else
+		return 0;
+}
+
+static inline void uart_subint_disable(struct ak_uart_port *ourport, unsigned long mask)
+{
+	unsigned long uart_reg;
+	
+	/* disable tx_end interrupt */
+	uart_reg = __raw_readl(ourport->port.membase + UART_CONF2);
+	uart_reg &= ~mask;
+	__raw_writel(uart_reg, ourport->port.membase + UART_CONF2);
+}
+
+static inline void uart_subint_enable(struct ak_uart_port *ourport, unsigned long unmask)
+{
+	unsigned long uart_reg;
+
+	/* enable tx_end interrupt */
+	uart_reg = __raw_readl(ourport->port.membase + UART_CONF2);
+	uart_reg |= unmask;
+	__raw_writel(uart_reg, ourport->port.membase + UART_CONF2);
+}
+
+static void uart_subint_clear(struct ak_uart_port *ourport, unsigned int subint)
+{
+	unsigned long uart_reg;
+
+	switch (subint) {
+
+	case TX_THR_INT:
+		uart_reg = __raw_readl(ourport->port.membase + UART_CONF2);
+		uart_reg |= (1<<subint);
+		__raw_writel(uart_reg, ourport->port.membase + UART_CONF2);
+	break;
+
+	case RX_THR_INT:
+		uart_reg = __raw_readl(ourport->port.membase + UART_CONF2);
+		uart_reg &= AKUART_INT_MASK;
+		uart_reg |= (1<<subint);
+		__raw_writel(uart_reg, ourport->port.membase + UART_CONF2);
+		break;
+	
+	case RECVDATA_ERR_INT:
+		uart_reg = __raw_readl(ourport->port.membase + UART_CONF2);
+		uart_reg &= AKUART_INT_MASK;
+		uart_reg |= (0x1 << subint);
+		__raw_writel(uart_reg, ourport->port.membase + UART_CONF2);
+		break;
+
+	case RX_TIMEOUT:
+		uart_reg = __raw_readl(ourport->port.membase + UART_CONF2);
+		uart_reg |= (0x1 << subint);
+		uart_reg &= ~( 0x1<<3 );
+		__raw_writel(uart_reg, ourport->port.membase + UART_CONF2); 
+		
+		/* start to receive data */
+		uart_reg = __raw_readl(ourport->port.membase + BUF_THRESHOLD);
+		uart_reg |= (1 << 31);
+		__raw_writel(uart_reg, ourport->port.membase + BUF_THRESHOLD);	
+		break;
+
+	default:
+		printk(KERN_ERR "akxx 9xx 9xx 9xx 9xx 9xx 9xx 9xx 9xx kown subint type: %d\n", subint);
+		break;
+	}
+
+	return;
+}
+
+static inline struct ak_uart_port *to_ourport(struct uart_port *port)
+{
+	return container_of(port, struct ak_uart_port, port);
+}
+
+static inline void uart_txend_interrupt(struct ak_uart_port *ourport, unsigned short status)
+{
+	unsigned long uart_reg;
+
+	/*handle Tx_end end interrupt */
+	uart_reg = __raw_readl(ourport->port.membase + UART_CONF2);
+	switch(status)
+	{
+		case ENABLE:
+			uart_reg |= (UARTN_CONFIG2_TX_END_INT_EN);
+			break;
+			
+		case DISABLE:
+			uart_reg &= ~(UARTN_CONFIG2_TX_END_INT_EN);
+			break;
+			
+		default:
+			break;
+	}
+	__raw_writel(uart_reg, ourport->port.membase + UART_CONF2);
+}
+
+/* clear a UARTn buffer status flag */
+static inline void clear_uart_buf_status(struct ak_uart_port *ourport, unsigned short status)
+{
+    unsigned long regval;
+	unsigned long flags;
+
+	local_irq_save(flags);
+	
+	regval = __raw_readl(AK_VA_L2CTRL + 0x8C);
+	switch(status)
+	{
+		case RX_STATUS: 
+			regval |= (0x1 << (17 + ourport->port.line * 2));
+			break;
+			
+		case TX_STATUS:
+			regval |= (0x1 << (16 + ourport->port.line * 2));
+			break;
+				
+		default:
+			break;
+    }
+	__raw_writel(regval,  AK_VA_L2CTRL + 0x8C);
+
+	local_irq_restore(flags);
+}
+
+/* clear TX and RX internal status */
+static inline void clear_internal_status(struct ak_uart_port *ourport, unsigned short status)
+{
+    unsigned long regval;
+	unsigned long flags;
+
+	local_irq_save(flags);
+	
+	regval = __raw_readl(ourport->port.membase + UART_CONF1);
+    switch(status)
+	{
+		case RX_STATUS:  
+			__raw_writel(regval | (0x1 << 29), ourport->port.membase + UART_CONF1);
+			break;
+
+		case TX_STATUS:
+			__raw_writel(regval | (0x1 << 28), ourport->port.membase + UART_CONF1);
+    		break;			
+			
+		default:
+			break;
+    }
+
+	local_irq_restore(flags);
+}
+
+/* clear TX_th and RX_th count interrupt */
+static inline void clear_Int_status(struct ak_uart_port *ourport, unsigned short status)
+{
+    unsigned long regval;
+	unsigned long flags;
+
+	local_irq_save(flags);
+	
+	regval = __raw_readl(ourport->port.membase + BUF_THRESHOLD);
+    switch(status)
+	{
+		case RX_STATUS:  
+			__raw_writel(regval | (0x1 << 5), ourport->port.membase + BUF_THRESHOLD);
+			break;
+
+		case TX_STATUS:
+			__raw_writel(regval | (0x1 << 11), ourport->port.membase + BUF_THRESHOLD);
+    		break;			
+			
+		default:
+			break;
+    }
+
+	local_irq_restore(flags);
+}
+
+
+/* enable/disable interrupt of  RX_th */
+static inline void uart_Rx_interrupt(struct ak_uart_port *ourport, unsigned short status)
+{
+    unsigned long regval;
+	unsigned long flags;
+
+	local_irq_save(flags);
+	
+	regval = __raw_readl(ourport->port.membase + UART_CONF2);
+	if(status)
+		__raw_writel(regval | (0x1 << RX_INTTERUPT), ourport->port.membase + UART_CONF2);
+	else
+		__raw_writel(regval & ~(0x1 << RX_INTTERUPT), ourport->port.membase + UART_CONF2);
+
+	local_irq_restore(flags);
+}
+
+
+static int uart_enable_clock(struct ak_uart_port *ourport, int enable)
+{
+	unsigned long regval;
+
+	regval = __raw_readl(AK_VA_SYSCTRL + 0x1C);
+
+	switch (ourport->port.line) {
+		case 0:
+			if (enable)
+				regval &= ~(1 << 7);
+			else 
+				regval |= (1 << 7);
+			
+		case 1:
+			if (enable)
+				regval &= ~(1 << 8);
+			else 
+				regval |= (1 << 8);
+			break;
+
+		default:
+			printk(KERN_ERR "unknown uart port\n");
+			return -1;
+	}
+	__raw_writel(regval, AK_VA_SYSCTRL + 0x1C);
+
+	return 0;
+}
+
+/* power management control */
+static void ak_serial_pm(struct uart_port *port, unsigned int level, unsigned int old)
+{
+	switch (level) {
+	case 3: /* disable */	
+		//dbg("%s: enterring pm level: %d\n", __FUNCTION__, level);
+		break;
+
+	case 0:	/* enable  */
+		//dbg("%s: enterring pm level: %d\n", __FUNCTION__, level);
+		break;
+
+	default:
+		dbg(KERN_ERR "akxx serial: unknown pm %d\n", level);
+		break;
+	}
+}
+
+/* is tx fifo empty */
+static unsigned int ak_serial_tx_empty(struct uart_port *port)
+{
+	unsigned long uart_reg;
+
+	uart_reg = __raw_readl(port->membase + UART_CONF2);
+
+	if (uart_reg & (1 << TXFIFO_EMPTY))
+		return 1;
+
+	return 0;
+}
+
+/* no modem control lines */
+static unsigned int ak_serial_get_mctrl(struct uart_port *port)
+{
+	/* FIXME */
+	dbg("%s\n", __FUNCTION__);
+	return 0;
+}
+
+static void ak_serial_set_mctrl(struct uart_port *port, unsigned int mctrl)
+{
+	/* todo - possibly remove AFC and do manual CTS */
+	dbg("%s\n", __FUNCTION__);
+}
+
+
+static void ak_serial_start_tx(struct uart_port *port)
+{
+	struct ak_uart_port *ourport = to_ourport(port);
+
+	dbg("%s\n", __FUNCTION__); 
+
+	if (!tx_enabled(port))
+	{
+		uart_txend_interrupt(ourport, ENABLE);
+		tx_enabled(port) = 1;
+	}
+}
+
+static void ak_serial_stop_tx(struct uart_port *port)
+{
+	struct ak_uart_port *ourport = to_ourport(port);
+
+	dbg("%s\n", __FUNCTION__); 
+
+	if (tx_enabled(port))
+   	{
+   		uart_txend_interrupt(ourport, DISABLE);
+		tx_enabled(port) = 0;
+	}
+}
+
+static void ak_serial_stop_rx(struct uart_port *port)
+{
+	struct ak_uart_port *ourport = to_ourport(port);
+
+	dbg("%s\n", __FUNCTION__);
+
+	if (rx_enabled(port))
+   	{
+		uart_Rx_interrupt(ourport, DISABLE);
+		rx_enabled(port) = 0;
+	}
+}
+
+static void ak_serial_enable_ms(struct uart_port *port)
+{
+	dbg("%s\n", __FUNCTION__);
+}
+
+static void ak_serial_break_ctl(struct uart_port *port, int break_state)
+{
+	dbg("%s\n", __FUNCTION__);
+}
+
+static irqreturn_t ak_uart_irqhandler(int irq, void *dev_id)
+{
+	struct ak_uart_port	*ourport = dev_id;
+	struct uart_port *port = &ourport->port;
+	struct circ_buf *xmit = &port->state->xmit;	    //&port->info->xmit;
+	//struct tty_struct *tty = port->state->port.tty;	//port->info->tty;
+	struct tty_port *tty = &(port->state->port);	//port->info->tty;
+
+	unsigned int flag= TTY_NORMAL;
+
+	unsigned char __iomem   *pbuf;
+	unsigned char *pxmitbuf;
+	unsigned long uart_status;
+	unsigned int rxcount = 0;
+	unsigned char ch = 0;
+	unsigned int i;
+	int txcount , tx_tail;
+	unsigned int l2_offset = 0;
+	unsigned long regval;
+
+	uart_status = __raw_readl(ourport->port.membase + UART_CONF2);
+
+	/* clear R_err interrupt */
+	if ( uart_intevent_decode(uart_status, RECVDATA_ERR_INT_ENABLE, RECVDATA_ERR_INT) )
+	{
+		uart_subint_clear(ourport, RECVDATA_ERR_INT);
+	}
+
+	if ( uart_intevent_decode(uart_status, TX_END_INTERRUPT, TX_END_STATUS) )
+	{
+		/* if there is not anything more to transmit, or the uart is now
+		 * stopped, disable the uart and exit
+		 */
+		if (uart_circ_empty(xmit) || uart_tx_stopped(port))
+		{
+			ak_serial_stop_tx(port);
+			goto rx_irq;
+		}
+
+		txcount = uart_circ_chars_pending(xmit);
+
+		if(txcount > 32)
+			txcount = 32;
+		pbuf = ourport->txfifo_base;
+		pxmitbuf = xmit->buf;
+
+		/* clear a uartx buffer status */
+		clear_uart_buf_status(ourport, TX_STATUS);
+
+		/* clear the tx internal status */
+		clear_internal_status(ourport, TX_STATUS);
+
+		__raw_writel(0x0, ourport->txfifo_base + 0x3C);
+
+		l2_offset = 0;
+		tx_tail = xmit->tail;
+		regval = 0;
+		for(i = 0; i < txcount; i++)
+		{
+			regval |= pxmitbuf[tx_tail]<<((i & 3) * 8 );
+			if((i & 3) == 3)
+			{
+				__raw_writel(regval, pbuf + l2_offset);
+				l2_offset = l2_offset + 4;
+				regval = 0;
+			}
+			tx_tail = (tx_tail + 1) & (UART_XMIT_SIZE - 1);
+			port->icount.tx += 1;
+		}
+		if(i & 3)
+		{
+			__raw_writel(regval, pbuf + l2_offset);
+		}
+
+		regval = (__raw_readl(ourport->port.membase + UART_CONF2)&(~UARTN_CONFIG2_TX_BYT_CNT_MASK)) | (UARTN_CONFIG2_TX_BYT_CNT(txcount))  | (UARTN_CONFIG2_TX_BYT_CNT_VLD);
+		__raw_writel(regval, ourport->port.membase + UART_CONF2);
+		xmit->tail = tx_tail;
+
+		if (uart_circ_chars_pending(xmit) < WAKEUP_CHARS)
+			uart_write_wakeup(port);
+
+		if (uart_circ_empty(xmit))
+			ak_serial_stop_tx(port);
+	}
+	
+rx_irq:
+
+	/* rx threshold interrupt */
+	if ( uart_intevent_decode(uart_status, RX_THR_INT_ENABLE, RX_THR_INT) ||
+		uart_intevent_decode(uart_status, RX_TIMEOUT_INT_ENABLE, RX_TIMEOUT))
+	{
+		if ( uart_intevent_decode(uart_status, RX_THR_INT_ENABLE, RX_THR_INT))
+			uart_subint_clear(ourport, RX_THR_INT);
+		else {
+			uart_subint_clear(ourport, RX_TIMEOUT);
+		}
+
+		while(__raw_readl(ourport->port.membase + UART_CONF2) & (UARTN_CONFIG2_MEM_RDY));
+		
+		ourport->nbr_to_read = (__raw_readl(ourport->port.membase + DATA_CONF)>>13) & 0x7f;
+
+		if (ourport->nbr_to_read  != ourport->rxfifo_offset) {
+			l2_offset = ourport->rxfifo_offset; 
+			pbuf = ourport->rxfifo_base + l2_offset;
+
+			/* copy data */
+			if (ourport->nbr_to_read > l2_offset) {
+            			rxcount = ourport->nbr_to_read - l2_offset;
+				for (i=0; i<rxcount; i++) {
+					ch = __raw_readb(pbuf + i);
+					uart_insert_char(port, 0, 0, ch, flag);
+				}	
+		        } else {
+				rxcount = (UART_RX_FIFO_SIZE - l2_offset);
+				for (i=0; i<rxcount; i++) {
+					ch = __raw_readb(pbuf + i);
+					uart_insert_char(port, 0, 0, ch, flag);
+				}
+			
+				pbuf = ourport->rxfifo_base;
+				for (i=0; i < ourport->nbr_to_read; i++) {
+					ch = __raw_readb(pbuf + i);
+					uart_insert_char(port, 0, 0, ch, flag);
+				}
+			}
+			ourport->rxfifo_offset = ourport->nbr_to_read;
+		}
+
+		tty_flip_buffer_push(tty);
+	}
+
+	return IRQ_HANDLED;
+
+}
+
+static void ak_serial_shutdown(struct uart_port *port)
+{
+	struct ak_uart_port *ourport = to_ourport(port);
+	unsigned int uart_reg = 0;
+	u32 regval;
+
+	/*
+	 * 1st, free irq.
+	 * 2nd, disable/mask hw uart setting.
+	 * 3rd, close uart clock.
+	 */
+	
+	/* mask all interrupt */
+	__raw_writel(0, ourport->port.membase + UART_CONF2);
+	
+	uart_reg = __raw_readl(ourport->port.membase + 0xc);
+	uart_reg  &= (~(1<<5));
+	__raw_writel(uart_reg, ourport->port.membase + 0xc);
+	uart_reg = __raw_readl(ourport->port.membase + 0x0);
+	uart_reg  &= (~(1<<29));
+	__raw_writel(uart_reg, ourport->port.membase + 0x0);
+	/* clear uartx interrupt */
+	uart_reg  &= (~1<<21);
+	__raw_writel(uart_reg, ourport->port.membase + 0x0);
+
+	/* clear uartn TX/RX buf status flag and call ak_setpin_as_gpio() */
+	switch(ourport->port.line) {
+		case 0:
+			regval = __raw_readl(rL2_CONBUF8_15);
+			regval |= (0x3<<16);
+			__raw_writel(regval, rL2_CONBUF8_15);
+			break;
+		case 1:
+			regval = __raw_readl(rL2_CONBUF8_15);
+			regval |= (0x3<<18);
+			__raw_writel(regval, rL2_CONBUF8_15);
+			break;
+	}	
+	free_irq(port->irq, ourport);	
+	uart_enable_clock(ourport, 0);
+}
+
+/*
+ * 1, setup gpio.
+ * 2, enable clock.
+ * 3, request irq and setting up uart control.
+ * 4, enable subirq.
+ */
+static int ak_serial_startup(struct uart_port *port)
+{
+	struct ak_uart_port *ourport = to_ourport(port);
+	unsigned long uart_reg;
+	int ret;
+
+	if ( rx_enabled(port) && tx_enabled(port))
+		return 0;
+
+	/* enable uart clock */
+	uart_enable_clock(ourport, 1);
+	
+	//clear L2 Buffer
+	clear_uart_buf_status(ourport, RX_STATUS);
+	
+	uart_reg = UARTN_CONFIG1_RTS_EN_BY_CIRCUIT | UARTN_CONFIG1_EN |UARTN_CONFIG1_RX_STA_CLR|UARTN_CONFIG1_TX_STA_CLR|UARTN_CONFIG1_TIMEOUT_EN;
+	__raw_writel(uart_reg, ourport->port.membase + UART_CONF1);
+
+	/* mask all interrupt */
+	__raw_writel(0, ourport->port.membase + UART_CONF2);
+
+	/*
+	 * config stop bit and timeout value
+	 * set timeout = 32, stop bit = 1;
+	 */
+	uart_reg = (0x1f << 16);
+	__raw_writel(uart_reg, ourport->port.membase + UART_STOPBIT_TIMEOUT);	
+
+
+   /* 
+      * set threshold to 32bytes 
+      * set RX_th_cfg_h = 0, set RX_th_cfg_l = 31
+      */
+	uart_reg = __raw_readl(ourport->port.membase + DATA_CONF);
+	uart_reg &= ~UARTN_RX_TH_CFG_H_MASK;
+	__raw_writel(uart_reg, ourport->port.membase + DATA_CONF);	
+	uart_reg = __raw_readl(ourport->port.membase + BUF_THRESHOLD);
+    uart_reg &= ~(UARTN_RX_TH_CFG_L_MASK);
+	uart_reg |= UARTN_RX_TH_CFG_L(0x1F);	/* 32 Bytes */
+	//uart_reg |= (1 << 11);
+	__raw_writel(uart_reg, ourport->port.membase + BUF_THRESHOLD);
+	
+	clear_internal_status(ourport, RX_STATUS);
+
+	/* ourport->rxfifo_offset = 0; */
+	ourport->rxfifo_offset = 0;
+
+   	/* to clear  RX_th count interrupt */
+	uart_reg = __raw_readl(ourport->port.membase + BUF_THRESHOLD);
+	uart_reg |= (UARTN_RX_TH_CLR);
+	__raw_writel(uart_reg, ourport->port.membase + BUF_THRESHOLD);
+	udelay(10);
+	uart_reg = __raw_readl(ourport->port.membase + BUF_THRESHOLD);
+	uart_reg &= ~(UARTN_RX_TH_CLR);
+	__raw_writel(uart_reg, ourport->port.membase + BUF_THRESHOLD);
+		udelay(10);
+	uart_reg = __raw_readl(ourport->port.membase + BUF_THRESHOLD);
+	uart_reg |= (UARTN_RX_START);
+	__raw_writel(uart_reg, ourport->port.membase + BUF_THRESHOLD);
+	
+
+    /*
+	 *  enable timeout, rx mem_rdy and rx_th tx_end interrupt 
+	 */
+	 uart_reg = (UARTN_CONFIG2_RX_TH_INT_EN|UARTN_CONFIG2_RX_BUF_FULL_INT_EN|UARTN_CONFIG2_TIMEOUT_INT_EN|UARTN_CONFIG2_R_ERR_INT_EN);
+	__raw_writel(uart_reg, ourport->port.membase + UART_CONF2);
+
+	rx_enabled(port) = 1;
+	tx_enabled(port) = 0;
+
+	/* register interrupt */
+	ret = request_irq(port->irq, ak_uart_irqhandler, 0/*IRQF_DISABLED*/, ourport->name, ourport);
+	if (ret) {
+		printk(KERN_ERR "can't request irq %d for %s\n", port->irq, ourport->name);
+		goto startup_err;
+	}
+	return 0;
+
+startup_err:
+	ak_serial_shutdown(port);
+	return ret;
+}
+
+static void ak_serial_set_termios(struct uart_port *port, 
+				struct ktermios *termios, struct ktermios *old)
+{
+	struct ak_uart_port *ourport = to_ourport(port);
+	unsigned int baud;
+	unsigned long flags;
+	unsigned long regval;
+	unsigned long asic_clk;
+
+	asic_clk = 120000000;
+
+	termios->c_cflag &= ~(HUPCL | CMSPAR);
+	termios->c_cflag |= CLOCAL;
+
+	/*
+	 * Ask the core to calculate the divisor for us.
+	 * min: 2.4kbps, max: 2.4Mbps
+	 */
+#ifdef CONFIG_AEC_DUMP_DEBUG
+            baud = 921600;
+#else
+	baud = uart_get_baud_rate(port, termios, old, 2400, 115200*20);
+#endif
+
+	spin_lock_irqsave(&port->lock, flags);
+
+	/* baudrate setting */
+	regval = __raw_readl(port->membase + UART_CONF1);
+	regval &= ~(0xffff);
+	regval &= ~(0x1 << 22);
+	regval |= ((asic_clk / baud - 1) & 0xffff);
+	regval |= (1 << 28) | (1 << 29);
+
+	if (asic_clk % baud)
+		regval |= (0x1 << 22);
+
+	ourport->rxfifo_offset = 0;
+
+	/* flow control setting */
+	if(port->line != 0)
+	{
+		if((termios->c_cflag & CRTSCTS)) /* directly */
+		{
+			switch (port->line) {
+			case 1:
+				//AK_GPIO_UART1_FLOW(1);
+ 				printk(KERN_WARNING "%s: Hardware flow control is open\n", __func__);				
+				break;
+			}
+			regval &= ~(1<<18|1<<19);
+		}
+		else  /* inversly */
+		{
+			switch(port->line) {
+			case 1:
+//				ak_setpin_as_gpio(8);
+//				ak_setpin_as_gpio(9);
+				break;
+			}
+			regval &= ~(1<<18|1<<19);
+		}
+	}
+
+	/* parity setting */
+	if (termios->c_cflag & PARENB) {
+		if (termios->c_cflag & PARODD)
+			regval |= (0x2 << 25);  /* odd parity */
+		else
+			regval |= (0x3 << 25);  /* evnt parity*/
+	}
+	__raw_writel(regval, port->membase + UART_CONF1);
+
+	/*
+	 * Update the per-port timeout.
+	 */
+	uart_update_timeout(port, termios->c_cflag, baud);
+
+	/*
+	 * Which character status flags should we ignore?
+	 */
+	port->ignore_status_mask = 0;
+
+	spin_unlock_irqrestore(&port->lock, flags);
+}
+
+static const char *ak_serial_type(struct uart_port *port)
+{
+	switch (port->type) 
+	{
+		case PORT_AK:
+			return "AK";
+		default:
+			return NULL;
+	}
+}
+
+static void ak_serial_release_port(struct uart_port *port)
+{
+	dbg("%s\n", __FUNCTION__);
+}
+
+static int ak_serial_request_port(struct uart_port *port)
+{
+	dbg("%s\n", __FUNCTION__);
+	return 0;
+}
+
+static void ak_serial_config_port(struct uart_port *port, int flags)
+{
+	struct ak_uart_port *ourport = to_ourport(port);
+
+	port->type = PORT_AK;
+	ourport->rxfifo_offset = 0;
+}
+
+/*
+ * verify the new serial_struct (for TIOCSSERIAL).
+ */
+static int
+ak_serial_verify_port(struct uart_port *port, struct serial_struct *ser)
+{
+	dbg("%s\n", __FUNCTION__);
+
+	return 0;
+}
+
+
+static struct uart_ops ak_serial_ops = {
+	.pm             = ak_serial_pm,
+	.tx_empty       = ak_serial_tx_empty,
+	.get_mctrl      = ak_serial_get_mctrl,
+	.set_mctrl      = ak_serial_set_mctrl,
+	.stop_tx        = ak_serial_stop_tx,
+	.start_tx       = ak_serial_start_tx,
+	.stop_rx        = ak_serial_stop_rx,
+	.enable_ms      = ak_serial_enable_ms,
+	.break_ctl      = ak_serial_break_ctl,
+	.startup        = ak_serial_startup,
+	.shutdown       = ak_serial_shutdown,
+	.set_termios    = ak_serial_set_termios,
+	.type           = ak_serial_type,
+	.release_port   = ak_serial_release_port,
+	.request_port   = ak_serial_request_port,
+	.config_port    = ak_serial_config_port,
+	.verify_port    = ak_serial_verify_port,
+};
+
+
+
+static struct ak_uart_port ak_serial_ports[NR_PORTS] = {
+	[0] = {
+        .rxfifo_base	= AK_UART0_RXBUF_BASE,
+		.txfifo_base	= AK_UART0_TXBUF_BASE,
+		.port = {
+			.lock		= __SPIN_LOCK_UNLOCKED(ak_serial_ports[0].port.lock),
+			.iotype		= UPIO_MEM,
+			.mapbase	= AK_UART0_PA_BASE,
+			.membase	= AK_UART0_BASE,
+			.irq		= IRQ_UART0,
+			.uartclk        = 0,
+	/*every buffer of L2 memory is divided into several block, 
+      each of which can store 64-byte data.*/
+			.fifosize       = 64,
+			.ops            = &ak_serial_ops,
+			.flags			= UPF_BOOT_AUTOCONF,
+			.line           = 0,
+		},
+	},
+	[1] = {
+		.rxfifo_base	= AK_UART1_RXBUF_BASE,
+		.txfifo_base	= AK_UART1_TXBUF_BASE,
+		.port = {
+			.lock		= __SPIN_LOCK_UNLOCKED(ak_serial_ports[1].port.lock),
+			.iotype		= UPIO_MEM,
+			.mapbase	= AK_UART1_PA_BASE,
+			.membase	= AK_UART1_BASE,
+			.irq		= IRQ_UART1,
+			.uartclk	= 0,
+	/*every buffer of L2 memory is divided into several block, 
+      each of which can store 64-byte data.*/			
+			.fifosize	= 64,
+			.ops		= &ak_serial_ops,
+			.flags		= UPF_BOOT_AUTOCONF,
+			.line		= 1,
+		},
+	},
+};
+
+static struct uart_driver ak_uart_drv = {
+	.owner		= THIS_MODULE,
+	.dev_name	= AK_SERIAL_NAME,
+	.driver_name	= AK_SERIAL_NAME,
+	.nr			= NR_PORTS,
+	.major		= AK_SERIAL_MAJOR,
+	.minor		= AK_SERIAL_MINOR,
+	.cons		= AK_SERIAL_CONSOLE,
+};
+
+#ifdef CONFIG_CPU_FREQ
+
+static int ak_serial_cpufreq_transition(struct notifier_block *nb,
+    unsigned long val, void *data)
+{
+    struct ak_uart_port *port;
+    struct uart_port *uport;
+
+    port = container_of(nb, struct ak_uart_port, freq_transition);
+    uport = &port->port;
+
+    if(val == CPUFREQ_PRECHANGE){
+        /* we should really shut the port down whilst the
+		 * frequency change is in progress. */
+    }
+    else if(val == CPUFREQ_POSTCHANGE) {
+
+        struct ktermios termios;
+        struct tty_struct *tty;
+
+        if (uport->state == NULL)
+            goto exit;
+
+        tty = uport->state->port.tty;
+        if (tty == NULL)
+            goto exit;
+
+        termios = tty->termios;
+        if (&termios == NULL) {
+            printk(KERN_WARNING "%s: no termios?\n", __func__);
+            goto exit;
+        }
+
+        ak_serial_set_termios(uport, &termios, NULL);
+    }
+exit:
+    return 0;
+
+}
+
+static inline int ak_serial_cpufreq_register(struct ak_uart_port *port)
+{
+    port->freq_transition.notifier_call = ak_serial_cpufreq_transition;
+
+    return cpufreq_register_notifier(&port->freq_transition,
+        CPUFREQ_TRANSITION_NOTIFIER);
+}
+
+static inline void ak_serial_cpufreq_unregister(struct ak_uart_port *port)
+{
+    cpufreq_unregister_notifier(&port->freq_transition,
+        CPUFREQ_TRANSITION_NOTIFIER);
+}
+#else
+static inline int ak_serial_cpufreq_register(struct ak_uart_port *port)
+{
+    return 0;
+}
+
+static inline void ak_serial_cpufreq_unregister(struct ak_uart_port *port)
+{
+}
+
+#endif
+
+
+/* ak_serial_init_port
+ *
+ * initialise a single serial port from the platform device given
+ */
+static int ak_serial_init_port(struct ak_uart_port *ourport,
+		struct platform_device *platdev)
+{
+	struct uart_port *port = &ourport->port;
+
+	if (platdev == NULL)
+		return -ENODEV;
+
+	/* setup info for port */
+	port->dev = &platdev->dev;
+
+	ourport->clk = clk_get(port->dev, "asic_clk");
+
+	return 0;
+}
+
+static int ak_serial_probe(struct platform_device *dev)
+{
+	struct ak_uart_port *ourport;
+	int ret = 0;
+    char uart_name[6];
+    struct resource *resource;
+
+	struct device_node *np = dev->dev.of_node;
+	dev->id = of_alias_get_id(np, "uart");
+
+    ourport = devm_kzalloc(&dev->dev, sizeof(*ourport), GFP_KERNEL);
+	if (!ourport) {
+		dev_err(&dev->dev, "Failed to allocate memory for tup\n");
+		return -ENOMEM;
+	}
+
+    resource = platform_get_resource(dev, IORESOURCE_MEM, 0);
+	if (!resource) {
+		dev_err(&dev->dev, "No IO memory resource\n");
+		return -ENODEV;
+	}
+    
+    sprintf(uart_name,"uart%d",dev->id);
+    strcpy(ourport->name,uart_name);
+    ourport->rxfifo_base	= AK_UART0_RXBUF_BASE + (dev->id)*0x100;
+	ourport->txfifo_base	= AK_UART0_TXBUF_BASE + (dev->id)*0x100;
+		
+    
+	ourport->port.ops = &ak_serial_ops;
+    ourport->port.lock		= __SPIN_LOCK_UNLOCKED(ak_serial_ports[0].port.lock);
+	ourport->port.iotype	= UPIO_MEM;
+	ourport->port.mapbase	= resource->start;
+	ourport->port.membase	= AK_UART0_BASE;
+	ourport->port.irq		= platform_get_irq(dev, 0);
+
+	ourport->port.flags		= UPF_BOOT_AUTOCONF;
+	ourport->port.line      = dev->id;
+
+    if (of_property_read_u32(dev->dev.of_node,
+			"fifosize",&ourport->port.fifosize)) {
+		dev_err(&dev->dev,"Unable to find fifosize in uart node.\n");
+		ret = -EFAULT;
+		goto probe_err;
+	}
+
+			
+	ret = ak_serial_init_port(ourport, dev);
+	if (ret < 0)
+		goto probe_err;
+
+	uart_add_one_port(&ak_uart_drv, &ourport->port);
+	
+	platform_set_drvdata(dev, &ourport->port);
+	
+	ret = ak_serial_cpufreq_register(ourport);
+	if(ret < 0)
+		dev_err(&dev->dev, "faild to add cpufreq notifier\n");
+	return 0;
+
+probe_err:
+	return ret;
+}
+
+static int ak_serial_remove(struct platform_device *dev)
+{
+	struct uart_port *port = (struct uart_port *)dev_get_drvdata(&dev->dev);
+
+	if (port) {		
+		ak_serial_cpufreq_unregister(to_ourport(port));
+		uart_remove_one_port(&ak_uart_drv, port);
+	}
+	return 0;
+}
+
+/* UART power management code */
+
+#ifdef CONFIG_PM
+
+static int ak_serial_suspend(struct platform_device *dev, pm_message_t state)
+{
+	struct uart_port *port = (struct uart_port *)dev_get_drvdata(&dev->dev);
+
+	if (port) 
+		uart_suspend_port(&ak_uart_drv, port);
+	return 0;
+}
+
+static int ak_serial_resume(struct platform_device *dev)
+{
+	struct uart_port *port = (struct uart_port *)dev_get_drvdata(&dev->dev);
+
+	if (port) 	
+		uart_resume_port(&ak_uart_drv, port);
+	return 0;
+}
+#else
+#define ak_serial_suspend NULL
+#define ak_serial_resume	NULL
+#endif
+
+static const struct of_device_id ak_uart_of_ids[] = {
+    { .compatible = "anyka,ak3916ev300-uart0" },
+	{ .compatible = "anyka,ak3790d-uart0" },
+	{ .compatible = "anyka,ak3790d-uart1" },
+	{ .compatible = "anyka,ak3790d-uart2" },
+	{ .compatible = "anyka,ak3790d-uart3" },
+	{},
+};
+MODULE_DEVICE_TABLE(of, ak_uart_of_ids);
+
+
+static struct platform_driver ak_serial_drv = {
+	.probe          = ak_serial_probe,
+	.remove         = ak_serial_remove,
+	.suspend        = ak_serial_suspend,
+	.resume         = ak_serial_resume,
+	.driver         = {
+		.name   = "ak-uart",
+        .of_match_table = of_match_ptr(ak_uart_of_ids),
+		.owner  = THIS_MODULE,
+	},
+};
+
+
+/* module initialisation code */
+static int __init ak_serial_modinit(void)
+{
+	int ret;
+
+	printk("AKxx uart driver init, (c) 2013 ANYKA\n");
+
+	//register 
+	ret = uart_register_driver(&ak_uart_drv);
+	if (ret < 0) {
+		printk(KERN_ERR "failed to register UART driver\n");
+		return -1;
+	}
+
+	platform_driver_register(&ak_serial_drv);
+
+	return 0;
+}
+
+static void __exit ak_serial_modexit(void)
+{
+	platform_driver_unregister(&ak_serial_drv);
+	
+	uart_unregister_driver(&ak_uart_drv);
+}
+
+module_init(ak_serial_modinit);
+module_exit(ak_serial_modexit);
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("anyka");
+MODULE_DESCRIPTION("Anyka Serial port driver");
+
+
+/************* Console code ************/
+#ifdef CONFIG_SERIAL_AK_CONSOLE
+
+struct uart_port *cons_uart;
+
+static inline void ak_uart_putchar(struct ak_uart_port *ourport, unsigned char ch)
+{
+	unsigned long regval;
+
+	/* clear the tx internal status */
+	clear_internal_status(ourport, TX_STATUS);
+
+	/* clear a uartx buffer status */
+	clear_uart_buf_status(ourport, TX_STATUS);
+
+	/*to inform the buf is full*/	
+	__raw_writel(ch, ourport->txfifo_base);
+	__raw_writel(0x0, ourport->txfifo_base + 0x3C);
+
+   	/* to clear  TX_th count interrupt */
+	clear_Int_status(ourport, TX_STATUS);
+
+	/* start to transmit */
+	regval = __raw_readl(ourport->port.membase + UART_CONF2);
+	regval &= AKUART_INT_MASK;
+	regval |= (0x1<<4) | (0x1<<16);
+	__raw_writel(regval, ourport->port.membase + UART_CONF2);
+	
+
+	/* wait for tx end */
+	while (!(__raw_readl(ourport->port.membase + UART_CONF2) & (1 << TX_END_STATUS)))
+		;
+}
+EXPORT_SYMBOL_GPL(cons_uart);
+
+static inline void ak_uart_send(struct ak_uart_port *ourport, const char *s, unsigned int count)
+{
+	unsigned long regval;
+    unsigned int left, trans_size;
+    int offset;
+    
+	/* clear the tx internal status */
+	clear_internal_status(ourport, TX_STATUS);
+
+	/* clear a uartx buffer status */
+	clear_uart_buf_status(ourport, TX_STATUS);
+
+    left = count;
+    
+    while (left)
+    {
+        trans_size = 128; // L2 buffer for UART is 128 bytes
+        if (left < trans_size)
+            trans_size = left;
+
+        if ((int)s & 0x3) // this should not happen
+            return;
+
+        // copy
+        for (offset=0; offset<trans_size; offset+=4)
+        {
+            __raw_writel(*(int *)(s+offset), ourport->txfifo_base + offset);
+        }
+        left -= trans_size;
+        s += trans_size;
+        
+        if ((offset&0x3f) != 0)
+        {// when an L2 block is not filled, write last dword to inform the buf is full   
+            __raw_writel(0x0, ourport->txfifo_base + offset - (offset&0x3f) + 0x3C);
+        }
+        
+        /* to clear  TX_th count interrupt */
+        clear_Int_status(ourport, TX_STATUS);
+        
+        /* start to transmit */
+        regval = __raw_readl(ourport->port.membase + UART_CONF2);
+        regval &= AKUART_INT_MASK;
+        regval |= (trans_size<<4) | (0x1<<16);
+        __raw_writel(regval, ourport->port.membase + UART_CONF2);
+        
+        /* wait for tx end */
+        while (!(__raw_readl(ourport->port.membase + UART_CONF2) & (1 << TX_END_STATUS)))
+            ;
+    }
+}
+
+static inline void ak_wait_for_txend(struct ak_uart_port *ourport)
+{
+	unsigned int timeout = 10000;
+
+	/*
+	 * Wait up to 10ms for the character(s) to be sent
+	 */
+    while (!(__raw_readl(ourport->port.membase + UART_CONF2) & (1 << TX_END_STATUS))) {
+        if (--timeout == 0)
+            break;
+        udelay(1);
+    }
+}
+
+static void
+ak_serial_console_putchar(struct uart_port *port, int ch)
+{
+	struct ak_uart_port *ourport = to_ourport(port);
+
+	ak_wait_for_txend(ourport);
+
+	ak_uart_putchar(ourport, ch);
+}
+
+static void
+ak_serial_console_write(struct console *co, const char *s, unsigned int count)
+{
+	uart_console_write(cons_uart, s, count, ak_serial_console_putchar);
+}
+
+void
+ak_serial_console_send(struct uart_port *port, const char *s, unsigned int count)
+{
+	struct ak_uart_port *ourport = to_ourport(port);
+
+	ak_wait_for_txend(ourport);
+    ak_uart_send(ourport, s, count);
+}
+EXPORT_SYMBOL_GPL(ak_serial_console_send);
+
+static void __init
+ak_serial_get_options(struct uart_port *port, int *baud, int *parity, int *bits)
+{
+
+#if 0
+	unsigned long regval;
+	struct clk *clk;
+
+	*bits	= 8;
+
+	regval = __raw_readl(port->membase + UART_CONF1);
+
+	if (regval & 0x1<<26) {
+		if (regval & 0x1<<25)
+			*parity = 'e';
+		else
+			*parity = 'o';
+	}
+	else
+		*parity = 'n';
+
+	clk = clk_get(port->dev, "asic_clk");
+	if (!IS_ERR(clk) && clk != NULL)
+		*baud = clk_get_rate(clk) / ((regval & 0xFFFF) + 1);
+
+	printk("calculated baudrate: %d\n", *baud);
+#endif
+}
+
+
+static int __init
+ak_serial_console_setup(struct console *co, char *options)
+{
+	struct uart_port *port;
+	int baud = 115200;
+	int bits = 8;
+	int parity = 'n';
+	int flow = 'n';
+
+	dbg("ak_serial_console_setup: co=%p (%d), %s\n", co, co->index, options);
+
+	port = &ak_serial_ports[co->index].port;
+
+	/* is this a valid port */
+
+	if (co->index == -1 || co->index >= NR_PORTS)
+		co->index = 0;
+
+	dbg("ak_serial_console_setup: port=%p (%d)\n", port, co->index);
+
+	cons_uart = port;
+
+	/*
+	 * Check whether an invalid uart number has been specified, and
+	 * if so, search for the first available port that does have
+	 * console support.
+	 */
+	if (options)
+		uart_parse_options(options, &baud, &parity, &bits, &flow);
+	else
+		ak_serial_get_options(port, &baud, &parity, &bits);
+
+	dbg("ak_serial_console_setup: baud %d\n", baud);
+
+	return uart_set_options(port, co, baud, parity, bits, flow);
+}
+
+
+static struct console ak_serial_console = {
+	.name		= AK_SERIAL_NAME,
+	.device		= uart_console_device,
+	.flags		= CON_PRINTBUFFER,
+	.index		= -1,
+	.write		= ak_serial_console_write,
+	.setup		= ak_serial_console_setup
+};
+
+
+/* ak_serial_initconsole
+ *
+ * initialise the console from one of the uart drivers
+*/
+static int ak_serial_initconsole(void)
+{
+	printk("AK console driver initial\n");
+
+	ak_serial_console.data = &ak_uart_drv;
+
+	register_console(&ak_serial_console);
+
+	return 0;
+}
+
+console_initcall(ak_serial_initconsole);
+
+#endif /* CONFIG_SERIAL_AK_CONSOLE */
+
diff --git a/drivers/tty/serial/ak_uart.h b/drivers/tty/serial/ak_uart.h
new file mode 100755
index 0000000..57a4ece
--- /dev/null
+++ b/drivers/tty/serial/ak_uart.h
@@ -0,0 +1,145 @@
+/*
+ * AKXX uart driver
+ *
+ * Copyright (C) 2018 Anyka(Guangzhou) Microelectronics Technology Co., Ltd.
+ *
+ * Author: Zhipeng Zhang <zhang_zhipeng@anyka.com>
+ *         Feilong_Dong   <dong_feilong@anyka.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+
+#ifndef __AK_UART_H_
+#define __AK_UART_H_
+
+/* Anyka AKxx UART */
+#define PORT_AK   101
+
+/* Anyka GPIO UART */
+#define PORT_GPIO   102
+
+#define AK_UART0_TXBUF_BASE	(AK_VA_L2MEM + 0x1000)
+#define AK_UART0_RXBUF_BASE	(AK_VA_L2MEM + 0x1080)
+#define AK_UART1_TXBUF_BASE	(AK_VA_L2MEM + 0x1100)
+#define AK_UART1_RXBUF_BASE	(AK_VA_L2MEM + 0x1180)
+
+#define AK_UART0_BASE			(AK_VA_UART + 0x0000)
+#define AK_UART1_BASE			(AK_VA_UART + 0x8000)
+
+#define AK_UART0_PA_BASE		(AK_PA_UART + 0x0000)
+#define AK_UART1_PA_BASE		(AK_PA_UART + 0x8000)
+
+
+#define UART_CONF1			    (0x00)
+#define	UART_CONF2			    (0x04)
+#define	DATA_CONF			    (0x08)
+#define	BUF_THRESHOLD		    (0x0C)
+#define	UART_RXBUF			    (0x10)
+#define UART_STOPBIT_TIMEOUT    (0x18)
+
+#define RX_THR_INT_ENABLE		(28)
+#define TX_END_INTERRUPT		(27)
+#define TXBUF_EMP_INT_ENABLE	(24)
+#define RECVDATA_ERR_INT_ENABLE	(23)
+#define RX_TIMEOUT_INT_ENABLE	(22)
+#define	MEM_RDY_INT_ENABLE		(21)
+#define TX_THR_INT			(31)
+#define RX_THR_INT			(30)
+#define	TX_END_STATUS		(19)
+#define	RX_OV				(18)
+#define	MEM_RDY_INT			(17)
+#define TX_BYT_CNT_VLD		(16)
+#define RECVDATA_ERR_INT	(3)
+#define	RX_TIMEOUT			(2)
+#define RXBUF_FULL			(1)
+#define TXFIFO_EMPTY		(0)
+
+#define TX_INTTERUPT		(29)
+#define RX_INTTERUPT		(28)
+
+#define	TX_STATUS		    (1)
+#define	RX_STATUS	    	(0)
+#define DISABLE		    	(0)
+#define ENABLE			    (1)
+#define	AKUART_INT_MASK		0x3FE00000
+#define UART_RX_FIFO_SIZE	128
+
+// Configuration Register 1 of UARTn
+#define UARTN_CONFIG1_DIV_CNT(cnt)          ((cnt) & 0xffff)
+#define UARTN_CONFIG1_UTD_INVERSELY         (1 << 16)
+#define UARTN_CONFIG1_URD_INVERSELY         (1 << 17)
+#define UARTN_CONFIG1_CTS_INVERSELY         (1 << 18)
+#define UARTN_CONFIG1_RTS_INVERSELY         (1 << 19)
+#define UARTN_CONFIG1_RTS_EN_BY_CIRCUIT     (1 << 20)
+#define UARTN_CONFIG1_EN                    (1 << 21)
+#define UARTN_CONFIG1_DIV_ADJ_EN            (1 << 22)
+#define UARTN_CONFIG1_TIMEOUT_EN            (1 << 23)
+#define UARTN_CONFIG1_PAR_EVEN              (1 << 25)
+#define UARTN_CONFIG1_PAR_EN                (1 << 26)
+#define UARTN_CONFIG1_ENDIAN_BIG            (1 << 27)
+#define UARTN_CONFIG1_TX_STA_CLR            (1 << 28)
+#define UARTN_CONFIG1_RX_STA_CLR            (1 << 29)
+#define UARTN_RX_ADDR_CLR					(1 << 30)
+#define UARTN_TX_ADDR_CLR					(1 << 31)
+
+// Configuration Register 2 of UARTn
+#define UARTN_CONFIG2_TX_FIFO_EMPTY         (1 << 0)  // read only
+#define UARTN_CONFIG2_RX_BUF_FULL           (1 << 1)  // write clear
+#define UARTN_CONFIG2_TIMEOUT               (1 << 2)  // write clear
+#define UARTN_CONFIG2_R_ERR                 (1 << 3)  // write clear
+#define UARTN_CONFIG2_TX_BYT_CNT(cnt)       (cnt << 4)
+#define UARTN_CONFIG2_TX_BYT_CNT_MASK       (0xfff << 4)
+#define UARTN_CONFIG2_TX_BYT_CNT_VLD        (1 << 16) // auto clear
+#define UARTN_CONFIG2_MEM_RDY               (1 << 17) // read only
+
+#define UARTN_CONFIG2_TX_END                (1 << 19) // read only
+
+#define UARTN_CONFIG2_RX_BUF_FULL_INT_EN    (1 << 21)
+#define UARTN_CONFIG2_TIMEOUT_INT_EN        (1 << 22)
+#define UARTN_CONFIG2_R_ERR_INT_EN          (1 << 23)
+#define UARTN_CONFIG2_TX_BUF_EMP_INT_EN     (1 << 24)
+
+#define UARTN_CONFIG2_TX_END_INT_EN         (1 << 27)
+#define UARTN_CONFIG2_RX_TH_INT_EN          (1 << 28)
+#define UARTN_CONFIG2_TX_TH_INT_EN          (1 << 29)
+
+#define UARTN_CONFIG2_RX_TH_STA             (1 << 30) // write clear
+#define UARTN_CONFIG2_TX_TH_STA             (1 << 31) // write clear
+
+// Data Configuration Register of UARTn
+#define UARTN_DATACONFIG_TX_BYT_SUM(rval)   	((rval) & 0x1FFF)
+#define UARTN_DATACONFIG_RX_ADR(rval)       	(((rval) >> 13) & 0x7F)
+#define UARTN_DATACONFIG_TX_ADR(rval)       	(((rval) >> 20) & 0x1F)
+#define UARTN_RX_TH_CFG_H_MASK              	(0x7f >> 25)
+#define UARTN_RX_TH_CFG_H(value)                (((value & 0x7f) >> 25))
+
+
+// TX RX Data Threshold Resgister
+#define UARTN_RX_TH_CFG_L_MASK              (0x1f)
+#define UARTN_RX_TH_CFG_L(value)            (value)
+
+#define UARTN_RX_TH_CLR                     (1 << 5)
+#define UARTN_TX_TH_CFG(value)              (((value) & 0x1f) << 6)
+#define UARTN_TX_TH_CLR                     (1 << 11)
+#define UARTN_RX_TH_CNT(rvalue)             (((rvalue) >> 12) & 0xFFF)   // read only
+#define UARTN_TX_TH_CNT(rvalue)             (((rvalue) >> 24) & 0x1F)   // read only
+#define UARTN_BFIFO_BYTE_NUM(rvalue)		(((rvalue) >> 29) & 0x03)   // read only
+#define UARTN_RX_START						(1 <<31)
+
+#define rL2_CONBUF8_15          (AK_VA_L2CTRL + 0x8C) 
+
+//Stop Bit Timeout Configuration Register
+
+#define UARTN_BIT_CFG(value)				((value) & 0x1ff)
+#define UARTN_TIME_OUT_CFG(value)			(((value) >> 16) & 0x0ffff)
+
+#endif  /* end __AK_UART_H_ */
diff --git a/drivers/watchdog/Kconfig b/drivers/watchdog/Kconfig
old mode 100644
new mode 100755
index 1c427be..c05fd0b
--- a/drivers/watchdog/Kconfig
+++ b/drivers/watchdog/Kconfig
@@ -407,6 +407,18 @@ config TWL4030_WATCHDOG
 	  Support for TI TWL4030 watchdog.  Say 'Y' here to enable the
 	  watchdog timer support for TWL4030 chips.
 
+config AK_WATCHDOG_TOP
+	tristate "TOP"
+	depends on ARCH_AK39 || ARCH_AK
+	help
+	  Say Y here if you are using the top watchdog
+
+config AK_WATCHDOG_NONE
+	tristate "NONE"
+	depends on ARCH_AK39 || ARCH_AK
+	help
+	  Say Y here if you are not useing any watchdog
+
 config STMP3XXX_RTC_WATCHDOG
 	tristate "Freescale STMP3XXX & i.MX23/28 watchdog"
 	depends on RTC_DRV_STMP
diff --git a/drivers/watchdog/Makefile b/drivers/watchdog/Makefile
old mode 100644
new mode 100755
index 53d4827..1c552a7
--- a/drivers/watchdog/Makefile
+++ b/drivers/watchdog/Makefile
@@ -192,3 +192,4 @@ obj-$(CONFIG_WM8350_WATCHDOG) += wm8350_wdt.o
 obj-$(CONFIG_MAX63XX_WATCHDOG) += max63xx_wdt.o
 obj-$(CONFIG_SOFT_WATCHDOG) += softdog.o
 obj-$(CONFIG_MENF21BMC_WATCHDOG) += menf21bmc_wdt.o
+obj-$(CONFIG_AK_WATCHDOG_TOP) += ak_top_wdt.o
diff --git a/drivers/watchdog/ak_top_wdt.c b/drivers/watchdog/ak_top_wdt.c
new file mode 100755
index 0000000..e1d9f39
--- /dev/null
+++ b/drivers/watchdog/ak_top_wdt.c
@@ -0,0 +1,326 @@
+/*
+ * drivers/char/watchdog/ak_top_wdt.c
+ *
+ * Watchdog driver for ANYKA H3D processors
+ *
+ * Author: zhang zhipeng
+ *
+ * Adapted from the IXP2000 watchdog driver by Lennert Buytenhek.
+ * The original version carries these notices:
+ *
+ * Author: Deepak Saxena <dsaxena@plexity.net>
+ *
+ * Copyright 2004 (c) MontaVista, Software, Inc.
+ * Based on sa1100 driver, Copyright (C) 2000 Oleg Drokin <green@crimea.edu>
+ *
+ * This file is licensed under  the terms of the GNU General Public
+ * License version 2. This program is licensed "as is" without any
+ * warranty of any kind, whether express or implied.
+ */
+
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/fs.h>
+#include <linux/miscdevice.h>
+#include <linux/watchdog.h>
+#include <linux/init.h>
+#include <linux/bitops.h>
+#include <linux/uaccess.h>
+#include <linux/reboot.h>
+
+#include <mach/map.h>
+#include <linux/platform_device.h>
+#include <linux/of.h>
+#include <linux/of_platform.h>
+#include <asm/io.h>
+
+#define UNIT_NS  21333
+/* 1 seconed = 1000000*64/3  */
+#define WATCH_DOG_1_SECOND_SET	(1000000000 / UNIT_NS)
+/* max feed dog time = 0xffffff* 21333 ~= 357S */
+#define MAX_FEED_DOG 357
+
+static int nowayout = WATCHDOG_NOWAYOUT;
+static unsigned int heartbeat = 0;
+static unsigned int def_heartbeat = 0;
+static unsigned int now_heartbeat = 0;
+
+#define MODULE_RESET_CON1       (AK_VA_SYSCTRL + 0x20)
+#define MODULE_WDT_CFG1	(AK_VA_SYSCTRL + 0xe4)
+#define MODULE_WDT_CFG2	(AK_VA_SYSCTRL + 0Xe8)
+
+static unsigned long in_use;
+static atomic_t in_write = ATOMIC_INIT(0);
+static DEFINE_SPINLOCK(wdt_lock);
+
+static int ak_wdt_disable_nb(struct notifier_block *n, unsigned long state,void *cmd);
+static struct notifier_block ak_wdt_nb = {
+	.notifier_call = ak_wdt_disable_nb,
+};
+
+module_param(def_heartbeat, int, 0);
+MODULE_PARM_DESC(def_heartbeat, "Watchdog heartbeat in seconds");
+
+module_param(nowayout, int, 0);
+MODULE_PARM_DESC(nowayout, "Watchdog cannot be stopped once started");
+
+void wdt_enable(void)
+{
+    u32 regval;
+    
+	unsigned int cfg_val = (unsigned int)def_heartbeat;
+	spin_lock(&wdt_lock);	
+	/* configure the watchdog time*/
+	regval = __raw_readl(MODULE_WDT_CFG1);
+    regval = ((0x55 << 24) | cfg_val);
+    __raw_writel(regval,MODULE_WDT_CFG1);
+    /* enable watchdog */
+	regval = __raw_readl(MODULE_WDT_CFG2);
+    regval = ((0xaa << 24) | 0x1);
+    __raw_writel(regval,MODULE_WDT_CFG2);
+    /* start watchdog */
+	regval = __raw_readl(MODULE_WDT_CFG2);
+	regval = ((0xaa << 24) | 0x3);
+    __raw_writel(regval,MODULE_WDT_CFG2);
+     
+	spin_unlock(&wdt_lock);
+}
+
+static void wdt_disable(void)
+{
+	u32 regval;
+    
+	pr_debug("%s\n", __func__);
+	spin_lock(&wdt_lock);
+    
+	regval = __raw_readl(MODULE_WDT_CFG2);
+    regval = ((0xaa << 24));
+    __raw_writel(regval,MODULE_WDT_CFG2);
+    
+	spin_unlock(&wdt_lock);
+}
+
+ /* feed watchdog time setting and enable watchdog. */
+void wdt_keepalive(unsigned int heartbeat)
+{
+    u32 regval;
+	unsigned int cfg_val = (unsigned int)heartbeat;	
+
+    spin_lock(&wdt_lock);
+    /* configure the watchdog time*/
+    regval = __raw_readl(MODULE_WDT_CFG1);
+    regval = ((0x55 << 24) | cfg_val);
+    __raw_writel(regval,MODULE_WDT_CFG1);
+    /* enable watchdog */
+	regval = __raw_readl(MODULE_WDT_CFG2);
+    regval = ((0xaa << 24) | 0x1);
+    __raw_writel(regval,MODULE_WDT_CFG2);
+    /* feed watchdog */
+	regval = __raw_readl(MODULE_WDT_CFG2);
+    regval = ((0xaa << 24) | 0x3);
+    __raw_writel(regval,MODULE_WDT_CFG2);
+    
+	spin_unlock(&wdt_lock);
+}
+
+static int ak_wdt_disable_nb(struct notifier_block *n, unsigned long state,void *cmd)
+{
+        wdt_disable();
+        return NOTIFY_DONE;
+}
+
+static struct watchdog_info ident = {
+	.options	= WDIOF_MAGICCLOSE | WDIOF_SETTIMEOUT | WDIOF_KEEPALIVEPING,
+	.identity	= "ANYKA ak Watchdog",
+};
+
+static long ak_wdt_ioctl(struct file *file, unsigned int cmd,
+							unsigned long arg)
+{
+	void __user *argp = (void __user *)arg;
+	int __user *p = argp;
+	int ret = -ENOTTY;
+	int time;
+
+	switch (cmd) {
+
+	case WDIOC_GETSUPPORT:
+		return copy_to_user((struct watchdog_info *)argp, &ident,
+				   sizeof(ident)) ? -EFAULT : 0;
+	case WDIOC_GETSTATUS:
+	case WDIOC_GETBOOTSTATUS:
+		return put_user(0, p);
+
+	case WDIOC_KEEPALIVE:
+		wdt_keepalive(now_heartbeat);
+		return 0;
+
+	case WDIOC_SETTIMEOUT:
+		if(get_user(time, p))
+			return -EFAULT;
+
+		if(time == -1)
+		{
+			pr_debug("\n[close watch_dog]\n");
+			wdt_disable();
+			nowayout = 0;
+			atomic_set(&in_write, 0);
+			pr_debug("\n[MODULE_WDT_CFG2]:0x%08x\n",__raw_readl(MODULE_WDT_CFG2));
+			return 0;
+		}
+		
+		if (time > MAX_FEED_DOG){
+            pr_debug("\n[Beyond the limits of feeddog time.]\n");
+			return -EINVAL;
+        }
+
+		now_heartbeat = time * WATCH_DOG_1_SECOND_SET;
+		wdt_keepalive(now_heartbeat);
+		return 0;
+
+	case WDIOC_GETTIMEOUT:
+		return put_user((now_heartbeat + 1) / WATCH_DOG_1_SECOND_SET, p);
+
+	default:
+		return -ENOTTY;
+	}
+
+	return ret;
+}
+
+
+static ssize_t ak_wdt_write(struct file *file, const char *data, size_t len, loff_t *ppos)
+{
+	if (len) {
+		size_t i;
+
+		atomic_set(&in_write, 1);
+		for (i = 0; i != len; i++) {
+			char c;
+
+			if (get_user(c, data + i))
+				return -EFAULT;
+			if (c == 'V') {
+				pr_debug("Detect \"V\" Magic Character\n");
+				atomic_set(&in_write, 0);
+			}
+		}
+		wdt_keepalive(def_heartbeat);
+	}
+
+	return len;
+}
+
+static int ak_wdt_open(struct inode *inode, struct file *file)
+{
+	if (test_and_set_bit(0, &in_use))
+		return -EBUSY;
+	
+	if (nowayout)
+		__module_get(THIS_MODULE);
+
+	wdt_enable();
+
+	return nonseekable_open(inode, file);
+}
+
+static int ak_wdt_release(struct inode *inode, struct file *file)
+{
+	if (nowayout)
+		pr_info("WATCHDOG: Driver support nowayout option -"
+							"no way to disable watchdog\n");
+	else if (atomic_read(&in_write))
+		pr_info("WATCHDOG: Device closed unexpectedly - "
+							"timer will not stop\n");
+	else
+		wdt_disable();
+	clear_bit(0, &in_use);
+
+	return 0;
+}
+
+static const struct file_operations ak_wdt_fops = {
+	.owner		= THIS_MODULE,
+	.llseek		= no_llseek,
+	.write		= ak_wdt_write,
+	.unlocked_ioctl	= ak_wdt_ioctl,
+	.open		= ak_wdt_open,
+	.release	= ak_wdt_release,
+};
+
+static struct miscdevice ak_wdt_miscdev = {
+	.minor		= WATCHDOG_MINOR,
+	.name		= "watchdog",
+	.fops		= &ak_wdt_fops,
+};
+
+static int ak_watchdog_probe(struct platform_device *pdev)
+{
+
+	int ret = 0;
+	
+    pr_info("ak_wdt_init: watchdog register...\n");
+	register_reboot_notifier(&ak_wdt_nb);
+
+    ret = of_property_read_u32(pdev->dev.of_node, "def_heartbeat",
+				   &heartbeat);
+	if (ret < 0) {
+		dev_warn(&pdev->dev,
+			 "Could not read linein-detect property\n");
+	} 
+
+    def_heartbeat = heartbeat * WATCH_DOG_1_SECOND_SET;
+    now_heartbeat = heartbeat * WATCH_DOG_1_SECOND_SET;
+    
+	ret = misc_register(&ak_wdt_miscdev);
+	if(ret) {
+		pr_info("%s reg miscdev failed.\n", __func__);
+		ret = -ENOENT;
+	}
+    
+    return ret;
+}
+
+static int ak_watchdog_remove(struct platform_device *pdev)
+{
+	unregister_reboot_notifier(&ak_wdt_nb);
+
+	misc_deregister(&ak_wdt_miscdev);
+
+	return 0;
+}
+
+static const struct of_device_id ak_watchdog_of_ids[] = {
+	{ .compatible = "anyka,ak3916ev300-wdt" },
+    { .compatible = "anyka,ak3790d-wdt" },
+	{},
+};
+MODULE_DEVICE_TABLE(of, ak_watchdog_of_ids);
+
+static struct platform_driver ak_watchdog_driver = {
+	.driver		= {
+		.name	= "ak-watchdog",
+        .of_match_table = of_match_ptr(ak_watchdog_of_ids),
+		.owner	= THIS_MODULE,
+	},
+	.probe		= ak_watchdog_probe,
+	.remove		= ak_watchdog_remove,
+};
+
+static int __init ak_wdt_init(void)
+{	
+	return platform_driver_register(&ak_watchdog_driver);
+}
+
+static void __exit ak_wdt_exit(void)
+{
+	platform_driver_unregister(&ak_watchdog_driver);
+}
+module_init(ak_wdt_init);
+module_exit(ak_wdt_exit);
+
+MODULE_DESCRIPTION("ANYKA ak Watchdog driver");
+MODULE_LICENSE("GPL");
+MODULE_ALIAS_MISCDEV(WATCHDOG_MINOR);
diff --git a/fs/Kconfig b/fs/Kconfig
old mode 100644
new mode 100755
index 6ce72d8..38dbd9a
--- a/fs/Kconfig
+++ b/fs/Kconfig
@@ -205,6 +205,7 @@ source "fs/befs/Kconfig"
 source "fs/bfs/Kconfig"
 source "fs/efs/Kconfig"
 source "fs/jffs2/Kconfig"
+source "fs/yaffs2/Kconfig"
 # UBIFS File system configuration
 source "fs/ubifs/Kconfig"
 source "fs/logfs/Kconfig"
diff --git a/fs/Makefile b/fs/Makefile
old mode 100644
new mode 100755
index 79f5225..3e4c0d0
--- a/fs/Makefile
+++ b/fs/Makefile
@@ -126,3 +126,6 @@ obj-y				+= exofs/ # Multiple modules
 obj-$(CONFIG_CEPH_FS)		+= ceph/
 obj-$(CONFIG_PSTORE)		+= pstore/
 obj-$(CONFIG_EFIVAR_FS)		+= efivarfs/
+
+# Patched by YAFFS
+obj-$(CONFIG_YAFFS_FS)		+= yaffs2/
diff --git a/fs/yaffs2/Kconfig b/fs/yaffs2/Kconfig
new file mode 100755
index 0000000..aac0dbf
--- /dev/null
+++ b/fs/yaffs2/Kconfig
@@ -0,0 +1,171 @@
+#
+# YAFFS file system configurations
+#
+
+config YAFFS_FS
+	tristate "YAFFS2 file system support"
+	default y
+	depends on MTD_BLOCK
+	select YAFFS_YAFFS1
+	select YAFFS_YAFFS2
+	help
+	  YAFFS2, or Yet Another Flash Filing System, is a filing system
+	  optimised for NAND Flash chips.
+
+	  To compile the YAFFS2 file system support as a module, choose M
+	  here: the module will be called yaffs2.
+
+	  If unsure, say N.
+
+	  Further information on YAFFS2 is available at
+	  <http://www.aleph1.co.uk/yaffs/>.
+
+config YAFFS_YAFFS1
+	bool "512 byte / page devices"
+	depends on YAFFS_FS
+	default y
+	help
+	  Enable YAFFS1 support -- yaffs for 512 byte / page devices
+
+	  Not needed for 2K-page devices.
+
+	  If unsure, say Y.
+
+config YAFFS_9BYTE_TAGS
+	bool "Use older-style on-NAND data format with pageStatus byte"
+	depends on YAFFS_YAFFS1
+	default n
+	help
+
+	  Older-style on-NAND data format has a "pageStatus" byte to record
+	  chunk/page state.  This byte is zero when the page is discarded.
+	  Choose this option if you have existing on-NAND data using this
+	  format that you need to continue to support.  New data written
+	  also uses the older-style format.  Note: Use of this option
+	  generally requires that MTD's oob layout be adjusted to use the
+	  older-style format.  See notes on tags formats and MTD versions
+	  in yaffs_mtdif1.c.
+
+	  If unsure, say N.
+
+config YAFFS_DOES_ECC
+	bool "Lets Yaffs do its own ECC"
+	depends on YAFFS_FS && YAFFS_YAFFS1 && !YAFFS_9BYTE_TAGS
+	default n
+	help
+	  This enables Yaffs to use its own ECC functions instead of using
+	  the ones from the generic MTD-NAND driver.
+
+	  If unsure, say N.
+
+config YAFFS_ECC_WRONG_ORDER
+	bool "Use the same ecc byte order as Steven Hill's nand_ecc.c"
+	depends on YAFFS_FS && YAFFS_DOES_ECC && !YAFFS_9BYTE_TAGS
+	default n
+	help
+	  This makes yaffs_ecc.c use the same ecc byte order as Steven
+	  Hill's nand_ecc.c. If not set, then you get the same ecc byte
+	  order as SmartMedia.
+
+	  If unsure, say N.
+
+config YAFFS_YAFFS2
+	bool "2048 byte (or larger) / page devices"
+	depends on YAFFS_FS
+	default y
+	help
+	  Enable YAFFS2 support -- yaffs for >= 2K bytes per page devices
+
+	  If unsure, say Y.
+
+config YAFFS_AUTO_YAFFS2
+	bool "Autoselect yaffs2 format"
+	depends on YAFFS_YAFFS2
+	default y
+	help
+	  Without this, you need to explicitely use yaffs2 as the file
+	  system type. With this, you can say "yaffs" and yaffs or yaffs2
+	  will be used depending on the device page size (yaffs on
+	  512-byte page devices, yaffs2 on 2K page devices).
+
+	  If unsure, say Y.
+
+config YAFFS_DISABLE_TAGS_ECC
+	bool "Disable YAFFS from doing ECC on tags by default"
+	depends on YAFFS_FS && YAFFS_YAFFS2
+	default n
+	help
+	  This defaults Yaffs to using its own ECC calculations on tags instead of
+	  just relying on the MTD.
+	  This behavior can also be overridden with tags_ecc_on and
+	  tags_ecc_off mount options.
+
+	  If unsure, say N.
+
+config YAFFS_ALWAYS_CHECK_CHUNK_ERASED
+	bool "Force chunk erase check"
+	depends on YAFFS_FS
+	default n
+	help
+          Normally YAFFS only checks chunks before writing until an erased
+	  chunk is found. This helps to detect any partially written
+	  chunks that might have happened due to power loss.
+
+	  Enabling this forces on the test that chunks are erased in flash
+	  before writing to them. This takes more time but is potentially
+	  a bit more secure.
+
+	  Suggest setting Y during development and ironing out driver
+	  issues etc. Suggest setting to N if you want faster writing.
+
+	  If unsure, say Y.
+
+config YAFFS_EMPTY_LOST_AND_FOUND
+	bool "Empty lost and found on boot"
+	depends on YAFFS_FS
+	default n
+	help
+	  If this is enabled then the contents of lost and found is
+	  automatically dumped at mount.
+
+	  If unsure, say N.
+
+config YAFFS_DISABLE_BLOCK_REFRESHING
+	bool "Disable yaffs2 block refreshing"
+	depends on YAFFS_FS
+	default n
+	help
+	 If this is set, then block refreshing is disabled.
+	 Block refreshing infrequently refreshes the oldest block in
+	 a yaffs2 file system. This mechanism helps to refresh flash to
+	 mitigate against data loss. This is particularly useful for MLC.
+
+	  If unsure, say N.
+
+config YAFFS_DISABLE_BACKGROUND
+	bool "Disable yaffs2 background processing"
+	depends on YAFFS_FS
+	default n
+	help
+	 If this is set, then background processing is disabled.
+	 Background processing makes many foreground activities faster.
+
+	 If unsure, say N.
+
+config YAFFS_DISABLE_BAD_BLOCK_MARKING
+	bool "Disable yaffs2 bad block marking"
+	depends on YAFFS_FS
+	default n
+	help
+	 Useful during early flash bring up to prevent problems causing
+	 lots of bad block marking.
+
+	 If unsure, say N.
+
+config YAFFS_XATTR
+	bool "Enable yaffs2 xattr support"
+	depends on YAFFS_FS
+	default y
+	help
+	 If this is set then yaffs2 will provide xattr support.
+	 If unsure, say Y.
diff --git a/fs/yaffs2/Makefile b/fs/yaffs2/Makefile
new file mode 100755
index 0000000..fc03c80
--- /dev/null
+++ b/fs/yaffs2/Makefile
@@ -0,0 +1,33 @@
+#
+# Makefile for the linux YAFFS filesystem routines.
+#
+
+obj-$(CONFIG_YAFFS_FS) += yaffs2multi.o
+
+#	yaffs2-y := yaffs_mtdif_single.o
+#	yaffs2-y += yaffs_packedtags1.o
+#	yaffs2-y += yaffs_ecc.o yaffs_vfs_single.o yaffs_guts.o
+#	yaffs2-y += yaffs_packedtags2.o
+#	yaffs2-y += yaffs_tagscompat.o
+#	yaffs2-y += yaffs_tagsmarshall.o
+#	yaffs2-y += yaffs_checkptrw.o yaffs_nand.o
+#	yaffs2-y += yaffs_checkptrw.o yaffs_nand.o yaffs_nameval.o
+#	yaffs2-y += yaffs_allocator.o yaffs_bitmap.o yaffs_attribs.o
+#	yaffs2-y += yaffs_yaffs1.o
+#	yaffs2-y += yaffs_yaffs2.o
+#	yaffs2-y += yaffs_verify.o
+#	yaffs2-y += yaffs_summary.o
+
+	yaffs2multi-y := yaffs_mtdif_multi.o
+	yaffs2multi-y += yaffs_packedtags1.o
+	yaffs2multi-y += yaffs_ecc.o yaffs_vfs_multi.o yaffs_guts.o
+	yaffs2multi-y += yaffs_packedtags2.o
+	yaffs2multi-y += yaffs_tagscompat.o
+	yaffs2multi-y += yaffs_tagsmarshall.o
+	yaffs2multi-y += yaffs_checkptrw.o yaffs_nand.o
+	yaffs2multi-y += yaffs_checkptrw.o yaffs_nand.o yaffs_nameval.o
+	yaffs2multi-y += yaffs_allocator.o yaffs_bitmap.o yaffs_attribs.o
+	yaffs2multi-y += yaffs_yaffs1.o
+	yaffs2multi-y += yaffs_yaffs2.o
+	yaffs2multi-y += yaffs_verify.o
+	yaffs2multi-y += yaffs_summary.o
diff --git a/fs/yaffs2/yaffs_allocator.c b/fs/yaffs2/yaffs_allocator.c
new file mode 100755
index 0000000..c8f2861
--- /dev/null
+++ b/fs/yaffs2/yaffs_allocator.c
@@ -0,0 +1,357 @@
+/*
+ * YAFFS: Yet Another Flash File System. A NAND-flash specific file system.
+ *
+ * Copyright (C) 2002-2011 Aleph One Ltd.
+ *   for Toby Churchill Ltd and Brightstar Engineering
+ *
+ * Created by Charles Manning <charles@aleph1.co.uk>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include "yaffs_allocator.h"
+#include "yaffs_guts.h"
+#include "yaffs_trace.h"
+#include "yportenv.h"
+
+/*
+ * Each entry in yaffs_tnode_list and yaffs_obj_list hold blocks
+ * of approx 100 objects that are themn allocated singly.
+ * This is basically a simplified slab allocator.
+ *
+ * We don't use the Linux slab allocator because slab does not allow
+ * us to dump all the objects in one hit when we do a umount and tear
+ * down  all the tnodes and objects. slab requires that we first free
+ * the individual objects.
+ *
+ * Once yaffs has been mainlined I shall try to motivate for a change
+ * to slab to provide the extra features we need here.
+ */
+
+struct yaffs_tnode_list {
+	struct yaffs_tnode_list *next;
+	struct yaffs_tnode *tnodes;
+};
+
+struct yaffs_obj_list {
+	struct yaffs_obj_list *next;
+	struct yaffs_obj *objects;
+};
+
+struct yaffs_allocator {
+	int n_tnodes_created;
+	struct yaffs_tnode *free_tnodes;
+	int n_free_tnodes;
+	struct yaffs_tnode_list *alloc_tnode_list;
+
+	int n_obj_created;
+	struct list_head free_objs;
+	int n_free_objects;
+
+	struct yaffs_obj_list *allocated_obj_list;
+};
+
+static void yaffs_deinit_raw_tnodes(struct yaffs_dev *dev)
+{
+	struct yaffs_allocator *allocator =
+	    (struct yaffs_allocator *)dev->allocator;
+	struct yaffs_tnode_list *tmp;
+
+	if (!allocator) {
+		BUG();
+		return;
+	}
+
+	while (allocator->alloc_tnode_list) {
+		tmp = allocator->alloc_tnode_list->next;
+
+		kfree(allocator->alloc_tnode_list->tnodes);
+		kfree(allocator->alloc_tnode_list);
+		allocator->alloc_tnode_list = tmp;
+	}
+
+	allocator->free_tnodes = NULL;
+	allocator->n_free_tnodes = 0;
+	allocator->n_tnodes_created = 0;
+}
+
+static void yaffs_init_raw_tnodes(struct yaffs_dev *dev)
+{
+	struct yaffs_allocator *allocator = dev->allocator;
+
+	if (!allocator) {
+		BUG();
+		return;
+	}
+
+	allocator->alloc_tnode_list = NULL;
+	allocator->free_tnodes = NULL;
+	allocator->n_free_tnodes = 0;
+	allocator->n_tnodes_created = 0;
+}
+
+static int yaffs_create_tnodes(struct yaffs_dev *dev, int n_tnodes)
+{
+	struct yaffs_allocator *allocator =
+	    (struct yaffs_allocator *)dev->allocator;
+	int i;
+	struct yaffs_tnode *new_tnodes;
+	u8 *mem;
+	struct yaffs_tnode *curr;
+	struct yaffs_tnode *next;
+	struct yaffs_tnode_list *tnl;
+
+	if (!allocator) {
+		BUG();
+		return YAFFS_FAIL;
+	}
+
+	if (n_tnodes < 1)
+		return YAFFS_OK;
+
+	/* make these things */
+	new_tnodes = kmalloc(n_tnodes * dev->tnode_size, GFP_NOFS);
+	mem = (u8 *) new_tnodes;
+
+	if (!new_tnodes) {
+		yaffs_trace(YAFFS_TRACE_ERROR,
+			"yaffs: Could not allocate Tnodes");
+		return YAFFS_FAIL;
+	}
+
+	/* New hookup for wide tnodes */
+	for (i = 0; i < n_tnodes - 1; i++) {
+		curr = (struct yaffs_tnode *)&mem[i * dev->tnode_size];
+		next = (struct yaffs_tnode *)&mem[(i + 1) * dev->tnode_size];
+		curr->internal[0] = next;
+	}
+
+	curr = (struct yaffs_tnode *)&mem[(n_tnodes - 1) * dev->tnode_size];
+	curr->internal[0] = allocator->free_tnodes;
+	allocator->free_tnodes = (struct yaffs_tnode *)mem;
+
+	allocator->n_free_tnodes += n_tnodes;
+	allocator->n_tnodes_created += n_tnodes;
+
+	/* Now add this bunch of tnodes to a list for freeing up.
+	 * NB If we can't add this to the management list it isn't fatal
+	 * but it just means we can't free this bunch of tnodes later.
+	 */
+	tnl = kmalloc(sizeof(struct yaffs_tnode_list), GFP_NOFS);
+	if (!tnl) {
+		yaffs_trace(YAFFS_TRACE_ERROR,
+			"Could not add tnodes to management list");
+		return YAFFS_FAIL;
+	} else {
+		tnl->tnodes = new_tnodes;
+		tnl->next = allocator->alloc_tnode_list;
+		allocator->alloc_tnode_list = tnl;
+	}
+
+	yaffs_trace(YAFFS_TRACE_ALLOCATE, "Tnodes added");
+
+	return YAFFS_OK;
+}
+
+struct yaffs_tnode *yaffs_alloc_raw_tnode(struct yaffs_dev *dev)
+{
+	struct yaffs_allocator *allocator =
+	    (struct yaffs_allocator *)dev->allocator;
+	struct yaffs_tnode *tn = NULL;
+
+	if (!allocator) {
+		BUG();
+		return NULL;
+	}
+
+	/* If there are none left make more */
+	if (!allocator->free_tnodes)
+		yaffs_create_tnodes(dev, YAFFS_ALLOCATION_NTNODES);
+
+	if (allocator->free_tnodes) {
+		tn = allocator->free_tnodes;
+		allocator->free_tnodes = allocator->free_tnodes->internal[0];
+		allocator->n_free_tnodes--;
+	}
+
+	return tn;
+}
+
+/* FreeTnode frees up a tnode and puts it back on the free list */
+void yaffs_free_raw_tnode(struct yaffs_dev *dev, struct yaffs_tnode *tn)
+{
+	struct yaffs_allocator *allocator = dev->allocator;
+
+	if (!allocator) {
+		BUG();
+		return;
+	}
+
+	if (tn) {
+		tn->internal[0] = allocator->free_tnodes;
+		allocator->free_tnodes = tn;
+		allocator->n_free_tnodes++;
+	}
+	dev->checkpoint_blocks_required = 0;	/* force recalculation */
+}
+
+/*--------------- yaffs_obj alloaction ------------------------
+ *
+ * Free yaffs_objs are stored in a list using obj->siblings.
+ * The blocks of allocated objects are stored in a linked list.
+ */
+
+static void yaffs_init_raw_objs(struct yaffs_dev *dev)
+{
+	struct yaffs_allocator *allocator = dev->allocator;
+
+	if (!allocator) {
+		BUG();
+		return;
+	}
+
+	allocator->allocated_obj_list = NULL;
+	INIT_LIST_HEAD(&allocator->free_objs);
+	allocator->n_free_objects = 0;
+}
+
+static void yaffs_deinit_raw_objs(struct yaffs_dev *dev)
+{
+	struct yaffs_allocator *allocator = dev->allocator;
+	struct yaffs_obj_list *tmp;
+
+	if (!allocator) {
+		BUG();
+		return;
+	}
+
+	while (allocator->allocated_obj_list) {
+		tmp = allocator->allocated_obj_list->next;
+		kfree(allocator->allocated_obj_list->objects);
+		kfree(allocator->allocated_obj_list);
+		allocator->allocated_obj_list = tmp;
+	}
+
+	INIT_LIST_HEAD(&allocator->free_objs);
+	allocator->n_free_objects = 0;
+	allocator->n_obj_created = 0;
+}
+
+static int yaffs_create_free_objs(struct yaffs_dev *dev, int n_obj)
+{
+	struct yaffs_allocator *allocator = dev->allocator;
+	int i;
+	struct yaffs_obj *new_objs;
+	struct yaffs_obj_list *list;
+
+	if (!allocator) {
+		BUG();
+		return YAFFS_FAIL;
+	}
+
+	if (n_obj < 1)
+		return YAFFS_OK;
+
+	/* make these things */
+	new_objs = kmalloc(n_obj * sizeof(struct yaffs_obj), GFP_NOFS);
+	list = kmalloc(sizeof(struct yaffs_obj_list), GFP_NOFS);
+
+	if (!new_objs || !list) {
+		kfree(new_objs);
+		new_objs = NULL;
+		kfree(list);
+		list = NULL;
+		yaffs_trace(YAFFS_TRACE_ALLOCATE,
+			"Could not allocate more objects");
+		return YAFFS_FAIL;
+	}
+
+	/* Hook them into the free list */
+	for (i = 0; i < n_obj; i++)
+		list_add(&new_objs[i].siblings, &allocator->free_objs);
+
+	allocator->n_free_objects += n_obj;
+	allocator->n_obj_created += n_obj;
+
+	/* Now add this bunch of Objects to a list for freeing up. */
+
+	list->objects = new_objs;
+	list->next = allocator->allocated_obj_list;
+	allocator->allocated_obj_list = list;
+
+	return YAFFS_OK;
+}
+
+struct yaffs_obj *yaffs_alloc_raw_obj(struct yaffs_dev *dev)
+{
+	struct yaffs_obj *obj = NULL;
+	struct list_head *lh;
+	struct yaffs_allocator *allocator = dev->allocator;
+
+	if (!allocator) {
+		BUG();
+		return obj;
+	}
+
+	/* If there are none left make more */
+	if (list_empty(&allocator->free_objs))
+		yaffs_create_free_objs(dev, YAFFS_ALLOCATION_NOBJECTS);
+
+	if (!list_empty(&allocator->free_objs)) {
+		lh = allocator->free_objs.next;
+		obj = list_entry(lh, struct yaffs_obj, siblings);
+		list_del_init(lh);
+		allocator->n_free_objects--;
+	}
+
+	return obj;
+}
+
+void yaffs_free_raw_obj(struct yaffs_dev *dev, struct yaffs_obj *obj)
+{
+
+	struct yaffs_allocator *allocator = dev->allocator;
+
+	if (!allocator) {
+		BUG();
+		return;
+	}
+
+	/* Link into the free list. */
+	list_add(&obj->siblings, &allocator->free_objs);
+	allocator->n_free_objects++;
+}
+
+void yaffs_deinit_raw_tnodes_and_objs(struct yaffs_dev *dev)
+{
+
+	if (!dev->allocator) {
+		BUG();
+		return;
+	}
+
+	yaffs_deinit_raw_tnodes(dev);
+	yaffs_deinit_raw_objs(dev);
+	kfree(dev->allocator);
+	dev->allocator = NULL;
+}
+
+void yaffs_init_raw_tnodes_and_objs(struct yaffs_dev *dev)
+{
+	struct yaffs_allocator *allocator;
+
+	if (dev->allocator) {
+		BUG();
+		return;
+	}
+
+	allocator = kmalloc(sizeof(struct yaffs_allocator), GFP_NOFS);
+	if (allocator) {
+		dev->allocator = allocator;
+		yaffs_init_raw_tnodes(dev);
+		yaffs_init_raw_objs(dev);
+	}
+}
+
diff --git a/fs/yaffs2/yaffs_allocator.h b/fs/yaffs2/yaffs_allocator.h
new file mode 100755
index 0000000..a8cc322
--- /dev/null
+++ b/fs/yaffs2/yaffs_allocator.h
@@ -0,0 +1,30 @@
+/*
+ * YAFFS: Yet another Flash File System . A NAND-flash specific file system.
+ *
+ * Copyright (C) 2002-2011 Aleph One Ltd.
+ *   for Toby Churchill Ltd and Brightstar Engineering
+ *
+ * Created by Charles Manning <charles@aleph1.co.uk>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 2.1 as
+ * published by the Free Software Foundation.
+ *
+ * Note: Only YAFFS headers are LGPL, YAFFS C code is covered by GPL.
+ */
+
+#ifndef __YAFFS_ALLOCATOR_H__
+#define __YAFFS_ALLOCATOR_H__
+
+#include "yaffs_guts.h"
+
+void yaffs_init_raw_tnodes_and_objs(struct yaffs_dev *dev);
+void yaffs_deinit_raw_tnodes_and_objs(struct yaffs_dev *dev);
+
+struct yaffs_tnode *yaffs_alloc_raw_tnode(struct yaffs_dev *dev);
+void yaffs_free_raw_tnode(struct yaffs_dev *dev, struct yaffs_tnode *tn);
+
+struct yaffs_obj *yaffs_alloc_raw_obj(struct yaffs_dev *dev);
+void yaffs_free_raw_obj(struct yaffs_dev *dev, struct yaffs_obj *obj);
+
+#endif
diff --git a/fs/yaffs2/yaffs_attribs.c b/fs/yaffs2/yaffs_attribs.c
new file mode 100755
index 0000000..711941f
--- /dev/null
+++ b/fs/yaffs2/yaffs_attribs.c
@@ -0,0 +1,132 @@
+/*
+ * YAFFS: Yet Another Flash File System. A NAND-flash specific file system.
+ *
+ * Copyright (C) 2002-2011 Aleph One Ltd.
+ *   for Toby Churchill Ltd and Brightstar Engineering
+ *
+ * Created by Charles Manning <charles@aleph1.co.uk>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include "yaffs_guts.h"
+#include "yaffs_attribs.h"
+
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(3, 14, 0))
+#define IATTR_UID ia_uid
+#define IATTR_GID ia_gid
+#else
+#define IATTR_UID ia_uid.val
+#define IATTR_GID ia_gid.val
+#endif
+
+void yaffs_load_attribs(struct yaffs_obj *obj, struct yaffs_obj_hdr *oh)
+{
+	obj->yst_uid = oh->yst_uid;
+	obj->yst_gid = oh->yst_gid;
+	obj->yst_atime = oh->yst_atime;
+	obj->yst_mtime = oh->yst_mtime;
+	obj->yst_ctime = oh->yst_ctime;
+	obj->yst_rdev = oh->yst_rdev;
+}
+
+void yaffs_load_attribs_oh(struct yaffs_obj_hdr *oh, struct yaffs_obj *obj)
+{
+	oh->yst_uid = obj->yst_uid;
+	oh->yst_gid = obj->yst_gid;
+	oh->yst_atime = obj->yst_atime;
+	oh->yst_mtime = obj->yst_mtime;
+	oh->yst_ctime = obj->yst_ctime;
+	oh->yst_rdev = obj->yst_rdev;
+
+}
+
+void yaffs_load_current_time(struct yaffs_obj *obj, int do_a, int do_c)
+{
+	obj->yst_mtime = Y_CURRENT_TIME;
+	if (do_a)
+		obj->yst_atime = obj->yst_mtime;
+	if (do_c)
+		obj->yst_ctime = obj->yst_mtime;
+}
+
+void yaffs_attribs_init(struct yaffs_obj *obj, u32 gid, u32 uid, u32 rdev)
+{
+	yaffs_load_current_time(obj, 1, 1);
+	obj->yst_rdev = rdev;
+	obj->yst_uid = uid;
+	obj->yst_gid = gid;
+}
+
+static loff_t yaffs_get_file_size(struct yaffs_obj *obj)
+{
+	YCHAR *alias = NULL;
+	obj = yaffs_get_equivalent_obj(obj);
+
+	switch (obj->variant_type) {
+	case YAFFS_OBJECT_TYPE_FILE:
+		return obj->variant.file_variant.file_size;
+	case YAFFS_OBJECT_TYPE_SYMLINK:
+		alias = obj->variant.symlink_variant.alias;
+		if (!alias)
+			return 0;
+		return strnlen(alias, YAFFS_MAX_ALIAS_LENGTH);
+	default:
+		return 0;
+	}
+}
+
+int yaffs_set_attribs(struct yaffs_obj *obj, struct iattr *attr)
+{
+	unsigned int valid = attr->ia_valid;
+
+	if (valid & ATTR_MODE)
+		obj->yst_mode = attr->ia_mode;
+	if (valid & ATTR_UID)
+		obj->yst_uid = attr->IATTR_UID;
+	if (valid & ATTR_GID)
+		obj->yst_gid = attr->IATTR_GID;
+
+	if (valid & ATTR_ATIME)
+		obj->yst_atime = Y_TIME_CONVERT(attr->ia_atime);
+	if (valid & ATTR_CTIME)
+		obj->yst_ctime = Y_TIME_CONVERT(attr->ia_ctime);
+	if (valid & ATTR_MTIME)
+		obj->yst_mtime = Y_TIME_CONVERT(attr->ia_mtime);
+
+	if (valid & ATTR_SIZE)
+		yaffs_resize_file(obj, attr->ia_size);
+
+	yaffs_update_oh(obj, NULL, 1, 0, 0, NULL);
+
+	return YAFFS_OK;
+
+}
+
+int yaffs_get_attribs(struct yaffs_obj *obj, struct iattr *attr)
+{
+	unsigned int valid = 0;
+
+	attr->ia_mode = obj->yst_mode;
+	valid |= ATTR_MODE;
+	attr->IATTR_UID = obj->yst_uid;
+	valid |= ATTR_UID;
+	attr->IATTR_GID = obj->yst_gid;
+	valid |= ATTR_GID;
+
+	Y_TIME_CONVERT(attr->ia_atime) = obj->yst_atime;
+	valid |= ATTR_ATIME;
+	Y_TIME_CONVERT(attr->ia_ctime) = obj->yst_ctime;
+	valid |= ATTR_CTIME;
+	Y_TIME_CONVERT(attr->ia_mtime) = obj->yst_mtime;
+	valid |= ATTR_MTIME;
+
+	attr->ia_size = yaffs_get_file_size(obj);
+	valid |= ATTR_SIZE;
+
+	attr->ia_valid = valid;
+
+	return YAFFS_OK;
+}
diff --git a/fs/yaffs2/yaffs_attribs.h b/fs/yaffs2/yaffs_attribs.h
new file mode 100755
index 0000000..5b21b08
--- /dev/null
+++ b/fs/yaffs2/yaffs_attribs.h
@@ -0,0 +1,28 @@
+/*
+ * YAFFS: Yet another Flash File System . A NAND-flash specific file system.
+ *
+ * Copyright (C) 2002-2011 Aleph One Ltd.
+ *   for Toby Churchill Ltd and Brightstar Engineering
+ *
+ * Created by Charles Manning <charles@aleph1.co.uk>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 2.1 as
+ * published by the Free Software Foundation.
+ *
+ * Note: Only YAFFS headers are LGPL, YAFFS C code is covered by GPL.
+ */
+
+#ifndef __YAFFS_ATTRIBS_H__
+#define __YAFFS_ATTRIBS_H__
+
+#include "yaffs_guts.h"
+
+void yaffs_load_attribs(struct yaffs_obj *obj, struct yaffs_obj_hdr *oh);
+void yaffs_load_attribs_oh(struct yaffs_obj_hdr *oh, struct yaffs_obj *obj);
+void yaffs_attribs_init(struct yaffs_obj *obj, u32 gid, u32 uid, u32 rdev);
+void yaffs_load_current_time(struct yaffs_obj *obj, int do_a, int do_c);
+int yaffs_set_attribs(struct yaffs_obj *obj, struct iattr *attr);
+int yaffs_get_attribs(struct yaffs_obj *obj, struct iattr *attr);
+
+#endif
diff --git a/fs/yaffs2/yaffs_bitmap.c b/fs/yaffs2/yaffs_bitmap.c
new file mode 100755
index 0000000..4440e93
--- /dev/null
+++ b/fs/yaffs2/yaffs_bitmap.c
@@ -0,0 +1,97 @@
+/*
+ * YAFFS: Yet Another Flash File System. A NAND-flash specific file system.
+ *
+ * Copyright (C) 2002-2011 Aleph One Ltd.
+ *   for Toby Churchill Ltd and Brightstar Engineering
+ *
+ * Created by Charles Manning <charles@aleph1.co.uk>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include "yaffs_bitmap.h"
+#include "yaffs_trace.h"
+/*
+ * Chunk bitmap manipulations
+ */
+
+static inline u8 *yaffs_block_bits(struct yaffs_dev *dev, int blk)
+{
+	if (blk < dev->internal_start_block || blk > dev->internal_end_block) {
+		yaffs_trace(YAFFS_TRACE_ERROR,
+			"BlockBits block %d is not valid",
+			blk);
+		BUG();
+	}
+	return dev->chunk_bits +
+	    (dev->chunk_bit_stride * (blk - dev->internal_start_block));
+}
+
+void yaffs_verify_chunk_bit_id(struct yaffs_dev *dev, int blk, int chunk)
+{
+	if (blk < dev->internal_start_block || blk > dev->internal_end_block ||
+	    chunk < 0 || chunk >= dev->param.chunks_per_block) {
+		yaffs_trace(YAFFS_TRACE_ERROR,
+			"Chunk Id (%d:%d) invalid",
+			blk, chunk);
+		BUG();
+	}
+}
+
+void yaffs_clear_chunk_bits(struct yaffs_dev *dev, int blk)
+{
+	u8 *blk_bits = yaffs_block_bits(dev, blk);
+
+	memset(blk_bits, 0, dev->chunk_bit_stride);
+}
+
+void yaffs_clear_chunk_bit(struct yaffs_dev *dev, int blk, int chunk)
+{
+	u8 *blk_bits = yaffs_block_bits(dev, blk);
+
+	yaffs_verify_chunk_bit_id(dev, blk, chunk);
+	blk_bits[chunk / 8] &= ~(1 << (chunk & 7));
+}
+
+void yaffs_set_chunk_bit(struct yaffs_dev *dev, int blk, int chunk)
+{
+	u8 *blk_bits = yaffs_block_bits(dev, blk);
+
+	yaffs_verify_chunk_bit_id(dev, blk, chunk);
+	blk_bits[chunk / 8] |= (1 << (chunk & 7));
+}
+
+int yaffs_check_chunk_bit(struct yaffs_dev *dev, int blk, int chunk)
+{
+	u8 *blk_bits = yaffs_block_bits(dev, blk);
+
+	yaffs_verify_chunk_bit_id(dev, blk, chunk);
+	return (blk_bits[chunk / 8] & (1 << (chunk & 7))) ? 1 : 0;
+}
+
+int yaffs_still_some_chunks(struct yaffs_dev *dev, int blk)
+{
+	u8 *blk_bits = yaffs_block_bits(dev, blk);
+	int i;
+
+	for (i = 0; i < dev->chunk_bit_stride; i++) {
+		if (*blk_bits)
+			return 1;
+		blk_bits++;
+	}
+	return 0;
+}
+
+int yaffs_count_chunk_bits(struct yaffs_dev *dev, int blk)
+{
+	u8 *blk_bits = yaffs_block_bits(dev, blk);
+	int i;
+	int n = 0;
+
+	for (i = 0; i < dev->chunk_bit_stride; i++, blk_bits++)
+		n += hweight8(*blk_bits);
+
+	return n;
+}
diff --git a/fs/yaffs2/yaffs_bitmap.h b/fs/yaffs2/yaffs_bitmap.h
new file mode 100755
index 0000000..e26b37d
--- /dev/null
+++ b/fs/yaffs2/yaffs_bitmap.h
@@ -0,0 +1,33 @@
+/*
+ * YAFFS: Yet another Flash File System . A NAND-flash specific file system.
+ *
+ * Copyright (C) 2002-2011 Aleph One Ltd.
+ *   for Toby Churchill Ltd and Brightstar Engineering
+ *
+ * Created by Charles Manning <charles@aleph1.co.uk>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 2.1 as
+ * published by the Free Software Foundation.
+ *
+ * Note: Only YAFFS headers are LGPL, YAFFS C code is covered by GPL.
+ */
+
+/*
+ * Chunk bitmap manipulations
+ */
+
+#ifndef __YAFFS_BITMAP_H__
+#define __YAFFS_BITMAP_H__
+
+#include "yaffs_guts.h"
+
+void yaffs_verify_chunk_bit_id(struct yaffs_dev *dev, int blk, int chunk);
+void yaffs_clear_chunk_bits(struct yaffs_dev *dev, int blk);
+void yaffs_clear_chunk_bit(struct yaffs_dev *dev, int blk, int chunk);
+void yaffs_set_chunk_bit(struct yaffs_dev *dev, int blk, int chunk);
+int yaffs_check_chunk_bit(struct yaffs_dev *dev, int blk, int chunk);
+int yaffs_still_some_chunks(struct yaffs_dev *dev, int blk);
+int yaffs_count_chunk_bits(struct yaffs_dev *dev, int blk);
+
+#endif
diff --git a/fs/yaffs2/yaffs_checkptrw.c b/fs/yaffs2/yaffs_checkptrw.c
new file mode 100755
index 0000000..16ee1e0
--- /dev/null
+++ b/fs/yaffs2/yaffs_checkptrw.c
@@ -0,0 +1,466 @@
+/*
+ * YAFFS: Yet Another Flash File System. A NAND-flash specific file system.
+ *
+ * Copyright (C) 2002-2011 Aleph One Ltd.
+ *   for Toby Churchill Ltd and Brightstar Engineering
+ *
+ * Created by Charles Manning <charles@aleph1.co.uk>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include "yaffs_checkptrw.h"
+#include "yaffs_getblockinfo.h"
+
+struct yaffs_checkpt_chunk_hdr {
+	int version;
+	int seq;
+	u32 sum;
+	u32 xor;
+} ;
+
+
+static int apply_chunk_offset(struct yaffs_dev *dev, int chunk)
+{
+	return chunk - dev->chunk_offset;
+}
+
+static int apply_block_offset(struct yaffs_dev *dev, int block)
+{
+	return block - dev->block_offset;
+}
+
+static void yaffs2_checkpt_init_chunk_hdr(struct yaffs_dev *dev)
+{
+	struct yaffs_checkpt_chunk_hdr hdr;
+
+	hdr.version = YAFFS_CHECKPOINT_VERSION;
+	hdr.seq = dev->checkpt_page_seq;
+	hdr.sum = dev->checkpt_sum;
+	hdr.xor = dev->checkpt_xor;
+
+	dev->checkpt_byte_offs = sizeof(hdr);
+
+	memcpy(dev->checkpt_buffer, &hdr, sizeof(hdr));
+}
+
+static int yaffs2_checkpt_check_chunk_hdr(struct yaffs_dev *dev)
+{
+	struct yaffs_checkpt_chunk_hdr hdr;
+
+	memcpy(&hdr, dev->checkpt_buffer, sizeof(hdr));
+
+	dev->checkpt_byte_offs = sizeof(hdr);
+
+	return hdr.version == YAFFS_CHECKPOINT_VERSION &&
+		hdr.seq == dev->checkpt_page_seq &&
+		hdr.sum == dev->checkpt_sum &&
+		hdr.xor == dev->checkpt_xor;
+}
+
+static int yaffs2_checkpt_space_ok(struct yaffs_dev *dev)
+{
+	int blocks_avail = dev->n_erased_blocks - dev->param.n_reserved_blocks;
+
+	yaffs_trace(YAFFS_TRACE_CHECKPOINT,
+		"checkpt blocks_avail = %d", blocks_avail);
+
+	return (blocks_avail <= 0) ? 0 : 1;
+}
+
+static int yaffs_checkpt_erase(struct yaffs_dev *dev)
+{
+	int i;
+
+	if (!dev->drv.drv_erase_fn)
+		return 0;
+	yaffs_trace(YAFFS_TRACE_CHECKPOINT,
+		"checking blocks %d to %d",
+		dev->internal_start_block, dev->internal_end_block);
+
+	for (i = dev->internal_start_block; i <= dev->internal_end_block; i++) {
+		struct yaffs_block_info *bi = yaffs_get_block_info(dev, i);
+		int offset_i = apply_block_offset(dev, i);
+		int result;
+
+		if (bi->block_state == YAFFS_BLOCK_STATE_CHECKPOINT) {
+			yaffs_trace(YAFFS_TRACE_CHECKPOINT,
+			"erasing checkpt block %d", i);
+
+			dev->n_erasures++;
+
+			result = dev->drv.drv_erase_fn(dev, offset_i);
+			if(result) {
+				bi->block_state = YAFFS_BLOCK_STATE_EMPTY;
+				dev->n_erased_blocks++;
+				dev->n_free_chunks +=
+				    dev->param.chunks_per_block;
+			} else {
+				dev->drv.drv_mark_bad_fn(dev, offset_i);
+				bi->block_state = YAFFS_BLOCK_STATE_DEAD;
+			}
+		}
+	}
+
+	dev->blocks_in_checkpt = 0;
+
+	return 1;
+}
+
+static void yaffs2_checkpt_find_erased_block(struct yaffs_dev *dev)
+{
+	int i;
+	int blocks_avail = dev->n_erased_blocks - dev->param.n_reserved_blocks;
+
+	yaffs_trace(YAFFS_TRACE_CHECKPOINT,
+		"allocating checkpt block: erased %d reserved %d avail %d next %d ",
+		dev->n_erased_blocks, dev->param.n_reserved_blocks,
+		blocks_avail, dev->checkpt_next_block);
+
+	if (dev->checkpt_next_block >= 0 &&
+	    dev->checkpt_next_block <= dev->internal_end_block &&
+	    blocks_avail > 0) {
+
+		for (i = dev->checkpt_next_block; i <= dev->internal_end_block;
+		     i++) {
+			struct yaffs_block_info *bi;
+
+			bi = yaffs_get_block_info(dev, i);
+			if (bi->block_state == YAFFS_BLOCK_STATE_EMPTY) {
+				dev->checkpt_next_block = i + 1;
+				dev->checkpt_cur_block = i;
+				yaffs_trace(YAFFS_TRACE_CHECKPOINT,
+					"allocating checkpt block %d", i);
+				return;
+			}
+		}
+	}
+	yaffs_trace(YAFFS_TRACE_CHECKPOINT, "out of checkpt blocks");
+
+	dev->checkpt_next_block = -1;
+	dev->checkpt_cur_block = -1;
+}
+
+static void yaffs2_checkpt_find_block(struct yaffs_dev *dev)
+{
+	int i;
+	struct yaffs_ext_tags tags;
+
+	yaffs_trace(YAFFS_TRACE_CHECKPOINT,
+		"find next checkpt block: start:  blocks %d next %d",
+		dev->blocks_in_checkpt, dev->checkpt_next_block);
+
+	if (dev->blocks_in_checkpt < dev->checkpt_max_blocks)
+		for (i = dev->checkpt_next_block; i <= dev->internal_end_block;
+		     i++) {
+			int chunk = i * dev->param.chunks_per_block;
+			enum yaffs_block_state state;
+			u32 seq;
+
+			dev->tagger.read_chunk_tags_fn(dev,
+					apply_chunk_offset(dev, chunk),
+					NULL, &tags);
+			yaffs_trace(YAFFS_TRACE_CHECKPOINT,
+				"find next checkpt block: search: block %d state %d oid %d seq %d eccr %d",
+				i, (int) state,
+				tags.obj_id, tags.seq_number,
+				tags.ecc_result);
+
+			if (tags.seq_number != YAFFS_SEQUENCE_CHECKPOINT_DATA)
+				continue;
+
+			dev->tagger.query_block_fn(dev,
+						apply_block_offset(dev, i),
+						&state, &seq);
+			if (state == YAFFS_BLOCK_STATE_DEAD)
+				continue;
+
+			/* Right kind of block */
+			dev->checkpt_next_block = tags.obj_id;
+			dev->checkpt_cur_block = i;
+			dev->checkpt_block_list[dev->blocks_in_checkpt] = i;
+			dev->blocks_in_checkpt++;
+			yaffs_trace(YAFFS_TRACE_CHECKPOINT,
+				"found checkpt block %d", i);
+			return;
+		}
+
+	yaffs_trace(YAFFS_TRACE_CHECKPOINT, "found no more checkpt blocks");
+
+	dev->checkpt_next_block = -1;
+	dev->checkpt_cur_block = -1;
+}
+
+int yaffs2_checkpt_open(struct yaffs_dev *dev, int writing)
+{
+	int i;
+
+	dev->checkpt_open_write = writing;
+
+	/* Got the functions we need? */
+	if (!dev->tagger.write_chunk_tags_fn ||
+	    !dev->tagger.read_chunk_tags_fn ||
+	    !dev->drv.drv_erase_fn ||
+	    !dev->drv.drv_mark_bad_fn)
+		return 0;
+
+	if (writing && !yaffs2_checkpt_space_ok(dev))
+		return 0;
+
+	if (!dev->checkpt_buffer)
+		dev->checkpt_buffer =
+		    kmalloc(dev->param.total_bytes_per_chunk, GFP_NOFS);
+	if (!dev->checkpt_buffer)
+		return 0;
+
+	dev->checkpt_page_seq = 0;
+	dev->checkpt_byte_count = 0;
+	dev->checkpt_sum = 0;
+	dev->checkpt_xor = 0;
+	dev->checkpt_cur_block = -1;
+	dev->checkpt_cur_chunk = -1;
+	dev->checkpt_next_block = dev->internal_start_block;
+
+	if (writing) {
+		memset(dev->checkpt_buffer, 0, dev->data_bytes_per_chunk);
+		yaffs2_checkpt_init_chunk_hdr(dev);
+		return yaffs_checkpt_erase(dev);
+	}
+
+	/* Opening for a read */
+	/* Set to a value that will kick off a read */
+	dev->checkpt_byte_offs = dev->data_bytes_per_chunk;
+	/* A checkpoint block list of 1 checkpoint block per 16 block is
+	 * (hopefully) going to be way more than we need */
+	dev->blocks_in_checkpt = 0;
+	dev->checkpt_max_blocks =
+	    (dev->internal_end_block - dev->internal_start_block) / 16 + 2;
+	if (!dev->checkpt_block_list)
+		dev->checkpt_block_list =
+		      kmalloc(sizeof(int) * dev->checkpt_max_blocks, GFP_NOFS);
+
+	if (!dev->checkpt_block_list)
+		return 0;
+
+	for (i = 0; i < dev->checkpt_max_blocks; i++)
+		dev->checkpt_block_list[i] = -1;
+
+	return 1;
+}
+
+int yaffs2_get_checkpt_sum(struct yaffs_dev *dev, u32 * sum)
+{
+	u32 composite_sum;
+
+	composite_sum = (dev->checkpt_sum << 8) | (dev->checkpt_xor & 0xff);
+	*sum = composite_sum;
+	return 1;
+}
+
+static int yaffs2_checkpt_flush_buffer(struct yaffs_dev *dev)
+{
+	int chunk;
+	int offset_chunk;
+	struct yaffs_ext_tags tags;
+
+	if (dev->checkpt_cur_block < 0) {
+		yaffs2_checkpt_find_erased_block(dev);
+		dev->checkpt_cur_chunk = 0;
+	}
+
+	if (dev->checkpt_cur_block < 0)
+		return 0;
+
+	tags.is_deleted = 0;
+	tags.obj_id = dev->checkpt_next_block;	/* Hint to next place to look */
+	tags.chunk_id = dev->checkpt_page_seq + 1;
+	tags.seq_number = YAFFS_SEQUENCE_CHECKPOINT_DATA;
+	tags.n_bytes = dev->data_bytes_per_chunk;
+	if (dev->checkpt_cur_chunk == 0) {
+		/* First chunk we write for the block? Set block state to
+		   checkpoint */
+		struct yaffs_block_info *bi =
+		    yaffs_get_block_info(dev, dev->checkpt_cur_block);
+		bi->block_state = YAFFS_BLOCK_STATE_CHECKPOINT;
+		dev->blocks_in_checkpt++;
+	}
+
+	chunk =
+	    dev->checkpt_cur_block * dev->param.chunks_per_block +
+	    dev->checkpt_cur_chunk;
+
+	yaffs_trace(YAFFS_TRACE_CHECKPOINT,
+		"checkpoint wite buffer nand %d(%d:%d) objid %d chId %d",
+		chunk, dev->checkpt_cur_block, dev->checkpt_cur_chunk,
+		tags.obj_id, tags.chunk_id);
+
+	offset_chunk = apply_chunk_offset(dev, chunk);
+
+	dev->n_page_writes++;
+
+	dev->tagger.write_chunk_tags_fn(dev, offset_chunk,
+				       dev->checkpt_buffer, &tags);
+	dev->checkpt_page_seq++;
+	dev->checkpt_cur_chunk++;
+	if (dev->checkpt_cur_chunk >= dev->param.chunks_per_block) {
+		dev->checkpt_cur_chunk = 0;
+		dev->checkpt_cur_block = -1;
+	}
+	memset(dev->checkpt_buffer, 0, dev->data_bytes_per_chunk);
+
+	yaffs2_checkpt_init_chunk_hdr(dev);
+
+
+	return 1;
+}
+
+int yaffs2_checkpt_wr(struct yaffs_dev *dev, const void *data, int n_bytes)
+{
+	int i = 0;
+	int ok = 1;
+	u8 *data_bytes = (u8 *) data;
+
+	if (!dev->checkpt_buffer)
+		return 0;
+
+	if (!dev->checkpt_open_write)
+		return -1;
+
+	while (i < n_bytes && ok) {
+		dev->checkpt_buffer[dev->checkpt_byte_offs] = *data_bytes;
+		dev->checkpt_sum += *data_bytes;
+		dev->checkpt_xor ^= *data_bytes;
+
+		dev->checkpt_byte_offs++;
+		i++;
+		data_bytes++;
+		dev->checkpt_byte_count++;
+
+		if (dev->checkpt_byte_offs < 0 ||
+		    dev->checkpt_byte_offs >= dev->data_bytes_per_chunk)
+			ok = yaffs2_checkpt_flush_buffer(dev);
+	}
+
+	return i;
+}
+
+int yaffs2_checkpt_rd(struct yaffs_dev *dev, void *data, int n_bytes)
+{
+	int i = 0;
+	struct yaffs_ext_tags tags;
+	int chunk;
+	int offset_chunk;
+	u8 *data_bytes = (u8 *) data;
+
+	if (!dev->checkpt_buffer)
+		return 0;
+
+	if (dev->checkpt_open_write)
+		return -1;
+
+	while (i < n_bytes) {
+
+		if (dev->checkpt_byte_offs < 0 ||
+		    dev->checkpt_byte_offs >= dev->data_bytes_per_chunk) {
+
+			if (dev->checkpt_cur_block < 0) {
+				yaffs2_checkpt_find_block(dev);
+				dev->checkpt_cur_chunk = 0;
+			}
+
+			/* Bail out if we can't find a checpoint block */
+			if (dev->checkpt_cur_block < 0)
+				break;
+
+			chunk = dev->checkpt_cur_block *
+			    dev->param.chunks_per_block +
+			    dev->checkpt_cur_chunk;
+
+			offset_chunk = apply_chunk_offset(dev, chunk);
+			dev->n_page_reads++;
+
+			/* Read in the next chunk */
+			dev->tagger.read_chunk_tags_fn(dev,
+						offset_chunk,
+						dev->checkpt_buffer,
+						&tags);
+
+			/* Bail out if the chunk is corrupted. */
+			if (tags.chunk_id != (dev->checkpt_page_seq + 1) ||
+			    tags.ecc_result > YAFFS_ECC_RESULT_FIXED ||
+			    tags.seq_number != YAFFS_SEQUENCE_CHECKPOINT_DATA)
+				break;
+
+			/* Bail out if it is not a checkpoint chunk. */
+			if(!yaffs2_checkpt_check_chunk_hdr(dev))
+				break;
+
+			dev->checkpt_page_seq++;
+			dev->checkpt_cur_chunk++;
+
+			if (dev->checkpt_cur_chunk >=
+					dev->param.chunks_per_block)
+				dev->checkpt_cur_block = -1;
+
+		}
+
+		*data_bytes = dev->checkpt_buffer[dev->checkpt_byte_offs];
+		dev->checkpt_sum += *data_bytes;
+		dev->checkpt_xor ^= *data_bytes;
+		dev->checkpt_byte_offs++;
+		i++;
+		data_bytes++;
+		dev->checkpt_byte_count++;
+	}
+
+	return i; /* Number of bytes read */
+}
+
+int yaffs_checkpt_close(struct yaffs_dev *dev)
+{
+	int i;
+
+	if (dev->checkpt_open_write) {
+		if (dev->checkpt_byte_offs !=
+			sizeof(sizeof(struct yaffs_checkpt_chunk_hdr)))
+			yaffs2_checkpt_flush_buffer(dev);
+	} else if (dev->checkpt_block_list) {
+		for (i = 0;
+		     i < dev->blocks_in_checkpt &&
+		     dev->checkpt_block_list[i] >= 0; i++) {
+			int blk = dev->checkpt_block_list[i];
+			struct yaffs_block_info *bi = NULL;
+
+			if (dev->internal_start_block <= blk &&
+			    blk <= dev->internal_end_block)
+				bi = yaffs_get_block_info(dev, blk);
+			if (bi && bi->block_state == YAFFS_BLOCK_STATE_EMPTY)
+				bi->block_state = YAFFS_BLOCK_STATE_CHECKPOINT;
+		}
+	}
+
+	dev->n_free_chunks -=
+		dev->blocks_in_checkpt * dev->param.chunks_per_block;
+	dev->n_erased_blocks -= dev->blocks_in_checkpt;
+
+	yaffs_trace(YAFFS_TRACE_CHECKPOINT, "checkpoint byte count %d",
+		dev->checkpt_byte_count);
+
+	if (dev->checkpt_buffer)
+		return 1;
+	else
+		return 0;
+}
+
+int yaffs2_checkpt_invalidate_stream(struct yaffs_dev *dev)
+{
+	/* Erase the checkpoint data */
+
+	yaffs_trace(YAFFS_TRACE_CHECKPOINT,
+		"checkpoint invalidate of %d blocks",
+		dev->blocks_in_checkpt);
+
+	return yaffs_checkpt_erase(dev);
+}
diff --git a/fs/yaffs2/yaffs_checkptrw.h b/fs/yaffs2/yaffs_checkptrw.h
new file mode 100755
index 0000000..cdbaba7
--- /dev/null
+++ b/fs/yaffs2/yaffs_checkptrw.h
@@ -0,0 +1,33 @@
+/*
+ * YAFFS: Yet another Flash File System . A NAND-flash specific file system.
+ *
+ * Copyright (C) 2002-2011 Aleph One Ltd.
+ *   for Toby Churchill Ltd and Brightstar Engineering
+ *
+ * Created by Charles Manning <charles@aleph1.co.uk>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 2.1 as
+ * published by the Free Software Foundation.
+ *
+ * Note: Only YAFFS headers are LGPL, YAFFS C code is covered by GPL.
+ */
+
+#ifndef __YAFFS_CHECKPTRW_H__
+#define __YAFFS_CHECKPTRW_H__
+
+#include "yaffs_guts.h"
+
+int yaffs2_checkpt_open(struct yaffs_dev *dev, int writing);
+
+int yaffs2_checkpt_wr(struct yaffs_dev *dev, const void *data, int n_bytes);
+
+int yaffs2_checkpt_rd(struct yaffs_dev *dev, void *data, int n_bytes);
+
+int yaffs2_get_checkpt_sum(struct yaffs_dev *dev, u32 * sum);
+
+int yaffs_checkpt_close(struct yaffs_dev *dev);
+
+int yaffs2_checkpt_invalidate_stream(struct yaffs_dev *dev);
+
+#endif
diff --git a/fs/yaffs2/yaffs_ecc.c b/fs/yaffs2/yaffs_ecc.c
new file mode 100755
index 0000000..9294107
--- /dev/null
+++ b/fs/yaffs2/yaffs_ecc.c
@@ -0,0 +1,281 @@
+/*
+ * YAFFS: Yet Another Flash File System. A NAND-flash specific file system.
+ *
+ * Copyright (C) 2002-2011 Aleph One Ltd.
+ *   for Toby Churchill Ltd and Brightstar Engineering
+ *
+ * Created by Charles Manning <charles@aleph1.co.uk>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+/*
+ * This code implements the ECC algorithm used in SmartMedia.
+ *
+ * The ECC comprises 22 bits of parity information and is stuffed into 3 bytes.
+ * The two unused bit are set to 1.
+ * The ECC can correct single bit errors in a 256-byte page of data. Thus, two
+ * such ECC blocks are used on a 512-byte NAND page.
+ *
+ */
+
+#include "yportenv.h"
+
+#include "yaffs_ecc.h"
+
+/* Table generated by gen-ecc.c
+ * Using a table means we do not have to calculate p1..p4 and p1'..p4'
+ * for each byte of data. These are instead provided in a table in bits7..2.
+ * Bit 0 of each entry indicates whether the entry has an odd or even parity,
+ * and therefore this bytes influence on the line parity.
+ */
+
+static const unsigned char column_parity_table[] = {
+	0x00, 0x55, 0x59, 0x0c, 0x65, 0x30, 0x3c, 0x69,
+	0x69, 0x3c, 0x30, 0x65, 0x0c, 0x59, 0x55, 0x00,
+	0x95, 0xc0, 0xcc, 0x99, 0xf0, 0xa5, 0xa9, 0xfc,
+	0xfc, 0xa9, 0xa5, 0xf0, 0x99, 0xcc, 0xc0, 0x95,
+	0x99, 0xcc, 0xc0, 0x95, 0xfc, 0xa9, 0xa5, 0xf0,
+	0xf0, 0xa5, 0xa9, 0xfc, 0x95, 0xc0, 0xcc, 0x99,
+	0x0c, 0x59, 0x55, 0x00, 0x69, 0x3c, 0x30, 0x65,
+	0x65, 0x30, 0x3c, 0x69, 0x00, 0x55, 0x59, 0x0c,
+	0xa5, 0xf0, 0xfc, 0xa9, 0xc0, 0x95, 0x99, 0xcc,
+	0xcc, 0x99, 0x95, 0xc0, 0xa9, 0xfc, 0xf0, 0xa5,
+	0x30, 0x65, 0x69, 0x3c, 0x55, 0x00, 0x0c, 0x59,
+	0x59, 0x0c, 0x00, 0x55, 0x3c, 0x69, 0x65, 0x30,
+	0x3c, 0x69, 0x65, 0x30, 0x59, 0x0c, 0x00, 0x55,
+	0x55, 0x00, 0x0c, 0x59, 0x30, 0x65, 0x69, 0x3c,
+	0xa9, 0xfc, 0xf0, 0xa5, 0xcc, 0x99, 0x95, 0xc0,
+	0xc0, 0x95, 0x99, 0xcc, 0xa5, 0xf0, 0xfc, 0xa9,
+	0xa9, 0xfc, 0xf0, 0xa5, 0xcc, 0x99, 0x95, 0xc0,
+	0xc0, 0x95, 0x99, 0xcc, 0xa5, 0xf0, 0xfc, 0xa9,
+	0x3c, 0x69, 0x65, 0x30, 0x59, 0x0c, 0x00, 0x55,
+	0x55, 0x00, 0x0c, 0x59, 0x30, 0x65, 0x69, 0x3c,
+	0x30, 0x65, 0x69, 0x3c, 0x55, 0x00, 0x0c, 0x59,
+	0x59, 0x0c, 0x00, 0x55, 0x3c, 0x69, 0x65, 0x30,
+	0xa5, 0xf0, 0xfc, 0xa9, 0xc0, 0x95, 0x99, 0xcc,
+	0xcc, 0x99, 0x95, 0xc0, 0xa9, 0xfc, 0xf0, 0xa5,
+	0x0c, 0x59, 0x55, 0x00, 0x69, 0x3c, 0x30, 0x65,
+	0x65, 0x30, 0x3c, 0x69, 0x00, 0x55, 0x59, 0x0c,
+	0x99, 0xcc, 0xc0, 0x95, 0xfc, 0xa9, 0xa5, 0xf0,
+	0xf0, 0xa5, 0xa9, 0xfc, 0x95, 0xc0, 0xcc, 0x99,
+	0x95, 0xc0, 0xcc, 0x99, 0xf0, 0xa5, 0xa9, 0xfc,
+	0xfc, 0xa9, 0xa5, 0xf0, 0x99, 0xcc, 0xc0, 0x95,
+	0x00, 0x55, 0x59, 0x0c, 0x65, 0x30, 0x3c, 0x69,
+	0x69, 0x3c, 0x30, 0x65, 0x0c, 0x59, 0x55, 0x00,
+};
+
+
+/* Calculate the ECC for a 256-byte block of data */
+void yaffs_ecc_calc(const unsigned char *data, unsigned char *ecc)
+{
+	unsigned int i;
+	unsigned char col_parity = 0;
+	unsigned char line_parity = 0;
+	unsigned char line_parity_prime = 0;
+	unsigned char t;
+	unsigned char b;
+
+	for (i = 0; i < 256; i++) {
+		b = column_parity_table[*data++];
+		col_parity ^= b;
+
+		if (b & 0x01) {	/* odd number of bits in the byte */
+			line_parity ^= i;
+			line_parity_prime ^= ~i;
+		}
+	}
+
+	ecc[2] = (~col_parity) | 0x03;
+
+	t = 0;
+	if (line_parity & 0x80)
+		t |= 0x80;
+	if (line_parity_prime & 0x80)
+		t |= 0x40;
+	if (line_parity & 0x40)
+		t |= 0x20;
+	if (line_parity_prime & 0x40)
+		t |= 0x10;
+	if (line_parity & 0x20)
+		t |= 0x08;
+	if (line_parity_prime & 0x20)
+		t |= 0x04;
+	if (line_parity & 0x10)
+		t |= 0x02;
+	if (line_parity_prime & 0x10)
+		t |= 0x01;
+	ecc[1] = ~t;
+
+	t = 0;
+	if (line_parity & 0x08)
+		t |= 0x80;
+	if (line_parity_prime & 0x08)
+		t |= 0x40;
+	if (line_parity & 0x04)
+		t |= 0x20;
+	if (line_parity_prime & 0x04)
+		t |= 0x10;
+	if (line_parity & 0x02)
+		t |= 0x08;
+	if (line_parity_prime & 0x02)
+		t |= 0x04;
+	if (line_parity & 0x01)
+		t |= 0x02;
+	if (line_parity_prime & 0x01)
+		t |= 0x01;
+	ecc[0] = ~t;
+
+}
+
+/* Correct the ECC on a 256 byte block of data */
+
+int yaffs_ecc_correct(unsigned char *data, unsigned char *read_ecc,
+		      const unsigned char *test_ecc)
+{
+	unsigned char d0, d1, d2;	/* deltas */
+
+	d0 = read_ecc[0] ^ test_ecc[0];
+	d1 = read_ecc[1] ^ test_ecc[1];
+	d2 = read_ecc[2] ^ test_ecc[2];
+
+	if ((d0 | d1 | d2) == 0)
+		return 0;	/* no error */
+
+	if (((d0 ^ (d0 >> 1)) & 0x55) == 0x55 &&
+	    ((d1 ^ (d1 >> 1)) & 0x55) == 0x55 &&
+	    ((d2 ^ (d2 >> 1)) & 0x54) == 0x54) {
+		/* Single bit (recoverable) error in data */
+
+		unsigned byte;
+		unsigned bit;
+
+		bit = byte = 0;
+
+		if (d1 & 0x80)
+			byte |= 0x80;
+		if (d1 & 0x20)
+			byte |= 0x40;
+		if (d1 & 0x08)
+			byte |= 0x20;
+		if (d1 & 0x02)
+			byte |= 0x10;
+		if (d0 & 0x80)
+			byte |= 0x08;
+		if (d0 & 0x20)
+			byte |= 0x04;
+		if (d0 & 0x08)
+			byte |= 0x02;
+		if (d0 & 0x02)
+			byte |= 0x01;
+
+		if (d2 & 0x80)
+			bit |= 0x04;
+		if (d2 & 0x20)
+			bit |= 0x02;
+		if (d2 & 0x08)
+			bit |= 0x01;
+
+		data[byte] ^= (1 << bit);
+
+		return 1;	/* Corrected the error */
+	}
+
+	if ((hweight8(d0) + hweight8(d1) + hweight8(d2)) == 1) {
+		/* Reccoverable error in ecc */
+
+		read_ecc[0] = test_ecc[0];
+		read_ecc[1] = test_ecc[1];
+		read_ecc[2] = test_ecc[2];
+
+		return 1;	/* Corrected the error */
+	}
+
+	/* Unrecoverable error */
+
+	return -1;
+
+}
+
+/*
+ * ECCxxxOther does ECC calcs on arbitrary n bytes of data
+ */
+void yaffs_ecc_calc_other(const unsigned char *data, unsigned n_bytes,
+			  struct yaffs_ecc_other *ecc_other)
+{
+	unsigned int i;
+	unsigned char col_parity = 0;
+	unsigned line_parity = 0;
+	unsigned line_parity_prime = 0;
+	unsigned char b;
+
+	for (i = 0; i < n_bytes; i++) {
+		b = column_parity_table[*data++];
+		col_parity ^= b;
+
+		if (b & 0x01) {
+			/* odd number of bits in the byte */
+			line_parity ^= i;
+			line_parity_prime ^= ~i;
+		}
+
+	}
+
+	ecc_other->col_parity = (col_parity >> 2) & 0x3f;
+	ecc_other->line_parity = line_parity;
+	ecc_other->line_parity_prime = line_parity_prime;
+}
+
+int yaffs_ecc_correct_other(unsigned char *data, unsigned n_bytes,
+			    struct yaffs_ecc_other *read_ecc,
+			    const struct yaffs_ecc_other *test_ecc)
+{
+	unsigned char delta_col;	/* column parity delta */
+	unsigned delta_line;	/* line parity delta */
+	unsigned delta_line_prime;	/* line parity delta */
+	unsigned bit;
+
+	delta_col = read_ecc->col_parity ^ test_ecc->col_parity;
+	delta_line = read_ecc->line_parity ^ test_ecc->line_parity;
+	delta_line_prime =
+	    read_ecc->line_parity_prime ^ test_ecc->line_parity_prime;
+
+	if ((delta_col | delta_line | delta_line_prime) == 0)
+		return 0;	/* no error */
+
+	if (delta_line == ~delta_line_prime &&
+	    (((delta_col ^ (delta_col >> 1)) & 0x15) == 0x15)) {
+		/* Single bit (recoverable) error in data */
+
+		bit = 0;
+
+		if (delta_col & 0x20)
+			bit |= 0x04;
+		if (delta_col & 0x08)
+			bit |= 0x02;
+		if (delta_col & 0x02)
+			bit |= 0x01;
+
+		if (delta_line >= n_bytes)
+			return -1;
+
+		data[delta_line] ^= (1 << bit);
+
+		return 1;	/* corrected */
+	}
+
+	if ((hweight32(delta_line) +
+	     hweight32(delta_line_prime) +
+	     hweight8(delta_col)) == 1) {
+		/* Reccoverable error in ecc */
+
+		*read_ecc = *test_ecc;
+		return 1;	/* corrected */
+	}
+
+	/* Unrecoverable error */
+
+	return -1;
+}
diff --git a/fs/yaffs2/yaffs_ecc.h b/fs/yaffs2/yaffs_ecc.h
new file mode 100755
index 0000000..17d47bd
--- /dev/null
+++ b/fs/yaffs2/yaffs_ecc.h
@@ -0,0 +1,44 @@
+/*
+ * YAFFS: Yet another Flash File System . A NAND-flash specific file system.
+ *
+ * Copyright (C) 2002-2011 Aleph One Ltd.
+ *   for Toby Churchill Ltd and Brightstar Engineering
+ *
+ * Created by Charles Manning <charles@aleph1.co.uk>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 2.1 as
+ * published by the Free Software Foundation.
+ *
+ * Note: Only YAFFS headers are LGPL, YAFFS C code is covered by GPL.
+ */
+
+/*
+ * This code implements the ECC algorithm used in SmartMedia.
+ *
+ * The ECC comprises 22 bits of parity information and is stuffed into 3 bytes.
+ * The two unused bit are set to 1.
+ * The ECC can correct single bit errors in a 256-byte page of data.
+ * Thus, two such ECC blocks are used on a 512-byte NAND page.
+ *
+ */
+
+#ifndef __YAFFS_ECC_H__
+#define __YAFFS_ECC_H__
+
+struct yaffs_ecc_other {
+	unsigned char col_parity;
+	unsigned line_parity;
+	unsigned line_parity_prime;
+};
+
+void yaffs_ecc_calc(const unsigned char *data, unsigned char *ecc);
+int yaffs_ecc_correct(unsigned char *data, unsigned char *read_ecc,
+		      const unsigned char *test_ecc);
+
+void yaffs_ecc_calc_other(const unsigned char *data, unsigned n_bytes,
+			  struct yaffs_ecc_other *ecc);
+int yaffs_ecc_correct_other(unsigned char *data, unsigned n_bytes,
+			    struct yaffs_ecc_other *read_ecc,
+			    const struct yaffs_ecc_other *test_ecc);
+#endif
diff --git a/fs/yaffs2/yaffs_getblockinfo.h b/fs/yaffs2/yaffs_getblockinfo.h
new file mode 100755
index 0000000..8fd0802
--- /dev/null
+++ b/fs/yaffs2/yaffs_getblockinfo.h
@@ -0,0 +1,35 @@
+/*
+ * YAFFS: Yet another Flash File System . A NAND-flash specific file system.
+ *
+ * Copyright (C) 2002-2011 Aleph One Ltd.
+ *   for Toby Churchill Ltd and Brightstar Engineering
+ *
+ * Created by Charles Manning <charles@aleph1.co.uk>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 2.1 as
+ * published by the Free Software Foundation.
+ *
+ * Note: Only YAFFS headers are LGPL, YAFFS C code is covered by GPL.
+ */
+
+#ifndef __YAFFS_GETBLOCKINFO_H__
+#define __YAFFS_GETBLOCKINFO_H__
+
+#include "yaffs_guts.h"
+#include "yaffs_trace.h"
+
+/* Function to manipulate block info */
+static inline struct yaffs_block_info *yaffs_get_block_info(struct yaffs_dev
+							      *dev, int blk)
+{
+	if (blk < dev->internal_start_block || blk > dev->internal_end_block) {
+		yaffs_trace(YAFFS_TRACE_ERROR,
+			"**>> yaffs: get_block_info block %d is not valid",
+			blk);
+		BUG();
+	}
+	return &dev->block_info[blk - dev->internal_start_block];
+}
+
+#endif
diff --git a/fs/yaffs2/yaffs_guts.c b/fs/yaffs2/yaffs_guts.c
new file mode 100755
index 0000000..bf58eca
--- /dev/null
+++ b/fs/yaffs2/yaffs_guts.c
@@ -0,0 +1,5152 @@
+/*
+ * YAFFS: Yet Another Flash File System. A NAND-flash specific file system.
+ *
+ * Copyright (C) 2002-2011 Aleph One Ltd.
+ *   for Toby Churchill Ltd and Brightstar Engineering
+ *
+ * Created by Charles Manning <charles@aleph1.co.uk>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include "yportenv.h"
+#include "yaffs_trace.h"
+
+#include "yaffs_guts.h"
+#include "yaffs_getblockinfo.h"
+#include "yaffs_tagscompat.h"
+#include "yaffs_tagsmarshall.h"
+#include "yaffs_nand.h"
+#include "yaffs_yaffs1.h"
+#include "yaffs_yaffs2.h"
+#include "yaffs_bitmap.h"
+#include "yaffs_verify.h"
+#include "yaffs_nand.h"
+#include "yaffs_packedtags2.h"
+#include "yaffs_nameval.h"
+#include "yaffs_allocator.h"
+#include "yaffs_attribs.h"
+#include "yaffs_summary.h"
+
+/* Note YAFFS_GC_GOOD_ENOUGH must be <= YAFFS_GC_PASSIVE_THRESHOLD */
+#define YAFFS_GC_GOOD_ENOUGH 2
+#define YAFFS_GC_PASSIVE_THRESHOLD 4
+
+#include "yaffs_ecc.h"
+
+/* Forward declarations */
+
+static int yaffs_wr_data_obj(struct yaffs_obj *in, int inode_chunk,
+			     const u8 *buffer, int n_bytes, int use_reserve);
+
+static void yaffs_fix_null_name(struct yaffs_obj *obj, YCHAR *name,
+				int buffer_size);
+
+/* Function to calculate chunk and offset */
+
+void yaffs_addr_to_chunk(struct yaffs_dev *dev, loff_t addr,
+				int *chunk_out, u32 *offset_out)
+{
+	int chunk;
+	u32 offset;
+
+	chunk = (u32) (addr >> dev->chunk_shift);
+
+	if (dev->chunk_div == 1) {
+		/* easy power of 2 case */
+		offset = (u32) (addr & dev->chunk_mask);
+	} else {
+		/* Non power-of-2 case */
+
+		loff_t chunk_base;
+
+		chunk /= dev->chunk_div;
+
+		chunk_base = ((loff_t) chunk) * dev->data_bytes_per_chunk;
+		offset = (u32) (addr - chunk_base);
+	}
+
+	*chunk_out = chunk;
+	*offset_out = offset;
+}
+
+/* Function to return the number of shifts for a power of 2 greater than or
+ * equal to the given number
+ * Note we don't try to cater for all possible numbers and this does not have to
+ * be hellishly efficient.
+ */
+
+static inline u32 calc_shifts_ceiling(u32 x)
+{
+	int extra_bits;
+	int shifts;
+
+	shifts = extra_bits = 0;
+
+	while (x > 1) {
+		if (x & 1)
+			extra_bits++;
+		x >>= 1;
+		shifts++;
+	}
+
+	if (extra_bits)
+		shifts++;
+
+	return shifts;
+}
+
+/* Function to return the number of shifts to get a 1 in bit 0
+ */
+
+static inline u32 calc_shifts(u32 x)
+{
+	u32 shifts;
+
+	shifts = 0;
+
+	if (!x)
+		return 0;
+
+	while (!(x & 1)) {
+		x >>= 1;
+		shifts++;
+	}
+
+	return shifts;
+}
+
+/*
+ * Temporary buffer manipulations.
+ */
+
+static int yaffs_init_tmp_buffers(struct yaffs_dev *dev)
+{
+	int i;
+	u8 *buf = (u8 *) 1;
+
+	memset(dev->temp_buffer, 0, sizeof(dev->temp_buffer));
+
+	for (i = 0; buf && i < YAFFS_N_TEMP_BUFFERS; i++) {
+		dev->temp_buffer[i].in_use = 0;
+		buf = kmalloc(dev->param.total_bytes_per_chunk, GFP_NOFS);
+		dev->temp_buffer[i].buffer = buf;
+	}
+
+	return buf ? YAFFS_OK : YAFFS_FAIL;
+}
+
+u8 *yaffs_get_temp_buffer(struct yaffs_dev * dev)
+{
+	int i;
+
+	dev->temp_in_use++;
+	if (dev->temp_in_use > dev->max_temp)
+		dev->max_temp = dev->temp_in_use;
+
+	for (i = 0; i < YAFFS_N_TEMP_BUFFERS; i++) {
+		if (dev->temp_buffer[i].in_use == 0) {
+			dev->temp_buffer[i].in_use = 1;
+			return dev->temp_buffer[i].buffer;
+		}
+	}
+
+	yaffs_trace(YAFFS_TRACE_BUFFERS, "Out of temp buffers");
+	/*
+	 * If we got here then we have to allocate an unmanaged one
+	 * This is not good.
+	 */
+
+	dev->unmanaged_buffer_allocs++;
+	return kmalloc(dev->data_bytes_per_chunk, GFP_NOFS);
+
+}
+
+void yaffs_release_temp_buffer(struct yaffs_dev *dev, u8 *buffer)
+{
+	int i;
+
+	dev->temp_in_use--;
+
+	for (i = 0; i < YAFFS_N_TEMP_BUFFERS; i++) {
+		if (dev->temp_buffer[i].buffer == buffer) {
+			dev->temp_buffer[i].in_use = 0;
+			return;
+		}
+	}
+
+	if (buffer) {
+		/* assume it is an unmanaged one. */
+		yaffs_trace(YAFFS_TRACE_BUFFERS,
+			"Releasing unmanaged temp buffer");
+		kfree(buffer);
+		dev->unmanaged_buffer_deallocs++;
+	}
+
+}
+
+/*
+ * Functions for robustisizing TODO
+ *
+ */
+
+static void yaffs_handle_chunk_wr_ok(struct yaffs_dev *dev, int nand_chunk,
+				     const u8 *data,
+				     const struct yaffs_ext_tags *tags)
+{
+	(void) dev;
+	(void) nand_chunk;
+	(void) data;
+	(void) tags;
+}
+
+static void yaffs_handle_chunk_update(struct yaffs_dev *dev, int nand_chunk,
+				      const struct yaffs_ext_tags *tags)
+{
+	(void) dev;
+	(void) nand_chunk;
+	(void) tags;
+}
+
+void yaffs_handle_chunk_error(struct yaffs_dev *dev,
+			      struct yaffs_block_info *bi)
+{
+	if (!bi->gc_prioritise) {
+		bi->gc_prioritise = 1;
+		dev->has_pending_prioritised_gc = 1;
+		bi->chunk_error_strikes++;
+
+		if (bi->chunk_error_strikes > 3) {
+			bi->needs_retiring = 1;	/* Too many stikes, so retire */
+			yaffs_trace(YAFFS_TRACE_ALWAYS,
+				"yaffs: Block struck out");
+
+		}
+	}
+}
+
+static void yaffs_handle_chunk_wr_error(struct yaffs_dev *dev, int nand_chunk,
+					int erased_ok)
+{
+	int flash_block = nand_chunk / dev->param.chunks_per_block;
+	struct yaffs_block_info *bi = yaffs_get_block_info(dev, flash_block);
+
+	yaffs_handle_chunk_error(dev, bi);
+
+	if (erased_ok) {
+		/* Was an actual write failure,
+		 * so mark the block for retirement.*/
+		bi->needs_retiring = 1;
+		yaffs_trace(YAFFS_TRACE_ERROR | YAFFS_TRACE_BAD_BLOCKS,
+		  "**>> Block %d needs retiring", flash_block);
+	}
+
+	/* Delete the chunk */
+	yaffs_chunk_del(dev, nand_chunk, 1, __LINE__);
+	yaffs_skip_rest_of_block(dev);
+}
+
+/*
+ * Verification code
+ */
+
+/*
+ *  Simple hash function. Needs to have a reasonable spread
+ */
+
+static inline int yaffs_hash_fn(int n)
+{
+	if (n < 0)
+		n = -n;
+	return n % YAFFS_NOBJECT_BUCKETS;
+}
+
+/*
+ * Access functions to useful fake objects.
+ * Note that root might have a presence in NAND if permissions are set.
+ */
+
+struct yaffs_obj *yaffs_root(struct yaffs_dev *dev)
+{
+	return dev->root_dir;
+}
+
+struct yaffs_obj *yaffs_lost_n_found(struct yaffs_dev *dev)
+{
+	return dev->lost_n_found;
+}
+
+/*
+ *  Erased NAND checking functions
+ */
+
+int yaffs_check_ff(u8 *buffer, int n_bytes)
+{
+	/* Horrible, slow implementation */
+	while (n_bytes--) {
+		if (*buffer != 0xff)
+			return 0;
+		buffer++;
+	}
+	return 1;
+}
+
+static int yaffs_check_chunk_erased(struct yaffs_dev *dev, int nand_chunk)
+{
+	int retval = YAFFS_OK;
+	u8 *data = yaffs_get_temp_buffer(dev);
+	struct yaffs_ext_tags tags;
+	int result;
+
+	result = yaffs_rd_chunk_tags_nand(dev, nand_chunk, data, &tags);
+
+	if (tags.ecc_result > YAFFS_ECC_RESULT_NO_ERROR)
+		retval = YAFFS_FAIL;
+
+	if (!yaffs_check_ff(data, dev->data_bytes_per_chunk) ||
+		tags.chunk_used) {
+		yaffs_trace(YAFFS_TRACE_NANDACCESS,
+			"Chunk %d not erased", nand_chunk);
+		retval = YAFFS_FAIL;
+	}
+
+	yaffs_release_temp_buffer(dev, data);
+
+	return retval;
+
+}
+
+static int yaffs_verify_chunk_written(struct yaffs_dev *dev,
+				      int nand_chunk,
+				      const u8 *data,
+				      struct yaffs_ext_tags *tags)
+{
+	int retval = YAFFS_OK;
+	struct yaffs_ext_tags temp_tags;
+	u8 *buffer = yaffs_get_temp_buffer(dev);
+	int result;
+
+	result = yaffs_rd_chunk_tags_nand(dev, nand_chunk, buffer, &temp_tags);
+	if (memcmp(buffer, data, dev->data_bytes_per_chunk) ||
+	    temp_tags.obj_id != tags->obj_id ||
+	    temp_tags.chunk_id != tags->chunk_id ||
+	    temp_tags.n_bytes != tags->n_bytes)
+		retval = YAFFS_FAIL;
+
+	yaffs_release_temp_buffer(dev, buffer);
+
+	return retval;
+}
+
+
+int yaffs_check_alloc_available(struct yaffs_dev *dev, int n_chunks)
+{
+	int reserved_chunks;
+	int reserved_blocks = dev->param.n_reserved_blocks;
+	int checkpt_blocks;
+
+	checkpt_blocks = yaffs_calc_checkpt_blocks_required(dev);
+
+	reserved_chunks =
+	    (reserved_blocks + checkpt_blocks) * dev->param.chunks_per_block;
+
+	return (dev->n_free_chunks > (reserved_chunks + n_chunks));
+}
+
+static int yaffs_find_alloc_block(struct yaffs_dev *dev)
+{
+	int i;
+	struct yaffs_block_info *bi;
+
+	if (dev->n_erased_blocks < 1) {
+		/* Hoosterman we've got a problem.
+		 * Can't get space to gc
+		 */
+		yaffs_trace(YAFFS_TRACE_ERROR,
+		  "yaffs tragedy: no more erased blocks");
+
+		return -1;
+	}
+
+	/* Find an empty block. */
+
+	for (i = dev->internal_start_block; i <= dev->internal_end_block; i++) {
+		dev->alloc_block_finder++;
+		if (dev->alloc_block_finder < dev->internal_start_block
+		    || dev->alloc_block_finder > dev->internal_end_block) {
+			dev->alloc_block_finder = dev->internal_start_block;
+		}
+
+		bi = yaffs_get_block_info(dev, dev->alloc_block_finder);
+
+		if (bi->block_state == YAFFS_BLOCK_STATE_EMPTY) {
+			bi->block_state = YAFFS_BLOCK_STATE_ALLOCATING;
+			dev->seq_number++;
+			bi->seq_number = dev->seq_number;
+			dev->n_erased_blocks--;
+			yaffs_trace(YAFFS_TRACE_ALLOCATE,
+			  "Allocated block %d, seq  %d, %d left" ,
+			   dev->alloc_block_finder, dev->seq_number,
+			   dev->n_erased_blocks);
+			return dev->alloc_block_finder;
+		}
+	}
+
+	yaffs_trace(YAFFS_TRACE_ALWAYS,
+		"yaffs tragedy: no more erased blocks, but there should have been %d",
+		dev->n_erased_blocks);
+
+	return -1;
+}
+
+static int yaffs_alloc_chunk(struct yaffs_dev *dev, int use_reserver,
+			     struct yaffs_block_info **block_ptr)
+{
+	int ret_val;
+	struct yaffs_block_info *bi;
+
+	if (dev->alloc_block < 0) {
+		/* Get next block to allocate off */
+		dev->alloc_block = yaffs_find_alloc_block(dev);
+		dev->alloc_page = 0;
+	}
+
+	if (!use_reserver && !yaffs_check_alloc_available(dev, 1)) {
+		/* No space unless we're allowed to use the reserve. */
+		return -1;
+	}
+
+	if (dev->n_erased_blocks < dev->param.n_reserved_blocks
+	    && dev->alloc_page == 0)
+		yaffs_trace(YAFFS_TRACE_ALLOCATE, "Allocating reserve");
+
+	/* Next page please.... */
+	if (dev->alloc_block >= 0) {
+		bi = yaffs_get_block_info(dev, dev->alloc_block);
+
+		ret_val = (dev->alloc_block * dev->param.chunks_per_block) +
+		    dev->alloc_page;
+		bi->pages_in_use++;
+		yaffs_set_chunk_bit(dev, dev->alloc_block, dev->alloc_page);
+
+		dev->alloc_page++;
+
+		dev->n_free_chunks--;
+
+		/* If the block is full set the state to full */
+		if (dev->alloc_page >= dev->param.chunks_per_block) {
+			bi->block_state = YAFFS_BLOCK_STATE_FULL;
+			dev->alloc_block = -1;
+		}
+
+		if (block_ptr)
+			*block_ptr = bi;
+
+		return ret_val;
+	}
+
+	yaffs_trace(YAFFS_TRACE_ERROR,
+		"!!!!!!!!! Allocator out !!!!!!!!!!!!!!!!!");
+
+	return -1;
+}
+
+static int yaffs_get_erased_chunks(struct yaffs_dev *dev)
+{
+	int n;
+
+	n = dev->n_erased_blocks * dev->param.chunks_per_block;
+
+	if (dev->alloc_block > 0)
+		n += (dev->param.chunks_per_block - dev->alloc_page);
+
+	return n;
+
+}
+
+/*
+ * yaffs_skip_rest_of_block() skips over the rest of the allocation block
+ * if we don't want to write to it.
+ */
+void yaffs_skip_rest_of_block(struct yaffs_dev *dev)
+{
+	struct yaffs_block_info *bi;
+
+	if (dev->alloc_block > 0) {
+		bi = yaffs_get_block_info(dev, dev->alloc_block);
+		if (bi->block_state == YAFFS_BLOCK_STATE_ALLOCATING) {
+			bi->block_state = YAFFS_BLOCK_STATE_FULL;
+			dev->alloc_block = -1;
+		}
+	}
+}
+
+static int yaffs_write_new_chunk(struct yaffs_dev *dev,
+				 const u8 *data,
+				 struct yaffs_ext_tags *tags, int use_reserver)
+{
+	int attempts = 0;
+	int write_ok = 0;
+	int chunk;
+
+	yaffs2_checkpt_invalidate(dev);
+
+	do {
+		struct yaffs_block_info *bi = 0;
+		int erased_ok = 0;
+
+		chunk = yaffs_alloc_chunk(dev, use_reserver, &bi);
+		if (chunk < 0) {
+			/* no space */
+			break;
+		}
+
+		/* First check this chunk is erased, if it needs
+		 * checking.  The checking policy (unless forced
+		 * always on) is as follows:
+		 *
+		 * Check the first page we try to write in a block.
+		 * If the check passes then we don't need to check any
+		 * more.        If the check fails, we check again...
+		 * If the block has been erased, we don't need to check.
+		 *
+		 * However, if the block has been prioritised for gc,
+		 * then we think there might be something odd about
+		 * this block and stop using it.
+		 *
+		 * Rationale: We should only ever see chunks that have
+		 * not been erased if there was a partially written
+		 * chunk due to power loss.  This checking policy should
+		 * catch that case with very few checks and thus save a
+		 * lot of checks that are most likely not needed.
+		 *
+		 * Mods to the above
+		 * If an erase check fails or the write fails we skip the
+		 * rest of the block.
+		 */
+
+		/* let's give it a try */
+		attempts++;
+
+		if (dev->param.always_check_erased)
+			bi->skip_erased_check = 0;
+
+		if (!bi->skip_erased_check) {
+			erased_ok = yaffs_check_chunk_erased(dev, chunk);
+			if (erased_ok != YAFFS_OK) {
+				yaffs_trace(YAFFS_TRACE_ERROR,
+				  "**>> yaffs chunk %d was not erased",
+				  chunk);
+
+				/* If not erased, delete this one,
+				 * skip rest of block and
+				 * try another chunk */
+				yaffs_chunk_del(dev, chunk, 1, __LINE__);
+				yaffs_skip_rest_of_block(dev);
+				continue;
+			}
+		}
+
+		write_ok = yaffs_wr_chunk_tags_nand(dev, chunk, data, tags);
+
+		if (!bi->skip_erased_check)
+			write_ok =
+			    yaffs_verify_chunk_written(dev, chunk, data, tags);
+
+		if (write_ok != YAFFS_OK) {
+			/* Clean up aborted write, skip to next block and
+			 * try another chunk */
+			yaffs_handle_chunk_wr_error(dev, chunk, erased_ok);
+			continue;
+		}
+
+		bi->skip_erased_check = 1;
+
+		/* Copy the data into the robustification buffer */
+		yaffs_handle_chunk_wr_ok(dev, chunk, data, tags);
+
+	} while (write_ok != YAFFS_OK &&
+		 (yaffs_wr_attempts <= 0 || attempts <= yaffs_wr_attempts));
+
+	if (!write_ok)
+		chunk = -1;
+
+	if (attempts > 1) {
+		yaffs_trace(YAFFS_TRACE_ERROR,
+			"**>> yaffs write required %d attempts",
+			attempts);
+		dev->n_retried_writes += (attempts - 1);
+	}
+
+	return chunk;
+}
+
+/*
+ * Block retiring for handling a broken block.
+ */
+
+static void yaffs_retire_block(struct yaffs_dev *dev, int flash_block)
+{
+	struct yaffs_block_info *bi = yaffs_get_block_info(dev, flash_block);
+
+	yaffs2_checkpt_invalidate(dev);
+
+	yaffs2_clear_oldest_dirty_seq(dev, bi);
+
+	if (yaffs_mark_bad(dev, flash_block) != YAFFS_OK) {
+		if (yaffs_erase_block(dev, flash_block) != YAFFS_OK) {
+			yaffs_trace(YAFFS_TRACE_ALWAYS,
+				"yaffs: Failed to mark bad and erase block %d",
+				flash_block);
+		} else {
+			struct yaffs_ext_tags tags;
+			int chunk_id =
+			    flash_block * dev->param.chunks_per_block;
+
+			u8 *buffer = yaffs_get_temp_buffer(dev);
+
+			memset(buffer, 0xff, dev->data_bytes_per_chunk);
+			memset(&tags, 0, sizeof(tags));
+			tags.seq_number = YAFFS_SEQUENCE_BAD_BLOCK;
+			if (dev->tagger.write_chunk_tags_fn(dev, chunk_id -
+							dev->chunk_offset,
+							buffer,
+							&tags) != YAFFS_OK)
+				yaffs_trace(YAFFS_TRACE_ALWAYS,
+					"yaffs: Failed to write bad block marker to block %d",
+					flash_block);
+
+			yaffs_release_temp_buffer(dev, buffer);
+		}
+	}
+
+	bi->block_state = YAFFS_BLOCK_STATE_DEAD;
+	bi->gc_prioritise = 0;
+	bi->needs_retiring = 0;
+
+	dev->n_retired_blocks++;
+}
+
+/*---------------- Name handling functions ------------*/
+
+static void yaffs_load_name_from_oh(struct yaffs_dev *dev, YCHAR *name,
+				    const YCHAR *oh_name, int buff_size)
+{
+#ifdef CONFIG_YAFFS_AUTO_UNICODE
+	if (dev->param.auto_unicode) {
+		if (*oh_name) {
+			/* It is an ASCII name, do an ASCII to
+			 * unicode conversion */
+			const char *ascii_oh_name = (const char *)oh_name;
+			int n = buff_size - 1;
+			while (n > 0 && *ascii_oh_name) {
+				*name = *ascii_oh_name;
+				name++;
+				ascii_oh_name++;
+				n--;
+			}
+		} else {
+			strncpy(name, oh_name + 1, buff_size - 1);
+		}
+	} else {
+#else
+	(void) dev;
+	{
+#endif
+		strncpy(name, oh_name, buff_size - 1);
+	}
+}
+
+static void yaffs_load_oh_from_name(struct yaffs_dev *dev, YCHAR *oh_name,
+				    const YCHAR *name)
+{
+#ifdef CONFIG_YAFFS_AUTO_UNICODE
+
+	int is_ascii;
+	const YCHAR *w;
+
+	if (dev->param.auto_unicode) {
+
+		is_ascii = 1;
+		w = name;
+
+		/* Figure out if the name will fit in ascii character set */
+		while (is_ascii && *w) {
+			if ((*w) & 0xff00)
+				is_ascii = 0;
+			w++;
+		}
+
+		if (is_ascii) {
+			/* It is an ASCII name, so convert unicode to ascii */
+			char *ascii_oh_name = (char *)oh_name;
+			int n = YAFFS_MAX_NAME_LENGTH - 1;
+			while (n > 0 && *name) {
+				*ascii_oh_name = *name;
+				name++;
+				ascii_oh_name++;
+				n--;
+			}
+		} else {
+			/* Unicode name, so save starting at the second YCHAR */
+			*oh_name = 0;
+			strncpy(oh_name + 1, name, YAFFS_MAX_NAME_LENGTH - 2);
+		}
+	} else {
+#else
+	dev = dev;
+	{
+#endif
+		strncpy(oh_name, name, YAFFS_MAX_NAME_LENGTH - 1);
+	}
+}
+
+static u16 yaffs_calc_name_sum(const YCHAR *name)
+{
+	u16 sum = 0;
+	u16 i = 1;
+
+	if (!name)
+		return 0;
+
+	while ((*name) && i < (YAFFS_MAX_NAME_LENGTH / 2)) {
+
+		/* 0x1f mask is case insensitive */
+		sum += ((*name) & 0x1f) * i;
+		i++;
+		name++;
+	}
+	return sum;
+}
+
+
+void yaffs_set_obj_name(struct yaffs_obj *obj, const YCHAR * name)
+{
+	memset(obj->short_name, 0, sizeof(obj->short_name));
+
+	if (name && !name[0]) {
+		yaffs_fix_null_name(obj, obj->short_name,
+				YAFFS_SHORT_NAME_LENGTH);
+		name = obj->short_name;
+	} else if (name &&
+		strnlen(name, YAFFS_SHORT_NAME_LENGTH + 1) <=
+		YAFFS_SHORT_NAME_LENGTH)  {
+		strcpy(obj->short_name, name);
+	}
+
+	obj->sum = yaffs_calc_name_sum(name);
+}
+
+void yaffs_set_obj_name_from_oh(struct yaffs_obj *obj,
+				const struct yaffs_obj_hdr *oh)
+{
+#ifdef CONFIG_YAFFS_AUTO_UNICODE
+	YCHAR tmp_name[YAFFS_MAX_NAME_LENGTH + 1];
+	memset(tmp_name, 0, sizeof(tmp_name));
+	yaffs_load_name_from_oh(obj->my_dev, tmp_name, oh->name,
+				YAFFS_MAX_NAME_LENGTH + 1);
+	yaffs_set_obj_name(obj, tmp_name);
+#else
+	yaffs_set_obj_name(obj, oh->name);
+#endif
+}
+
+loff_t yaffs_max_file_size(struct yaffs_dev *dev)
+{
+	if(sizeof(loff_t) < 8)
+		return YAFFS_MAX_FILE_SIZE_32;
+	else
+		return ((loff_t) YAFFS_MAX_CHUNK_ID) * dev->data_bytes_per_chunk;
+}
+
+/*-------------------- TNODES -------------------
+
+ * List of spare tnodes
+ * The list is hooked together using the first pointer
+ * in the tnode.
+ */
+
+struct yaffs_tnode *yaffs_get_tnode(struct yaffs_dev *dev)
+{
+	struct yaffs_tnode *tn = yaffs_alloc_raw_tnode(dev);
+
+	if (tn) {
+		memset(tn, 0, dev->tnode_size);
+		dev->n_tnodes++;
+	}
+
+	dev->checkpoint_blocks_required = 0;	/* force recalculation */
+
+	return tn;
+}
+
+/* FreeTnode frees up a tnode and puts it back on the free list */
+static void yaffs_free_tnode(struct yaffs_dev *dev, struct yaffs_tnode *tn)
+{
+	yaffs_free_raw_tnode(dev, tn);
+	dev->n_tnodes--;
+	dev->checkpoint_blocks_required = 0;	/* force recalculation */
+}
+
+static void yaffs_deinit_tnodes_and_objs(struct yaffs_dev *dev)
+{
+	yaffs_deinit_raw_tnodes_and_objs(dev);
+	dev->n_obj = 0;
+	dev->n_tnodes = 0;
+}
+
+static void yaffs_load_tnode_0(struct yaffs_dev *dev, struct yaffs_tnode *tn,
+			unsigned pos, unsigned val)
+{
+	u32 *map = (u32 *) tn;
+	u32 bit_in_map;
+	u32 bit_in_word;
+	u32 word_in_map;
+	u32 mask;
+
+	pos &= YAFFS_TNODES_LEVEL0_MASK;
+	val >>= dev->chunk_grp_bits;
+
+	bit_in_map = pos * dev->tnode_width;
+	word_in_map = bit_in_map / 32;
+	bit_in_word = bit_in_map & (32 - 1);
+
+	mask = dev->tnode_mask << bit_in_word;
+
+	map[word_in_map] &= ~mask;
+	map[word_in_map] |= (mask & (val << bit_in_word));
+
+	if (dev->tnode_width > (32 - bit_in_word)) {
+		bit_in_word = (32 - bit_in_word);
+		word_in_map++;
+		mask =
+		    dev->tnode_mask >> bit_in_word;
+		map[word_in_map] &= ~mask;
+		map[word_in_map] |= (mask & (val >> bit_in_word));
+	}
+}
+
+u32 yaffs_get_group_base(struct yaffs_dev *dev, struct yaffs_tnode *tn,
+			 unsigned pos)
+{
+	u32 *map = (u32 *) tn;
+	u32 bit_in_map;
+	u32 bit_in_word;
+	u32 word_in_map;
+	u32 val;
+
+	pos &= YAFFS_TNODES_LEVEL0_MASK;
+
+	bit_in_map = pos * dev->tnode_width;
+	word_in_map = bit_in_map / 32;
+	bit_in_word = bit_in_map & (32 - 1);
+
+	val = map[word_in_map] >> bit_in_word;
+
+	if (dev->tnode_width > (32 - bit_in_word)) {
+		bit_in_word = (32 - bit_in_word);
+		word_in_map++;
+		val |= (map[word_in_map] << bit_in_word);
+	}
+
+	val &= dev->tnode_mask;
+	val <<= dev->chunk_grp_bits;
+
+	return val;
+}
+
+/* ------------------- End of individual tnode manipulation -----------------*/
+
+/* ---------Functions to manipulate the look-up tree (made up of tnodes) ------
+ * The look up tree is represented by the top tnode and the number of top_level
+ * in the tree. 0 means only the level 0 tnode is in the tree.
+ */
+
+/* FindLevel0Tnode finds the level 0 tnode, if one exists. */
+struct yaffs_tnode *yaffs_find_tnode_0(struct yaffs_dev *dev,
+				       struct yaffs_file_var *file_struct,
+				       u32 chunk_id)
+{
+	struct yaffs_tnode *tn = file_struct->top;
+	u32 i;
+	int required_depth;
+	int level = file_struct->top_level;
+
+	(void) dev;
+
+	/* Check sane level and chunk Id */
+	if (level < 0 || level > YAFFS_TNODES_MAX_LEVEL)
+		return NULL;
+
+	if (chunk_id > YAFFS_MAX_CHUNK_ID)
+		return NULL;
+
+	/* First check we're tall enough (ie enough top_level) */
+
+	i = chunk_id >> YAFFS_TNODES_LEVEL0_BITS;
+	required_depth = 0;
+	while (i) {
+		i >>= YAFFS_TNODES_INTERNAL_BITS;
+		required_depth++;
+	}
+
+	if (required_depth > file_struct->top_level)
+		return NULL;	/* Not tall enough, so we can't find it */
+
+	/* Traverse down to level 0 */
+	while (level > 0 && tn) {
+		tn = tn->internal[(chunk_id >>
+				   (YAFFS_TNODES_LEVEL0_BITS +
+				    (level - 1) *
+				    YAFFS_TNODES_INTERNAL_BITS)) &
+				  YAFFS_TNODES_INTERNAL_MASK];
+		level--;
+	}
+
+	return tn;
+}
+
+/* add_find_tnode_0 finds the level 0 tnode if it exists,
+ * otherwise first expands the tree.
+ * This happens in two steps:
+ *  1. If the tree isn't tall enough, then make it taller.
+ *  2. Scan down the tree towards the level 0 tnode adding tnodes if required.
+ *
+ * Used when modifying the tree.
+ *
+ *  If the tn argument is NULL, then a fresh tnode will be added otherwise the
+ *  specified tn will be plugged into the ttree.
+ */
+
+struct yaffs_tnode *yaffs_add_find_tnode_0(struct yaffs_dev *dev,
+					   struct yaffs_file_var *file_struct,
+					   u32 chunk_id,
+					   struct yaffs_tnode *passed_tn)
+{
+	int required_depth;
+	int i;
+	int l;
+	struct yaffs_tnode *tn;
+	u32 x;
+
+	/* Check sane level and page Id */
+	if (file_struct->top_level < 0 ||
+	    file_struct->top_level > YAFFS_TNODES_MAX_LEVEL)
+		return NULL;
+
+	if (chunk_id > YAFFS_MAX_CHUNK_ID)
+		return NULL;
+
+	/* First check we're tall enough (ie enough top_level) */
+
+	x = chunk_id >> YAFFS_TNODES_LEVEL0_BITS;
+	required_depth = 0;
+	while (x) {
+		x >>= YAFFS_TNODES_INTERNAL_BITS;
+		required_depth++;
+	}
+
+	if (required_depth > file_struct->top_level) {
+		/* Not tall enough, gotta make the tree taller */
+		for (i = file_struct->top_level; i < required_depth; i++) {
+
+			tn = yaffs_get_tnode(dev);
+
+			if (tn) {
+				tn->internal[0] = file_struct->top;
+				file_struct->top = tn;
+				file_struct->top_level++;
+			} else {
+				yaffs_trace(YAFFS_TRACE_ERROR,
+					"yaffs: no more tnodes");
+				return NULL;
+			}
+		}
+	}
+
+	/* Traverse down to level 0, adding anything we need */
+
+	l = file_struct->top_level;
+	tn = file_struct->top;
+
+	if (l > 0) {
+		while (l > 0 && tn) {
+			x = (chunk_id >>
+			     (YAFFS_TNODES_LEVEL0_BITS +
+			      (l - 1) * YAFFS_TNODES_INTERNAL_BITS)) &
+			    YAFFS_TNODES_INTERNAL_MASK;
+
+			if ((l > 1) && !tn->internal[x]) {
+				/* Add missing non-level-zero tnode */
+				tn->internal[x] = yaffs_get_tnode(dev);
+				if (!tn->internal[x])
+					return NULL;
+			} else if (l == 1) {
+				/* Looking from level 1 at level 0 */
+				if (passed_tn) {
+					/* If we already have one, release it */
+					if (tn->internal[x])
+						yaffs_free_tnode(dev,
+							tn->internal[x]);
+					tn->internal[x] = passed_tn;
+
+				} else if (!tn->internal[x]) {
+					/* Don't have one, none passed in */
+					tn->internal[x] = yaffs_get_tnode(dev);
+					if (!tn->internal[x])
+						return NULL;
+				}
+			}
+
+			tn = tn->internal[x];
+			l--;
+		}
+	} else {
+		/* top is level 0 */
+		if (passed_tn) {
+			memcpy(tn, passed_tn,
+			       (dev->tnode_width * YAFFS_NTNODES_LEVEL0) / 8);
+			yaffs_free_tnode(dev, passed_tn);
+		}
+	}
+
+	return tn;
+}
+
+static int yaffs_tags_match(const struct yaffs_ext_tags *tags, int obj_id,
+			    int chunk_obj)
+{
+	return (tags->chunk_id == chunk_obj &&
+		tags->obj_id == obj_id &&
+		!tags->is_deleted) ? 1 : 0;
+
+}
+
+static int yaffs_find_chunk_in_group(struct yaffs_dev *dev, int the_chunk,
+					struct yaffs_ext_tags *tags, int obj_id,
+					int inode_chunk)
+{
+	int j;
+
+	for (j = 0; the_chunk && j < dev->chunk_grp_size; j++) {
+		if (yaffs_check_chunk_bit
+		    (dev, the_chunk / dev->param.chunks_per_block,
+		     the_chunk % dev->param.chunks_per_block)) {
+
+			if (dev->chunk_grp_size == 1)
+				return the_chunk;
+			else {
+				yaffs_rd_chunk_tags_nand(dev, the_chunk, NULL,
+							 tags);
+				if (yaffs_tags_match(tags,
+							obj_id, inode_chunk)) {
+					/* found it; */
+					return the_chunk;
+				}
+			}
+		}
+		the_chunk++;
+	}
+	return -1;
+}
+
+int yaffs_find_chunk_in_file(struct yaffs_obj *in, int inode_chunk,
+				    struct yaffs_ext_tags *tags)
+{
+	/*Get the Tnode, then get the level 0 offset chunk offset */
+	struct yaffs_tnode *tn;
+	int the_chunk = -1;
+	struct yaffs_ext_tags local_tags;
+	int ret_val = -1;
+	struct yaffs_dev *dev = in->my_dev;
+
+	if (!tags) {
+		/* Passed a NULL, so use our own tags space */
+		tags = &local_tags;
+	}
+
+	tn = yaffs_find_tnode_0(dev, &in->variant.file_variant, inode_chunk);
+
+	if (!tn)
+		return ret_val;
+
+	the_chunk = yaffs_get_group_base(dev, tn, inode_chunk);
+
+	ret_val = yaffs_find_chunk_in_group(dev, the_chunk, tags, in->obj_id,
+					      inode_chunk);
+	return ret_val;
+}
+
+static int yaffs_find_del_file_chunk(struct yaffs_obj *in, int inode_chunk,
+				     struct yaffs_ext_tags *tags)
+{
+	/* Get the Tnode, then get the level 0 offset chunk offset */
+	struct yaffs_tnode *tn;
+	int the_chunk = -1;
+	struct yaffs_ext_tags local_tags;
+	struct yaffs_dev *dev = in->my_dev;
+	int ret_val = -1;
+
+	if (!tags) {
+		/* Passed a NULL, so use our own tags space */
+		tags = &local_tags;
+	}
+
+	tn = yaffs_find_tnode_0(dev, &in->variant.file_variant, inode_chunk);
+
+	if (!tn)
+		return ret_val;
+
+	the_chunk = yaffs_get_group_base(dev, tn, inode_chunk);
+
+	ret_val = yaffs_find_chunk_in_group(dev, the_chunk, tags, in->obj_id,
+					      inode_chunk);
+
+	/* Delete the entry in the filestructure (if found) */
+	if (ret_val != -1)
+		yaffs_load_tnode_0(dev, tn, inode_chunk, 0);
+
+	return ret_val;
+}
+
+int yaffs_put_chunk_in_file(struct yaffs_obj *in, int inode_chunk,
+			    int nand_chunk, int in_scan)
+{
+	/* NB in_scan is zero unless scanning.
+	 * For forward scanning, in_scan is > 0;
+	 * for backward scanning in_scan is < 0
+	 *
+	 * nand_chunk = 0 is a dummy insert to make sure the tnodes are there.
+	 */
+
+	struct yaffs_tnode *tn;
+	struct yaffs_dev *dev = in->my_dev;
+	int existing_cunk;
+	struct yaffs_ext_tags existing_tags;
+	struct yaffs_ext_tags new_tags;
+	unsigned existing_serial, new_serial;
+
+	if (in->variant_type != YAFFS_OBJECT_TYPE_FILE) {
+		/* Just ignore an attempt at putting a chunk into a non-file
+		 * during scanning.
+		 * If it is not during Scanning then something went wrong!
+		 */
+		if (!in_scan) {
+			yaffs_trace(YAFFS_TRACE_ERROR,
+				"yaffs tragedy:attempt to put data chunk into a non-file"
+				);
+			BUG();
+		}
+
+		yaffs_chunk_del(dev, nand_chunk, 1, __LINE__);
+		return YAFFS_OK;
+	}
+
+	tn = yaffs_add_find_tnode_0(dev,
+				    &in->variant.file_variant,
+				    inode_chunk, NULL);
+	if (!tn)
+		return YAFFS_FAIL;
+
+	if (!nand_chunk)
+		/* Dummy insert, bail now */
+		return YAFFS_OK;
+
+	existing_cunk = yaffs_get_group_base(dev, tn, inode_chunk);
+
+	if (in_scan != 0) {
+		/* If we're scanning then we need to test for duplicates
+		 * NB This does not need to be efficient since it should only
+		 * happen when the power fails during a write, then only one
+		 * chunk should ever be affected.
+		 *
+		 * Correction for YAFFS2: This could happen quite a lot and we
+		 * need to think about efficiency! TODO
+		 * Update: For backward scanning we don't need to re-read tags
+		 * so this is quite cheap.
+		 */
+
+		if (existing_cunk > 0) {
+			/* NB Right now existing chunk will not be real
+			 * chunk_id if the chunk group size > 1
+			 * thus we have to do a FindChunkInFile to get the
+			 * real chunk id.
+			 *
+			 * We have a duplicate now we need to decide which
+			 * one to use:
+			 *
+			 * Backwards scanning YAFFS2: The old one is what
+			 * we use, dump the new one.
+			 * YAFFS1: Get both sets of tags and compare serial
+			 * numbers.
+			 */
+
+			if (in_scan > 0) {
+				/* Only do this for forward scanning */
+				yaffs_rd_chunk_tags_nand(dev,
+							 nand_chunk,
+							 NULL, &new_tags);
+
+				/* Do a proper find */
+				existing_cunk =
+				    yaffs_find_chunk_in_file(in, inode_chunk,
+							     &existing_tags);
+			}
+
+			if (existing_cunk <= 0) {
+				/*Hoosterman - how did this happen? */
+
+				yaffs_trace(YAFFS_TRACE_ERROR,
+					"yaffs tragedy: existing chunk < 0 in scan"
+					);
+
+			}
+
+			/* NB The deleted flags should be false, otherwise
+			 * the chunks will not be loaded during a scan
+			 */
+
+			if (in_scan > 0) {
+				new_serial = new_tags.serial_number;
+				existing_serial = existing_tags.serial_number;
+			}
+
+			if ((in_scan > 0) &&
+			    (existing_cunk <= 0 ||
+			     ((existing_serial + 1) & 3) == new_serial)) {
+				/* Forward scanning.
+				 * Use new
+				 * Delete the old one and drop through to
+				 * update the tnode
+				 */
+				yaffs_chunk_del(dev, existing_cunk, 1,
+						__LINE__);
+			} else {
+				/* Backward scanning or we want to use the
+				 * existing one
+				 * Delete the new one and return early so that
+				 * the tnode isn't changed
+				 */
+				yaffs_chunk_del(dev, nand_chunk, 1, __LINE__);
+				return YAFFS_OK;
+			}
+		}
+
+	}
+
+	if (existing_cunk == 0)
+		in->n_data_chunks++;
+
+	yaffs_load_tnode_0(dev, tn, inode_chunk, nand_chunk);
+
+	return YAFFS_OK;
+}
+
+static void yaffs_soft_del_chunk(struct yaffs_dev *dev, int chunk)
+{
+	struct yaffs_block_info *the_block;
+	unsigned block_no;
+
+	yaffs_trace(YAFFS_TRACE_DELETION, "soft delete chunk %d", chunk);
+
+	block_no = chunk / dev->param.chunks_per_block;
+	the_block = yaffs_get_block_info(dev, block_no);
+	if (the_block) {
+		the_block->soft_del_pages++;
+		dev->n_free_chunks++;
+		yaffs2_update_oldest_dirty_seq(dev, block_no, the_block);
+	}
+}
+
+/* SoftDeleteWorker scans backwards through the tnode tree and soft deletes all
+ * the chunks in the file.
+ * All soft deleting does is increment the block's softdelete count and pulls
+ * the chunk out of the tnode.
+ * Thus, essentially this is the same as DeleteWorker except that the chunks
+ * are soft deleted.
+ */
+
+static int yaffs_soft_del_worker(struct yaffs_obj *in, struct yaffs_tnode *tn,
+				 u32 level, int chunk_offset)
+{
+	int i;
+	int the_chunk;
+	int all_done = 1;
+	struct yaffs_dev *dev = in->my_dev;
+
+	if (!tn)
+		return 1;
+
+	if (level > 0) {
+		for (i = YAFFS_NTNODES_INTERNAL - 1;
+			all_done && i >= 0;
+			i--) {
+			if (tn->internal[i]) {
+				all_done =
+				    yaffs_soft_del_worker(in,
+					tn->internal[i],
+					level - 1,
+					(chunk_offset <<
+					YAFFS_TNODES_INTERNAL_BITS)
+					+ i);
+				if (all_done) {
+					yaffs_free_tnode(dev,
+						tn->internal[i]);
+					tn->internal[i] = NULL;
+				} else {
+					/* Can this happen? */
+				}
+			}
+		}
+		return (all_done) ? 1 : 0;
+	}
+
+	/* level 0 */
+	 for (i = YAFFS_NTNODES_LEVEL0 - 1; i >= 0; i--) {
+		the_chunk = yaffs_get_group_base(dev, tn, i);
+		if (the_chunk) {
+			yaffs_soft_del_chunk(dev, the_chunk);
+			yaffs_load_tnode_0(dev, tn, i, 0);
+		}
+	}
+	return 1;
+}
+
+static void yaffs_remove_obj_from_dir(struct yaffs_obj *obj)
+{
+	struct yaffs_dev *dev = obj->my_dev;
+	struct yaffs_obj *parent;
+
+	yaffs_verify_obj_in_dir(obj);
+	parent = obj->parent;
+
+	yaffs_verify_dir(parent);
+
+	if (dev && dev->param.remove_obj_fn)
+		dev->param.remove_obj_fn(obj);
+
+	list_del_init(&obj->siblings);
+	obj->parent = NULL;
+
+	yaffs_verify_dir(parent);
+}
+
+void yaffs_add_obj_to_dir(struct yaffs_obj *directory, struct yaffs_obj *obj)
+{
+	if (!directory) {
+		yaffs_trace(YAFFS_TRACE_ALWAYS,
+			"tragedy: Trying to add an object to a null pointer directory"
+			);
+		BUG();
+		return;
+	}
+	if (directory->variant_type != YAFFS_OBJECT_TYPE_DIRECTORY) {
+		yaffs_trace(YAFFS_TRACE_ALWAYS,
+			"tragedy: Trying to add an object to a non-directory"
+			);
+		BUG();
+	}
+
+	if (obj->siblings.prev == NULL) {
+		/* Not initialised */
+		BUG();
+	}
+
+	yaffs_verify_dir(directory);
+
+	yaffs_remove_obj_from_dir(obj);
+
+	/* Now add it */
+	list_add(&obj->siblings, &directory->variant.dir_variant.children);
+	obj->parent = directory;
+
+	if (directory == obj->my_dev->unlinked_dir
+	    || directory == obj->my_dev->del_dir) {
+		obj->unlinked = 1;
+		obj->my_dev->n_unlinked_files++;
+		obj->rename_allowed = 0;
+	}
+
+	yaffs_verify_dir(directory);
+	yaffs_verify_obj_in_dir(obj);
+}
+
+static int yaffs_change_obj_name(struct yaffs_obj *obj,
+				 struct yaffs_obj *new_dir,
+				 const YCHAR *new_name, int force, int shadows)
+{
+	int unlink_op;
+	int del_op;
+	struct yaffs_obj *existing_target;
+
+	if (new_dir == NULL)
+		new_dir = obj->parent;	/* use the old directory */
+
+	if (new_dir->variant_type != YAFFS_OBJECT_TYPE_DIRECTORY) {
+		yaffs_trace(YAFFS_TRACE_ALWAYS,
+			"tragedy: yaffs_change_obj_name: new_dir is not a directory"
+			);
+		BUG();
+	}
+
+	unlink_op = (new_dir == obj->my_dev->unlinked_dir);
+	del_op = (new_dir == obj->my_dev->del_dir);
+
+	existing_target = yaffs_find_by_name(new_dir, new_name);
+
+	/* If the object is a file going into the unlinked directory,
+	 *   then it is OK to just stuff it in since duplicate names are OK.
+	 *   else only proceed if the new name does not exist and we're putting
+	 *   it into a directory.
+	 */
+	if (!(unlink_op || del_op || force ||
+	      shadows > 0 || !existing_target) ||
+	      new_dir->variant_type != YAFFS_OBJECT_TYPE_DIRECTORY)
+		return YAFFS_FAIL;
+
+	yaffs_set_obj_name(obj, new_name);
+	obj->dirty = 1;
+	yaffs_add_obj_to_dir(new_dir, obj);
+
+	if (unlink_op)
+		obj->unlinked = 1;
+
+	/* If it is a deletion then we mark it as a shrink for gc  */
+	if (yaffs_update_oh(obj, new_name, 0, del_op, shadows, NULL) >= 0)
+		return YAFFS_OK;
+
+	return YAFFS_FAIL;
+}
+
+/*------------------------ Short Operations Cache ------------------------------
+ *   In many situations where there is no high level buffering  a lot of
+ *   reads might be short sequential reads, and a lot of writes may be short
+ *   sequential writes. eg. scanning/writing a jpeg file.
+ *   In these cases, a short read/write cache can provide a huge perfomance
+ *   benefit with dumb-as-a-rock code.
+ *   In Linux, the page cache provides read buffering and the short op cache
+ *   provides write buffering.
+ *
+ *   There are a small number (~10) of cache chunks per device so that we don't
+ *   need a very intelligent search.
+ */
+
+static int yaffs_obj_cache_dirty(struct yaffs_obj *obj)
+{
+	struct yaffs_dev *dev = obj->my_dev;
+	int i;
+	struct yaffs_cache *cache;
+	int n_caches = obj->my_dev->param.n_caches;
+
+	for (i = 0; i < n_caches; i++) {
+		cache = &dev->cache[i];
+		if (cache->object == obj && cache->dirty)
+			return 1;
+	}
+
+	return 0;
+}
+
+static void yaffs_flush_single_cache(struct yaffs_cache *cache, int discard)
+{
+
+	if (!cache || cache->locked)
+		return;
+
+	/* Write it out and free it up  if need be.*/
+	if (cache->dirty) {
+		yaffs_wr_data_obj(cache->object,
+				  cache->chunk_id,
+				  cache->data,
+				  cache->n_bytes,
+				  1);
+
+		cache->dirty = 0;
+	}
+
+	if (discard)
+		cache->object = NULL;
+}
+
+static void yaffs_flush_file_cache(struct yaffs_obj *obj, int discard)
+{
+	struct yaffs_dev *dev = obj->my_dev;
+	int i;
+	struct yaffs_cache *cache;
+	int n_caches = obj->my_dev->param.n_caches;
+
+	if (n_caches < 1)
+		return;
+
+
+	/* Find the chunks for this object and flush them. */
+	for (i = 0; i < n_caches; i++) {
+		cache = &dev->cache[i];
+		if (cache->object == obj)
+			yaffs_flush_single_cache(cache, discard);
+	}
+
+}
+
+
+void yaffs_flush_whole_cache(struct yaffs_dev *dev, int discard)
+{
+	struct yaffs_obj *obj;
+	int n_caches = dev->param.n_caches;
+	int i;
+
+	/* Find a dirty object in the cache and flush it...
+	 * until there are no further dirty objects.
+	 */
+	do {
+		obj = NULL;
+		for (i = 0; i < n_caches && !obj; i++) {
+			if (dev->cache[i].object && dev->cache[i].dirty)
+				obj = dev->cache[i].object;
+		}
+		if (obj)
+			yaffs_flush_file_cache(obj, discard);
+	} while (obj);
+
+}
+
+/* Grab us an unused cache chunk for use.
+ * First look for an empty one.
+ * Then look for the least recently used non-dirty one.
+ * Then look for the least recently used dirty one...., flush and look again.
+ */
+static struct yaffs_cache *yaffs_grab_chunk_worker(struct yaffs_dev *dev)
+{
+	int i;
+
+	if (dev->param.n_caches > 0) {
+		for (i = 0; i < dev->param.n_caches; i++) {
+			if (!dev->cache[i].object)
+				return &dev->cache[i];
+		}
+	}
+
+	return NULL;
+}
+
+static struct yaffs_cache *yaffs_grab_chunk_cache(struct yaffs_dev *dev)
+{
+	struct yaffs_cache *cache;
+	int usage;
+	int i;
+
+	if (dev->param.n_caches < 1)
+		return NULL;
+
+	/* First look for an unused cache */
+
+	cache = yaffs_grab_chunk_worker(dev);
+
+	if (cache)
+		return cache;
+
+	/*
+	 * Thery were all in use.
+	 * Find the LRU cache and flush it if it is dirty.
+	 */
+
+	usage = -1;
+	cache = NULL;
+
+	for (i = 0; i < dev->param.n_caches; i++) {
+		if (dev->cache[i].object &&
+		    !dev->cache[i].locked &&
+		    (dev->cache[i].last_use < usage || !cache)) {
+				usage = dev->cache[i].last_use;
+				cache = &dev->cache[i];
+		}
+	}
+
+#if 1
+	yaffs_flush_single_cache(cache, 1);
+#else
+	yaffs_flush_file_cache(cache->object, 1);
+	cache = yaffs_grab_chunk_worker(dev);
+#endif
+
+	return cache;
+}
+
+/* Find a cached chunk */
+static struct yaffs_cache *yaffs_find_chunk_cache(const struct yaffs_obj *obj,
+						  int chunk_id)
+{
+	struct yaffs_dev *dev = obj->my_dev;
+	int i;
+
+	if (dev->param.n_caches < 1)
+		return NULL;
+
+	for (i = 0; i < dev->param.n_caches; i++) {
+		if (dev->cache[i].object == obj &&
+		    dev->cache[i].chunk_id == chunk_id) {
+			dev->cache_hits++;
+
+			return &dev->cache[i];
+		}
+	}
+	return NULL;
+}
+
+/* Mark the chunk for the least recently used algorithym */
+static void yaffs_use_cache(struct yaffs_dev *dev, struct yaffs_cache *cache,
+			    int is_write)
+{
+	int i;
+
+	if (dev->param.n_caches < 1)
+		return;
+
+	if (dev->cache_last_use < 0 ||
+		dev->cache_last_use > 100000000) {
+		/* Reset the cache usages */
+		for (i = 1; i < dev->param.n_caches; i++)
+			dev->cache[i].last_use = 0;
+
+		dev->cache_last_use = 0;
+	}
+	dev->cache_last_use++;
+	cache->last_use = dev->cache_last_use;
+
+	if (is_write)
+		cache->dirty = 1;
+}
+
+/* Invalidate a single cache page.
+ * Do this when a whole page gets written,
+ * ie the short cache for this page is no longer valid.
+ */
+static void yaffs_invalidate_chunk_cache(struct yaffs_obj *object, int chunk_id)
+{
+	struct yaffs_cache *cache;
+
+	if (object->my_dev->param.n_caches > 0) {
+		cache = yaffs_find_chunk_cache(object, chunk_id);
+
+		if (cache)
+			cache->object = NULL;
+	}
+}
+
+/* Invalidate all the cache pages associated with this object
+ * Do this whenever ther file is deleted or resized.
+ */
+static void yaffs_invalidate_whole_cache(struct yaffs_obj *in)
+{
+	int i;
+	struct yaffs_dev *dev = in->my_dev;
+
+	if (dev->param.n_caches > 0) {
+		/* Invalidate it. */
+		for (i = 0; i < dev->param.n_caches; i++) {
+			if (dev->cache[i].object == in)
+				dev->cache[i].object = NULL;
+		}
+	}
+}
+
+static void yaffs_unhash_obj(struct yaffs_obj *obj)
+{
+	int bucket;
+	struct yaffs_dev *dev = obj->my_dev;
+
+	/* If it is still linked into the bucket list, free from the list */
+	if (!list_empty(&obj->hash_link)) {
+		list_del_init(&obj->hash_link);
+		bucket = yaffs_hash_fn(obj->obj_id);
+		dev->obj_bucket[bucket].count--;
+	}
+}
+
+/*  FreeObject frees up a Object and puts it back on the free list */
+static void yaffs_free_obj(struct yaffs_obj *obj)
+{
+	struct yaffs_dev *dev;
+
+	if (!obj) {
+		BUG();
+		return;
+	}
+	dev = obj->my_dev;
+	yaffs_trace(YAFFS_TRACE_OS, "FreeObject %p inode %p",
+		obj, obj->my_inode);
+	if (obj->parent)
+		BUG();
+	if (!list_empty(&obj->siblings))
+		BUG();
+
+	if (obj->my_inode) {
+		/* We're still hooked up to a cached inode.
+		 * Don't delete now, but mark for later deletion
+		 */
+		obj->defered_free = 1;
+		return;
+	}
+
+	yaffs_unhash_obj(obj);
+
+	yaffs_free_raw_obj(dev, obj);
+	dev->n_obj--;
+	dev->checkpoint_blocks_required = 0;	/* force recalculation */
+}
+
+void yaffs_handle_defered_free(struct yaffs_obj *obj)
+{
+	if (obj->defered_free)
+		yaffs_free_obj(obj);
+}
+
+static int yaffs_generic_obj_del(struct yaffs_obj *in)
+{
+	/* Iinvalidate the file's data in the cache, without flushing. */
+	yaffs_invalidate_whole_cache(in);
+
+	if (in->my_dev->param.is_yaffs2 && in->parent != in->my_dev->del_dir) {
+		/* Move to unlinked directory so we have a deletion record */
+		yaffs_change_obj_name(in, in->my_dev->del_dir, _Y("deleted"), 0,
+				      0);
+	}
+
+	yaffs_remove_obj_from_dir(in);
+	yaffs_chunk_del(in->my_dev, in->hdr_chunk, 1, __LINE__);
+	in->hdr_chunk = 0;
+
+	yaffs_free_obj(in);
+	return YAFFS_OK;
+
+}
+
+static void yaffs_soft_del_file(struct yaffs_obj *obj)
+{
+	if (!obj->deleted ||
+	    obj->variant_type != YAFFS_OBJECT_TYPE_FILE ||
+	    obj->soft_del)
+		return;
+
+	if (obj->n_data_chunks <= 0) {
+		/* Empty file with no duplicate object headers,
+		 * just delete it immediately */
+		yaffs_free_tnode(obj->my_dev, obj->variant.file_variant.top);
+		obj->variant.file_variant.top = NULL;
+		yaffs_trace(YAFFS_TRACE_TRACING,
+			"yaffs: Deleting empty file %d",
+			obj->obj_id);
+		yaffs_generic_obj_del(obj);
+	} else {
+		yaffs_soft_del_worker(obj,
+				      obj->variant.file_variant.top,
+				      obj->variant.
+				      file_variant.top_level, 0);
+		obj->soft_del = 1;
+	}
+}
+
+/* Pruning removes any part of the file structure tree that is beyond the
+ * bounds of the file (ie that does not point to chunks).
+ *
+ * A file should only get pruned when its size is reduced.
+ *
+ * Before pruning, the chunks must be pulled from the tree and the
+ * level 0 tnode entries must be zeroed out.
+ * Could also use this for file deletion, but that's probably better handled
+ * by a special case.
+ *
+ * This function is recursive. For levels > 0 the function is called again on
+ * any sub-tree. For level == 0 we just check if the sub-tree has data.
+ * If there is no data in a subtree then it is pruned.
+ */
+
+static struct yaffs_tnode *yaffs_prune_worker(struct yaffs_dev *dev,
+					      struct yaffs_tnode *tn, u32 level,
+					      int del0)
+{
+	int i;
+	int has_data;
+
+	if (!tn)
+		return tn;
+
+	has_data = 0;
+
+	if (level > 0) {
+		for (i = 0; i < YAFFS_NTNODES_INTERNAL; i++) {
+			if (tn->internal[i]) {
+				tn->internal[i] =
+				    yaffs_prune_worker(dev,
+						tn->internal[i],
+						level - 1,
+						(i == 0) ? del0 : 1);
+			}
+
+			if (tn->internal[i])
+				has_data++;
+		}
+	} else {
+		int tnode_size_u32 = dev->tnode_size / sizeof(u32);
+		u32 *map = (u32 *) tn;
+
+		for (i = 0; !has_data && i < tnode_size_u32; i++) {
+			if (map[i])
+				has_data++;
+		}
+	}
+
+	if (has_data == 0 && del0) {
+		/* Free and return NULL */
+		yaffs_free_tnode(dev, tn);
+		tn = NULL;
+	}
+	return tn;
+}
+
+static int yaffs_prune_tree(struct yaffs_dev *dev,
+			    struct yaffs_file_var *file_struct)
+{
+	int i;
+	int has_data;
+	int done = 0;
+	struct yaffs_tnode *tn;
+
+	if (file_struct->top_level < 1)
+		return YAFFS_OK;
+
+	file_struct->top =
+	   yaffs_prune_worker(dev, file_struct->top, file_struct->top_level, 0);
+
+	/* Now we have a tree with all the non-zero branches NULL but
+	 * the height is the same as it was.
+	 * Let's see if we can trim internal tnodes to shorten the tree.
+	 * We can do this if only the 0th element in the tnode is in use
+	 * (ie all the non-zero are NULL)
+	 */
+
+	while (file_struct->top_level && !done) {
+		tn = file_struct->top;
+
+		has_data = 0;
+		for (i = 1; i < YAFFS_NTNODES_INTERNAL; i++) {
+			if (tn->internal[i])
+				has_data++;
+		}
+
+		if (!has_data) {
+			file_struct->top = tn->internal[0];
+			file_struct->top_level--;
+			yaffs_free_tnode(dev, tn);
+		} else {
+			done = 1;
+		}
+	}
+
+	return YAFFS_OK;
+}
+
+/*-------------------- End of File Structure functions.-------------------*/
+
+/* alloc_empty_obj gets us a clean Object.*/
+static struct yaffs_obj *yaffs_alloc_empty_obj(struct yaffs_dev *dev)
+{
+	struct yaffs_obj *obj = yaffs_alloc_raw_obj(dev);
+
+	if (!obj)
+		return obj;
+
+	dev->n_obj++;
+
+	/* Now sweeten it up... */
+
+	memset(obj, 0, sizeof(struct yaffs_obj));
+	obj->being_created = 1;
+
+	obj->my_dev = dev;
+	obj->hdr_chunk = 0;
+	obj->variant_type = YAFFS_OBJECT_TYPE_UNKNOWN;
+	INIT_LIST_HEAD(&(obj->hard_links));
+	INIT_LIST_HEAD(&(obj->hash_link));
+	INIT_LIST_HEAD(&obj->siblings);
+
+	/* Now make the directory sane */
+	if (dev->root_dir) {
+		obj->parent = dev->root_dir;
+		list_add(&(obj->siblings),
+			 &dev->root_dir->variant.dir_variant.children);
+	}
+
+	/* Add it to the lost and found directory.
+	 * NB Can't put root or lost-n-found in lost-n-found so
+	 * check if lost-n-found exists first
+	 */
+	if (dev->lost_n_found)
+		yaffs_add_obj_to_dir(dev->lost_n_found, obj);
+
+	obj->being_created = 0;
+
+	dev->checkpoint_blocks_required = 0;	/* force recalculation */
+
+	return obj;
+}
+
+static int yaffs_find_nice_bucket(struct yaffs_dev *dev)
+{
+	int i;
+	int l = 999;
+	int lowest = 999999;
+
+	/* Search for the shortest list or one that
+	 * isn't too long.
+	 */
+
+	for (i = 0; i < 10 && lowest > 4; i++) {
+		dev->bucket_finder++;
+		dev->bucket_finder %= YAFFS_NOBJECT_BUCKETS;
+		if (dev->obj_bucket[dev->bucket_finder].count < lowest) {
+			lowest = dev->obj_bucket[dev->bucket_finder].count;
+			l = dev->bucket_finder;
+		}
+	}
+
+	return l;
+}
+
+static int yaffs_new_obj_id(struct yaffs_dev *dev)
+{
+	int bucket = yaffs_find_nice_bucket(dev);
+	int found = 0;
+	struct list_head *i;
+	u32 n = (u32) bucket;
+
+	/*
+	 * Now find an object value that has not already been taken
+	 * by scanning the list, incrementing each time by number of buckets.
+	 */
+	while (!found) {
+		found = 1;
+		n += YAFFS_NOBJECT_BUCKETS;
+		list_for_each(i, &dev->obj_bucket[bucket].list) {
+			/* Check if this value is already taken. */
+			if (i && list_entry(i, struct yaffs_obj,
+					    hash_link)->obj_id == n)
+				found = 0;
+		}
+	}
+	return n;
+}
+
+static void yaffs_hash_obj(struct yaffs_obj *in)
+{
+	int bucket = yaffs_hash_fn(in->obj_id);
+	struct yaffs_dev *dev = in->my_dev;
+
+	list_add(&in->hash_link, &dev->obj_bucket[bucket].list);
+	dev->obj_bucket[bucket].count++;
+}
+
+struct yaffs_obj *yaffs_find_by_number(struct yaffs_dev *dev, u32 number)
+{
+	int bucket = yaffs_hash_fn(number);
+	struct list_head *i;
+	struct yaffs_obj *in;
+
+	list_for_each(i, &dev->obj_bucket[bucket].list) {
+		/* Look if it is in the list */
+		in = list_entry(i, struct yaffs_obj, hash_link);
+		if (in->obj_id == number) {
+			/* Don't show if it is defered free */
+			if (in->defered_free)
+				return NULL;
+			return in;
+		}
+	}
+
+	return NULL;
+}
+
+static struct yaffs_obj *yaffs_new_obj(struct yaffs_dev *dev, int number,
+				enum yaffs_obj_type type)
+{
+	struct yaffs_obj *the_obj = NULL;
+	struct yaffs_tnode *tn = NULL;
+
+	if (number < 0)
+		number = yaffs_new_obj_id(dev);
+
+	if (type == YAFFS_OBJECT_TYPE_FILE) {
+		tn = yaffs_get_tnode(dev);
+		if (!tn)
+			return NULL;
+	}
+
+	the_obj = yaffs_alloc_empty_obj(dev);
+	if (!the_obj) {
+		if (tn)
+			yaffs_free_tnode(dev, tn);
+		return NULL;
+	}
+
+	the_obj->fake = 0;
+	the_obj->rename_allowed = 1;
+	the_obj->unlink_allowed = 1;
+	the_obj->obj_id = number;
+	yaffs_hash_obj(the_obj);
+	the_obj->variant_type = type;
+	yaffs_load_current_time(the_obj, 1, 1);
+
+	switch (type) {
+	case YAFFS_OBJECT_TYPE_FILE:
+		the_obj->variant.file_variant.file_size = 0;
+		the_obj->variant.file_variant.stored_size = 0;
+		the_obj->variant.file_variant.shrink_size =
+						yaffs_max_file_size(dev);
+		the_obj->variant.file_variant.top_level = 0;
+		the_obj->variant.file_variant.top = tn;
+		break;
+	case YAFFS_OBJECT_TYPE_DIRECTORY:
+		INIT_LIST_HEAD(&the_obj->variant.dir_variant.children);
+		INIT_LIST_HEAD(&the_obj->variant.dir_variant.dirty);
+		break;
+	case YAFFS_OBJECT_TYPE_SYMLINK:
+	case YAFFS_OBJECT_TYPE_HARDLINK:
+	case YAFFS_OBJECT_TYPE_SPECIAL:
+		/* No action required */
+		break;
+	case YAFFS_OBJECT_TYPE_UNKNOWN:
+		/* todo this should not happen */
+		break;
+	}
+	return the_obj;
+}
+
+static struct yaffs_obj *yaffs_create_fake_dir(struct yaffs_dev *dev,
+					       int number, u32 mode)
+{
+
+	struct yaffs_obj *obj =
+	    yaffs_new_obj(dev, number, YAFFS_OBJECT_TYPE_DIRECTORY);
+
+	if (!obj)
+		return NULL;
+
+	obj->fake = 1;	/* it is fake so it might not use NAND */
+	obj->rename_allowed = 0;
+	obj->unlink_allowed = 0;
+	obj->deleted = 0;
+	obj->unlinked = 0;
+	obj->yst_mode = mode;
+	obj->my_dev = dev;
+	obj->hdr_chunk = 0;	/* Not a valid chunk. */
+	return obj;
+
+}
+
+
+static void yaffs_init_tnodes_and_objs(struct yaffs_dev *dev)
+{
+	int i;
+
+	dev->n_obj = 0;
+	dev->n_tnodes = 0;
+	yaffs_init_raw_tnodes_and_objs(dev);
+
+	for (i = 0; i < YAFFS_NOBJECT_BUCKETS; i++) {
+		INIT_LIST_HEAD(&dev->obj_bucket[i].list);
+		dev->obj_bucket[i].count = 0;
+	}
+}
+
+struct yaffs_obj *yaffs_find_or_create_by_number(struct yaffs_dev *dev,
+						 int number,
+						 enum yaffs_obj_type type)
+{
+	struct yaffs_obj *the_obj = NULL;
+
+	if (number > 0)
+		the_obj = yaffs_find_by_number(dev, number);
+
+	if (!the_obj)
+		the_obj = yaffs_new_obj(dev, number, type);
+
+	return the_obj;
+
+}
+
+YCHAR *yaffs_clone_str(const YCHAR *str)
+{
+	YCHAR *new_str = NULL;
+	int len;
+
+	if (!str)
+		str = _Y("");
+
+	len = strnlen(str, YAFFS_MAX_ALIAS_LENGTH);
+	new_str = kmalloc((len + 1) * sizeof(YCHAR), GFP_NOFS);
+	if (new_str) {
+		strncpy(new_str, str, len);
+		new_str[len] = 0;
+	}
+	return new_str;
+
+}
+/*
+ *yaffs_update_parent() handles fixing a directories mtime and ctime when a new
+ * link (ie. name) is created or deleted in the directory.
+ *
+ * ie.
+ *   create dir/a : update dir's mtime/ctime
+ *   rm dir/a:   update dir's mtime/ctime
+ *   modify dir/a: don't update dir's mtimme/ctime
+ *
+ * This can be handled immediately or defered. Defering helps reduce the number
+ * of updates when many files in a directory are changed within a brief period.
+ *
+ * If the directory updating is defered then yaffs_update_dirty_dirs must be
+ * called periodically.
+ */
+
+static void yaffs_update_parent(struct yaffs_obj *obj)
+{
+	struct yaffs_dev *dev;
+
+	if (!obj)
+		return;
+	dev = obj->my_dev;
+	obj->dirty = 1;
+	yaffs_load_current_time(obj, 0, 1);
+	if (dev->param.defered_dir_update) {
+		struct list_head *link = &obj->variant.dir_variant.dirty;
+
+		if (list_empty(link)) {
+			list_add(link, &dev->dirty_dirs);
+			yaffs_trace(YAFFS_TRACE_BACKGROUND,
+			  "Added object %d to dirty directories",
+			   obj->obj_id);
+		}
+
+	} else {
+		yaffs_update_oh(obj, NULL, 0, 0, 0, NULL);
+	}
+}
+
+void yaffs_update_dirty_dirs(struct yaffs_dev *dev)
+{
+	struct list_head *link;
+	struct yaffs_obj *obj;
+	struct yaffs_dir_var *d_s;
+	union yaffs_obj_var *o_v;
+
+	yaffs_trace(YAFFS_TRACE_BACKGROUND, "Update dirty directories");
+
+	while (!list_empty(&dev->dirty_dirs)) {
+		link = dev->dirty_dirs.next;
+		list_del_init(link);
+
+		d_s = list_entry(link, struct yaffs_dir_var, dirty);
+		o_v = list_entry(d_s, union yaffs_obj_var, dir_variant);
+		obj = list_entry(o_v, struct yaffs_obj, variant);
+
+		yaffs_trace(YAFFS_TRACE_BACKGROUND, "Update directory %d",
+			obj->obj_id);
+
+		if (obj->dirty)
+			yaffs_update_oh(obj, NULL, 0, 0, 0, NULL);
+	}
+}
+
+/*
+ * Mknod (create) a new object.
+ * equiv_obj only has meaning for a hard link;
+ * alias_str only has meaning for a symlink.
+ * rdev only has meaning for devices (a subset of special objects)
+ */
+
+static struct yaffs_obj *yaffs_create_obj(enum yaffs_obj_type type,
+					  struct yaffs_obj *parent,
+					  const YCHAR *name,
+					  u32 mode,
+					  u32 uid,
+					  u32 gid,
+					  struct yaffs_obj *equiv_obj,
+					  const YCHAR *alias_str, u32 rdev)
+{
+	struct yaffs_obj *in;
+	YCHAR *str = NULL;
+	struct yaffs_dev *dev = parent->my_dev;
+
+	/* Check if the entry exists.
+	 * If it does then fail the call since we don't want a dup. */
+	if (yaffs_find_by_name(parent, name))
+		return NULL;
+
+	if (type == YAFFS_OBJECT_TYPE_SYMLINK) {
+		str = yaffs_clone_str(alias_str);
+		if (!str)
+			return NULL;
+	}
+
+	in = yaffs_new_obj(dev, -1, type);
+
+	if (!in) {
+		kfree(str);
+		return NULL;
+	}
+
+	in->hdr_chunk = 0;
+	in->valid = 1;
+	in->variant_type = type;
+
+	in->yst_mode = mode;
+
+	yaffs_attribs_init(in, gid, uid, rdev);
+
+	in->n_data_chunks = 0;
+
+	yaffs_set_obj_name(in, name);
+	in->dirty = 1;
+
+	yaffs_add_obj_to_dir(parent, in);
+
+	in->my_dev = parent->my_dev;
+
+	switch (type) {
+	case YAFFS_OBJECT_TYPE_SYMLINK:
+		in->variant.symlink_variant.alias = str;
+		break;
+	case YAFFS_OBJECT_TYPE_HARDLINK:
+		in->variant.hardlink_variant.equiv_obj = equiv_obj;
+		in->variant.hardlink_variant.equiv_id = equiv_obj->obj_id;
+		list_add(&in->hard_links, &equiv_obj->hard_links);
+		break;
+	case YAFFS_OBJECT_TYPE_FILE:
+	case YAFFS_OBJECT_TYPE_DIRECTORY:
+	case YAFFS_OBJECT_TYPE_SPECIAL:
+	case YAFFS_OBJECT_TYPE_UNKNOWN:
+		/* do nothing */
+		break;
+	}
+
+	if (yaffs_update_oh(in, name, 0, 0, 0, NULL) < 0) {
+		/* Could not create the object header, fail */
+		yaffs_del_obj(in);
+		in = NULL;
+	}
+
+	if (in)
+		yaffs_update_parent(parent);
+
+	return in;
+}
+
+struct yaffs_obj *yaffs_create_file(struct yaffs_obj *parent,
+				    const YCHAR *name, u32 mode, u32 uid,
+				    u32 gid)
+{
+	return yaffs_create_obj(YAFFS_OBJECT_TYPE_FILE, parent, name, mode,
+				uid, gid, NULL, NULL, 0);
+}
+
+struct yaffs_obj *yaffs_create_dir(struct yaffs_obj *parent, const YCHAR *name,
+				   u32 mode, u32 uid, u32 gid)
+{
+	return yaffs_create_obj(YAFFS_OBJECT_TYPE_DIRECTORY, parent, name,
+				mode, uid, gid, NULL, NULL, 0);
+}
+
+struct yaffs_obj *yaffs_create_special(struct yaffs_obj *parent,
+				       const YCHAR *name, u32 mode, u32 uid,
+				       u32 gid, u32 rdev)
+{
+	return yaffs_create_obj(YAFFS_OBJECT_TYPE_SPECIAL, parent, name, mode,
+				uid, gid, NULL, NULL, rdev);
+}
+
+struct yaffs_obj *yaffs_create_symlink(struct yaffs_obj *parent,
+				       const YCHAR *name, u32 mode, u32 uid,
+				       u32 gid, const YCHAR *alias)
+{
+	return yaffs_create_obj(YAFFS_OBJECT_TYPE_SYMLINK, parent, name, mode,
+				uid, gid, NULL, alias, 0);
+}
+
+/* yaffs_link_obj returns the object id of the equivalent object.*/
+struct yaffs_obj *yaffs_link_obj(struct yaffs_obj *parent, const YCHAR * name,
+				 struct yaffs_obj *equiv_obj)
+{
+	/* Get the real object in case we were fed a hard link obj */
+	equiv_obj = yaffs_get_equivalent_obj(equiv_obj);
+
+	if (yaffs_create_obj(YAFFS_OBJECT_TYPE_HARDLINK,
+			parent, name, 0, 0, 0,
+			equiv_obj, NULL, 0))
+		return equiv_obj;
+
+	return NULL;
+
+}
+
+
+
+/*---------------------- Block Management and Page Allocation -------------*/
+
+static void yaffs_deinit_blocks(struct yaffs_dev *dev)
+{
+	if (dev->block_info_alt && dev->block_info)
+		vfree(dev->block_info);
+	else
+		kfree(dev->block_info);
+
+	dev->block_info_alt = 0;
+
+	dev->block_info = NULL;
+
+	if (dev->chunk_bits_alt && dev->chunk_bits)
+		vfree(dev->chunk_bits);
+	else
+		kfree(dev->chunk_bits);
+	dev->chunk_bits_alt = 0;
+	dev->chunk_bits = NULL;
+}
+
+static int yaffs_init_blocks(struct yaffs_dev *dev)
+{
+	int n_blocks = dev->internal_end_block - dev->internal_start_block + 1;
+
+	dev->block_info = NULL;
+	dev->chunk_bits = NULL;
+	dev->alloc_block = -1;	/* force it to get a new one */
+
+	/* If the first allocation strategy fails, thry the alternate one */
+	dev->block_info =
+		kmalloc(n_blocks * sizeof(struct yaffs_block_info), GFP_NOFS);
+	if (!dev->block_info) {
+		dev->block_info =
+		    vmalloc(n_blocks * sizeof(struct yaffs_block_info));
+		dev->block_info_alt = 1;
+	} else {
+		dev->block_info_alt = 0;
+	}
+
+	if (!dev->block_info)
+		goto alloc_error;
+
+	/* Set up dynamic blockinfo stuff. Round up bytes. */
+	dev->chunk_bit_stride = (dev->param.chunks_per_block + 7) / 8;
+	dev->chunk_bits =
+		kmalloc(dev->chunk_bit_stride * n_blocks, GFP_NOFS);
+	if (!dev->chunk_bits) {
+		dev->chunk_bits =
+		    vmalloc(dev->chunk_bit_stride * n_blocks);
+		dev->chunk_bits_alt = 1;
+	} else {
+		dev->chunk_bits_alt = 0;
+	}
+	if (!dev->chunk_bits)
+		goto alloc_error;
+
+
+	memset(dev->block_info, 0, n_blocks * sizeof(struct yaffs_block_info));
+	memset(dev->chunk_bits, 0, dev->chunk_bit_stride * n_blocks);
+	return YAFFS_OK;
+
+alloc_error:
+	yaffs_deinit_blocks(dev);
+	return YAFFS_FAIL;
+}
+
+
+void yaffs_block_became_dirty(struct yaffs_dev *dev, int block_no)
+{
+	struct yaffs_block_info *bi = yaffs_get_block_info(dev, block_no);
+	int erased_ok = 0;
+	int i;
+
+	/* If the block is still healthy erase it and mark as clean.
+	 * If the block has had a data failure, then retire it.
+	 */
+
+	yaffs_trace(YAFFS_TRACE_GC | YAFFS_TRACE_ERASE,
+		"yaffs_block_became_dirty block %d state %d %s",
+		block_no, bi->block_state,
+		(bi->needs_retiring) ? "needs retiring" : "");
+
+	yaffs2_clear_oldest_dirty_seq(dev, bi);
+
+	bi->block_state = YAFFS_BLOCK_STATE_DIRTY;
+
+	/* If this is the block being garbage collected then stop gc'ing */
+	if (block_no == dev->gc_block)
+		dev->gc_block = 0;
+
+	/* If this block is currently the best candidate for gc
+	 * then drop as a candidate */
+	if (block_no == dev->gc_dirtiest) {
+		dev->gc_dirtiest = 0;
+		dev->gc_pages_in_use = 0;
+	}
+
+	if (!bi->needs_retiring) {
+		yaffs2_checkpt_invalidate(dev);
+		erased_ok = yaffs_erase_block(dev, block_no);
+		if (!erased_ok) {
+			dev->n_erase_failures++;
+			yaffs_trace(YAFFS_TRACE_ERROR | YAFFS_TRACE_BAD_BLOCKS,
+			  "**>> Erasure failed %d", block_no);
+		}
+	}
+
+	/* Verify erasure if needed */
+	if (erased_ok &&
+	    ((yaffs_trace_mask & YAFFS_TRACE_ERASE) ||
+	     !yaffs_skip_verification(dev))) {
+		for (i = 0; i < dev->param.chunks_per_block; i++) {
+			if (!yaffs_check_chunk_erased(dev,
+				block_no * dev->param.chunks_per_block + i)) {
+				yaffs_trace(YAFFS_TRACE_ERROR,
+					">>Block %d erasure supposedly OK, but chunk %d not erased",
+					block_no, i);
+			}
+		}
+	}
+
+	if (!erased_ok) {
+		/* We lost a block of free space */
+		dev->n_free_chunks -= dev->param.chunks_per_block;
+		yaffs_retire_block(dev, block_no);
+		yaffs_trace(YAFFS_TRACE_ERROR | YAFFS_TRACE_BAD_BLOCKS,
+			"**>> Block %d retired", block_no);
+		return;
+	}
+
+	/* Clean it up... */
+	bi->block_state = YAFFS_BLOCK_STATE_EMPTY;
+	bi->seq_number = 0;
+	dev->n_erased_blocks++;
+	bi->pages_in_use = 0;
+	bi->soft_del_pages = 0;
+	bi->has_shrink_hdr = 0;
+	bi->skip_erased_check = 1;	/* Clean, so no need to check */
+	bi->gc_prioritise = 0;
+	bi->has_summary = 0;
+
+	yaffs_clear_chunk_bits(dev, block_no);
+
+	yaffs_trace(YAFFS_TRACE_ERASE, "Erased block %d", block_no);
+}
+
+static inline int yaffs_gc_process_chunk(struct yaffs_dev *dev,
+					struct yaffs_block_info *bi,
+					int old_chunk, u8 *buffer)
+{
+	int new_chunk;
+	int mark_flash = 1;
+	struct yaffs_ext_tags tags;
+	struct yaffs_obj *object;
+	int matching_chunk;
+	int ret_val = YAFFS_OK;
+
+	memset(&tags, 0, sizeof(tags));
+	yaffs_rd_chunk_tags_nand(dev, old_chunk,
+				 buffer, &tags);
+	object = yaffs_find_by_number(dev, tags.obj_id);
+
+	yaffs_trace(YAFFS_TRACE_GC_DETAIL,
+		"Collecting chunk in block %d, %d %d %d ",
+		dev->gc_chunk, tags.obj_id,
+		tags.chunk_id, tags.n_bytes);
+
+	if (object && !yaffs_skip_verification(dev)) {
+		if (tags.chunk_id == 0)
+			matching_chunk =
+			    object->hdr_chunk;
+		else if (object->soft_del)
+			/* Defeat the test */
+			matching_chunk = old_chunk;
+		else
+			matching_chunk =
+			    yaffs_find_chunk_in_file
+			    (object, tags.chunk_id,
+			     NULL);
+
+		if (old_chunk != matching_chunk)
+			yaffs_trace(YAFFS_TRACE_ERROR,
+				"gc: page in gc mismatch: %d %d %d %d",
+				old_chunk,
+				matching_chunk,
+				tags.obj_id,
+				tags.chunk_id);
+	}
+
+	if (!object) {
+		yaffs_trace(YAFFS_TRACE_ERROR,
+			"page %d in gc has no object: %d %d %d ",
+			old_chunk,
+			tags.obj_id, tags.chunk_id,
+			tags.n_bytes);
+	}
+
+	if (object &&
+	    object->deleted &&
+	    object->soft_del && tags.chunk_id != 0) {
+		/* Data chunk in a soft deleted file,
+		 * throw it away.
+		 * It's a soft deleted data chunk,
+		 * No need to copy this, just forget
+		 * about it and fix up the object.
+		 */
+
+		/* Free chunks already includes
+		 * softdeleted chunks, how ever this
+		 * chunk is going to soon be really
+		 * deleted which will increment free
+		 * chunks. We have to decrement free
+		 * chunks so this works out properly.
+		 */
+		dev->n_free_chunks--;
+		bi->soft_del_pages--;
+
+		object->n_data_chunks--;
+		if (object->n_data_chunks <= 0) {
+			/* remeber to clean up obj */
+			dev->gc_cleanup_list[dev->n_clean_ups] = tags.obj_id;
+			dev->n_clean_ups++;
+		}
+		mark_flash = 0;
+	} else if (object) {
+		/* It's either a data chunk in a live
+		 * file or an ObjectHeader, so we're
+		 * interested in it.
+		 * NB Need to keep the ObjectHeaders of
+		 * deleted files until the whole file
+		 * has been deleted off
+		 */
+		tags.serial_number++;
+		dev->n_gc_copies++;
+
+		if (tags.chunk_id == 0) {
+			/* It is an object Id,
+			 * We need to nuke the
+			 * shrinkheader flags since its
+			 * work is done.
+			 * Also need to clean up
+			 * shadowing.
+			 */
+			struct yaffs_obj_hdr *oh;
+			oh = (struct yaffs_obj_hdr *) buffer;
+
+			oh->is_shrink = 0;
+			tags.extra_is_shrink = 0;
+			oh->shadows_obj = 0;
+			oh->inband_shadowed_obj_id = 0;
+			tags.extra_shadows = 0;
+
+			/* Update file size */
+			if (object->variant_type == YAFFS_OBJECT_TYPE_FILE) {
+				yaffs_oh_size_load(oh,
+				    object->variant.file_variant.stored_size);
+				tags.extra_file_size =
+				    object->variant.file_variant.stored_size;
+			}
+
+			yaffs_verify_oh(object, oh, &tags, 1);
+			new_chunk =
+			    yaffs_write_new_chunk(dev, (u8 *) oh, &tags, 1);
+		} else {
+			new_chunk =
+			    yaffs_write_new_chunk(dev, buffer, &tags, 1);
+		}
+
+		if (new_chunk < 0) {
+			ret_val = YAFFS_FAIL;
+		} else {
+
+			/* Now fix up the Tnodes etc. */
+
+			if (tags.chunk_id == 0) {
+				/* It's a header */
+				object->hdr_chunk = new_chunk;
+				object->serial = tags.serial_number;
+			} else {
+				/* It's a data chunk */
+				yaffs_put_chunk_in_file(object, tags.chunk_id,
+							new_chunk, 0);
+			}
+		}
+	}
+	if (ret_val == YAFFS_OK)
+		yaffs_chunk_del(dev, old_chunk, mark_flash, __LINE__);
+	return ret_val;
+}
+
+static int yaffs_gc_block(struct yaffs_dev *dev, int block, int whole_block)
+{
+	int old_chunk;
+	int ret_val = YAFFS_OK;
+	int i;
+	int is_checkpt_block;
+	int max_copies;
+	int chunks_before = yaffs_get_erased_chunks(dev);
+	int chunks_after;
+	struct yaffs_block_info *bi = yaffs_get_block_info(dev, block);
+
+	is_checkpt_block = (bi->block_state == YAFFS_BLOCK_STATE_CHECKPOINT);
+
+	yaffs_trace(YAFFS_TRACE_TRACING,
+		"Collecting block %d, in use %d, shrink %d, whole_block %d",
+		block, bi->pages_in_use, bi->has_shrink_hdr,
+		whole_block);
+
+	/*yaffs_verify_free_chunks(dev); */
+
+	if (bi->block_state == YAFFS_BLOCK_STATE_FULL)
+		bi->block_state = YAFFS_BLOCK_STATE_COLLECTING;
+
+	bi->has_shrink_hdr = 0;	/* clear the flag so that the block can erase */
+
+	dev->gc_disable = 1;
+
+	yaffs_summary_gc(dev, block);
+
+	if (is_checkpt_block || !yaffs_still_some_chunks(dev, block)) {
+		yaffs_trace(YAFFS_TRACE_TRACING,
+			"Collecting block %d that has no chunks in use",
+			block);
+		yaffs_block_became_dirty(dev, block);
+	} else {
+
+		u8 *buffer = yaffs_get_temp_buffer(dev);
+
+		yaffs_verify_blk(dev, bi, block);
+
+		max_copies = (whole_block) ? dev->param.chunks_per_block : 5;
+		old_chunk = block * dev->param.chunks_per_block + dev->gc_chunk;
+
+		for (/* init already done */ ;
+		     ret_val == YAFFS_OK &&
+		     dev->gc_chunk < dev->param.chunks_per_block &&
+		     (bi->block_state == YAFFS_BLOCK_STATE_COLLECTING) &&
+		     max_copies > 0;
+		     dev->gc_chunk++, old_chunk++) {
+			if (yaffs_check_chunk_bit(dev, block, dev->gc_chunk)) {
+				/* Page is in use and might need to be copied */
+				max_copies--;
+				ret_val = yaffs_gc_process_chunk(dev, bi,
+							old_chunk, buffer);
+			}
+		}
+		yaffs_release_temp_buffer(dev, buffer);
+	}
+
+	yaffs_verify_collected_blk(dev, bi, block);
+
+	if (bi->block_state == YAFFS_BLOCK_STATE_COLLECTING) {
+		/*
+		 * The gc did not complete. Set block state back to FULL
+		 * because checkpointing does not restore gc.
+		 */
+		bi->block_state = YAFFS_BLOCK_STATE_FULL;
+	} else {
+		/* The gc completed. */
+		/* Do any required cleanups */
+		for (i = 0; i < dev->n_clean_ups; i++) {
+			/* Time to delete the file too */
+			struct yaffs_obj *object =
+			    yaffs_find_by_number(dev, dev->gc_cleanup_list[i]);
+			if (object) {
+				yaffs_free_tnode(dev,
+					  object->variant.file_variant.top);
+				object->variant.file_variant.top = NULL;
+				yaffs_trace(YAFFS_TRACE_GC,
+					"yaffs: About to finally delete object %d",
+					object->obj_id);
+				yaffs_generic_obj_del(object);
+				object->my_dev->n_deleted_files--;
+			}
+
+		}
+		chunks_after = yaffs_get_erased_chunks(dev);
+		if (chunks_before >= chunks_after)
+			yaffs_trace(YAFFS_TRACE_GC,
+				"gc did not increase free chunks before %d after %d",
+				chunks_before, chunks_after);
+		dev->gc_block = 0;
+		dev->gc_chunk = 0;
+		dev->n_clean_ups = 0;
+	}
+
+	dev->gc_disable = 0;
+
+	return ret_val;
+}
+
+/*
+ * find_gc_block() selects the dirtiest block (or close enough)
+ * for garbage collection.
+ */
+
+static unsigned yaffs_find_gc_block(struct yaffs_dev *dev,
+				    int aggressive, int background)
+{
+	int i;
+	int iterations;
+	unsigned selected = 0;
+	int prioritised = 0;
+	int prioritised_exist = 0;
+	struct yaffs_block_info *bi;
+	int threshold;
+
+	/* First let's see if we need to grab a prioritised block */
+	if (dev->has_pending_prioritised_gc && !aggressive) {
+		dev->gc_dirtiest = 0;
+		bi = dev->block_info;
+		for (i = dev->internal_start_block;
+		     i <= dev->internal_end_block && !selected; i++) {
+
+			if (bi->gc_prioritise) {
+				prioritised_exist = 1;
+				if (bi->block_state == YAFFS_BLOCK_STATE_FULL &&
+				    yaffs_block_ok_for_gc(dev, bi)) {
+					selected = i;
+					prioritised = 1;
+				}
+			}
+			bi++;
+		}
+
+		/*
+		 * If there is a prioritised block and none was selected then
+		 * this happened because there is at least one old dirty block
+		 * gumming up the works. Let's gc the oldest dirty block.
+		 */
+
+		if (prioritised_exist &&
+		    !selected && dev->oldest_dirty_block > 0)
+			selected = dev->oldest_dirty_block;
+
+		if (!prioritised_exist)	/* None found, so we can clear this */
+			dev->has_pending_prioritised_gc = 0;
+	}
+
+	/* If we're doing aggressive GC then we are happy to take a less-dirty
+	 * block, and search harder.
+	 * else (leasurely gc), then we only bother to do this if the
+	 * block has only a few pages in use.
+	 */
+
+	if (!selected) {
+		int pages_used;
+		int n_blocks =
+		    dev->internal_end_block - dev->internal_start_block + 1;
+		if (aggressive) {
+			threshold = dev->param.chunks_per_block;
+			iterations = n_blocks;
+		} else {
+			int max_threshold;
+
+			if (background)
+				max_threshold = dev->param.chunks_per_block / 2;
+			else
+				max_threshold = dev->param.chunks_per_block / 8;
+
+			if (max_threshold < YAFFS_GC_PASSIVE_THRESHOLD)
+				max_threshold = YAFFS_GC_PASSIVE_THRESHOLD;
+
+			threshold = background ? (dev->gc_not_done + 2) * 2 : 0;
+			if (threshold < YAFFS_GC_PASSIVE_THRESHOLD)
+				threshold = YAFFS_GC_PASSIVE_THRESHOLD;
+			if (threshold > max_threshold)
+				threshold = max_threshold;
+
+			iterations = n_blocks / 16 + 1;
+			if (iterations > 100)
+				iterations = 100;
+		}
+
+		for (i = 0;
+		     i < iterations &&
+		     (dev->gc_dirtiest < 1 ||
+		      dev->gc_pages_in_use > YAFFS_GC_GOOD_ENOUGH);
+		     i++) {
+			dev->gc_block_finder++;
+			if (dev->gc_block_finder < dev->internal_start_block ||
+			    dev->gc_block_finder > dev->internal_end_block)
+				dev->gc_block_finder =
+				    dev->internal_start_block;
+
+			bi = yaffs_get_block_info(dev, dev->gc_block_finder);
+
+			pages_used = bi->pages_in_use - bi->soft_del_pages;
+
+			if (bi->block_state == YAFFS_BLOCK_STATE_FULL &&
+			    pages_used < dev->param.chunks_per_block &&
+			    (dev->gc_dirtiest < 1 ||
+			     pages_used < dev->gc_pages_in_use) &&
+			    yaffs_block_ok_for_gc(dev, bi)) {
+				dev->gc_dirtiest = dev->gc_block_finder;
+				dev->gc_pages_in_use = pages_used;
+			}
+		}
+
+		if (dev->gc_dirtiest > 0 && dev->gc_pages_in_use <= threshold)
+			selected = dev->gc_dirtiest;
+	}
+
+	/*
+	 * If nothing has been selected for a while, try the oldest dirty
+	 * because that's gumming up the works.
+	 */
+
+	if (!selected && dev->param.is_yaffs2 &&
+	    dev->gc_not_done >= (background ? 10 : 20)) {
+		yaffs2_find_oldest_dirty_seq(dev);
+		if (dev->oldest_dirty_block > 0) {
+			selected = dev->oldest_dirty_block;
+			dev->gc_dirtiest = selected;
+			dev->oldest_dirty_gc_count++;
+			bi = yaffs_get_block_info(dev, selected);
+			dev->gc_pages_in_use =
+			    bi->pages_in_use - bi->soft_del_pages;
+		} else {
+			dev->gc_not_done = 0;
+		}
+	}
+
+	if (selected) {
+		yaffs_trace(YAFFS_TRACE_GC,
+			"GC Selected block %d with %d free, prioritised:%d",
+			selected,
+			dev->param.chunks_per_block - dev->gc_pages_in_use,
+			prioritised);
+
+		dev->n_gc_blocks++;
+		if (background)
+			dev->bg_gcs++;
+
+		dev->gc_dirtiest = 0;
+		dev->gc_pages_in_use = 0;
+		dev->gc_not_done = 0;
+		if (dev->refresh_skip > 0)
+			dev->refresh_skip--;
+	} else {
+		dev->gc_not_done++;
+		yaffs_trace(YAFFS_TRACE_GC,
+			"GC none: finder %d skip %d threshold %d dirtiest %d using %d oldest %d%s",
+			dev->gc_block_finder, dev->gc_not_done, threshold,
+			dev->gc_dirtiest, dev->gc_pages_in_use,
+			dev->oldest_dirty_block, background ? " bg" : "");
+	}
+
+	return selected;
+}
+
+/* New garbage collector
+ * If we're very low on erased blocks then we do aggressive garbage collection
+ * otherwise we do "leasurely" garbage collection.
+ * Aggressive gc looks further (whole array) and will accept less dirty blocks.
+ * Passive gc only inspects smaller areas and only accepts more dirty blocks.
+ *
+ * The idea is to help clear out space in a more spread-out manner.
+ * Dunno if it really does anything useful.
+ */
+static int yaffs_check_gc(struct yaffs_dev *dev, int background)
+{
+	int aggressive = 0;
+	int gc_ok = YAFFS_OK;
+	int max_tries = 0;
+	int min_erased;
+	int erased_chunks;
+	int checkpt_block_adjust;
+
+	if (dev->param.gc_control_fn &&
+		(dev->param.gc_control_fn(dev) & 1) == 0)
+		return YAFFS_OK;
+
+	if (dev->gc_disable)
+		/* Bail out so we don't get recursive gc */
+		return YAFFS_OK;
+
+	/* This loop should pass the first time.
+	 * Only loops here if the collection does not increase space.
+	 */
+
+	do {
+		max_tries++;
+
+		checkpt_block_adjust = yaffs_calc_checkpt_blocks_required(dev);
+
+		min_erased =
+		    dev->param.n_reserved_blocks + checkpt_block_adjust + 1;
+		erased_chunks =
+		    dev->n_erased_blocks * dev->param.chunks_per_block;
+
+		/* If we need a block soon then do aggressive gc. */
+		if (dev->n_erased_blocks < min_erased)
+			aggressive = 1;
+		else {
+			if (!background
+			    && erased_chunks > (dev->n_free_chunks / 4))
+				break;
+
+			if (dev->gc_skip > 20)
+				dev->gc_skip = 20;
+			if (erased_chunks < dev->n_free_chunks / 2 ||
+			    dev->gc_skip < 1 || background)
+				aggressive = 0;
+			else {
+				dev->gc_skip--;
+				break;
+			}
+		}
+
+		dev->gc_skip = 5;
+
+		/* If we don't already have a block being gc'd then see if we
+		 * should start another */
+
+		if (dev->gc_block < 1 && !aggressive) {
+			dev->gc_block = yaffs2_find_refresh_block(dev);
+			dev->gc_chunk = 0;
+			dev->n_clean_ups = 0;
+		}
+		if (dev->gc_block < 1) {
+			dev->gc_block =
+			    yaffs_find_gc_block(dev, aggressive, background);
+			dev->gc_chunk = 0;
+			dev->n_clean_ups = 0;
+		}
+
+		if (dev->gc_block > 0) {
+			dev->all_gcs++;
+			if (!aggressive)
+				dev->passive_gc_count++;
+
+			yaffs_trace(YAFFS_TRACE_GC,
+				"yaffs: GC n_erased_blocks %d aggressive %d",
+				dev->n_erased_blocks, aggressive);
+
+			gc_ok = yaffs_gc_block(dev, dev->gc_block, aggressive);
+		}
+
+		if (dev->n_erased_blocks < (dev->param.n_reserved_blocks) &&
+		    dev->gc_block > 0) {
+			yaffs_trace(YAFFS_TRACE_GC,
+				"yaffs: GC !!!no reclaim!!! n_erased_blocks %d after try %d block %d",
+				dev->n_erased_blocks, max_tries,
+				dev->gc_block);
+		}
+	} while ((dev->n_erased_blocks < dev->param.n_reserved_blocks) &&
+		 (dev->gc_block > 0) && (max_tries < 2));
+
+	return aggressive ? gc_ok : YAFFS_OK;
+}
+
+/*
+ * yaffs_bg_gc()
+ * Garbage collects. Intended to be called from a background thread.
+ * Returns non-zero if at least half the free chunks are erased.
+ */
+int yaffs_bg_gc(struct yaffs_dev *dev, unsigned urgency)
+{
+	int erased_chunks = dev->n_erased_blocks * dev->param.chunks_per_block;
+
+	yaffs_trace(YAFFS_TRACE_BACKGROUND, "Background gc %u", urgency);
+
+	yaffs_check_gc(dev, 1);
+	return erased_chunks > dev->n_free_chunks / 2;
+}
+
+/*-------------------- Data file manipulation -----------------*/
+
+static int yaffs_rd_data_obj(struct yaffs_obj *in, int inode_chunk, u8 * buffer)
+{
+	int nand_chunk = yaffs_find_chunk_in_file(in, inode_chunk, NULL);
+
+	if (nand_chunk >= 0)
+		return yaffs_rd_chunk_tags_nand(in->my_dev, nand_chunk,
+						buffer, NULL);
+	else {
+		yaffs_trace(YAFFS_TRACE_NANDACCESS,
+			"Chunk %d not found zero instead",
+			nand_chunk);
+		/* get sane (zero) data if you read a hole */
+		memset(buffer, 0, in->my_dev->data_bytes_per_chunk);
+		return 0;
+	}
+
+}
+
+void yaffs_chunk_del(struct yaffs_dev *dev, int chunk_id, int mark_flash,
+		     int lyn)
+{
+	int block;
+	int page;
+	struct yaffs_ext_tags tags;
+	struct yaffs_block_info *bi;
+
+	if (chunk_id <= 0)
+		return;
+
+	dev->n_deletions++;
+	block = chunk_id / dev->param.chunks_per_block;
+	page = chunk_id % dev->param.chunks_per_block;
+
+	if (!yaffs_check_chunk_bit(dev, block, page))
+		yaffs_trace(YAFFS_TRACE_VERIFY,
+			"Deleting invalid chunk %d", chunk_id);
+
+	bi = yaffs_get_block_info(dev, block);
+
+	yaffs2_update_oldest_dirty_seq(dev, block, bi);
+
+	yaffs_trace(YAFFS_TRACE_DELETION,
+		"line %d delete of chunk %d",
+		lyn, chunk_id);
+
+	if (!dev->param.is_yaffs2 && mark_flash &&
+	    bi->block_state != YAFFS_BLOCK_STATE_COLLECTING) {
+
+		memset(&tags, 0, sizeof(tags));
+		tags.is_deleted = 1;
+		yaffs_wr_chunk_tags_nand(dev, chunk_id, NULL, &tags);
+		yaffs_handle_chunk_update(dev, chunk_id, &tags);
+	} else {
+		dev->n_unmarked_deletions++;
+	}
+
+	/* Pull out of the management area.
+	 * If the whole block became dirty, this will kick off an erasure.
+	 */
+	if (bi->block_state == YAFFS_BLOCK_STATE_ALLOCATING ||
+	    bi->block_state == YAFFS_BLOCK_STATE_FULL ||
+	    bi->block_state == YAFFS_BLOCK_STATE_NEEDS_SCAN ||
+	    bi->block_state == YAFFS_BLOCK_STATE_COLLECTING) {
+		dev->n_free_chunks++;
+		yaffs_clear_chunk_bit(dev, block, page);
+		bi->pages_in_use--;
+
+		if (bi->pages_in_use == 0 &&
+		    !bi->has_shrink_hdr &&
+		    bi->block_state != YAFFS_BLOCK_STATE_ALLOCATING &&
+		    bi->block_state != YAFFS_BLOCK_STATE_NEEDS_SCAN) {
+			yaffs_block_became_dirty(dev, block);
+		}
+	}
+}
+
+static int yaffs_wr_data_obj(struct yaffs_obj *in, int inode_chunk,
+			     const u8 *buffer, int n_bytes, int use_reserve)
+{
+	/* Find old chunk Need to do this to get serial number
+	 * Write new one and patch into tree.
+	 * Invalidate old tags.
+	 */
+
+	int prev_chunk_id;
+	struct yaffs_ext_tags prev_tags;
+	int new_chunk_id;
+	struct yaffs_ext_tags new_tags;
+	struct yaffs_dev *dev = in->my_dev;
+	loff_t endpos;
+
+	yaffs_check_gc(dev, 0);
+
+	/* Get the previous chunk at this location in the file if it exists.
+	 * If it does not exist then put a zero into the tree. This creates
+	 * the tnode now, rather than later when it is harder to clean up.
+	 */
+	prev_chunk_id = yaffs_find_chunk_in_file(in, inode_chunk, &prev_tags);
+	if (prev_chunk_id < 1 &&
+	    !yaffs_put_chunk_in_file(in, inode_chunk, 0, 0))
+		return 0;
+
+	/* Set up new tags */
+	memset(&new_tags, 0, sizeof(new_tags));
+
+	new_tags.chunk_id = inode_chunk;
+	new_tags.obj_id = in->obj_id;
+	new_tags.serial_number =
+	    (prev_chunk_id > 0) ? prev_tags.serial_number + 1 : 1;
+	new_tags.n_bytes = n_bytes;
+
+	if (n_bytes < 1 || n_bytes > dev->data_bytes_per_chunk) {
+		yaffs_trace(YAFFS_TRACE_ERROR,
+		  "Writing %d bytes to chunk!!!!!!!!!",
+		   n_bytes);
+		BUG();
+	}
+
+	/*
+	 * If this is a data chunk and the write goes past the end of the stored
+	 * size then update the stored_size.
+	 */
+	if (inode_chunk > 0) {
+		endpos =  (inode_chunk - 1) * dev->data_bytes_per_chunk +
+				n_bytes;
+		if (in->variant.file_variant.stored_size < endpos)
+			in->variant.file_variant.stored_size = endpos;
+	}
+
+	new_chunk_id =
+	    yaffs_write_new_chunk(dev, buffer, &new_tags, use_reserve);
+
+	if (new_chunk_id > 0) {
+		yaffs_put_chunk_in_file(in, inode_chunk, new_chunk_id, 0);
+
+		if (prev_chunk_id > 0)
+			yaffs_chunk_del(dev, prev_chunk_id, 1, __LINE__);
+
+		yaffs_verify_file_sane(in);
+	}
+	return new_chunk_id;
+}
+
+
+
+static int yaffs_do_xattrib_mod(struct yaffs_obj *obj, int set,
+				const YCHAR *name, const void *value, int size,
+				int flags)
+{
+	struct yaffs_xattr_mod xmod;
+	int result;
+
+	xmod.set = set;
+	xmod.name = name;
+	xmod.data = value;
+	xmod.size = size;
+	xmod.flags = flags;
+	xmod.result = -ENOSPC;
+
+	result = yaffs_update_oh(obj, NULL, 0, 0, 0, &xmod);
+
+	if (result > 0)
+		return xmod.result;
+	else
+		return -ENOSPC;
+}
+
+static int yaffs_apply_xattrib_mod(struct yaffs_obj *obj, char *buffer,
+				   struct yaffs_xattr_mod *xmod)
+{
+	int retval = 0;
+	int x_offs = sizeof(struct yaffs_obj_hdr);
+	struct yaffs_dev *dev = obj->my_dev;
+	int x_size = dev->data_bytes_per_chunk - sizeof(struct yaffs_obj_hdr);
+	char *x_buffer = buffer + x_offs;
+
+	if (xmod->set)
+		retval =
+		    nval_set(x_buffer, x_size, xmod->name, xmod->data,
+			     xmod->size, xmod->flags);
+	else
+		retval = nval_del(x_buffer, x_size, xmod->name);
+
+	obj->has_xattr = nval_hasvalues(x_buffer, x_size);
+	obj->xattr_known = 1;
+	xmod->result = retval;
+
+	return retval;
+}
+
+static int yaffs_do_xattrib_fetch(struct yaffs_obj *obj, const YCHAR *name,
+				  void *value, int size)
+{
+	char *buffer = NULL;
+	int result;
+	struct yaffs_ext_tags tags;
+	struct yaffs_dev *dev = obj->my_dev;
+	int x_offs = sizeof(struct yaffs_obj_hdr);
+	int x_size = dev->data_bytes_per_chunk - sizeof(struct yaffs_obj_hdr);
+	char *x_buffer;
+	int retval = 0;
+
+	if (obj->hdr_chunk < 1)
+		return -ENODATA;
+
+	/* If we know that the object has no xattribs then don't do all the
+	 * reading and parsing.
+	 */
+	if (obj->xattr_known && !obj->has_xattr) {
+		if (name)
+			return -ENODATA;
+		else
+			return 0;
+	}
+
+	buffer = (char *)yaffs_get_temp_buffer(dev);
+	if (!buffer)
+		return -ENOMEM;
+
+	result =
+	    yaffs_rd_chunk_tags_nand(dev, obj->hdr_chunk, (u8 *) buffer, &tags);
+
+	if (result != YAFFS_OK)
+		retval = -ENOENT;
+	else {
+		x_buffer = buffer + x_offs;
+
+		if (!obj->xattr_known) {
+			obj->has_xattr = nval_hasvalues(x_buffer, x_size);
+			obj->xattr_known = 1;
+		}
+
+		if (name)
+			retval = nval_get(x_buffer, x_size, name, value, size);
+		else
+			retval = nval_list(x_buffer, x_size, value, size);
+	}
+	yaffs_release_temp_buffer(dev, (u8 *) buffer);
+	return retval;
+}
+
+int yaffs_set_xattrib(struct yaffs_obj *obj, const YCHAR * name,
+		      const void *value, int size, int flags)
+{
+	return yaffs_do_xattrib_mod(obj, 1, name, value, size, flags);
+}
+
+int yaffs_remove_xattrib(struct yaffs_obj *obj, const YCHAR * name)
+{
+	return yaffs_do_xattrib_mod(obj, 0, name, NULL, 0, 0);
+}
+
+int yaffs_get_xattrib(struct yaffs_obj *obj, const YCHAR * name, void *value,
+		      int size)
+{
+	return yaffs_do_xattrib_fetch(obj, name, value, size);
+}
+
+int yaffs_list_xattrib(struct yaffs_obj *obj, char *buffer, int size)
+{
+	return yaffs_do_xattrib_fetch(obj, NULL, buffer, size);
+}
+
+static void yaffs_check_obj_details_loaded(struct yaffs_obj *in)
+{
+	u8 *buf;
+	struct yaffs_obj_hdr *oh;
+	struct yaffs_dev *dev;
+	struct yaffs_ext_tags tags;
+	int result;
+	int alloc_failed = 0;
+
+	if (!in || !in->lazy_loaded || in->hdr_chunk < 1)
+		return;
+
+	dev = in->my_dev;
+	in->lazy_loaded = 0;
+	buf = yaffs_get_temp_buffer(dev);
+
+	result = yaffs_rd_chunk_tags_nand(dev, in->hdr_chunk, buf, &tags);
+	oh = (struct yaffs_obj_hdr *)buf;
+
+	in->yst_mode = oh->yst_mode;
+	yaffs_load_attribs(in, oh);
+	yaffs_set_obj_name_from_oh(in, oh);
+
+	if (in->variant_type == YAFFS_OBJECT_TYPE_SYMLINK) {
+		in->variant.symlink_variant.alias =
+		    yaffs_clone_str(oh->alias);
+		if (!in->variant.symlink_variant.alias)
+			alloc_failed = 1;	/* Not returned */
+	}
+	yaffs_release_temp_buffer(dev, buf);
+}
+
+/* UpdateObjectHeader updates the header on NAND for an object.
+ * If name is not NULL, then that new name is used.
+ */
+int yaffs_update_oh(struct yaffs_obj *in, const YCHAR *name, int force,
+		    int is_shrink, int shadows, struct yaffs_xattr_mod *xmod)
+{
+
+	struct yaffs_block_info *bi;
+	struct yaffs_dev *dev = in->my_dev;
+	int prev_chunk_id;
+	int ret_val = 0;
+	int result = 0;
+	int new_chunk_id;
+	struct yaffs_ext_tags new_tags;
+	struct yaffs_ext_tags old_tags;
+	const YCHAR *alias = NULL;
+	u8 *buffer = NULL;
+	YCHAR old_name[YAFFS_MAX_NAME_LENGTH + 1];
+	struct yaffs_obj_hdr *oh = NULL;
+	loff_t file_size = 0;
+
+	strcpy(old_name, _Y("silly old name"));
+
+	if (in->fake && in != dev->root_dir && !force && !xmod)
+		return ret_val;
+
+	yaffs_check_gc(dev, 0);
+	yaffs_check_obj_details_loaded(in);
+
+	buffer = yaffs_get_temp_buffer(in->my_dev);
+	oh = (struct yaffs_obj_hdr *)buffer;
+
+	prev_chunk_id = in->hdr_chunk;
+
+	if (prev_chunk_id > 0) {
+		result = yaffs_rd_chunk_tags_nand(dev, prev_chunk_id,
+						  buffer, &old_tags);
+
+		yaffs_verify_oh(in, oh, &old_tags, 0);
+		memcpy(old_name, oh->name, sizeof(oh->name));
+		memset(buffer, 0xff, sizeof(struct yaffs_obj_hdr));
+	} else {
+		memset(buffer, 0xff, dev->data_bytes_per_chunk);
+	}
+
+	oh->type = in->variant_type;
+	oh->yst_mode = in->yst_mode;
+	oh->shadows_obj = oh->inband_shadowed_obj_id = shadows;
+
+	yaffs_load_attribs_oh(oh, in);
+
+	if (in->parent)
+		oh->parent_obj_id = in->parent->obj_id;
+	else
+		oh->parent_obj_id = 0;
+
+	if (name && *name) {
+		memset(oh->name, 0, sizeof(oh->name));
+		yaffs_load_oh_from_name(dev, oh->name, name);
+	} else if (prev_chunk_id > 0) {
+		memcpy(oh->name, old_name, sizeof(oh->name));
+	} else {
+		memset(oh->name, 0, sizeof(oh->name));
+	}
+
+	oh->is_shrink = is_shrink;
+
+	switch (in->variant_type) {
+	case YAFFS_OBJECT_TYPE_UNKNOWN:
+		/* Should not happen */
+		break;
+	case YAFFS_OBJECT_TYPE_FILE:
+		if (oh->parent_obj_id != YAFFS_OBJECTID_DELETED &&
+		    oh->parent_obj_id != YAFFS_OBJECTID_UNLINKED)
+			file_size = in->variant.file_variant.stored_size;
+		yaffs_oh_size_load(oh, file_size);
+		break;
+	case YAFFS_OBJECT_TYPE_HARDLINK:
+		oh->equiv_id = in->variant.hardlink_variant.equiv_id;
+		break;
+	case YAFFS_OBJECT_TYPE_SPECIAL:
+		/* Do nothing */
+		break;
+	case YAFFS_OBJECT_TYPE_DIRECTORY:
+		/* Do nothing */
+		break;
+	case YAFFS_OBJECT_TYPE_SYMLINK:
+		alias = in->variant.symlink_variant.alias;
+		if (!alias)
+			alias = _Y("no alias");
+		strncpy(oh->alias, alias, YAFFS_MAX_ALIAS_LENGTH);
+		oh->alias[YAFFS_MAX_ALIAS_LENGTH] = 0;
+		break;
+	}
+
+	/* process any xattrib modifications */
+	if (xmod)
+		yaffs_apply_xattrib_mod(in, (char *)buffer, xmod);
+
+	/* Tags */
+	memset(&new_tags, 0, sizeof(new_tags));
+	in->serial++;
+	new_tags.chunk_id = 0;
+	new_tags.obj_id = in->obj_id;
+	new_tags.serial_number = in->serial;
+
+	/* Add extra info for file header */
+	new_tags.extra_available = 1;
+	new_tags.extra_parent_id = oh->parent_obj_id;
+	new_tags.extra_file_size = file_size;
+	new_tags.extra_is_shrink = oh->is_shrink;
+	new_tags.extra_equiv_id = oh->equiv_id;
+	new_tags.extra_shadows = (oh->shadows_obj > 0) ? 1 : 0;
+	new_tags.extra_obj_type = in->variant_type;
+	yaffs_verify_oh(in, oh, &new_tags, 1);
+
+	/* Create new chunk in NAND */
+	new_chunk_id =
+	    yaffs_write_new_chunk(dev, buffer, &new_tags,
+				  (prev_chunk_id > 0) ? 1 : 0);
+
+	if (buffer)
+		yaffs_release_temp_buffer(dev, buffer);
+
+	if (new_chunk_id < 0)
+		return new_chunk_id;
+
+	in->hdr_chunk = new_chunk_id;
+
+	if (prev_chunk_id > 0)
+		yaffs_chunk_del(dev, prev_chunk_id, 1, __LINE__);
+
+	if (!yaffs_obj_cache_dirty(in))
+		in->dirty = 0;
+
+	/* If this was a shrink, then mark the block
+	 * that the chunk lives on */
+	if (is_shrink) {
+		bi = yaffs_get_block_info(in->my_dev,
+					  new_chunk_id /
+					  in->my_dev->param.chunks_per_block);
+		bi->has_shrink_hdr = 1;
+	}
+
+
+	return new_chunk_id;
+}
+
+/*--------------------- File read/write ------------------------
+ * Read and write have very similar structures.
+ * In general the read/write has three parts to it
+ * An incomplete chunk to start with (if the read/write is not chunk-aligned)
+ * Some complete chunks
+ * An incomplete chunk to end off with
+ *
+ * Curve-balls: the first chunk might also be the last chunk.
+ */
+
+int yaffs_file_rd(struct yaffs_obj *in, u8 * buffer, loff_t offset, int n_bytes)
+{
+	int chunk;
+	u32 start;
+	int n_copy;
+	int n = n_bytes;
+	int n_done = 0;
+	struct yaffs_cache *cache;
+	struct yaffs_dev *dev;
+
+	dev = in->my_dev;
+
+	while (n > 0) {
+		yaffs_addr_to_chunk(dev, offset, &chunk, &start);
+		chunk++;
+
+		/* OK now check for the curveball where the start and end are in
+		 * the same chunk.
+		 */
+		if ((start + n) < dev->data_bytes_per_chunk)
+			n_copy = n;
+		else
+			n_copy = dev->data_bytes_per_chunk - start;
+
+		cache = yaffs_find_chunk_cache(in, chunk);
+
+		/* If the chunk is already in the cache or it is less than
+		 * a whole chunk or we're using inband tags then use the cache
+		 * (if there is caching) else bypass the cache.
+		 */
+		if (cache || n_copy != dev->data_bytes_per_chunk ||
+		    dev->param.inband_tags) {
+			if (dev->param.n_caches > 0) {
+
+				/* If we can't find the data in the cache,
+				 * then load it up. */
+
+				if (!cache) {
+					cache =
+					    yaffs_grab_chunk_cache(in->my_dev);
+					cache->object = in;
+					cache->chunk_id = chunk;
+					cache->dirty = 0;
+					cache->locked = 0;
+					yaffs_rd_data_obj(in, chunk,
+							  cache->data);
+					cache->n_bytes = 0;
+				}
+
+				yaffs_use_cache(dev, cache, 0);
+
+				cache->locked = 1;
+
+				memcpy(buffer, &cache->data[start], n_copy);
+
+				cache->locked = 0;
+			} else {
+				/* Read into the local buffer then copy.. */
+
+				u8 *local_buffer =
+				    yaffs_get_temp_buffer(dev);
+				yaffs_rd_data_obj(in, chunk, local_buffer);
+
+				memcpy(buffer, &local_buffer[start], n_copy);
+
+				yaffs_release_temp_buffer(dev, local_buffer);
+			}
+		} else {
+			/* A full chunk. Read directly into the buffer. */
+			yaffs_rd_data_obj(in, chunk, buffer);
+		}
+		n -= n_copy;
+		offset += n_copy;
+		buffer += n_copy;
+		n_done += n_copy;
+	}
+	return n_done;
+}
+
+int yaffs_do_file_wr(struct yaffs_obj *in, const u8 *buffer, loff_t offset,
+		     int n_bytes, int write_through)
+{
+
+	int chunk;
+	u32 start;
+	int n_copy;
+	int n = n_bytes;
+	int n_done = 0;
+	int n_writeback;
+	loff_t start_write = offset;
+	int chunk_written = 0;
+	u32 n_bytes_read;
+	loff_t chunk_start;
+	struct yaffs_dev *dev;
+
+	dev = in->my_dev;
+
+	while (n > 0 && chunk_written >= 0) {
+		yaffs_addr_to_chunk(dev, offset, &chunk, &start);
+
+		if (((loff_t)chunk) *
+		    dev->data_bytes_per_chunk + start != offset ||
+		    start >= dev->data_bytes_per_chunk) {
+			yaffs_trace(YAFFS_TRACE_ERROR,
+				"AddrToChunk of offset %lld gives chunk %d start %d",
+				offset, chunk, start);
+		}
+		chunk++;	/* File pos to chunk in file offset */
+
+		/* OK now check for the curveball where the start and end are in
+		 * the same chunk.
+		 */
+
+		if ((start + n) < dev->data_bytes_per_chunk) {
+			n_copy = n;
+
+			/* Now calculate how many bytes to write back....
+			 * If we're overwriting and not writing to then end of
+			 * file then we need to write back as much as was there
+			 * before.
+			 */
+
+			chunk_start = (((loff_t)(chunk - 1)) *
+					dev->data_bytes_per_chunk);
+
+			if (chunk_start > in->variant.file_variant.file_size)
+				n_bytes_read = 0;	/* Past end of file */
+			else
+				n_bytes_read =
+				    in->variant.file_variant.file_size -
+				    chunk_start;
+
+			if (n_bytes_read > dev->data_bytes_per_chunk)
+				n_bytes_read = dev->data_bytes_per_chunk;
+
+			n_writeback =
+			    (n_bytes_read >
+			     (start + n)) ? n_bytes_read : (start + n);
+
+			if (n_writeback < 0 ||
+			    n_writeback > dev->data_bytes_per_chunk)
+				BUG();
+
+		} else {
+			n_copy = dev->data_bytes_per_chunk - start;
+			n_writeback = dev->data_bytes_per_chunk;
+		}
+
+		if (n_copy != dev->data_bytes_per_chunk ||
+		    !dev->param.cache_bypass_aligned ||
+		    dev->param.inband_tags) {
+			/* An incomplete start or end chunk (or maybe both
+			 * start and end chunk), or we're using inband tags,
+			 * or we're forcing writes through the cache,
+			 * so we want to use the cache buffers.
+			 */
+			if (dev->param.n_caches > 0) {
+				struct yaffs_cache *cache;
+
+				/* If we can't find the data in the cache, then
+				 * load the cache */
+				cache = yaffs_find_chunk_cache(in, chunk);
+
+				if (!cache &&
+				    yaffs_check_alloc_available(dev, 1)) {
+					cache = yaffs_grab_chunk_cache(dev);
+					cache->object = in;
+					cache->chunk_id = chunk;
+					cache->dirty = 0;
+					cache->locked = 0;
+					yaffs_rd_data_obj(in, chunk,
+							  cache->data);
+				} else if (cache &&
+					   !cache->dirty &&
+					   !yaffs_check_alloc_available(dev,
+									1)) {
+					/* Drop the cache if it was a read cache
+					 * item and no space check has been made
+					 * for it.
+					 */
+					cache = NULL;
+				}
+
+				if (cache) {
+					yaffs_use_cache(dev, cache, 1);
+					cache->locked = 1;
+
+					memcpy(&cache->data[start], buffer,
+					       n_copy);
+
+					cache->locked = 0;
+					cache->n_bytes = n_writeback;
+
+					if (write_through) {
+						chunk_written =
+						    yaffs_wr_data_obj
+						    (cache->object,
+						     cache->chunk_id,
+						     cache->data,
+						     cache->n_bytes, 1);
+						cache->dirty = 0;
+					}
+				} else {
+					chunk_written = -1;	/* fail write */
+				}
+			} else {
+				/* An incomplete start or end chunk (or maybe
+				 * both start and end chunk). Read into the
+				 * local buffer then copy over and write back.
+				 */
+
+				u8 *local_buffer = yaffs_get_temp_buffer(dev);
+
+				yaffs_rd_data_obj(in, chunk, local_buffer);
+				memcpy(&local_buffer[start], buffer, n_copy);
+
+				chunk_written =
+				    yaffs_wr_data_obj(in, chunk,
+						      local_buffer,
+						      n_writeback, 0);
+
+				yaffs_release_temp_buffer(dev, local_buffer);
+			}
+		} else {
+			/* A full chunk. Write directly from the buffer. */
+
+			chunk_written =
+			    yaffs_wr_data_obj(in, chunk, buffer,
+					      dev->data_bytes_per_chunk, 0);
+
+			/* Since we've overwritten the cached data,
+			 * we better invalidate it. */
+			yaffs_invalidate_chunk_cache(in, chunk);
+		}
+
+		if (chunk_written >= 0) {
+			n -= n_copy;
+			offset += n_copy;
+			buffer += n_copy;
+			n_done += n_copy;
+		}
+	}
+
+	/* Update file object */
+
+	if ((start_write + n_done) > in->variant.file_variant.file_size)
+		in->variant.file_variant.file_size = (start_write + n_done);
+
+	in->dirty = 1;
+	return n_done;
+}
+
+int yaffs_wr_file(struct yaffs_obj *in, const u8 *buffer, loff_t offset,
+		  int n_bytes, int write_through)
+{
+	yaffs2_handle_hole(in, offset);
+	return yaffs_do_file_wr(in, buffer, offset, n_bytes, write_through);
+}
+
+/* ---------------------- File resizing stuff ------------------ */
+
+static void yaffs_prune_chunks(struct yaffs_obj *in, loff_t new_size)
+{
+
+	struct yaffs_dev *dev = in->my_dev;
+	loff_t old_size = in->variant.file_variant.file_size;
+	int i;
+	int chunk_id;
+	u32 dummy;
+	int last_del;
+	int start_del;
+
+	if (old_size > 0)
+		yaffs_addr_to_chunk(dev, old_size - 1, &last_del, &dummy);
+	else
+		last_del = 0;
+
+	yaffs_addr_to_chunk(dev, new_size + dev->data_bytes_per_chunk - 1,
+				&start_del, &dummy);
+	last_del++;
+	start_del++;
+
+	/* Delete backwards so that we don't end up with holes if
+	 * power is lost part-way through the operation.
+	 */
+	for (i = last_del; i >= start_del; i--) {
+		/* NB this could be optimised somewhat,
+		 * eg. could retrieve the tags and write them without
+		 * using yaffs_chunk_del
+		 */
+
+		chunk_id = yaffs_find_del_file_chunk(in, i, NULL);
+
+		if (chunk_id < 1)
+			continue;
+
+		if (chunk_id <
+		    (dev->internal_start_block * dev->param.chunks_per_block) ||
+		    chunk_id >=
+		    ((dev->internal_end_block + 1) *
+		      dev->param.chunks_per_block)) {
+			yaffs_trace(YAFFS_TRACE_ALWAYS,
+				"Found daft chunk_id %d for %d",
+				chunk_id, i);
+		} else {
+			in->n_data_chunks--;
+			yaffs_chunk_del(dev, chunk_id, 1, __LINE__);
+		}
+	}
+}
+
+void yaffs_resize_file_down(struct yaffs_obj *obj, loff_t new_size)
+{
+	int new_full;
+	u32 new_partial;
+	struct yaffs_dev *dev = obj->my_dev;
+
+	yaffs_addr_to_chunk(dev, new_size, &new_full, &new_partial);
+
+	yaffs_prune_chunks(obj, new_size);
+
+	if (new_partial != 0) {
+		int last_chunk = 1 + new_full;
+		u8 *local_buffer = yaffs_get_temp_buffer(dev);
+
+		/* Rewrite the last chunk with its new size and zero pad */
+		yaffs_rd_data_obj(obj, last_chunk, local_buffer);
+		memset(local_buffer + new_partial, 0,
+		       dev->data_bytes_per_chunk - new_partial);
+
+		yaffs_wr_data_obj(obj, last_chunk, local_buffer,
+				  new_partial, 1);
+
+		yaffs_release_temp_buffer(dev, local_buffer);
+	}
+
+	obj->variant.file_variant.file_size = new_size;
+	obj->variant.file_variant.stored_size = new_size;
+
+	yaffs_prune_tree(dev, &obj->variant.file_variant);
+}
+
+int yaffs_resize_file(struct yaffs_obj *in, loff_t new_size)
+{
+	struct yaffs_dev *dev = in->my_dev;
+	loff_t old_size = in->variant.file_variant.file_size;
+
+	yaffs_flush_file_cache(in, 1);
+	yaffs_invalidate_whole_cache(in);
+
+	yaffs_check_gc(dev, 0);
+
+	if (in->variant_type != YAFFS_OBJECT_TYPE_FILE)
+		return YAFFS_FAIL;
+
+	if (new_size == old_size)
+		return YAFFS_OK;
+
+	if (new_size > old_size) {
+		yaffs2_handle_hole(in, new_size);
+		in->variant.file_variant.file_size = new_size;
+	} else {
+		/* new_size < old_size */
+		yaffs_resize_file_down(in, new_size);
+	}
+
+	/* Write a new object header to reflect the resize.
+	 * show we've shrunk the file, if need be
+	 * Do this only if the file is not in the deleted directories
+	 * and is not shadowed.
+	 */
+	if (in->parent &&
+	    !in->is_shadowed &&
+	    in->parent->obj_id != YAFFS_OBJECTID_UNLINKED &&
+	    in->parent->obj_id != YAFFS_OBJECTID_DELETED)
+		yaffs_update_oh(in, NULL, 0, 0, 0, NULL);
+
+	return YAFFS_OK;
+}
+
+int yaffs_flush_file(struct yaffs_obj *in,
+		     int update_time,
+		     int data_sync,
+		     int discard_cache)
+{
+	if (!in->dirty)
+		return YAFFS_OK;
+
+	yaffs_flush_file_cache(in, discard_cache);
+
+	if (data_sync)
+		return YAFFS_OK;
+
+	if (update_time)
+		yaffs_load_current_time(in, 0, 0);
+
+	return (yaffs_update_oh(in, NULL, 0, 0, 0, NULL) >= 0) ?
+				YAFFS_OK : YAFFS_FAIL;
+}
+
+
+/* yaffs_del_file deletes the whole file data
+ * and the inode associated with the file.
+ * It does not delete the links associated with the file.
+ */
+static int yaffs_unlink_file_if_needed(struct yaffs_obj *in)
+{
+	int ret_val;
+	int del_now = 0;
+	struct yaffs_dev *dev = in->my_dev;
+
+	if (!in->my_inode)
+		del_now = 1;
+
+	if (del_now) {
+		ret_val =
+		    yaffs_change_obj_name(in, in->my_dev->del_dir,
+					  _Y("deleted"), 0, 0);
+		yaffs_trace(YAFFS_TRACE_TRACING,
+			"yaffs: immediate deletion of file %d",
+			in->obj_id);
+		in->deleted = 1;
+		in->my_dev->n_deleted_files++;
+		if (dev->param.disable_soft_del || dev->param.is_yaffs2)
+			yaffs_resize_file(in, 0);
+		yaffs_soft_del_file(in);
+	} else {
+		ret_val =
+		    yaffs_change_obj_name(in, in->my_dev->unlinked_dir,
+					  _Y("unlinked"), 0, 0);
+	}
+	return ret_val;
+}
+
+static int yaffs_del_file(struct yaffs_obj *in)
+{
+	int ret_val = YAFFS_OK;
+	int deleted;	/* Need to cache value on stack if in is freed */
+	struct yaffs_dev *dev = in->my_dev;
+
+	if (dev->param.disable_soft_del || dev->param.is_yaffs2)
+		yaffs_resize_file(in, 0);
+
+	if (in->n_data_chunks > 0) {
+		/* Use soft deletion if there is data in the file.
+		 * That won't be the case if it has been resized to zero.
+		 */
+		if (!in->unlinked)
+			ret_val = yaffs_unlink_file_if_needed(in);
+
+		deleted = in->deleted;
+
+		if (ret_val == YAFFS_OK && in->unlinked && !in->deleted) {
+			in->deleted = 1;
+			deleted = 1;
+			in->my_dev->n_deleted_files++;
+			yaffs_soft_del_file(in);
+		}
+		return deleted ? YAFFS_OK : YAFFS_FAIL;
+	} else {
+		/* The file has no data chunks so we toss it immediately */
+		yaffs_free_tnode(in->my_dev, in->variant.file_variant.top);
+		in->variant.file_variant.top = NULL;
+		yaffs_generic_obj_del(in);
+
+		return YAFFS_OK;
+	}
+}
+
+int yaffs_is_non_empty_dir(struct yaffs_obj *obj)
+{
+	return (obj &&
+		obj->variant_type == YAFFS_OBJECT_TYPE_DIRECTORY) &&
+		!(list_empty(&obj->variant.dir_variant.children));
+}
+
+static int yaffs_del_dir(struct yaffs_obj *obj)
+{
+	/* First check that the directory is empty. */
+	if (yaffs_is_non_empty_dir(obj))
+		return YAFFS_FAIL;
+
+	return yaffs_generic_obj_del(obj);
+}
+
+static int yaffs_del_symlink(struct yaffs_obj *in)
+{
+	kfree(in->variant.symlink_variant.alias);
+	in->variant.symlink_variant.alias = NULL;
+
+	return yaffs_generic_obj_del(in);
+}
+
+static int yaffs_del_link(struct yaffs_obj *in)
+{
+	/* remove this hardlink from the list associated with the equivalent
+	 * object
+	 */
+	list_del_init(&in->hard_links);
+	return yaffs_generic_obj_del(in);
+}
+
+int yaffs_del_obj(struct yaffs_obj *obj)
+{
+	int ret_val = -1;
+
+	switch (obj->variant_type) {
+	case YAFFS_OBJECT_TYPE_FILE:
+		ret_val = yaffs_del_file(obj);
+		break;
+	case YAFFS_OBJECT_TYPE_DIRECTORY:
+		if (!list_empty(&obj->variant.dir_variant.dirty)) {
+			yaffs_trace(YAFFS_TRACE_BACKGROUND,
+				"Remove object %d from dirty directories",
+				obj->obj_id);
+			list_del_init(&obj->variant.dir_variant.dirty);
+		}
+		return yaffs_del_dir(obj);
+		break;
+	case YAFFS_OBJECT_TYPE_SYMLINK:
+		ret_val = yaffs_del_symlink(obj);
+		break;
+	case YAFFS_OBJECT_TYPE_HARDLINK:
+		ret_val = yaffs_del_link(obj);
+		break;
+	case YAFFS_OBJECT_TYPE_SPECIAL:
+		ret_val = yaffs_generic_obj_del(obj);
+		break;
+	case YAFFS_OBJECT_TYPE_UNKNOWN:
+		ret_val = 0;
+		break;		/* should not happen. */
+	}
+	return ret_val;
+}
+
+
+static void yaffs_empty_dir_to_dir(struct yaffs_obj *from_dir,
+				   struct yaffs_obj *to_dir)
+{
+	struct yaffs_obj *obj;
+	struct list_head *lh;
+	struct list_head *n;
+
+	list_for_each_safe(lh, n, &from_dir->variant.dir_variant.children) {
+		obj = list_entry(lh, struct yaffs_obj, siblings);
+		yaffs_add_obj_to_dir(to_dir, obj);
+	}
+}
+
+struct yaffs_obj *yaffs_retype_obj(struct yaffs_obj *obj,
+				   enum yaffs_obj_type type)
+{
+	/* Tear down the old variant */
+	switch (obj->variant_type) {
+	case YAFFS_OBJECT_TYPE_FILE:
+		/* Nuke file data */
+		yaffs_resize_file(obj, 0);
+		yaffs_free_tnode(obj->my_dev, obj->variant.file_variant.top);
+		obj->variant.file_variant.top = NULL;
+		break;
+	case YAFFS_OBJECT_TYPE_DIRECTORY:
+		/* Put the children in lost and found. */
+		yaffs_empty_dir_to_dir(obj, obj->my_dev->lost_n_found);
+		if (!list_empty(&obj->variant.dir_variant.dirty))
+			list_del_init(&obj->variant.dir_variant.dirty);
+		break;
+	case YAFFS_OBJECT_TYPE_SYMLINK:
+		/* Nuke symplink data */
+		kfree(obj->variant.symlink_variant.alias);
+		obj->variant.symlink_variant.alias = NULL;
+		break;
+	case YAFFS_OBJECT_TYPE_HARDLINK:
+		list_del_init(&obj->hard_links);
+		break;
+	default:
+		break;
+	}
+
+	memset(&obj->variant, 0, sizeof(obj->variant));
+
+	/*Set up new variant if the memset is not enough. */
+	switch (type) {
+	case YAFFS_OBJECT_TYPE_DIRECTORY:
+		INIT_LIST_HEAD(&obj->variant.dir_variant.children);
+		INIT_LIST_HEAD(&obj->variant.dir_variant.dirty);
+		break;
+	case YAFFS_OBJECT_TYPE_FILE:
+	case YAFFS_OBJECT_TYPE_SYMLINK:
+	case YAFFS_OBJECT_TYPE_HARDLINK:
+	default:
+		break;
+	}
+
+	obj->variant_type = type;
+
+	return obj;
+
+}
+
+static int yaffs_unlink_worker(struct yaffs_obj *obj)
+{
+	int del_now = 0;
+
+	if (!obj)
+		return YAFFS_FAIL;
+
+	if (!obj->my_inode)
+		del_now = 1;
+
+	yaffs_update_parent(obj->parent);
+
+	if (obj->variant_type == YAFFS_OBJECT_TYPE_HARDLINK) {
+		return yaffs_del_link(obj);
+	} else if (!list_empty(&obj->hard_links)) {
+		/* Curve ball: We're unlinking an object that has a hardlink.
+		 *
+		 * This problem arises because we are not strictly following
+		 * The Linux link/inode model.
+		 *
+		 * We can't really delete the object.
+		 * Instead, we do the following:
+		 * - Select a hardlink.
+		 * - Unhook it from the hard links
+		 * - Move it from its parent directory so that the rename works.
+		 * - Rename the object to the hardlink's name.
+		 * - Delete the hardlink
+		 */
+
+		struct yaffs_obj *hl;
+		struct yaffs_obj *parent;
+		int ret_val;
+		YCHAR name[YAFFS_MAX_NAME_LENGTH + 1];
+
+		hl = list_entry(obj->hard_links.next, struct yaffs_obj,
+				hard_links);
+
+		yaffs_get_obj_name(hl, name, YAFFS_MAX_NAME_LENGTH + 1);
+		parent = hl->parent;
+
+		list_del_init(&hl->hard_links);
+
+		yaffs_add_obj_to_dir(obj->my_dev->unlinked_dir, hl);
+
+		ret_val = yaffs_change_obj_name(obj, parent, name, 0, 0);
+
+		if (ret_val == YAFFS_OK)
+			ret_val = yaffs_generic_obj_del(hl);
+
+		return ret_val;
+
+	} else if (del_now) {
+		switch (obj->variant_type) {
+		case YAFFS_OBJECT_TYPE_FILE:
+			return yaffs_del_file(obj);
+			break;
+		case YAFFS_OBJECT_TYPE_DIRECTORY:
+			list_del_init(&obj->variant.dir_variant.dirty);
+			return yaffs_del_dir(obj);
+			break;
+		case YAFFS_OBJECT_TYPE_SYMLINK:
+			return yaffs_del_symlink(obj);
+			break;
+		case YAFFS_OBJECT_TYPE_SPECIAL:
+			return yaffs_generic_obj_del(obj);
+			break;
+		case YAFFS_OBJECT_TYPE_HARDLINK:
+		case YAFFS_OBJECT_TYPE_UNKNOWN:
+		default:
+			return YAFFS_FAIL;
+		}
+	} else if (yaffs_is_non_empty_dir(obj)) {
+		return YAFFS_FAIL;
+	} else {
+		return yaffs_change_obj_name(obj, obj->my_dev->unlinked_dir,
+						_Y("unlinked"), 0, 0);
+	}
+}
+
+int yaffs_unlink_obj(struct yaffs_obj *obj)
+{
+	if (obj && obj->unlink_allowed)
+		return yaffs_unlink_worker(obj);
+
+	return YAFFS_FAIL;
+}
+
+int yaffs_unlinker(struct yaffs_obj *dir, const YCHAR *name)
+{
+	struct yaffs_obj *obj;
+
+	obj = yaffs_find_by_name(dir, name);
+	return yaffs_unlink_obj(obj);
+}
+
+/* Note:
+ * If old_name is NULL then we take old_dir as the object to be renamed.
+ */
+int yaffs_rename_obj(struct yaffs_obj *old_dir, const YCHAR *old_name,
+		     struct yaffs_obj *new_dir, const YCHAR *new_name)
+{
+	struct yaffs_obj *obj = NULL;
+	struct yaffs_obj *existing_target = NULL;
+	int force = 0;
+	int result;
+	struct yaffs_dev *dev;
+
+	if (!old_dir || old_dir->variant_type != YAFFS_OBJECT_TYPE_DIRECTORY) {
+		BUG();
+		return YAFFS_FAIL;
+	}
+	if (!new_dir || new_dir->variant_type != YAFFS_OBJECT_TYPE_DIRECTORY) {
+		BUG();
+		return YAFFS_FAIL;
+	}
+
+	dev = old_dir->my_dev;
+
+#ifdef CONFIG_YAFFS_CASE_INSENSITIVE
+	/* Special case for case insemsitive systems.
+	 * While look-up is case insensitive, the name isn't.
+	 * Therefore we might want to change x.txt to X.txt
+	 */
+	if (old_dir == new_dir &&
+		old_name && new_name &&
+		strcmp(old_name, new_name) == 0)
+		force = 1;
+#endif
+
+	if (strnlen(new_name, YAFFS_MAX_NAME_LENGTH + 1) >
+	    YAFFS_MAX_NAME_LENGTH)
+		/* ENAMETOOLONG */
+		return YAFFS_FAIL;
+
+	if (old_name)
+		obj = yaffs_find_by_name(old_dir, old_name);
+	else{
+		obj = old_dir;
+		old_dir = obj->parent;
+	}
+
+	if (obj && obj->rename_allowed) {
+		/* Now handle an existing target, if there is one */
+		existing_target = yaffs_find_by_name(new_dir, new_name);
+		if (yaffs_is_non_empty_dir(existing_target)) {
+			return YAFFS_FAIL;	/* ENOTEMPTY */
+		} else if (existing_target && existing_target != obj) {
+			/* Nuke the target first, using shadowing,
+			 * but only if it isn't the same object.
+			 *
+			 * Note we must disable gc here otherwise it can mess
+			 * up the shadowing.
+			 *
+			 */
+			dev->gc_disable = 1;
+			yaffs_change_obj_name(obj, new_dir, new_name, force,
+					      existing_target->obj_id);
+			existing_target->is_shadowed = 1;
+			yaffs_unlink_obj(existing_target);
+			dev->gc_disable = 0;
+		}
+
+		result = yaffs_change_obj_name(obj, new_dir, new_name, 1, 0);
+
+		yaffs_update_parent(old_dir);
+		if (new_dir != old_dir)
+			yaffs_update_parent(new_dir);
+
+		return result;
+	}
+	return YAFFS_FAIL;
+}
+
+/*----------------------- Initialisation Scanning ---------------------- */
+
+void yaffs_handle_shadowed_obj(struct yaffs_dev *dev, int obj_id,
+			       int backward_scanning)
+{
+	struct yaffs_obj *obj;
+
+	if (backward_scanning) {
+		/* Handle YAFFS2 case (backward scanning)
+		 * If the shadowed object exists then ignore.
+		 */
+		obj = yaffs_find_by_number(dev, obj_id);
+		if (obj)
+			return;
+	}
+
+	/* Let's create it (if it does not exist) assuming it is a file so that
+	 * it can do shrinking etc.
+	 * We put it in unlinked dir to be cleaned up after the scanning
+	 */
+	obj =
+	    yaffs_find_or_create_by_number(dev, obj_id, YAFFS_OBJECT_TYPE_FILE);
+	if (!obj)
+		return;
+	obj->is_shadowed = 1;
+	yaffs_add_obj_to_dir(dev->unlinked_dir, obj);
+	obj->variant.file_variant.shrink_size = 0;
+	obj->valid = 1;		/* So that we don't read any other info. */
+}
+
+void yaffs_link_fixup(struct yaffs_dev *dev, struct list_head *hard_list)
+{
+	struct list_head *lh;
+	struct list_head *save;
+	struct yaffs_obj *hl;
+	struct yaffs_obj *in;
+
+	list_for_each_safe(lh, save, hard_list) {
+		hl = list_entry(lh, struct yaffs_obj, hard_links);
+		in = yaffs_find_by_number(dev,
+					hl->variant.hardlink_variant.equiv_id);
+
+		if (in) {
+			/* Add the hardlink pointers */
+			hl->variant.hardlink_variant.equiv_obj = in;
+			list_add(&hl->hard_links, &in->hard_links);
+		} else {
+			/* Todo Need to report/handle this better.
+			 * Got a problem... hardlink to a non-existant object
+			 */
+			hl->variant.hardlink_variant.equiv_obj = NULL;
+			INIT_LIST_HEAD(&hl->hard_links);
+		}
+	}
+}
+
+static void yaffs_strip_deleted_objs(struct yaffs_dev *dev)
+{
+	/*
+	 *  Sort out state of unlinked and deleted objects after scanning.
+	 */
+	struct list_head *i;
+	struct list_head *n;
+	struct yaffs_obj *l;
+
+	if (dev->read_only)
+		return;
+
+	/* Soft delete all the unlinked files */
+	list_for_each_safe(i, n,
+			   &dev->unlinked_dir->variant.dir_variant.children) {
+		l = list_entry(i, struct yaffs_obj, siblings);
+		yaffs_del_obj(l);
+	}
+
+	list_for_each_safe(i, n, &dev->del_dir->variant.dir_variant.children) {
+		l = list_entry(i, struct yaffs_obj, siblings);
+		yaffs_del_obj(l);
+	}
+}
+
+/*
+ * This code iterates through all the objects making sure that they are rooted.
+ * Any unrooted objects are re-rooted in lost+found.
+ * An object needs to be in one of:
+ * - Directly under deleted, unlinked
+ * - Directly or indirectly under root.
+ *
+ * Note:
+ *  This code assumes that we don't ever change the current relationships
+ *  between directories:
+ *   root_dir->parent == unlinked_dir->parent == del_dir->parent == NULL
+ *   lost-n-found->parent == root_dir
+ *
+ * This fixes the problem where directories might have inadvertently been
+ * deleted leaving the object "hanging" without being rooted in the
+ * directory tree.
+ */
+
+static int yaffs_has_null_parent(struct yaffs_dev *dev, struct yaffs_obj *obj)
+{
+	return (obj == dev->del_dir ||
+		obj == dev->unlinked_dir || obj == dev->root_dir);
+}
+
+static void yaffs_fix_hanging_objs(struct yaffs_dev *dev)
+{
+	struct yaffs_obj *obj;
+	struct yaffs_obj *parent;
+	int i;
+	struct list_head *lh;
+	struct list_head *n;
+	int depth_limit;
+	int hanging;
+
+	if (dev->read_only)
+		return;
+
+	/* Iterate through the objects in each hash entry,
+	 * looking at each object.
+	 * Make sure it is rooted.
+	 */
+
+	for (i = 0; i < YAFFS_NOBJECT_BUCKETS; i++) {
+		list_for_each_safe(lh, n, &dev->obj_bucket[i].list) {
+			obj = list_entry(lh, struct yaffs_obj, hash_link);
+			parent = obj->parent;
+
+			if (yaffs_has_null_parent(dev, obj)) {
+				/* These directories are not hanging */
+				hanging = 0;
+			} else if (!parent ||
+				   parent->variant_type !=
+				   YAFFS_OBJECT_TYPE_DIRECTORY) {
+				hanging = 1;
+			} else if (yaffs_has_null_parent(dev, parent)) {
+				hanging = 0;
+			} else {
+				/*
+				 * Need to follow the parent chain to
+				 * see if it is hanging.
+				 */
+				hanging = 0;
+				depth_limit = 100;
+
+				while (parent != dev->root_dir &&
+				       parent->parent &&
+				       parent->parent->variant_type ==
+				       YAFFS_OBJECT_TYPE_DIRECTORY &&
+				       depth_limit > 0) {
+					parent = parent->parent;
+					depth_limit--;
+				}
+				if (parent != dev->root_dir)
+					hanging = 1;
+			}
+			if (hanging) {
+				yaffs_trace(YAFFS_TRACE_SCAN,
+					"Hanging object %d moved to lost and found",
+					obj->obj_id);
+				yaffs_add_obj_to_dir(dev->lost_n_found, obj);
+			}
+		}
+	}
+}
+
+/*
+ * Delete directory contents for cleaning up lost and found.
+ */
+static void yaffs_del_dir_contents(struct yaffs_obj *dir)
+{
+	struct yaffs_obj *obj;
+	struct list_head *lh;
+	struct list_head *n;
+
+	if (dir->variant_type != YAFFS_OBJECT_TYPE_DIRECTORY)
+		BUG();
+
+	list_for_each_safe(lh, n, &dir->variant.dir_variant.children) {
+		obj = list_entry(lh, struct yaffs_obj, siblings);
+		if (obj->variant_type == YAFFS_OBJECT_TYPE_DIRECTORY)
+			yaffs_del_dir_contents(obj);
+		yaffs_trace(YAFFS_TRACE_SCAN,
+			"Deleting lost_found object %d",
+			obj->obj_id);
+		yaffs_unlink_obj(obj);
+	}
+}
+
+static void yaffs_empty_l_n_f(struct yaffs_dev *dev)
+{
+	yaffs_del_dir_contents(dev->lost_n_found);
+}
+
+
+struct yaffs_obj *yaffs_find_by_name(struct yaffs_obj *directory,
+				     const YCHAR *name)
+{
+	int sum;
+	struct list_head *i;
+	YCHAR buffer[YAFFS_MAX_NAME_LENGTH + 1];
+	struct yaffs_obj *l;
+
+	if (!name)
+		return NULL;
+
+	if (!directory) {
+		yaffs_trace(YAFFS_TRACE_ALWAYS,
+			"tragedy: yaffs_find_by_name: null pointer directory"
+			);
+		BUG();
+		return NULL;
+	}
+	if (directory->variant_type != YAFFS_OBJECT_TYPE_DIRECTORY) {
+		yaffs_trace(YAFFS_TRACE_ALWAYS,
+			"tragedy: yaffs_find_by_name: non-directory"
+			);
+		BUG();
+	}
+
+	sum = yaffs_calc_name_sum(name);
+
+	list_for_each(i, &directory->variant.dir_variant.children) {
+		l = list_entry(i, struct yaffs_obj, siblings);
+
+		if (l->parent != directory)
+			BUG();
+
+		yaffs_check_obj_details_loaded(l);
+
+		/* Special case for lost-n-found */
+		if (l->obj_id == YAFFS_OBJECTID_LOSTNFOUND) {
+			if (!strcmp(name, YAFFS_LOSTNFOUND_NAME))
+				return l;
+		} else if (l->sum == sum || l->hdr_chunk <= 0) {
+			/* LostnFound chunk called Objxxx
+			 * Do a real check
+			 */
+			yaffs_get_obj_name(l, buffer,
+				YAFFS_MAX_NAME_LENGTH + 1);
+			if (!strncmp(name, buffer, YAFFS_MAX_NAME_LENGTH))
+				return l;
+		}
+	}
+	return NULL;
+}
+
+/* GetEquivalentObject dereferences any hard links to get to the
+ * actual object.
+ */
+
+struct yaffs_obj *yaffs_get_equivalent_obj(struct yaffs_obj *obj)
+{
+	if (obj && obj->variant_type == YAFFS_OBJECT_TYPE_HARDLINK) {
+		obj = obj->variant.hardlink_variant.equiv_obj;
+		yaffs_check_obj_details_loaded(obj);
+	}
+	return obj;
+}
+
+/*
+ *  A note or two on object names.
+ *  * If the object name is missing, we then make one up in the form objnnn
+ *
+ *  * ASCII names are stored in the object header's name field from byte zero
+ *  * Unicode names are historically stored starting from byte zero.
+ *
+ * Then there are automatic Unicode names...
+ * The purpose of these is to save names in a way that can be read as
+ * ASCII or Unicode names as appropriate, thus allowing a Unicode and ASCII
+ * system to share files.
+ *
+ * These automatic unicode are stored slightly differently...
+ *  - If the name can fit in the ASCII character space then they are saved as
+ *    ascii names as per above.
+ *  - If the name needs Unicode then the name is saved in Unicode
+ *    starting at oh->name[1].
+
+ */
+static void yaffs_fix_null_name(struct yaffs_obj *obj, YCHAR *name,
+				int buffer_size)
+{
+	/* Create an object name if we could not find one. */
+	if (strnlen(name, YAFFS_MAX_NAME_LENGTH) == 0) {
+		YCHAR local_name[20];
+		YCHAR num_string[20];
+		YCHAR *x = &num_string[19];
+		unsigned v = obj->obj_id;
+		num_string[19] = 0;
+		while (v > 0) {
+			x--;
+			*x = '0' + (v % 10);
+			v /= 10;
+		}
+		/* make up a name */
+		strcpy(local_name, YAFFS_LOSTNFOUND_PREFIX);
+		strcat(local_name, x);
+		strncpy(name, local_name, buffer_size - 1);
+	}
+}
+
+int yaffs_get_obj_name(struct yaffs_obj *obj, YCHAR *name, int buffer_size)
+{
+	memset(name, 0, buffer_size * sizeof(YCHAR));
+	yaffs_check_obj_details_loaded(obj);
+	if (obj->obj_id == YAFFS_OBJECTID_LOSTNFOUND) {
+		strncpy(name, YAFFS_LOSTNFOUND_NAME, buffer_size - 1);
+	} else if (obj->short_name[0]) {
+		strcpy(name, obj->short_name);
+	} else if (obj->hdr_chunk > 0) {
+		int result;
+		u8 *buffer = yaffs_get_temp_buffer(obj->my_dev);
+
+		struct yaffs_obj_hdr *oh = (struct yaffs_obj_hdr *)buffer;
+
+		memset(buffer, 0, obj->my_dev->data_bytes_per_chunk);
+
+		if (obj->hdr_chunk > 0) {
+			result = yaffs_rd_chunk_tags_nand(obj->my_dev,
+							  obj->hdr_chunk,
+							  buffer, NULL);
+		}
+		yaffs_load_name_from_oh(obj->my_dev, name, oh->name,
+					buffer_size);
+
+		yaffs_release_temp_buffer(obj->my_dev, buffer);
+	}
+
+	yaffs_fix_null_name(obj, name, buffer_size);
+
+	return strnlen(name, YAFFS_MAX_NAME_LENGTH);
+}
+
+loff_t yaffs_get_obj_length(struct yaffs_obj *obj)
+{
+	/* Dereference any hard linking */
+	obj = yaffs_get_equivalent_obj(obj);
+
+	if (obj->variant_type == YAFFS_OBJECT_TYPE_FILE)
+		return obj->variant.file_variant.file_size;
+	if (obj->variant_type == YAFFS_OBJECT_TYPE_SYMLINK) {
+		if (!obj->variant.symlink_variant.alias)
+			return 0;
+		return strnlen(obj->variant.symlink_variant.alias,
+				     YAFFS_MAX_ALIAS_LENGTH);
+	} else {
+		/* Only a directory should drop through to here */
+		return obj->my_dev->data_bytes_per_chunk;
+	}
+}
+
+int yaffs_get_obj_link_count(struct yaffs_obj *obj)
+{
+	int count = 0;
+	struct list_head *i;
+
+	if (!obj->unlinked)
+		count++;	/* the object itself */
+
+	list_for_each(i, &obj->hard_links)
+	    count++;		/* add the hard links; */
+
+	return count;
+}
+
+int yaffs_get_obj_inode(struct yaffs_obj *obj)
+{
+	obj = yaffs_get_equivalent_obj(obj);
+
+	return obj->obj_id;
+}
+
+unsigned yaffs_get_obj_type(struct yaffs_obj *obj)
+{
+	obj = yaffs_get_equivalent_obj(obj);
+
+	switch (obj->variant_type) {
+	case YAFFS_OBJECT_TYPE_FILE:
+		return DT_REG;
+		break;
+	case YAFFS_OBJECT_TYPE_DIRECTORY:
+		return DT_DIR;
+		break;
+	case YAFFS_OBJECT_TYPE_SYMLINK:
+		return DT_LNK;
+		break;
+	case YAFFS_OBJECT_TYPE_HARDLINK:
+		return DT_REG;
+		break;
+	case YAFFS_OBJECT_TYPE_SPECIAL:
+		if (S_ISFIFO(obj->yst_mode))
+			return DT_FIFO;
+		if (S_ISCHR(obj->yst_mode))
+			return DT_CHR;
+		if (S_ISBLK(obj->yst_mode))
+			return DT_BLK;
+		if (S_ISSOCK(obj->yst_mode))
+			return DT_SOCK;
+		return DT_REG;
+		break;
+	default:
+		return DT_REG;
+		break;
+	}
+}
+
+YCHAR *yaffs_get_symlink_alias(struct yaffs_obj *obj)
+{
+	obj = yaffs_get_equivalent_obj(obj);
+	if (obj->variant_type == YAFFS_OBJECT_TYPE_SYMLINK)
+		return yaffs_clone_str(obj->variant.symlink_variant.alias);
+	else
+		return yaffs_clone_str(_Y(""));
+}
+
+/*--------------------------- Initialisation code -------------------------- */
+
+static int yaffs_check_dev_fns(struct yaffs_dev *dev)
+{
+	struct yaffs_driver *drv = &dev->drv;
+	struct yaffs_tags_handler *tagger = &dev->tagger;
+
+	/* Common functions, gotta have */
+	if (!drv->drv_read_chunk_fn ||
+	    !drv->drv_write_chunk_fn ||
+	    !drv->drv_erase_fn)
+		return 0;
+
+	if (dev->param.is_yaffs2 &&
+	     (!drv->drv_mark_bad_fn  || !drv->drv_check_bad_fn))
+		return 0;
+
+	/* Install the default tags marshalling functions if needed. */
+	yaffs_tags_compat_install(dev);
+	yaffs_tags_marshall_install(dev);
+
+	/* Check we now have the marshalling functions required. */
+	if (!tagger->write_chunk_tags_fn ||
+	    !tagger->read_chunk_tags_fn ||
+	    !tagger->query_block_fn ||
+	    !tagger->mark_bad_fn)
+		return 0;
+
+	return 1;
+}
+
+static int yaffs_create_initial_dir(struct yaffs_dev *dev)
+{
+	/* Initialise the unlinked, deleted, root and lost+found directories */
+	dev->lost_n_found = dev->root_dir = NULL;
+	dev->unlinked_dir = dev->del_dir = NULL;
+	dev->unlinked_dir =
+	    yaffs_create_fake_dir(dev, YAFFS_OBJECTID_UNLINKED, S_IFDIR);
+	dev->del_dir =
+	    yaffs_create_fake_dir(dev, YAFFS_OBJECTID_DELETED, S_IFDIR);
+	dev->root_dir =
+	    yaffs_create_fake_dir(dev, YAFFS_OBJECTID_ROOT,
+				  YAFFS_ROOT_MODE | S_IFDIR);
+	dev->lost_n_found =
+	    yaffs_create_fake_dir(dev, YAFFS_OBJECTID_LOSTNFOUND,
+				  YAFFS_LOSTNFOUND_MODE | S_IFDIR);
+
+	if (dev->lost_n_found && dev->root_dir && dev->unlinked_dir
+	    && dev->del_dir) {
+		yaffs_add_obj_to_dir(dev->root_dir, dev->lost_n_found);
+		return YAFFS_OK;
+	}
+	return YAFFS_FAIL;
+}
+
+/* Low level init.
+ * Typically only used by yaffs_guts_initialise, but also used by the
+ * Low level yaffs driver tests.
+ */
+
+int yaffs_guts_ll_init(struct yaffs_dev *dev)
+{
+
+
+	yaffs_trace(YAFFS_TRACE_TRACING, "yaffs: yaffs_ll_init()");
+
+	if (!dev) {
+		yaffs_trace(YAFFS_TRACE_ALWAYS,
+			"yaffs: Need a device"
+			);
+		return YAFFS_FAIL;
+	}
+
+	if (dev->ll_init)
+		return YAFFS_OK;
+
+	dev->internal_start_block = dev->param.start_block;
+	dev->internal_end_block = dev->param.end_block;
+	dev->block_offset = 0;
+	dev->chunk_offset = 0;
+	dev->n_free_chunks = 0;
+
+	dev->gc_block = 0;
+
+	if (dev->param.start_block == 0) {
+		dev->internal_start_block = dev->param.start_block + 1;
+		dev->internal_end_block = dev->param.end_block + 1;
+		dev->block_offset = 1;
+		dev->chunk_offset = dev->param.chunks_per_block;
+	}
+
+	/* Check geometry parameters. */
+
+	if ((!dev->param.inband_tags && dev->param.is_yaffs2 &&
+		dev->param.total_bytes_per_chunk < 1024) ||
+		(!dev->param.is_yaffs2 &&
+			dev->param.total_bytes_per_chunk < 512) ||
+		(dev->param.inband_tags && !dev->param.is_yaffs2) ||
+		 dev->param.chunks_per_block < 2 ||
+		 dev->param.n_reserved_blocks < 2 ||
+		dev->internal_start_block <= 0 ||
+		dev->internal_end_block <= 0 ||
+		dev->internal_end_block <=
+		(dev->internal_start_block + dev->param.n_reserved_blocks + 2)
+		) {
+		/* otherwise it is too small */
+		yaffs_trace(YAFFS_TRACE_ALWAYS,
+			"NAND geometry problems: chunk size %d, type is yaffs%s, inband_tags %d ",
+			dev->param.total_bytes_per_chunk,
+			dev->param.is_yaffs2 ? "2" : "",
+			dev->param.inband_tags);
+		return YAFFS_FAIL;
+	}
+
+	/* Sort out space for inband tags, if required */
+	if (dev->param.inband_tags)
+		dev->data_bytes_per_chunk =
+		    dev->param.total_bytes_per_chunk -
+		    sizeof(struct yaffs_packed_tags2_tags_only);
+	else
+		dev->data_bytes_per_chunk = dev->param.total_bytes_per_chunk;
+
+	/* Got the right mix of functions? */
+	if (!yaffs_check_dev_fns(dev)) {
+		/* Function missing */
+		yaffs_trace(YAFFS_TRACE_ALWAYS,
+			"device function(s) missing or wrong");
+
+		return YAFFS_FAIL;
+	}
+
+	if (yaffs_init_nand(dev) != YAFFS_OK) {
+		yaffs_trace(YAFFS_TRACE_ALWAYS, "InitialiseNAND failed");
+		return YAFFS_FAIL;
+	}
+
+	return YAFFS_OK;
+}
+
+
+int yaffs_guts_format_dev(struct yaffs_dev *dev)
+{
+	int i;
+	enum yaffs_block_state state;
+	u32 dummy;
+
+	if(yaffs_guts_ll_init(dev) != YAFFS_OK)
+		return YAFFS_FAIL;
+
+	if(dev->is_mounted)
+		return YAFFS_FAIL;
+
+	for (i = dev->internal_start_block; i <= dev->internal_end_block; i++) {
+		yaffs_query_init_block_state(dev, i, &state, &dummy);
+		if (state != YAFFS_BLOCK_STATE_DEAD)
+			yaffs_erase_block(dev, i);
+	}
+
+	return YAFFS_OK;
+}
+
+
+int yaffs_guts_initialise(struct yaffs_dev *dev)
+{
+	int init_failed = 0;
+	unsigned x;
+	int bits;
+
+	if(yaffs_guts_ll_init(dev) != YAFFS_OK)
+		return YAFFS_FAIL;
+
+	if (dev->is_mounted) {
+		yaffs_trace(YAFFS_TRACE_ALWAYS, "device already mounted");
+		return YAFFS_FAIL;
+	}
+
+	dev->is_mounted = 1;
+
+	/* OK now calculate a few things for the device */
+
+	/*
+	 *  Calculate all the chunk size manipulation numbers:
+	 */
+	x = dev->data_bytes_per_chunk;
+	/* We always use dev->chunk_shift and dev->chunk_div */
+	dev->chunk_shift = calc_shifts(x);
+	x >>= dev->chunk_shift;
+	dev->chunk_div = x;
+	/* We only use chunk mask if chunk_div is 1 */
+	dev->chunk_mask = (1 << dev->chunk_shift) - 1;
+
+	/*
+	 * Calculate chunk_grp_bits.
+	 * We need to find the next power of 2 > than internal_end_block
+	 */
+
+	x = dev->param.chunks_per_block * (dev->internal_end_block + 1);
+
+	bits = calc_shifts_ceiling(x);
+
+	/* Set up tnode width if wide tnodes are enabled. */
+	if (!dev->param.wide_tnodes_disabled) {
+		/* bits must be even so that we end up with 32-bit words */
+		if (bits & 1)
+			bits++;
+		if (bits < 16)
+			dev->tnode_width = 16;
+		else
+			dev->tnode_width = bits;
+	} else {
+		dev->tnode_width = 16;
+	}
+
+	dev->tnode_mask = (1 << dev->tnode_width) - 1;
+
+	/* Level0 Tnodes are 16 bits or wider (if wide tnodes are enabled),
+	 * so if the bitwidth of the
+	 * chunk range we're using is greater than 16 we need
+	 * to figure out chunk shift and chunk_grp_size
+	 */
+
+	if (bits <= dev->tnode_width)
+		dev->chunk_grp_bits = 0;
+	else
+		dev->chunk_grp_bits = bits - dev->tnode_width;
+
+	dev->tnode_size = (dev->tnode_width * YAFFS_NTNODES_LEVEL0) / 8;
+	if (dev->tnode_size < sizeof(struct yaffs_tnode))
+		dev->tnode_size = sizeof(struct yaffs_tnode);
+
+	dev->chunk_grp_size = 1 << dev->chunk_grp_bits;
+
+	if (dev->param.chunks_per_block < dev->chunk_grp_size) {
+		/* We have a problem because the soft delete won't work if
+		 * the chunk group size > chunks per block.
+		 * This can be remedied by using larger "virtual blocks".
+		 */
+		yaffs_trace(YAFFS_TRACE_ALWAYS, "chunk group too large");
+
+		return YAFFS_FAIL;
+	}
+
+	/* Finished verifying the device, continue with initialisation */
+
+	/* More device initialisation */
+	dev->all_gcs = 0;
+	dev->passive_gc_count = 0;
+	dev->oldest_dirty_gc_count = 0;
+	dev->bg_gcs = 0;
+	dev->gc_block_finder = 0;
+	dev->buffered_block = -1;
+	dev->doing_buffered_block_rewrite = 0;
+	dev->n_deleted_files = 0;
+	dev->n_bg_deletions = 0;
+	dev->n_unlinked_files = 0;
+	dev->n_ecc_fixed = 0;
+	dev->n_ecc_unfixed = 0;
+	dev->n_tags_ecc_fixed = 0;
+	dev->n_tags_ecc_unfixed = 0;
+	dev->n_erase_failures = 0;
+	dev->n_erased_blocks = 0;
+	dev->gc_disable = 0;
+	dev->has_pending_prioritised_gc = 1;
+		/* Assume the worst for now, will get fixed on first GC */
+	INIT_LIST_HEAD(&dev->dirty_dirs);
+	dev->oldest_dirty_seq = 0;
+	dev->oldest_dirty_block = 0;
+
+	/* Initialise temporary buffers and caches. */
+	if (!yaffs_init_tmp_buffers(dev))
+		init_failed = 1;
+
+	dev->cache = NULL;
+	dev->gc_cleanup_list = NULL;
+
+	if (!init_failed && dev->param.n_caches > 0) {
+		int i;
+		void *buf;
+		int cache_bytes =
+		    dev->param.n_caches * sizeof(struct yaffs_cache);
+
+		if (dev->param.n_caches > YAFFS_MAX_SHORT_OP_CACHES)
+			dev->param.n_caches = YAFFS_MAX_SHORT_OP_CACHES;
+
+		dev->cache = kmalloc(cache_bytes, GFP_NOFS);
+
+		buf = (u8 *) dev->cache;
+
+		if (dev->cache)
+			memset(dev->cache, 0, cache_bytes);
+
+		for (i = 0; i < dev->param.n_caches && buf; i++) {
+			dev->cache[i].object = NULL;
+			dev->cache[i].last_use = 0;
+			dev->cache[i].dirty = 0;
+			dev->cache[i].data = buf =
+			    kmalloc(dev->param.total_bytes_per_chunk, GFP_NOFS);
+		}
+		if (!buf)
+			init_failed = 1;
+
+		dev->cache_last_use = 0;
+	}
+
+	dev->cache_hits = 0;
+
+	if (!init_failed) {
+		dev->gc_cleanup_list =
+		    kmalloc(dev->param.chunks_per_block * sizeof(u32),
+					GFP_NOFS);
+		if (!dev->gc_cleanup_list)
+			init_failed = 1;
+	}
+
+	if (dev->param.is_yaffs2)
+		dev->param.use_header_file_size = 1;
+
+	if (!init_failed && !yaffs_init_blocks(dev))
+		init_failed = 1;
+
+	yaffs_init_tnodes_and_objs(dev);
+
+	if (!init_failed && !yaffs_create_initial_dir(dev))
+		init_failed = 1;
+
+	if (!init_failed && dev->param.is_yaffs2 &&
+		!dev->param.disable_summary &&
+		!yaffs_summary_init(dev))
+		init_failed = 1;
+
+	if (!init_failed) {
+		/* Now scan the flash. */
+		if (dev->param.is_yaffs2) {
+			if (yaffs2_checkpt_restore(dev)) {
+				yaffs_check_obj_details_loaded(dev->root_dir);
+				yaffs_trace(YAFFS_TRACE_CHECKPOINT |
+					YAFFS_TRACE_MOUNT,
+					"yaffs: restored from checkpoint"
+					);
+			} else {
+
+				/* Clean up the mess caused by an aborted
+				 * checkpoint load then scan backwards.
+				 */
+				yaffs_deinit_blocks(dev);
+
+				yaffs_deinit_tnodes_and_objs(dev);
+
+				dev->n_erased_blocks = 0;
+				dev->n_free_chunks = 0;
+				dev->alloc_block = -1;
+				dev->alloc_page = -1;
+				dev->n_deleted_files = 0;
+				dev->n_unlinked_files = 0;
+				dev->n_bg_deletions = 0;
+
+				if (!init_failed && !yaffs_init_blocks(dev))
+					init_failed = 1;
+
+				yaffs_init_tnodes_and_objs(dev);
+
+				if (!init_failed
+				    && !yaffs_create_initial_dir(dev))
+					init_failed = 1;
+
+				if (!init_failed && !yaffs2_scan_backwards(dev))
+					init_failed = 1;
+			}
+		} else if (!yaffs1_scan(dev)) {
+			init_failed = 1;
+		}
+
+		yaffs_strip_deleted_objs(dev);
+		yaffs_fix_hanging_objs(dev);
+		if (dev->param.empty_lost_n_found)
+			yaffs_empty_l_n_f(dev);
+	}
+
+	if (init_failed) {
+		/* Clean up the mess */
+		yaffs_trace(YAFFS_TRACE_TRACING,
+		  "yaffs: yaffs_guts_initialise() aborted.");
+
+		yaffs_deinitialise(dev);
+		return YAFFS_FAIL;
+	}
+
+	/* Zero out stats */
+	dev->n_page_reads = 0;
+	dev->n_page_writes = 0;
+	dev->n_erasures = 0;
+	dev->n_gc_copies = 0;
+	dev->n_retried_writes = 0;
+
+	dev->n_retired_blocks = 0;
+
+	yaffs_verify_free_chunks(dev);
+	yaffs_verify_blocks(dev);
+
+	/* Clean up any aborted checkpoint data */
+	if (!dev->is_checkpointed && dev->blocks_in_checkpt > 0)
+		yaffs2_checkpt_invalidate(dev);
+
+	yaffs_trace(YAFFS_TRACE_TRACING,
+	  "yaffs: yaffs_guts_initialise() done.");
+	return YAFFS_OK;
+}
+
+void yaffs_deinitialise(struct yaffs_dev *dev)
+{
+	if (dev->is_mounted) {
+		int i;
+
+		yaffs_deinit_blocks(dev);
+		yaffs_deinit_tnodes_and_objs(dev);
+		yaffs_summary_deinit(dev);
+
+		if (dev->param.n_caches > 0 && dev->cache) {
+
+			for (i = 0; i < dev->param.n_caches; i++) {
+				kfree(dev->cache[i].data);
+				dev->cache[i].data = NULL;
+			}
+
+			kfree(dev->cache);
+			dev->cache = NULL;
+		}
+
+		kfree(dev->gc_cleanup_list);
+
+		for (i = 0; i < YAFFS_N_TEMP_BUFFERS; i++) {
+			kfree(dev->temp_buffer[i].buffer);
+			dev->temp_buffer[i].buffer = NULL;
+		}
+
+		kfree(dev->checkpt_buffer);
+		dev->checkpt_buffer = NULL;
+		kfree(dev->checkpt_block_list);
+		dev->checkpt_block_list = NULL;
+
+		dev->is_mounted = 0;
+
+		yaffs_deinit_nand(dev);
+	}
+}
+
+int yaffs_count_free_chunks(struct yaffs_dev *dev)
+{
+	int n_free = 0;
+	int b;
+	struct yaffs_block_info *blk;
+
+	blk = dev->block_info;
+	for (b = dev->internal_start_block; b <= dev->internal_end_block; b++) {
+		switch (blk->block_state) {
+		case YAFFS_BLOCK_STATE_EMPTY:
+		case YAFFS_BLOCK_STATE_ALLOCATING:
+		case YAFFS_BLOCK_STATE_COLLECTING:
+		case YAFFS_BLOCK_STATE_FULL:
+			n_free +=
+			    (dev->param.chunks_per_block - blk->pages_in_use +
+			     blk->soft_del_pages);
+			break;
+		default:
+			break;
+		}
+		blk++;
+	}
+	return n_free;
+}
+
+int yaffs_get_n_free_chunks(struct yaffs_dev *dev)
+{
+	/* This is what we report to the outside world */
+	int n_free;
+	int n_dirty_caches;
+	int blocks_for_checkpt;
+	int i;
+
+	n_free = dev->n_free_chunks;
+	n_free += dev->n_deleted_files;
+
+	/* Now count and subtract the number of dirty chunks in the cache. */
+
+	for (n_dirty_caches = 0, i = 0; i < dev->param.n_caches; i++) {
+		if (dev->cache[i].dirty)
+			n_dirty_caches++;
+	}
+
+	n_free -= n_dirty_caches;
+
+	n_free -=
+	    ((dev->param.n_reserved_blocks + 1) * dev->param.chunks_per_block);
+
+	/* Now figure checkpoint space and report that... */
+	blocks_for_checkpt = yaffs_calc_checkpt_blocks_required(dev);
+
+	n_free -= (blocks_for_checkpt * dev->param.chunks_per_block);
+
+	if (n_free < 0)
+		n_free = 0;
+
+	return n_free;
+}
+
+
+
+/*
+ * Marshalling functions to get loff_t file sizes into and out of
+ * object headers.
+ */
+void yaffs_oh_size_load(struct yaffs_obj_hdr *oh, loff_t fsize)
+{
+	oh->file_size_low = (fsize & 0xFFFFFFFF);
+	oh->file_size_high = ((fsize >> 32) & 0xFFFFFFFF);
+}
+
+loff_t yaffs_oh_to_size(struct yaffs_obj_hdr *oh)
+{
+	loff_t retval;
+
+	if (sizeof(loff_t) >= 8 && ~(oh->file_size_high))
+		retval = (((loff_t) oh->file_size_high) << 32) |
+			(((loff_t) oh->file_size_low) & 0xFFFFFFFF);
+	else
+		retval = (loff_t) oh->file_size_low;
+
+	return retval;
+}
+
+
+void yaffs_count_blocks_by_state(struct yaffs_dev *dev, int bs[10])
+{
+	int i;
+	struct yaffs_block_info *bi;
+	int s;
+
+	for(i = 0; i < 10; i++)
+		bs[i] = 0;
+
+	for(i = dev->internal_start_block; i <= dev->internal_end_block; i++) {
+		bi = yaffs_get_block_info(dev, i);
+		s = bi->block_state;
+		if(s > YAFFS_BLOCK_STATE_DEAD || s < YAFFS_BLOCK_STATE_UNKNOWN)
+			bs[0]++;
+		else
+			bs[s]++;
+	}
+}
diff --git a/fs/yaffs2/yaffs_guts.h b/fs/yaffs2/yaffs_guts.h
new file mode 100755
index 0000000..e2b2fb9
--- /dev/null
+++ b/fs/yaffs2/yaffs_guts.h
@@ -0,0 +1,1026 @@
+/*
+ * YAFFS: Yet another Flash File System . A NAND-flash specific file system.
+ *
+ * Copyright (C) 2002-2011 Aleph One Ltd.
+ *   for Toby Churchill Ltd and Brightstar Engineering
+ *
+ * Created by Charles Manning <charles@aleph1.co.uk>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 2.1 as
+ * published by the Free Software Foundation.
+ *
+ * Note: Only YAFFS headers are LGPL, YAFFS C code is covered by GPL.
+ */
+
+#ifndef __YAFFS_GUTS_H__
+#define __YAFFS_GUTS_H__
+
+#include "yportenv.h"
+
+#define YAFFS_OK	1
+#define YAFFS_FAIL  0
+
+/* Give us a  Y=0x59,
+ * Give us an A=0x41,
+ * Give us an FF=0xff
+ * Give us an S=0x53
+ * And what have we got...
+ */
+#define YAFFS_MAGIC			0x5941ff53
+
+/*
+ * Tnodes form a tree with the tnodes in "levels"
+ * Levels greater than 0 hold 8 slots which point to other tnodes.
+ * Those at level 0 hold 16 slots which point to chunks in NAND.
+ *
+ * A maximum level of 8 thust supports files of size up to:
+ *
+ * 2^(3*MAX_LEVEL+4)
+ *
+ * Thus a max level of 8 supports files with up to 2^^28 chunks which gives
+ * a maximum file size of around 512Gbytees with 2k chunks.
+ */
+#define YAFFS_NTNODES_LEVEL0		16
+#define YAFFS_TNODES_LEVEL0_BITS	4
+#define YAFFS_TNODES_LEVEL0_MASK	0xf
+
+#define YAFFS_NTNODES_INTERNAL		(YAFFS_NTNODES_LEVEL0 / 2)
+#define YAFFS_TNODES_INTERNAL_BITS	(YAFFS_TNODES_LEVEL0_BITS - 1)
+#define YAFFS_TNODES_INTERNAL_MASK	0x7
+#define YAFFS_TNODES_MAX_LEVEL		8
+#define YAFFS_TNODES_MAX_BITS		(YAFFS_TNODES_LEVEL0_BITS + \
+					YAFFS_TNODES_INTERNAL_BITS * \
+					YAFFS_TNODES_MAX_LEVEL)
+#define YAFFS_MAX_CHUNK_ID		((1 << YAFFS_TNODES_MAX_BITS) - 1)
+
+#define YAFFS_MAX_FILE_SIZE_32		0x7fffffff
+
+/* Constants for YAFFS1 mode */
+#define YAFFS_BYTES_PER_SPARE		16
+#define YAFFS_BYTES_PER_CHUNK		512
+#define YAFFS_CHUNK_SIZE_SHIFT		9
+#define YAFFS_CHUNKS_PER_BLOCK		32
+#define YAFFS_BYTES_PER_BLOCK	(YAFFS_CHUNKS_PER_BLOCK*YAFFS_BYTES_PER_CHUNK)
+
+#define YAFFS_MIN_YAFFS2_CHUNK_SIZE	1024
+#define YAFFS_MIN_YAFFS2_SPARE_SIZE	32
+
+
+
+#define YAFFS_ALLOCATION_NOBJECTS	100
+#define YAFFS_ALLOCATION_NTNODES	100
+#define YAFFS_ALLOCATION_NLINKS		100
+
+#define YAFFS_NOBJECT_BUCKETS		256
+
+#define YAFFS_OBJECT_SPACE		0x40000
+#define YAFFS_MAX_OBJECT_ID		(YAFFS_OBJECT_SPACE - 1)
+
+/* Binary data version stamps */
+#define YAFFS_SUMMARY_VERSION		1
+#define YAFFS_CHECKPOINT_VERSION	7
+
+#ifdef CONFIG_YAFFS_UNICODE
+#define YAFFS_MAX_NAME_LENGTH		127
+#define YAFFS_MAX_ALIAS_LENGTH		79
+#else
+#define YAFFS_MAX_NAME_LENGTH		255
+#define YAFFS_MAX_ALIAS_LENGTH		159
+#endif
+
+#define YAFFS_SHORT_NAME_LENGTH		15
+
+/* Some special object ids for pseudo objects */
+#define YAFFS_OBJECTID_ROOT		1
+#define YAFFS_OBJECTID_LOSTNFOUND	2
+#define YAFFS_OBJECTID_UNLINKED		3
+#define YAFFS_OBJECTID_DELETED		4
+
+/* Fake object Id for summary data */
+#define YAFFS_OBJECTID_SUMMARY		0x10
+
+/* Pseudo object ids for checkpointing */
+#define YAFFS_OBJECTID_CHECKPOINT_DATA	0x20
+#define YAFFS_SEQUENCE_CHECKPOINT_DATA	0x21
+
+#define YAFFS_MAX_SHORT_OP_CACHES	20
+
+#define YAFFS_N_TEMP_BUFFERS		6
+
+/* We limit the number attempts at sucessfully saving a chunk of data.
+ * Small-page devices have 32 pages per block; large-page devices have 64.
+ * Default to something in the order of 5 to 10 blocks worth of chunks.
+ */
+#define YAFFS_WR_ATTEMPTS		(5*64)
+
+/* Sequence numbers are used in YAFFS2 to determine block allocation order.
+ * The range is limited slightly to help distinguish bad numbers from good.
+ * This also allows us to perhaps in the future use special numbers for
+ * special purposes.
+ * EFFFFF00 allows the allocation of 8 blocks/second (~1Mbytes) for 15 years,
+ * and is a larger number than the lifetime of a 2GB device.
+ */
+#define YAFFS_LOWEST_SEQUENCE_NUMBER	0x00001000
+#define YAFFS_HIGHEST_SEQUENCE_NUMBER	0xefffff00
+
+/* Special sequence number for bad block that failed to be marked bad */
+#define YAFFS_SEQUENCE_BAD_BLOCK	0xffff0000
+
+/* ChunkCache is used for short read/write operations.*/
+struct yaffs_cache {
+	struct yaffs_obj *object;
+	int chunk_id;
+	int last_use;
+	int dirty;
+	int n_bytes;		/* Only valid if the cache is dirty */
+	int locked;		/* Can't push out or flush while locked. */
+	u8 *data;
+};
+
+/* yaffs1 tags structures in RAM
+ * NB This uses bitfield. Bitfields should not straddle a u32 boundary
+ * otherwise the structure size will get blown out.
+ */
+
+struct yaffs_tags {
+	u32 chunk_id:20;
+	u32 serial_number:2;
+	u32 n_bytes_lsb:10;
+	u32 obj_id:18;
+	u32 ecc:12;
+	u32 n_bytes_msb:2;
+};
+
+union yaffs_tags_union {
+	struct yaffs_tags as_tags;
+	u8 as_bytes[8];
+};
+
+
+/* Stuff used for extended tags in YAFFS2 */
+
+enum yaffs_ecc_result {
+	YAFFS_ECC_RESULT_UNKNOWN,
+	YAFFS_ECC_RESULT_NO_ERROR,
+	YAFFS_ECC_RESULT_FIXED,
+	YAFFS_ECC_RESULT_UNFIXED
+};
+
+/*
+ * Object type enum:
+ * When this is stored in flash we store it as a u32 instead
+ * to prevent any alignment change issues as compiler variants change.
+ */
+
+enum yaffs_obj_type {
+	YAFFS_OBJECT_TYPE_UNKNOWN,
+	YAFFS_OBJECT_TYPE_FILE,
+	YAFFS_OBJECT_TYPE_SYMLINK,
+	YAFFS_OBJECT_TYPE_DIRECTORY,
+	YAFFS_OBJECT_TYPE_HARDLINK,
+	YAFFS_OBJECT_TYPE_SPECIAL
+};
+
+#define YAFFS_OBJECT_TYPE_MAX YAFFS_OBJECT_TYPE_SPECIAL
+
+struct yaffs_ext_tags {
+	unsigned chunk_used;	/*  Status of the chunk: used or unused */
+	unsigned obj_id;	/* If 0 this is not used */
+	unsigned chunk_id;	/* If 0 this is a header, else a data chunk */
+	unsigned n_bytes;	/* Only valid for data chunks */
+
+	/* The following stuff only has meaning when we read */
+	enum yaffs_ecc_result ecc_result;
+	unsigned block_bad;
+
+	/* YAFFS 1 stuff */
+	unsigned is_deleted;	/* The chunk is marked deleted */
+	unsigned serial_number;	/* Yaffs1 2-bit serial number */
+
+	/* YAFFS2 stuff */
+	unsigned seq_number;	/* The sequence number of this block */
+
+	/* Extra info if this is an object header (YAFFS2 only) */
+
+	unsigned extra_available;	/* Extra info available if not zero */
+	unsigned extra_parent_id;	/* The parent object */
+	unsigned extra_is_shrink;	/* Is it a shrink header? */
+	unsigned extra_shadows;	/* Does this shadow another object? */
+
+	enum yaffs_obj_type extra_obj_type;	/* What object type? */
+
+	loff_t extra_file_size;		/* Length if it is a file */
+	unsigned extra_equiv_id;	/* Equivalent object for a hard link */
+};
+
+/* Spare structure for YAFFS1 */
+struct yaffs_spare {
+	u8 tb0;
+	u8 tb1;
+	u8 tb2;
+	u8 tb3;
+	u8 page_status;		/* set to 0 to delete the chunk */
+	u8 block_status;
+	u8 tb4;
+	u8 tb5;
+	u8 ecc1[3];
+	u8 tb6;
+	u8 tb7;
+	u8 ecc2[3];
+};
+
+/*Special structure for passing through to mtd */
+struct yaffs_nand_spare {
+	struct yaffs_spare spare;
+	int eccres1;
+	int eccres2;
+};
+
+/* Block data in RAM */
+
+enum yaffs_block_state {
+	YAFFS_BLOCK_STATE_UNKNOWN = 0,
+
+	YAFFS_BLOCK_STATE_SCANNING,
+	/* Being scanned */
+
+	YAFFS_BLOCK_STATE_NEEDS_SCAN,
+	/* The block might have something on it (ie it is allocating or full,
+	 * perhaps empty) but it needs to be scanned to determine its true
+	 * state.
+	 * This state is only valid during scanning.
+	 * NB We tolerate empty because the pre-scanner might be incapable of
+	 * deciding
+	 * However, if this state is returned on a YAFFS2 device,
+	 * then we expect a sequence number
+	 */
+
+	YAFFS_BLOCK_STATE_EMPTY,
+	/* This block is empty */
+
+	YAFFS_BLOCK_STATE_ALLOCATING,
+	/* This block is partially allocated.
+	 * At least one page holds valid data.
+	 * This is the one currently being used for page
+	 * allocation. Should never be more than one of these.
+	 * If a block is only partially allocated at mount it is treated as
+	 * full.
+	 */
+
+	YAFFS_BLOCK_STATE_FULL,
+	/* All the pages in this block have been allocated.
+	 * If a block was only partially allocated when mounted we treat
+	 * it as fully allocated.
+	 */
+
+	YAFFS_BLOCK_STATE_DIRTY,
+	/* The block was full and now all chunks have been deleted.
+	 * Erase me, reuse me.
+	 */
+
+	YAFFS_BLOCK_STATE_CHECKPOINT,
+	/* This block is assigned to holding checkpoint data. */
+
+	YAFFS_BLOCK_STATE_COLLECTING,
+	/* This block is being garbage collected */
+
+	YAFFS_BLOCK_STATE_DEAD
+	    /* This block has failed and is not in use */
+};
+
+#define	YAFFS_NUMBER_OF_BLOCK_STATES (YAFFS_BLOCK_STATE_DEAD + 1)
+
+struct yaffs_block_info {
+
+	s32 soft_del_pages:10;	/* number of soft deleted pages */
+	s32 pages_in_use:10;	/* number of pages in use */
+	u32 block_state:4;	/* One of the above block states. */
+				/* NB use unsigned because enum is sometimes
+				 * an int */
+	u32 needs_retiring:1;	/* Data has failed on this block, */
+				/*need to get valid data off and retire*/
+	u32 skip_erased_check:1;/* Skip the erased check on this block */
+	u32 gc_prioritise:1;	/* An ECC check or blank check has failed.
+				   Block should be prioritised for GC */
+	u32 chunk_error_strikes:3;	/* How many times we've had ecc etc
+				failures on this block and tried to reuse it */
+	u32 has_summary:1;	/* The block has a summary */
+
+	u32 has_shrink_hdr:1;	/* This block has at least one shrink header */
+	u32 seq_number;		/* block sequence number for yaffs2 */
+
+};
+
+/* -------------------------- Object structure -------------------------------*/
+/* This is the object structure as stored on NAND */
+
+struct yaffs_obj_hdr {
+	u32 type;  /* enum yaffs_obj_type  */
+
+	/* Apply to everything  */
+	int parent_obj_id;
+	u16 sum_no_longer_used;	/* checksum of name. No longer used */
+	YCHAR name[YAFFS_MAX_NAME_LENGTH + 1];
+
+	/* The following apply to all object types except for hard links */
+	u32 yst_mode;		/* protection */
+
+	u32 yst_uid;
+	u32 yst_gid;
+	u32 yst_atime;
+	u32 yst_mtime;
+	u32 yst_ctime;
+
+	/* File size  applies to files only */
+	u32 file_size_low;
+
+	/* Equivalent object id applies to hard links only. */
+	int equiv_id;
+
+	/* Alias is for symlinks only. */
+	YCHAR alias[YAFFS_MAX_ALIAS_LENGTH + 1];
+
+	u32 yst_rdev;	/* stuff for block and char devices (major/min) */
+
+	u32 win_ctime[2];
+	u32 win_atime[2];
+	u32 win_mtime[2];
+
+	u32 inband_shadowed_obj_id;
+	u32 inband_is_shrink;
+
+	u32 file_size_high;
+	u32 reserved[1];
+	int shadows_obj;	/* This object header shadows the
+				specified object if > 0 */
+
+	/* is_shrink applies to object headers written when wemake a hole. */
+	u32 is_shrink;
+
+};
+
+/*--------------------------- Tnode -------------------------- */
+
+struct yaffs_tnode {
+	struct yaffs_tnode *internal[YAFFS_NTNODES_INTERNAL];
+};
+
+/*------------------------  Object -----------------------------*/
+/* An object can be one of:
+ * - a directory (no data, has children links
+ * - a regular file (data.... not prunes :->).
+ * - a symlink [symbolic link] (the alias).
+ * - a hard link
+ */
+
+/* The file variant has three file sizes:
+ *  - file_size : size of file as written into Yaffs - including data in cache.
+ *  - stored_size - size of file as stored on media.
+ *  - shrink_size - size of file that has been shrunk back to.
+ *
+ * The stored_size and file_size might be different because the data written
+ * into the cache will increase the file_size but the stored_size will only
+ * change when the data is actually stored.
+ *
+ */
+struct yaffs_file_var {
+	loff_t file_size;
+	loff_t stored_size;
+	loff_t shrink_size;
+	int top_level;
+	struct yaffs_tnode *top;
+};
+
+struct yaffs_dir_var {
+	struct list_head children;	/* list of child links */
+	struct list_head dirty;	/* Entry for list of dirty directories */
+};
+
+struct yaffs_symlink_var {
+	YCHAR *alias;
+};
+
+struct yaffs_hardlink_var {
+	struct yaffs_obj *equiv_obj;
+	u32 equiv_id;
+};
+
+union yaffs_obj_var {
+	struct yaffs_file_var file_variant;
+	struct yaffs_dir_var dir_variant;
+	struct yaffs_symlink_var symlink_variant;
+	struct yaffs_hardlink_var hardlink_variant;
+};
+
+struct yaffs_obj {
+	u8 deleted:1;		/* This should only apply to unlinked files. */
+	u8 soft_del:1;		/* it has also been soft deleted */
+	u8 unlinked:1;		/* An unlinked file.*/
+	u8 fake:1;		/* A fake object has no presence on NAND. */
+	u8 rename_allowed:1;	/* Some objects cannot be renamed. */
+	u8 unlink_allowed:1;
+	u8 dirty:1;		/* the object needs to be written to flash */
+	u8 valid:1;		/* When the file system is being loaded up, this
+				 * object might be created before the data
+				 * is available
+				 * ie. file data chunks encountered before
+				* the header.
+				 */
+	u8 lazy_loaded:1;	/* This object has been lazy loaded and
+				 * is missing some detail */
+
+	u8 defered_free:1;	/* Object is removed from NAND, but is
+				 * still in the inode cache.
+				 * Free of object is defered.
+				 * until the inode is released.
+				 */
+	u8 being_created:1;	/* This object is still being created
+				 * so skip some verification checks. */
+	u8 is_shadowed:1;	/* This object is shadowed on the way
+				 * to being renamed. */
+
+	u8 xattr_known:1;	/* We know if this has object has xattribs
+				 * or not. */
+	u8 has_xattr:1;		/* This object has xattribs.
+				 * Only valid if xattr_known. */
+
+	u8 serial;		/* serial number of chunk in NAND.*/
+	u16 sum;		/* sum of the name to speed searching */
+
+	struct yaffs_dev *my_dev;	/* The device I'm on */
+
+	struct list_head hash_link;	/* list of objects in hash bucket */
+
+	struct list_head hard_links;	/* hard linked object chain*/
+
+	/* directory structure stuff */
+	/* also used for linking up the free list */
+	struct yaffs_obj *parent;
+	struct list_head siblings;
+
+	/* Where's my object header in NAND? */
+	int hdr_chunk;
+
+	int n_data_chunks;	/* Number of data chunks for this file. */
+
+	u32 obj_id;		/* the object id value */
+
+	u32 yst_mode;
+
+	YCHAR short_name[YAFFS_SHORT_NAME_LENGTH + 1];
+
+#ifdef CONFIG_YAFFS_WINCE
+	u32 win_ctime[2];
+	u32 win_mtime[2];
+	u32 win_atime[2];
+#else
+	u32 yst_uid;
+	u32 yst_gid;
+	u32 yst_atime;
+	u32 yst_mtime;
+	u32 yst_ctime;
+#endif
+
+	u32 yst_rdev;
+
+	void *my_inode;
+
+	u32 variant_type; /* enum yaffs_object_type */
+
+	union yaffs_obj_var variant;
+
+};
+
+struct yaffs_obj_bucket {
+	struct list_head list;
+	int count;
+};
+
+/* yaffs_checkpt_obj holds the definition of an object as dumped
+ * by checkpointing.
+ */
+
+struct yaffs_checkpt_obj {
+	int struct_type;
+	u32 obj_id;
+	u32 parent_id;
+	int hdr_chunk;
+	u32 variant_type:3; /* enum yaffs_obj_type */
+	u8 deleted:1;
+	u8 soft_del:1;
+	u8 unlinked:1;
+	u8 fake:1;
+	u8 rename_allowed:1;
+	u8 unlink_allowed:1;
+	u8 serial;
+	int n_data_chunks;
+	loff_t size_or_equiv_obj;
+};
+
+/*--------------------- Temporary buffers ----------------
+ *
+ * These are chunk-sized working buffers. Each device has a few.
+ */
+
+struct yaffs_buffer {
+	u8 *buffer;
+	int in_use;
+};
+
+/*----------------- Device ---------------------------------*/
+
+struct yaffs_param {
+	const YCHAR *name;
+
+	/*
+	 * Entry parameters set up way early. Yaffs sets up the rest.
+	 * The structure should be zeroed out before use so that unused
+	 * and default values are zero.
+	 */
+
+	int inband_tags;	/* Use unband tags */
+	u32 total_bytes_per_chunk;	/* Should be >= 512, does not need to
+					 be a power of 2 */
+	int chunks_per_block;	/* does not need to be a power of 2 */
+	int spare_bytes_per_chunk;	/* spare area size */
+	int start_block;	/* Start block we're allowed to use */
+	int end_block;		/* End block we're allowed to use */
+	int n_reserved_blocks;	/* Tuneable so that we can reduce
+				 * reserved blocks on NOR and RAM. */
+
+	int n_caches;		/* If <= 0, then short op caching is disabled,
+				 * else the number of short op caches.
+				 */
+	int cache_bypass_aligned; /* If non-zero then bypass the cache for
+				   * aligned writes.
+				   */
+
+	int use_nand_ecc;	/* Flag to decide whether or not to use
+				 * NAND driver ECC on data (yaffs1) */
+	int tags_9bytes;	/* Use 9 byte tags */
+	int no_tags_ecc;	/* Flag to decide whether or not to do ECC
+				 * on packed tags (yaffs2) */
+
+	int is_yaffs2;		/* Use yaffs2 mode on this device */
+
+	int empty_lost_n_found;	/* Auto-empty lost+found directory on mount */
+
+	int refresh_period;	/* How often to check for a block refresh */
+
+	/* Checkpoint control. Can be set before or after initialisation */
+	u8 skip_checkpt_rd;
+	u8 skip_checkpt_wr;
+
+	int enable_xattr;	/* Enable xattribs */
+
+	int max_objects;	/*
+				 * Set to limit the number of objects created.
+				 * 0 = no limit.
+				*/
+
+	/* The remove_obj_fn function must be supplied by OS flavours that
+	 * need it.
+	 * yaffs direct uses it to implement the faster readdir.
+	 * Linux uses it to protect the directory during unlocking.
+	 */
+	void (*remove_obj_fn) (struct yaffs_obj *obj);
+
+	/* Callback to mark the superblock dirty */
+	void (*sb_dirty_fn) (struct yaffs_dev *dev);
+
+	/*  Callback to control garbage collection. */
+	unsigned (*gc_control_fn) (struct yaffs_dev *dev);
+
+	/* Debug control flags. Don't use unless you know what you're doing */
+	int use_header_file_size;	/* Flag to determine if we should use
+					 * file sizes from the header */
+	int disable_lazy_load;	/* Disable lazy loading on this device */
+	int wide_tnodes_disabled;	/* Set to disable wide tnodes */
+	int disable_soft_del;	/* yaffs 1 only: Set to disable the use of
+				 * softdeletion. */
+
+	int defered_dir_update;	/* Set to defer directory updates */
+
+#ifdef CONFIG_YAFFS_AUTO_UNICODE
+	int auto_unicode;
+#endif
+	int always_check_erased;	/* Force chunk erased check always on */
+
+	int disable_summary;
+	int disable_bad_block_marking;
+
+};
+
+struct yaffs_driver {
+	int (*drv_write_chunk_fn) (struct yaffs_dev *dev, int nand_chunk,
+				   const u8 *data, int data_len,
+				   const u8 *oob, int oob_len);
+	int (*drv_read_chunk_fn) (struct yaffs_dev *dev, int nand_chunk,
+				   u8 *data, int data_len,
+				   u8 *oob, int oob_len,
+				   enum yaffs_ecc_result *ecc_result);
+	int (*drv_erase_fn) (struct yaffs_dev *dev, int block_no);
+	int (*drv_mark_bad_fn) (struct yaffs_dev *dev, int block_no);
+	int (*drv_check_bad_fn) (struct yaffs_dev *dev, int block_no);
+	int (*drv_initialise_fn) (struct yaffs_dev *dev);
+	int (*drv_deinitialise_fn) (struct yaffs_dev *dev);
+};
+
+struct yaffs_tags_handler {
+	int (*write_chunk_tags_fn) (struct yaffs_dev *dev,
+				    int nand_chunk, const u8 *data,
+				    const struct yaffs_ext_tags *tags);
+	int (*read_chunk_tags_fn) (struct yaffs_dev *dev,
+				   int nand_chunk, u8 *data,
+				   struct yaffs_ext_tags *tags);
+
+	int (*query_block_fn) (struct yaffs_dev *dev, int block_no,
+			       enum yaffs_block_state *state,
+			       u32 *seq_number);
+	int (*mark_bad_fn) (struct yaffs_dev *dev, int block_no);
+};
+
+struct yaffs_dev {
+	struct yaffs_param param;
+	struct yaffs_driver drv;
+	struct yaffs_tags_handler tagger;
+
+	/* Context storage. Holds extra OS specific data for this device */
+
+	void *os_context;
+	void *driver_context;
+
+	struct list_head dev_list;
+
+	int ll_init;
+	/* Runtime parameters. Set up by YAFFS. */
+	int data_bytes_per_chunk;
+
+	/* Non-wide tnode stuff */
+	u16 chunk_grp_bits;	/* Number of bits that need to be resolved if
+				 * the tnodes are not wide enough.
+				 */
+	u16 chunk_grp_size;	/* == 2^^chunk_grp_bits */
+
+	/* Stuff to support wide tnodes */
+	u32 tnode_width;
+	u32 tnode_mask;
+	u32 tnode_size;
+
+	/* Stuff for figuring out file offset to chunk conversions */
+	u32 chunk_shift;	/* Shift value */
+	u32 chunk_div;		/* Divisor after shifting: 1 for 2^n sizes */
+	u32 chunk_mask;		/* Mask to use for power-of-2 case */
+
+	int is_mounted;
+	int read_only;
+	int is_checkpointed;
+
+	/* Stuff to support block offsetting to support start block zero */
+	int internal_start_block;
+	int internal_end_block;
+	int block_offset;
+	int chunk_offset;
+
+	/* Runtime checkpointing stuff */
+	int checkpt_page_seq;	/* running sequence number of checkpt pages */
+	int checkpt_byte_count;
+	int checkpt_byte_offs;
+	u8 *checkpt_buffer;
+	int checkpt_open_write;
+	int blocks_in_checkpt;
+	int checkpt_cur_chunk;
+	int checkpt_cur_block;
+	int checkpt_next_block;
+	int *checkpt_block_list;
+	int checkpt_max_blocks;
+	u32 checkpt_sum;
+	u32 checkpt_xor;
+
+	int checkpoint_blocks_required;	/* Number of blocks needed to store
+					 * current checkpoint set */
+
+	/* Block Info */
+	struct yaffs_block_info *block_info;
+	u8 *chunk_bits;		/* bitmap of chunks in use */
+	u8 block_info_alt:1;	/* allocated using alternative alloc */
+	u8 chunk_bits_alt:1;	/* allocated using alternative alloc */
+	int chunk_bit_stride;	/* Number of bytes of chunk_bits per block.
+				 * Must be consistent with chunks_per_block.
+				 */
+
+	int n_erased_blocks;
+	int alloc_block;	/* Current block being allocated off */
+	u32 alloc_page;
+	int alloc_block_finder;	/* Used to search for next allocation block */
+
+	/* Object and Tnode memory management */
+	void *allocator;
+	int n_obj;
+	int n_tnodes;
+
+	int n_hardlinks;
+
+	struct yaffs_obj_bucket obj_bucket[YAFFS_NOBJECT_BUCKETS];
+	u32 bucket_finder;
+
+	int n_free_chunks;
+
+	/* Garbage collection control */
+	u32 *gc_cleanup_list;	/* objects to delete at the end of a GC. */
+	u32 n_clean_ups;
+
+	unsigned has_pending_prioritised_gc;	/* We think this device might
+						have pending prioritised gcs */
+	unsigned gc_disable;
+	unsigned gc_block_finder;
+	unsigned gc_dirtiest;
+	unsigned gc_pages_in_use;
+	unsigned gc_not_done;
+	unsigned gc_block;
+	unsigned gc_chunk;
+	unsigned gc_skip;
+	struct yaffs_summary_tags *gc_sum_tags;
+
+	/* Special directories */
+	struct yaffs_obj *root_dir;
+	struct yaffs_obj *lost_n_found;
+
+	int buffered_block;	/* Which block is buffered here? */
+	int doing_buffered_block_rewrite;
+
+	struct yaffs_cache *cache;
+	int cache_last_use;
+
+	/* Stuff for background deletion and unlinked files. */
+	struct yaffs_obj *unlinked_dir;	/* Directory where unlinked and deleted
+					 files live. */
+	struct yaffs_obj *del_dir;	/* Directory where deleted objects are
+					sent to disappear. */
+	struct yaffs_obj *unlinked_deletion;	/* Current file being
+							background deleted. */
+	int n_deleted_files;	/* Count of files awaiting deletion; */
+	int n_unlinked_files;	/* Count of unlinked files. */
+	int n_bg_deletions;	/* Count of background deletions. */
+
+	/* Temporary buffer management */
+	struct yaffs_buffer temp_buffer[YAFFS_N_TEMP_BUFFERS];
+	int max_temp;
+	int temp_in_use;
+	int unmanaged_buffer_allocs;
+	int unmanaged_buffer_deallocs;
+
+	/* yaffs2 runtime stuff */
+	unsigned seq_number;	/* Sequence number of currently
+					allocating block */
+	unsigned oldest_dirty_seq;
+	unsigned oldest_dirty_block;
+
+	/* Block refreshing */
+	int refresh_skip;	/* A skip down counter.
+				 * Refresh happens when this gets to zero. */
+
+	/* Dirty directory handling */
+	struct list_head dirty_dirs;	/* List of dirty directories */
+
+	/* Summary */
+	int chunks_per_summary;
+	struct yaffs_summary_tags *sum_tags;
+
+	/* Statistics */
+	u32 n_page_writes;
+	u32 n_page_reads;
+	u32 n_erasures;
+	u32 n_bad_queries;
+	u32 n_bad_markings;
+	u32 n_erase_failures;
+	u32 n_gc_copies;
+	u32 all_gcs;
+	u32 passive_gc_count;
+	u32 oldest_dirty_gc_count;
+	u32 n_gc_blocks;
+	u32 bg_gcs;
+	u32 n_retried_writes;
+	u32 n_retired_blocks;
+	u32 n_ecc_fixed;
+	u32 n_ecc_unfixed;
+	u32 n_tags_ecc_fixed;
+	u32 n_tags_ecc_unfixed;
+	u32 n_deletions;
+	u32 n_unmarked_deletions;
+	u32 refresh_count;
+	u32 cache_hits;
+	u32 tags_used;
+	u32 summary_used;
+
+};
+
+/* The CheckpointDevice structure holds the device information that changes
+ *at runtime and must be preserved over unmount/mount cycles.
+ */
+struct yaffs_checkpt_dev {
+	int struct_type;
+	int n_erased_blocks;
+	int alloc_block;	/* Current block being allocated off */
+	u32 alloc_page;
+	int n_free_chunks;
+
+	int n_deleted_files;	/* Count of files awaiting deletion; */
+	int n_unlinked_files;	/* Count of unlinked files. */
+	int n_bg_deletions;	/* Count of background deletions. */
+
+	/* yaffs2 runtime stuff */
+	unsigned seq_number;	/* Sequence number of currently
+				 * allocating block */
+
+};
+
+struct yaffs_checkpt_validity {
+	int struct_type;
+	u32 magic;
+	u32 version;
+	u32 head;
+};
+
+struct yaffs_shadow_fixer {
+	int obj_id;
+	int shadowed_id;
+	struct yaffs_shadow_fixer *next;
+};
+
+/* Structure for doing xattr modifications */
+struct yaffs_xattr_mod {
+	int set;		/* If 0 then this is a deletion */
+	const YCHAR *name;
+	const void *data;
+	int size;
+	int flags;
+	int result;
+};
+
+/*----------------------- YAFFS Functions -----------------------*/
+
+int yaffs_guts_initialise(struct yaffs_dev *dev);
+void yaffs_deinitialise(struct yaffs_dev *dev);
+
+int yaffs_get_n_free_chunks(struct yaffs_dev *dev);
+
+int yaffs_rename_obj(struct yaffs_obj *old_dir, const YCHAR * old_name,
+		     struct yaffs_obj *new_dir, const YCHAR * new_name);
+
+int yaffs_unlinker(struct yaffs_obj *dir, const YCHAR * name);
+int yaffs_del_obj(struct yaffs_obj *obj);
+struct yaffs_obj *yaffs_retype_obj(struct yaffs_obj *obj,
+				   enum yaffs_obj_type type);
+
+
+int yaffs_get_obj_name(struct yaffs_obj *obj, YCHAR * name, int buffer_size);
+loff_t yaffs_get_obj_length(struct yaffs_obj *obj);
+int yaffs_get_obj_inode(struct yaffs_obj *obj);
+unsigned yaffs_get_obj_type(struct yaffs_obj *obj);
+int yaffs_get_obj_link_count(struct yaffs_obj *obj);
+
+/* File operations */
+int yaffs_file_rd(struct yaffs_obj *obj, u8 * buffer, loff_t offset,
+		  int n_bytes);
+int yaffs_wr_file(struct yaffs_obj *obj, const u8 * buffer, loff_t offset,
+		  int n_bytes, int write_trhrough);
+int yaffs_resize_file(struct yaffs_obj *obj, loff_t new_size);
+
+struct yaffs_obj *yaffs_create_file(struct yaffs_obj *parent,
+				    const YCHAR *name, u32 mode, u32 uid,
+				    u32 gid);
+
+int yaffs_flush_file(struct yaffs_obj *in,
+		     int update_time,
+		     int data_sync,
+		     int discard_cache);
+
+/* Flushing and checkpointing */
+void yaffs_flush_whole_cache(struct yaffs_dev *dev, int discard);
+
+int yaffs_checkpoint_save(struct yaffs_dev *dev);
+int yaffs_checkpoint_restore(struct yaffs_dev *dev);
+
+/* Directory operations */
+struct yaffs_obj *yaffs_create_dir(struct yaffs_obj *parent, const YCHAR *name,
+				   u32 mode, u32 uid, u32 gid);
+struct yaffs_obj *yaffs_find_by_name(struct yaffs_obj *the_dir,
+				     const YCHAR *name);
+struct yaffs_obj *yaffs_find_by_number(struct yaffs_dev *dev, u32 number);
+
+/* Link operations */
+struct yaffs_obj *yaffs_link_obj(struct yaffs_obj *parent, const YCHAR *name,
+				 struct yaffs_obj *equiv_obj);
+
+struct yaffs_obj *yaffs_get_equivalent_obj(struct yaffs_obj *obj);
+
+/* Symlink operations */
+struct yaffs_obj *yaffs_create_symlink(struct yaffs_obj *parent,
+				       const YCHAR *name, u32 mode, u32 uid,
+				       u32 gid, const YCHAR *alias);
+YCHAR *yaffs_get_symlink_alias(struct yaffs_obj *obj);
+
+/* Special inodes (fifos, sockets and devices) */
+struct yaffs_obj *yaffs_create_special(struct yaffs_obj *parent,
+				       const YCHAR *name, u32 mode, u32 uid,
+				       u32 gid, u32 rdev);
+
+int yaffs_set_xattrib(struct yaffs_obj *obj, const YCHAR *name,
+		      const void *value, int size, int flags);
+int yaffs_get_xattrib(struct yaffs_obj *obj, const YCHAR *name, void *value,
+		      int size);
+int yaffs_list_xattrib(struct yaffs_obj *obj, char *buffer, int size);
+int yaffs_remove_xattrib(struct yaffs_obj *obj, const YCHAR *name);
+
+/* Special directories */
+struct yaffs_obj *yaffs_root(struct yaffs_dev *dev);
+struct yaffs_obj *yaffs_lost_n_found(struct yaffs_dev *dev);
+
+void yaffs_handle_defered_free(struct yaffs_obj *obj);
+
+void yaffs_update_dirty_dirs(struct yaffs_dev *dev);
+
+int yaffs_bg_gc(struct yaffs_dev *dev, unsigned urgency);
+
+/* Debug dump  */
+int yaffs_dump_obj(struct yaffs_obj *obj);
+
+void yaffs_guts_test(struct yaffs_dev *dev);
+int yaffs_guts_ll_init(struct yaffs_dev *dev);
+
+
+/* A few useful functions to be used within the core files*/
+void yaffs_chunk_del(struct yaffs_dev *dev, int chunk_id, int mark_flash,
+		     int lyn);
+int yaffs_check_ff(u8 *buffer, int n_bytes);
+void yaffs_handle_chunk_error(struct yaffs_dev *dev,
+			      struct yaffs_block_info *bi);
+
+u8 *yaffs_get_temp_buffer(struct yaffs_dev *dev);
+void yaffs_release_temp_buffer(struct yaffs_dev *dev, u8 *buffer);
+
+struct yaffs_obj *yaffs_find_or_create_by_number(struct yaffs_dev *dev,
+						 int number,
+						 enum yaffs_obj_type type);
+int yaffs_put_chunk_in_file(struct yaffs_obj *in, int inode_chunk,
+			    int nand_chunk, int in_scan);
+void yaffs_set_obj_name(struct yaffs_obj *obj, const YCHAR *name);
+void yaffs_set_obj_name_from_oh(struct yaffs_obj *obj,
+				const struct yaffs_obj_hdr *oh);
+void yaffs_add_obj_to_dir(struct yaffs_obj *directory, struct yaffs_obj *obj);
+YCHAR *yaffs_clone_str(const YCHAR *str);
+void yaffs_link_fixup(struct yaffs_dev *dev, struct list_head *hard_list);
+void yaffs_block_became_dirty(struct yaffs_dev *dev, int block_no);
+int yaffs_update_oh(struct yaffs_obj *in, const YCHAR *name,
+		    int force, int is_shrink, int shadows,
+		    struct yaffs_xattr_mod *xop);
+void yaffs_handle_shadowed_obj(struct yaffs_dev *dev, int obj_id,
+			       int backward_scanning);
+int yaffs_check_alloc_available(struct yaffs_dev *dev, int n_chunks);
+struct yaffs_tnode *yaffs_get_tnode(struct yaffs_dev *dev);
+struct yaffs_tnode *yaffs_add_find_tnode_0(struct yaffs_dev *dev,
+					   struct yaffs_file_var *file_struct,
+					   u32 chunk_id,
+					   struct yaffs_tnode *passed_tn);
+
+int yaffs_do_file_wr(struct yaffs_obj *in, const u8 *buffer, loff_t offset,
+		     int n_bytes, int write_trhrough);
+void yaffs_resize_file_down(struct yaffs_obj *obj, loff_t new_size);
+void yaffs_skip_rest_of_block(struct yaffs_dev *dev);
+
+int yaffs_count_free_chunks(struct yaffs_dev *dev);
+
+struct yaffs_tnode *yaffs_find_tnode_0(struct yaffs_dev *dev,
+				       struct yaffs_file_var *file_struct,
+				       u32 chunk_id);
+
+u32 yaffs_get_group_base(struct yaffs_dev *dev, struct yaffs_tnode *tn,
+			 unsigned pos);
+
+int yaffs_is_non_empty_dir(struct yaffs_obj *obj);
+
+int yaffs_guts_format_dev(struct yaffs_dev *dev);
+
+void yaffs_addr_to_chunk(struct yaffs_dev *dev, loff_t addr,
+				int *chunk_out, u32 *offset_out);
+/*
+ * Marshalling functions to get loff_t file sizes into aand out of
+ * object headers.
+ */
+void yaffs_oh_size_load(struct yaffs_obj_hdr *oh, loff_t fsize);
+loff_t yaffs_oh_to_size(struct yaffs_obj_hdr *oh);
+loff_t yaffs_max_file_size(struct yaffs_dev *dev);
+
+/*
+ * Debug function to count number of blocks in each state
+ * NB Needs to be called with correct number of integers
+ */
+
+void yaffs_count_blocks_by_state(struct yaffs_dev *dev, int bs[10]);
+
+int yaffs_find_chunk_in_file(struct yaffs_obj *in, int inode_chunk,
+				    struct yaffs_ext_tags *tags);
+
+#endif
diff --git a/fs/yaffs2/yaffs_linux.h b/fs/yaffs2/yaffs_linux.h
new file mode 100755
index 0000000..c20ab14
--- /dev/null
+++ b/fs/yaffs2/yaffs_linux.h
@@ -0,0 +1,48 @@
+/*
+ * YAFFS: Yet another Flash File System . A NAND-flash specific file system.
+ *
+ * Copyright (C) 2002-2011 Aleph One Ltd.
+ *   for Toby Churchill Ltd and Brightstar Engineering
+ *
+ * Created by Charles Manning <charles@aleph1.co.uk>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 2.1 as
+ * published by the Free Software Foundation.
+ *
+ * Note: Only YAFFS headers are LGPL, YAFFS C code is covered by GPL.
+ */
+
+#ifndef __YAFFS_LINUX_H__
+#define __YAFFS_LINUX_H__
+
+#include "yportenv.h"
+
+struct yaffs_linux_context {
+	struct list_head context_list;	/* List of these we have mounted */
+	struct yaffs_dev *dev;
+	struct super_block *super;
+	struct task_struct *bg_thread;	/* Background thread for this device */
+	int bg_running;
+	struct mutex gross_lock;	/* Gross locking mutex*/
+	u8 *spare_buffer;	/* For mtdif2 use. Don't know the buffer size
+				 * at compile time so we have to allocate it.
+				 */
+	struct list_head search_contexts;
+	struct task_struct *readdir_process;
+	unsigned mount_id;
+	int dirty;
+};
+
+#define yaffs_dev_to_lc(dev) ((struct yaffs_linux_context *)((dev)->os_context))
+#define yaffs_dev_to_mtd(dev) ((struct mtd_info *)((dev)->driver_context))
+
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 17))
+#define WRITE_SIZE_STR "writesize"
+#define WRITE_SIZE(mtd) ((mtd)->writesize)
+#else
+#define WRITE_SIZE_STR "oobblock"
+#define WRITE_SIZE(mtd) ((mtd)->oobblock)
+#endif
+
+#endif
diff --git a/fs/yaffs2/yaffs_mtdif.h b/fs/yaffs2/yaffs_mtdif.h
new file mode 100755
index 0000000..9cff224
--- /dev/null
+++ b/fs/yaffs2/yaffs_mtdif.h
@@ -0,0 +1,25 @@
+/*
+ * YAFFS: Yet another Flash File System . A NAND-flash specific file system.
+ *
+ * Copyright (C) 2002-2011 Aleph One Ltd.
+ *   for Toby Churchill Ltd and Brightstar Engineering
+ *
+ * Created by Charles Manning <charles@aleph1.co.uk>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 2.1 as
+ * published by the Free Software Foundation.
+ *
+ * Note: Only YAFFS headers are LGPL, YAFFS C code is covered by GPL.
+ */
+
+#ifndef __YAFFS_MTDIF_H__
+#define __YAFFS_MTDIF_H__
+
+#include "yaffs_guts.h"
+
+void yaffs_mtd_drv_install(struct yaffs_dev *dev);
+struct mtd_info * yaffs_get_mtd_device(dev_t sdev);
+void yaffs_put_mtd_device(struct mtd_info *mtd);
+int yaffs_verify_mtd(struct mtd_info *mtd, int yaffs_version, int inband_tags);
+#endif
diff --git a/fs/yaffs2/yaffs_mtdif_multi.c b/fs/yaffs2/yaffs_mtdif_multi.c
new file mode 100755
index 0000000..7c01461
--- /dev/null
+++ b/fs/yaffs2/yaffs_mtdif_multi.c
@@ -0,0 +1,310 @@
+/*
+ * YAFFS: Yet Another Flash File System. A NAND-flash specific file system.
+ *
+ * Copyright (C) 2002-2011 Aleph One Ltd.
+ *   for Toby Churchill Ltd and Brightstar Engineering
+ *
+ * Created by Charles Manning <charles@aleph1.co.uk>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include "yportenv.h"
+
+#include "yaffs_mtdif.h"
+
+#include "linux/mtd/mtd.h"
+#include "linux/types.h"
+#include "linux/time.h"
+#include "linux/mtd/nand.h"
+#include "linux/kernel.h"
+#include "linux/version.h"
+#include "linux/types.h"
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 14, 0))
+#include "uapi/linux/major.h"
+#endif
+
+#include "yaffs_trace.h"
+#include "yaffs_guts.h"
+#include "yaffs_linux.h"
+
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(3, 2, 0))
+#define MTD_OPS_AUTO_OOB MTD_OOB_AUTO
+#endif
+
+
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(3, 4, 0))
+#define mtd_erase(m, ei) (m)->erase(m, ei)
+#define mtd_write_oob(m, addr, pops) (m)->write_oob(m, addr, pops)
+#define mtd_read_oob(m, addr, pops) (m)->read_oob(m, addr, pops)
+#define mtd_block_isbad(m, offs) (m)->block_isbad(m, offs)
+#define mtd_block_markbad(m, offs) (m)->block_markbad(m, offs)
+#endif
+
+
+
+int nandmtd_erase_block(struct yaffs_dev *dev, int block_no)
+{
+	struct mtd_info *mtd = yaffs_dev_to_mtd(dev);
+	u32 addr =
+	    ((loff_t) block_no) * dev->param.total_bytes_per_chunk *
+	    dev->param.chunks_per_block;
+	struct erase_info ei;
+	int retval = 0;
+
+	ei.mtd = mtd;
+	ei.addr = addr;
+	ei.len = dev->param.total_bytes_per_chunk * dev->param.chunks_per_block;
+	ei.time = 1000;
+	ei.retries = 2;
+	ei.callback = NULL;
+	ei.priv = (u_long) dev;
+
+	retval = mtd_erase(mtd, &ei);
+
+	if (retval == 0)
+		return YAFFS_OK;
+
+	return YAFFS_FAIL;
+}
+
+
+static 	int yaffs_mtd_write(struct yaffs_dev *dev, int nand_chunk,
+				   const u8 *data, int data_len,
+				   const u8 *oob, int oob_len)
+{
+	struct mtd_info *mtd = yaffs_dev_to_mtd(dev);
+	loff_t addr;
+	struct mtd_oob_ops ops;
+	int retval;
+
+	yaffs_trace(YAFFS_TRACE_MTD,
+			"yaffs_mtd_write(%p, %d, %p, %d, %p, %d)\n",
+			dev, nand_chunk, data, data_len, oob, oob_len);
+
+	if (!data || !data_len) {
+		data = NULL;
+		data_len = 0;
+	}
+
+	if (!oob || !oob_len) {
+		oob = NULL;
+		oob_len = 0;
+	}
+
+	addr = ((loff_t) nand_chunk) * dev->param.total_bytes_per_chunk;
+	memset(&ops, 0, sizeof(ops));
+	ops.mode = MTD_OPS_AUTO_OOB;
+	ops.len = (data) ? data_len : 0;
+	ops.ooblen = oob_len;
+	ops.datbuf = (u8 *)data;
+	ops.oobbuf = (u8 *)oob;
+
+	retval = mtd_write_oob(mtd, addr, &ops);
+	if (retval) {
+		yaffs_trace(YAFFS_TRACE_MTD,
+			"write_oob failed, chunk %d, mtd error %d",
+			nand_chunk, retval);
+	}
+	return retval ? YAFFS_FAIL : YAFFS_OK;
+}
+
+static int yaffs_mtd_read(struct yaffs_dev *dev, int nand_chunk,
+				   u8 *data, int data_len,
+				   u8 *oob, int oob_len,
+				   enum yaffs_ecc_result *ecc_result)
+{
+	struct mtd_info *mtd = yaffs_dev_to_mtd(dev);
+	loff_t addr;
+	struct mtd_oob_ops ops;
+	int retval;
+
+	addr = ((loff_t) nand_chunk) * dev->param.total_bytes_per_chunk;
+	memset(&ops, 0, sizeof(ops));
+	ops.mode = MTD_OPS_AUTO_OOB;
+	ops.len = (data) ? data_len : 0;
+	ops.ooblen = oob_len;
+	ops.datbuf = data;
+	ops.oobbuf = oob;
+
+#if (MTD_VERSION_CODE < MTD_VERSION(2, 6, 20))
+	/* In MTD 2.6.18 to 2.6.19 nand_base.c:nand_do_read_oob() has a bug;
+	 * help it out with ops.len = ops.ooblen when ops.datbuf == NULL.
+	 */
+	ops.len = (ops.datbuf) ? ops.len : ops.ooblen;
+#endif
+	/* Read page and oob using MTD.
+	 * Check status and determine ECC result.
+	 */
+	retval = mtd_read_oob(mtd, addr, &ops);
+	if (retval)
+		yaffs_trace(YAFFS_TRACE_MTD,
+			"read_oob failed, chunk %d, mtd error %d",
+			nand_chunk, retval);
+
+	switch (retval) {
+	case 0:
+		/* no error */
+		if(ecc_result)
+			*ecc_result = YAFFS_ECC_RESULT_NO_ERROR;
+		break;
+
+	case -EUCLEAN:
+		/* MTD's ECC fixed the data */
+		if(ecc_result)
+			*ecc_result = YAFFS_ECC_RESULT_FIXED;
+		dev->n_ecc_fixed++;
+		break;
+
+	case -EBADMSG:
+	default:
+		/* MTD's ECC could not fix the data */
+		dev->n_ecc_unfixed++;
+		if(ecc_result)
+			*ecc_result = YAFFS_ECC_RESULT_UNFIXED;
+		return YAFFS_FAIL;
+	}
+
+	return YAFFS_OK;
+}
+
+static 	int yaffs_mtd_erase(struct yaffs_dev *dev, int block_no)
+{
+	struct mtd_info *mtd = yaffs_dev_to_mtd(dev);
+
+	loff_t addr;
+	struct erase_info ei;
+	int retval = 0;
+	u32 block_size;
+
+	block_size = dev->param.total_bytes_per_chunk *
+		     dev->param.chunks_per_block;
+	addr = ((loff_t) block_no) * block_size;
+
+	ei.mtd = mtd;
+	ei.addr = addr;
+	ei.len = block_size;
+	ei.time = 1000;
+	ei.retries = 2;
+	ei.callback = NULL;
+	ei.priv = (u_long) dev;
+
+	retval = mtd_erase(mtd, &ei);
+
+	if (retval == 0)
+		return YAFFS_OK;
+
+	return YAFFS_FAIL;
+}
+
+static int yaffs_mtd_mark_bad(struct yaffs_dev *dev, int block_no)
+{
+	struct mtd_info *mtd = yaffs_dev_to_mtd(dev);
+	int blocksize = dev->param.chunks_per_block * dev->param.total_bytes_per_chunk;
+	int retval;
+
+	yaffs_trace(YAFFS_TRACE_BAD_BLOCKS, "marking block %d bad", block_no);
+
+	retval = mtd_block_markbad(mtd, (loff_t) blocksize * block_no);
+	return (retval) ? YAFFS_FAIL : YAFFS_OK;
+}
+
+static int yaffs_mtd_check_bad(struct yaffs_dev *dev, int block_no)
+{
+	struct mtd_info *mtd = yaffs_dev_to_mtd(dev);
+	int blocksize = dev->param.chunks_per_block * dev->param.total_bytes_per_chunk;
+	int retval;
+
+	yaffs_trace(YAFFS_TRACE_MTD, "checking block %d bad", block_no);
+
+	retval = mtd_block_isbad(mtd, (loff_t) blocksize * block_no);
+	return (retval) ? YAFFS_FAIL : YAFFS_OK;
+}
+
+static int yaffs_mtd_initialise(struct yaffs_dev *dev)
+{
+	return YAFFS_OK;
+}
+
+static int yaffs_mtd_deinitialise(struct yaffs_dev *dev)
+{
+	return YAFFS_OK;
+}
+
+
+void yaffs_mtd_drv_install(struct yaffs_dev *dev)
+{
+	struct yaffs_driver *drv = &dev->drv;
+
+	drv->drv_write_chunk_fn = yaffs_mtd_write;
+	drv->drv_read_chunk_fn = yaffs_mtd_read;
+	drv->drv_erase_fn = yaffs_mtd_erase;
+	drv->drv_mark_bad_fn = yaffs_mtd_mark_bad;
+	drv->drv_check_bad_fn = yaffs_mtd_check_bad;
+	drv->drv_initialise_fn = yaffs_mtd_initialise;
+	drv->drv_deinitialise_fn = yaffs_mtd_deinitialise;
+}
+
+
+struct mtd_info * yaffs_get_mtd_device(dev_t sdev)
+{
+	struct mtd_info *mtd;
+
+	mtd = yaffs_get_mtd_device(sdev);
+
+	/* Check it's an mtd device..... */
+	if (MAJOR(sdev) != MTD_BLOCK_MAJOR)
+		return NULL;	/* This isn't an mtd device */
+
+	/* Check it's NAND */
+	if (mtd->type != MTD_NANDFLASH) {
+		yaffs_trace(YAFFS_TRACE_ALWAYS,
+			"yaffs: MTD device is not NAND it's type %d",
+			mtd->type);
+		return NULL;
+	}
+
+	yaffs_trace(YAFFS_TRACE_OS, " %s %d", WRITE_SIZE_STR, WRITE_SIZE(mtd));
+	yaffs_trace(YAFFS_TRACE_OS, " oobsize %d", mtd->oobsize);
+	yaffs_trace(YAFFS_TRACE_OS, " erasesize %d", mtd->erasesize);
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 29)
+	yaffs_trace(YAFFS_TRACE_OS, " size %u", mtd->size);
+#else
+	yaffs_trace(YAFFS_TRACE_OS, " size %lld", mtd->size);
+#endif
+
+	return mtd;
+}
+
+int yaffs_verify_mtd(struct mtd_info *mtd, int yaffs_version, int inband_tags)
+{
+	if (yaffs_version == 2) {
+		if ((WRITE_SIZE(mtd) < YAFFS_MIN_YAFFS2_CHUNK_SIZE ||
+		     mtd->oobsize < YAFFS_MIN_YAFFS2_SPARE_SIZE) &&
+		    !inband_tags) {
+			yaffs_trace(YAFFS_TRACE_ALWAYS,
+				"MTD device does not have the right page sizes"
+			);
+			return -1;
+		}
+	} else {
+		if (WRITE_SIZE(mtd) < YAFFS_BYTES_PER_CHUNK ||
+		    mtd->oobsize != YAFFS_BYTES_PER_SPARE) {
+			yaffs_trace(YAFFS_TRACE_ALWAYS,
+				"MTD device does not support have the right page sizes"
+			);
+			return -1;
+		}
+	}
+
+	return 0;
+}
+
+
+void yaffs_put_mtd_device(struct mtd_info *mtd)
+{
+	if(mtd)
+		put_mtd_device(mtd);
+}
diff --git a/fs/yaffs2/yaffs_mtdif_single.c b/fs/yaffs2/yaffs_mtdif_single.c
new file mode 100755
index 0000000..3fdd676
--- /dev/null
+++ b/fs/yaffs2/yaffs_mtdif_single.c
@@ -0,0 +1,212 @@
+/*
+ * YAFFS: Yet Another Flash File System. A NAND-flash specific file system.
+ *
+ * Copyright (C) 2002-2011 Aleph One Ltd.
+ *   for Toby Churchill Ltd and Brightstar Engineering
+ *
+ * Created by Charles Manning <charles@aleph1.co.uk>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include "yportenv.h"
+
+#include "yaffs_mtdif.h"
+
+#include "linux/mtd/mtd.h"
+#include "linux/types.h"
+#include "linux/time.h"
+#include "linux/mtd/nand.h"
+#include "linux/kernel.h"
+#include "linux/version.h"
+#include "linux/types.h"
+
+#include "yaffs_trace.h"
+#include "yaffs_guts.h"
+#include "yaffs_linux.h"
+
+
+int nandmtd_erase_block(struct yaffs_dev *dev, int block_no)
+{
+	struct mtd_info *mtd = yaffs_dev_to_mtd(dev);
+	u32 addr =
+	    ((loff_t) block_no) * dev->param.total_bytes_per_chunk *
+	    dev->param.chunks_per_block;
+	struct erase_info ei;
+	int retval = 0;
+
+	ei.mtd = mtd;
+	ei.addr = addr;
+	ei.len = dev->param.total_bytes_per_chunk * dev->param.chunks_per_block;
+	ei.time = 1000;
+	ei.retries = 2;
+	ei.callback = NULL;
+	ei.priv = (u_long) dev;
+
+	retval = mtd->_erase(mtd, &ei);
+
+	if (retval == 0)
+		return YAFFS_OK;
+
+	return YAFFS_FAIL;
+}
+
+
+static 	int yaffs_mtd_write(struct yaffs_dev *dev, int nand_chunk,
+				   const u8 *data, int data_len,
+				   const u8 *oob, int oob_len)
+{
+	struct mtd_info *mtd = yaffs_dev_to_mtd(dev);
+	loff_t addr;
+	struct mtd_oob_ops ops;
+	int retval;
+
+	addr = ((loff_t) nand_chunk) * dev->param.total_bytes_per_chunk;
+	memset(&ops, 0, sizeof(ops));
+	ops.mode = MTD_OPS_AUTO_OOB;
+	ops.len = (data) ? data_len : 0;
+	ops.ooblen = oob_len;
+	ops.datbuf = (u8 *)data;
+	ops.oobbuf = (u8 *)oob;
+
+	retval = mtd->_write_oob(mtd, addr, &ops);
+	if (retval) {
+		yaffs_trace(YAFFS_TRACE_MTD,
+			"write_oob failed, chunk %d, mtd error %d",
+			nand_chunk, retval);
+	}
+	return retval ? YAFFS_FAIL : YAFFS_OK;
+}
+
+static int yaffs_mtd_read(struct yaffs_dev *dev, int nand_chunk,
+				   u8 *data, int data_len,
+				   u8 *oob, int oob_len,
+				   enum yaffs_ecc_result *ecc_result)
+{
+	struct mtd_info *mtd = yaffs_dev_to_mtd(dev);
+	loff_t addr;
+	struct mtd_oob_ops ops;
+	int retval;
+
+	addr = ((loff_t) nand_chunk) * dev->data_bytes_per_chunk;
+	memset(&ops, 0, sizeof(ops));
+	ops.mode = MTD_OPS_AUTO_OOB;
+	ops.len = (data) ? data_len : 0;
+	ops.ooblen = oob_len;
+	ops.datbuf = data;
+	ops.oobbuf = oob;
+
+	/* Read page and oob using MTD.
+	 * Check status and determine ECC result.
+	 */
+	retval = mtd->_read_oob(mtd, addr, &ops);
+	if (retval)
+		yaffs_trace(YAFFS_TRACE_MTD,
+			"read_oob failed, chunk %d, mtd error %d",
+			nand_chunk, retval);
+
+	switch (retval) {
+	case 0:
+		/* no error */
+		if(ecc_result)
+			*ecc_result = YAFFS_ECC_RESULT_NO_ERROR;
+		break;
+
+	case -EUCLEAN:
+		/* MTD's ECC fixed the data */
+		if(ecc_result)
+			*ecc_result = YAFFS_ECC_RESULT_FIXED;
+		dev->n_ecc_fixed++;
+		break;
+
+	case -EBADMSG:
+	default:
+		/* MTD's ECC could not fix the data */
+		dev->n_ecc_unfixed++;
+		if(ecc_result)
+			*ecc_result = YAFFS_ECC_RESULT_UNFIXED;
+		return YAFFS_FAIL;
+	}
+
+	return YAFFS_OK;
+}
+
+static 	int yaffs_mtd_erase(struct yaffs_dev *dev, int block_no)
+{
+	struct mtd_info *mtd = yaffs_dev_to_mtd(dev);
+
+	loff_t addr;
+	struct erase_info ei;
+	int retval = 0;
+	u32 block_size;
+
+	block_size = dev->param.total_bytes_per_chunk *
+		     dev->param.chunks_per_block;
+	addr = ((loff_t) block_no) * block_size;
+
+	ei.mtd = mtd;
+	ei.addr = addr;
+	ei.len = block_size;
+	ei.time = 1000;
+	ei.retries = 2;
+	ei.callback = NULL;
+	ei.priv = (u_long) dev;
+
+	retval = mtd->_erase(mtd, &ei);
+
+	if (retval == 0)
+		return YAFFS_OK;
+
+	return YAFFS_FAIL;
+}
+
+static int yaffs_mtd_mark_bad(struct yaffs_dev *dev, int block_no)
+{
+	struct mtd_info *mtd = yaffs_dev_to_mtd(dev);
+	int blocksize = dev->param.chunks_per_block * dev->data_bytes_per_chunk;
+	int retval;
+
+	yaffs_trace(YAFFS_TRACE_BAD_BLOCKS, "marking block %d bad", block_no);
+
+	retval = mtd->_block_markbad(mtd, (loff_t) blocksize * block_no);
+	return (retval) ? YAFFS_FAIL : YAFFS_OK;
+}
+
+static int yaffs_mtd_check_bad(struct yaffs_dev *dev, int block_no)
+{
+	struct mtd_info *mtd = yaffs_dev_to_mtd(dev);
+	int blocksize = dev->param.chunks_per_block * dev->data_bytes_per_chunk;
+	int retval;
+
+	yaffs_trace(YAFFS_TRACE_BAD_BLOCKS, "checking block %d bad", block_no);
+
+	retval = mtd->_block_isbad(mtd, (loff_t) blocksize * block_no);
+	return (retval) ? YAFFS_FAIL : YAFFS_OK;
+}
+
+static int yaffs_mtd_initialise(struct yaffs_dev *dev)
+{
+	return YAFFS_OK;
+}
+
+static int yaffs_mtd_deinitialise(struct yaffs_dev *dev)
+{
+	return YAFFS_OK;
+}
+
+
+
+void yaffs_mtd_drv_install(struct yaffs_dev *dev)
+{
+	struct yaffs_driver *drv = &dev->drv;
+
+	drv->drv_write_chunk_fn = yaffs_mtd_write;
+	drv->drv_read_chunk_fn = yaffs_mtd_read;
+	drv->drv_erase_fn = yaffs_mtd_erase;
+	drv->drv_mark_bad_fn = yaffs_mtd_mark_bad;
+	drv->drv_check_bad_fn = yaffs_mtd_check_bad;
+	drv->drv_initialise_fn = yaffs_mtd_initialise;
+	drv->drv_deinitialise_fn = yaffs_mtd_deinitialise;
+}
diff --git a/fs/yaffs2/yaffs_nameval.c b/fs/yaffs2/yaffs_nameval.c
new file mode 100755
index 0000000..4bdf4ed
--- /dev/null
+++ b/fs/yaffs2/yaffs_nameval.c
@@ -0,0 +1,208 @@
+/*
+ * YAFFS: Yet Another Flash File System. A NAND-flash specific file system.
+ *
+ * Copyright (C) 2002-2011 Aleph One Ltd.
+ *   for Toby Churchill Ltd and Brightstar Engineering
+ *
+ * Created by Charles Manning <charles@aleph1.co.uk>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+/*
+ * This simple implementation of a name-value store assumes a small number of
+* values and fits into a small finite buffer.
+ *
+ * Each attribute is stored as a record:
+ *  sizeof(int) bytes   record size.
+ *  strnlen+1 bytes name null terminated.
+ *  nbytes    value.
+ *  ----------
+ *  total size  stored in record size
+ *
+ * This code has not been tested with unicode yet.
+ */
+
+#include "yaffs_nameval.h"
+
+#include "yportenv.h"
+
+static int nval_find(const char *xb, int xb_size, const YCHAR *name,
+		     int *exist_size)
+{
+	int pos = 0;
+	int size;
+
+	memcpy(&size, xb, sizeof(int));
+	while (size > 0 && (size < xb_size) && (pos + size < xb_size)) {
+		if (!strncmp((YCHAR *) (xb + pos + sizeof(int)),
+				name, size)) {
+			if (exist_size)
+				*exist_size = size;
+			return pos;
+		}
+		pos += size;
+		if (pos < xb_size - sizeof(int))
+			memcpy(&size, xb + pos, sizeof(int));
+		else
+			size = 0;
+	}
+	if (exist_size)
+		*exist_size = 0;
+	return -ENODATA;
+}
+
+static int nval_used(const char *xb, int xb_size)
+{
+	int pos = 0;
+	int size;
+
+	memcpy(&size, xb + pos, sizeof(int));
+	while (size > 0 && (size < xb_size) && (pos + size < xb_size)) {
+		pos += size;
+		if (pos < xb_size - sizeof(int))
+			memcpy(&size, xb + pos, sizeof(int));
+		else
+			size = 0;
+	}
+	return pos;
+}
+
+int nval_del(char *xb, int xb_size, const YCHAR *name)
+{
+	int pos = nval_find(xb, xb_size, name, NULL);
+	int size;
+
+	if (pos < 0 || pos >= xb_size)
+		return -ENODATA;
+
+	/* Find size, shift rest over this record,
+	 * then zero out the rest of buffer */
+	memcpy(&size, xb + pos, sizeof(int));
+	memcpy(xb + pos, xb + pos + size, xb_size - (pos + size));
+	memset(xb + (xb_size - size), 0, size);
+	return 0;
+}
+
+int nval_set(char *xb, int xb_size, const YCHAR *name, const char *buf,
+		int bsize, int flags)
+{
+	int pos;
+	int namelen = strnlen(name, xb_size);
+	int reclen;
+	int size_exist = 0;
+	int space;
+	int start;
+
+	pos = nval_find(xb, xb_size, name, &size_exist);
+
+	if (flags & XATTR_CREATE && pos >= 0)
+		return -EEXIST;
+	if (flags & XATTR_REPLACE && pos < 0)
+		return -ENODATA;
+
+	start = nval_used(xb, xb_size);
+	space = xb_size - start + size_exist;
+
+	reclen = (sizeof(int) + namelen + 1 + bsize);
+
+	if (reclen > space)
+		return -ENOSPC;
+
+	if (pos >= 0) {
+		nval_del(xb, xb_size, name);
+		start = nval_used(xb, xb_size);
+	}
+
+	pos = start;
+
+	memcpy(xb + pos, &reclen, sizeof(int));
+	pos += sizeof(int);
+	strncpy((YCHAR *) (xb + pos), name, reclen);
+	pos += (namelen + 1);
+	memcpy(xb + pos, buf, bsize);
+	return 0;
+}
+
+int nval_get(const char *xb, int xb_size, const YCHAR * name, char *buf,
+	     int bsize)
+{
+	int pos = nval_find(xb, xb_size, name, NULL);
+	int size;
+
+	if (pos >= 0 && pos < xb_size) {
+
+		memcpy(&size, xb + pos, sizeof(int));
+		pos += sizeof(int);	/* advance past record length */
+		size -= sizeof(int);
+
+		/* Advance over name string */
+		while (xb[pos] && size > 0 && pos < xb_size) {
+			pos++;
+			size--;
+		}
+		/*Advance over NUL */
+		pos++;
+		size--;
+
+		/* If bsize is zero then this is a size query.
+		 * Return the size, but don't copy.
+		 */
+		if (!bsize)
+			return size;
+
+		if (size <= bsize) {
+			memcpy(buf, xb + pos, size);
+			return size;
+		}
+	}
+	if (pos >= 0)
+		return -ERANGE;
+
+	return -ENODATA;
+}
+
+int nval_list(const char *xb, int xb_size, char *buf, int bsize)
+{
+	int pos = 0;
+	int size;
+	int name_len;
+	int ncopied = 0;
+	int filled = 0;
+
+	memcpy(&size, xb + pos, sizeof(int));
+	while (size > sizeof(int) &&
+		size <= xb_size &&
+		(pos + size) < xb_size &&
+		!filled) {
+		pos += sizeof(int);
+		size -= sizeof(int);
+		name_len = strnlen((YCHAR *) (xb + pos), size);
+		if (ncopied + name_len + 1 < bsize) {
+			memcpy(buf, xb + pos, name_len * sizeof(YCHAR));
+			buf += name_len;
+			*buf = '\0';
+			buf++;
+			if (sizeof(YCHAR) > 1) {
+				*buf = '\0';
+				buf++;
+			}
+			ncopied += (name_len + 1);
+		} else {
+			filled = 1;
+		}
+		pos += size;
+		if (pos < xb_size - sizeof(int))
+			memcpy(&size, xb + pos, sizeof(int));
+		else
+			size = 0;
+	}
+	return ncopied;
+}
+
+int nval_hasvalues(const char *xb, int xb_size)
+{
+	return nval_used(xb, xb_size) > 0;
+}
diff --git a/fs/yaffs2/yaffs_nameval.h b/fs/yaffs2/yaffs_nameval.h
new file mode 100755
index 0000000..951e64f
--- /dev/null
+++ b/fs/yaffs2/yaffs_nameval.h
@@ -0,0 +1,28 @@
+/*
+ * YAFFS: Yet another Flash File System . A NAND-flash specific file system.
+ *
+ * Copyright (C) 2002-2011 Aleph One Ltd.
+ *   for Toby Churchill Ltd and Brightstar Engineering
+ *
+ * Created by Charles Manning <charles@aleph1.co.uk>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 2.1 as
+ * published by the Free Software Foundation.
+ *
+ * Note: Only YAFFS headers are LGPL, YAFFS C code is covered by GPL.
+ */
+
+#ifndef __NAMEVAL_H__
+#define __NAMEVAL_H__
+
+#include "yportenv.h"
+
+int nval_del(char *xb, int xb_size, const YCHAR * name);
+int nval_set(char *xb, int xb_size, const YCHAR * name, const char *buf,
+	     int bsize, int flags);
+int nval_get(const char *xb, int xb_size, const YCHAR * name, char *buf,
+	     int bsize);
+int nval_list(const char *xb, int xb_size, char *buf, int bsize);
+int nval_hasvalues(const char *xb, int xb_size);
+#endif
diff --git a/fs/yaffs2/yaffs_nand.c b/fs/yaffs2/yaffs_nand.c
new file mode 100755
index 0000000..0d8499b
--- /dev/null
+++ b/fs/yaffs2/yaffs_nand.c
@@ -0,0 +1,122 @@
+/*
+ * YAFFS: Yet Another Flash File System. A NAND-flash specific file system.
+ *
+ * Copyright (C) 2002-2011 Aleph One Ltd.
+ *   for Toby Churchill Ltd and Brightstar Engineering
+ *
+ * Created by Charles Manning <charles@aleph1.co.uk>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include "yaffs_nand.h"
+#include "yaffs_tagscompat.h"
+
+#include "yaffs_getblockinfo.h"
+#include "yaffs_summary.h"
+
+static int apply_chunk_offset(struct yaffs_dev *dev, int chunk)
+{
+	return chunk - dev->chunk_offset;
+}
+
+int yaffs_rd_chunk_tags_nand(struct yaffs_dev *dev, int nand_chunk,
+			     u8 *buffer, struct yaffs_ext_tags *tags)
+{
+	int result;
+	struct yaffs_ext_tags local_tags;
+	int flash_chunk = apply_chunk_offset(dev, nand_chunk);
+
+	dev->n_page_reads++;
+
+	/* If there are no tags provided use local tags. */
+	if (!tags)
+		tags = &local_tags;
+
+	result = dev->tagger.read_chunk_tags_fn(dev, flash_chunk, buffer, tags);
+	if (tags && tags->ecc_result > YAFFS_ECC_RESULT_NO_ERROR) {
+
+		struct yaffs_block_info *bi;
+		bi = yaffs_get_block_info(dev,
+					  nand_chunk /
+					  dev->param.chunks_per_block);
+		yaffs_handle_chunk_error(dev, bi);
+	}
+	return result;
+}
+
+int yaffs_wr_chunk_tags_nand(struct yaffs_dev *dev,
+				int nand_chunk,
+				const u8 *buffer, struct yaffs_ext_tags *tags)
+{
+	int result;
+	int flash_chunk = apply_chunk_offset(dev, nand_chunk);
+
+	dev->n_page_writes++;
+
+	if (!tags) {
+		yaffs_trace(YAFFS_TRACE_ERROR, "Writing with no tags");
+		BUG();
+		return YAFFS_FAIL;
+	}
+
+	tags->seq_number = dev->seq_number;
+	tags->chunk_used = 1;
+	yaffs_trace(YAFFS_TRACE_WRITE,
+		"Writing chunk %d tags %d %d",
+		nand_chunk, tags->obj_id, tags->chunk_id);
+
+	result = dev->tagger.write_chunk_tags_fn(dev, flash_chunk,
+							buffer, tags);
+
+	yaffs_summary_add(dev, tags, nand_chunk);
+
+	return result;
+}
+
+int yaffs_mark_bad(struct yaffs_dev *dev, int block_no)
+{
+	block_no -= dev->block_offset;
+	dev->n_bad_markings++;
+
+	if (dev->param.disable_bad_block_marking)
+		return YAFFS_OK;
+
+	return dev->tagger.mark_bad_fn(dev, block_no);
+}
+
+
+int yaffs_query_init_block_state(struct yaffs_dev *dev,
+				 int block_no,
+				 enum yaffs_block_state *state,
+				 u32 *seq_number)
+{
+	block_no -= dev->block_offset;
+	return dev->tagger.query_block_fn(dev, block_no, state, seq_number);
+}
+
+int yaffs_erase_block(struct yaffs_dev *dev, int block_no)
+{
+	int result;
+
+	block_no -= dev->block_offset;
+	dev->n_erasures++;
+	result = dev->drv.drv_erase_fn(dev, block_no);
+	return result;
+}
+
+int yaffs_init_nand(struct yaffs_dev *dev)
+{
+	if (dev->drv.drv_initialise_fn)
+		return dev->drv.drv_initialise_fn(dev);
+	return YAFFS_OK;
+}
+
+int yaffs_deinit_nand(struct yaffs_dev *dev)
+{
+	if (dev->drv.drv_deinitialise_fn)
+		return dev->drv.drv_deinitialise_fn(dev);
+	return YAFFS_OK;
+}
diff --git a/fs/yaffs2/yaffs_nand.h b/fs/yaffs2/yaffs_nand.h
new file mode 100755
index 0000000..804e97a
--- /dev/null
+++ b/fs/yaffs2/yaffs_nand.h
@@ -0,0 +1,39 @@
+/*
+ * YAFFS: Yet another Flash File System . A NAND-flash specific file system.
+ *
+ * Copyright (C) 2002-2011 Aleph One Ltd.
+ *   for Toby Churchill Ltd and Brightstar Engineering
+ *
+ * Created by Charles Manning <charles@aleph1.co.uk>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 2.1 as
+ * published by the Free Software Foundation.
+ *
+ * Note: Only YAFFS headers are LGPL, YAFFS C code is covered by GPL.
+ */
+
+#ifndef __YAFFS_NAND_H__
+#define __YAFFS_NAND_H__
+#include "yaffs_guts.h"
+
+int yaffs_rd_chunk_tags_nand(struct yaffs_dev *dev, int nand_chunk,
+			     u8 *buffer, struct yaffs_ext_tags *tags);
+
+int yaffs_wr_chunk_tags_nand(struct yaffs_dev *dev,
+			     int nand_chunk,
+			     const u8 *buffer, struct yaffs_ext_tags *tags);
+
+int yaffs_mark_bad(struct yaffs_dev *dev, int block_no);
+
+int yaffs_query_init_block_state(struct yaffs_dev *dev,
+				 int block_no,
+				 enum yaffs_block_state *state,
+				 unsigned *seq_number);
+
+int yaffs_erase_block(struct yaffs_dev *dev, int flash_block);
+
+int yaffs_init_nand(struct yaffs_dev *dev);
+int yaffs_deinit_nand(struct yaffs_dev *dev);
+
+#endif
diff --git a/fs/yaffs2/yaffs_packedtags1.c b/fs/yaffs2/yaffs_packedtags1.c
new file mode 100755
index 0000000..dd9a331
--- /dev/null
+++ b/fs/yaffs2/yaffs_packedtags1.c
@@ -0,0 +1,56 @@
+/*
+ * YAFFS: Yet Another Flash File System. A NAND-flash specific file system.
+ *
+ * Copyright (C) 2002-2011 Aleph One Ltd.
+ *   for Toby Churchill Ltd and Brightstar Engineering
+ *
+ * Created by Charles Manning <charles@aleph1.co.uk>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include "yaffs_packedtags1.h"
+#include "yportenv.h"
+
+static const u8 all_ff[20] = {
+	0xff, 0xff, 0xff, 0xff,
+	0xff, 0xff, 0xff, 0xff,
+	0xff, 0xff, 0xff, 0xff,
+	0xff, 0xff, 0xff, 0xff,
+	0xff, 0xff, 0xff, 0xff
+};
+
+void yaffs_pack_tags1(struct yaffs_packed_tags1 *pt,
+		      const struct yaffs_ext_tags *t)
+{
+	pt->chunk_id = t->chunk_id;
+	pt->serial_number = t->serial_number;
+	pt->n_bytes = t->n_bytes;
+	pt->obj_id = t->obj_id;
+	pt->ecc = 0;
+	pt->deleted = (t->is_deleted) ? 0 : 1;
+	pt->unused_stuff = 0;
+	pt->should_be_ff = 0xffffffff;
+}
+
+void yaffs_unpack_tags1(struct yaffs_ext_tags *t,
+			const struct yaffs_packed_tags1 *pt)
+{
+
+	if (memcmp(all_ff, pt, sizeof(struct yaffs_packed_tags1))) {
+		t->block_bad = 0;
+		if (pt->should_be_ff != 0xffffffff)
+			t->block_bad = 1;
+		t->chunk_used = 1;
+		t->obj_id = pt->obj_id;
+		t->chunk_id = pt->chunk_id;
+		t->n_bytes = pt->n_bytes;
+		t->ecc_result = YAFFS_ECC_RESULT_NO_ERROR;
+		t->is_deleted = (pt->deleted) ? 0 : 1;
+		t->serial_number = pt->serial_number;
+	} else {
+		memset(t, 0, sizeof(struct yaffs_ext_tags));
+	}
+}
diff --git a/fs/yaffs2/yaffs_packedtags1.h b/fs/yaffs2/yaffs_packedtags1.h
new file mode 100755
index 0000000..3015d58
--- /dev/null
+++ b/fs/yaffs2/yaffs_packedtags1.h
@@ -0,0 +1,39 @@
+/*
+ * YAFFS: Yet another Flash File System . A NAND-flash specific file system.
+ *
+ * Copyright (C) 2002-2011 Aleph One Ltd.
+ *   for Toby Churchill Ltd and Brightstar Engineering
+ *
+ * Created by Charles Manning <charles@aleph1.co.uk>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 2.1 as
+ * published by the Free Software Foundation.
+ *
+ * Note: Only YAFFS headers are LGPL, YAFFS C code is covered by GPL.
+ */
+
+/* This is used to pack YAFFS1 tags, not YAFFS2 tags. */
+
+#ifndef __YAFFS_PACKEDTAGS1_H__
+#define __YAFFS_PACKEDTAGS1_H__
+
+#include "yaffs_guts.h"
+
+struct yaffs_packed_tags1 {
+	u32 chunk_id:20;
+	u32 serial_number:2;
+	u32 n_bytes:10;
+	u32 obj_id:18;
+	u32 ecc:12;
+	u32 deleted:1;
+	u32 unused_stuff:1;
+	unsigned should_be_ff;
+
+};
+
+void yaffs_pack_tags1(struct yaffs_packed_tags1 *pt,
+		      const struct yaffs_ext_tags *t);
+void yaffs_unpack_tags1(struct yaffs_ext_tags *t,
+			const struct yaffs_packed_tags1 *pt);
+#endif
diff --git a/fs/yaffs2/yaffs_packedtags2.c b/fs/yaffs2/yaffs_packedtags2.c
new file mode 100755
index 0000000..bc2cfa7
--- /dev/null
+++ b/fs/yaffs2/yaffs_packedtags2.c
@@ -0,0 +1,202 @@
+/*
+ * YAFFS: Yet Another Flash File System. A NAND-flash specific file system.
+ *
+ * Copyright (C) 2002-2011 Aleph One Ltd.
+ *   for Toby Churchill Ltd and Brightstar Engineering
+ *
+ * Created by Charles Manning <charles@aleph1.co.uk>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include "yaffs_packedtags2.h"
+#include "yportenv.h"
+#include "yaffs_trace.h"
+
+/* This code packs a set of extended tags into a binary structure for
+ * NAND storage
+ */
+
+/* Some of the information is "extra" struff which can be packed in to
+ * speed scanning
+ * This is defined by having the EXTRA_HEADER_INFO_FLAG set.
+ */
+
+/* Extra flags applied to chunk_id */
+
+#define EXTRA_HEADER_INFO_FLAG	0x80000000
+#define EXTRA_SHRINK_FLAG	0x40000000
+#define EXTRA_SHADOWS_FLAG	0x20000000
+#define EXTRA_SPARE_FLAGS	0x10000000
+
+#define ALL_EXTRA_FLAGS		0xf0000000
+
+/* Also, the top 4 bits of the object Id are set to the object type. */
+#define EXTRA_OBJECT_TYPE_SHIFT (28)
+#define EXTRA_OBJECT_TYPE_MASK  ((0x0f) << EXTRA_OBJECT_TYPE_SHIFT)
+
+static void yaffs_dump_packed_tags2_tags_only(
+				const struct yaffs_packed_tags2_tags_only *ptt)
+{
+	yaffs_trace(YAFFS_TRACE_MTD,
+		"packed tags obj %d chunk %d byte %d seq %d",
+		ptt->obj_id, ptt->chunk_id, ptt->n_bytes, ptt->seq_number);
+}
+
+static void yaffs_dump_packed_tags2(const struct yaffs_packed_tags2 *pt)
+{
+	yaffs_dump_packed_tags2_tags_only(&pt->t);
+}
+
+static void yaffs_dump_tags2(const struct yaffs_ext_tags *t)
+{
+	yaffs_trace(YAFFS_TRACE_MTD,
+		"ext.tags eccres %d blkbad %d chused %d obj %d chunk%d byte %d del %d ser %d seq %d",
+		t->ecc_result, t->block_bad, t->chunk_used, t->obj_id,
+		t->chunk_id, t->n_bytes, t->is_deleted, t->serial_number,
+		t->seq_number);
+
+}
+
+static int yaffs_check_tags_extra_packable(const struct yaffs_ext_tags *t)
+{
+	if (t->chunk_id != 0 || !t->extra_available)
+		return 0;
+
+	/* Check if the file size is too long to store */
+	if (t->extra_obj_type == YAFFS_OBJECT_TYPE_FILE &&
+	    (t->extra_file_size >> 31) != 0)
+		return 0;
+	return 1;
+}
+
+void yaffs_pack_tags2_tags_only(struct yaffs_packed_tags2_tags_only *ptt,
+				const struct yaffs_ext_tags *t)
+{
+	ptt->chunk_id = t->chunk_id;
+	ptt->seq_number = t->seq_number;
+	ptt->n_bytes = t->n_bytes;
+	ptt->obj_id = t->obj_id;
+
+	/* Only store extra tags for object headers.
+	 * If it is a file then only store  if the file size is short\
+	 * enough to fit.
+	 */
+	if (yaffs_check_tags_extra_packable(t)) {
+		/* Store the extra header info instead */
+		/* We save the parent object in the chunk_id */
+		ptt->chunk_id = EXTRA_HEADER_INFO_FLAG | t->extra_parent_id;
+		if (t->extra_is_shrink)
+			ptt->chunk_id |= EXTRA_SHRINK_FLAG;
+		if (t->extra_shadows)
+			ptt->chunk_id |= EXTRA_SHADOWS_FLAG;
+
+		ptt->obj_id &= ~EXTRA_OBJECT_TYPE_MASK;
+		ptt->obj_id |= (t->extra_obj_type << EXTRA_OBJECT_TYPE_SHIFT);
+
+		if (t->extra_obj_type == YAFFS_OBJECT_TYPE_HARDLINK)
+			ptt->n_bytes = t->extra_equiv_id;
+		else if (t->extra_obj_type == YAFFS_OBJECT_TYPE_FILE)
+			ptt->n_bytes = (unsigned) t->extra_file_size;
+		else
+			ptt->n_bytes = 0;
+	}
+
+	yaffs_dump_packed_tags2_tags_only(ptt);
+	yaffs_dump_tags2(t);
+}
+
+void yaffs_pack_tags2(struct yaffs_packed_tags2 *pt,
+		      const struct yaffs_ext_tags *t, int tags_ecc)
+{
+	yaffs_pack_tags2_tags_only(&pt->t, t);
+	//do for warring
+#if 0 //CONFIG_YAFFS_DOES_ECC
+	if (tags_ecc)
+		yaffs_ecc_calc_other((unsigned char *)&pt->t,
+				    sizeof(struct yaffs_packed_tags2_tags_only),
+				    &pt->ecc);
+#endif	
+}
+
+void yaffs_unpack_tags2_tags_only(struct yaffs_ext_tags *t,
+				  struct yaffs_packed_tags2_tags_only *ptt)
+{
+	memset(t, 0, sizeof(struct yaffs_ext_tags));
+
+	if (ptt->seq_number == 0xffffffff)
+		return;
+
+	t->block_bad = 0;
+	t->chunk_used = 1;
+	t->obj_id = ptt->obj_id;
+	t->chunk_id = ptt->chunk_id;
+	t->n_bytes = ptt->n_bytes;
+	t->is_deleted = 0;
+	t->serial_number = 0;
+	t->seq_number = ptt->seq_number;
+
+	/* Do extra header info stuff */
+	if (ptt->chunk_id & EXTRA_HEADER_INFO_FLAG) {
+		t->chunk_id = 0;
+		t->n_bytes = 0;
+
+		t->extra_available = 1;
+		t->extra_parent_id = ptt->chunk_id & (~(ALL_EXTRA_FLAGS));
+		t->extra_is_shrink = ptt->chunk_id & EXTRA_SHRINK_FLAG ? 1 : 0;
+		t->extra_shadows = ptt->chunk_id & EXTRA_SHADOWS_FLAG ? 1 : 0;
+		t->extra_obj_type = ptt->obj_id >> EXTRA_OBJECT_TYPE_SHIFT;
+		t->obj_id &= ~EXTRA_OBJECT_TYPE_MASK;
+
+		if (t->extra_obj_type == YAFFS_OBJECT_TYPE_HARDLINK)
+			t->extra_equiv_id = ptt->n_bytes;
+		else
+			t->extra_file_size = ptt->n_bytes;
+	}
+	yaffs_dump_packed_tags2_tags_only(ptt);
+	yaffs_dump_tags2(t);
+}
+
+void yaffs_unpack_tags2(struct yaffs_ext_tags *t, struct yaffs_packed_tags2 *pt,
+			int tags_ecc)
+{
+	enum yaffs_ecc_result ecc_result = YAFFS_ECC_RESULT_NO_ERROR;
+
+	if (pt->t.seq_number != 0xffffffff && tags_ecc) {
+		/* Chunk is in use and we need to do ECC */
+
+	//do for warring	
+#if 0 //CONFIG_YAFFS_DOES_ECC
+		struct yaffs_ecc_other ecc;
+		int result;
+		yaffs_ecc_calc_other((unsigned char *)&pt->t,
+				sizeof(struct yaffs_packed_tags2_tags_only),
+				&ecc);
+		result =
+		    yaffs_ecc_correct_other((unsigned char *)&pt->t,
+				sizeof(struct yaffs_packed_tags2_tags_only),
+				&pt->ecc, &ecc);
+		switch (result) {
+		case 0:
+			ecc_result = YAFFS_ECC_RESULT_NO_ERROR;
+			break;
+		case 1:
+			ecc_result = YAFFS_ECC_RESULT_FIXED;
+			break;
+		case -1:
+			ecc_result = YAFFS_ECC_RESULT_UNFIXED;
+			break;
+		default:
+			ecc_result = YAFFS_ECC_RESULT_UNKNOWN;
+		}
+#endif
+	}
+	yaffs_unpack_tags2_tags_only(t, &pt->t);
+
+	t->ecc_result = ecc_result;
+
+	yaffs_dump_packed_tags2(pt);
+	yaffs_dump_tags2(t);
+}
diff --git a/fs/yaffs2/yaffs_packedtags2.h b/fs/yaffs2/yaffs_packedtags2.h
new file mode 100755
index 0000000..675e719
--- /dev/null
+++ b/fs/yaffs2/yaffs_packedtags2.h
@@ -0,0 +1,47 @@
+/*
+ * YAFFS: Yet another Flash File System . A NAND-flash specific file system.
+ *
+ * Copyright (C) 2002-2011 Aleph One Ltd.
+ *   for Toby Churchill Ltd and Brightstar Engineering
+ *
+ * Created by Charles Manning <charles@aleph1.co.uk>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 2.1 as
+ * published by the Free Software Foundation.
+ *
+ * Note: Only YAFFS headers are LGPL, YAFFS C code is covered by GPL.
+ */
+
+/* This is used to pack YAFFS2 tags, not YAFFS1tags. */
+
+#ifndef __YAFFS_PACKEDTAGS2_H__
+#define __YAFFS_PACKEDTAGS2_H__
+
+#include "yaffs_guts.h"
+#include "yaffs_ecc.h"
+
+struct yaffs_packed_tags2_tags_only {
+	unsigned seq_number;
+	unsigned obj_id;
+	unsigned chunk_id;
+	unsigned n_bytes;
+};
+
+struct yaffs_packed_tags2 {
+	struct yaffs_packed_tags2_tags_only t;
+	struct yaffs_ecc_other ecc;
+};
+
+/* Full packed tags with ECC, used for oob tags */
+void yaffs_pack_tags2(struct yaffs_packed_tags2 *pt,
+		      const struct yaffs_ext_tags *t, int tags_ecc);
+void yaffs_unpack_tags2(struct yaffs_ext_tags *t, struct yaffs_packed_tags2 *pt,
+			int tags_ecc);
+
+/* Only the tags part (no ECC for use with inband tags */
+void yaffs_pack_tags2_tags_only(struct yaffs_packed_tags2_tags_only *pt,
+				const struct yaffs_ext_tags *t);
+void yaffs_unpack_tags2_tags_only(struct yaffs_ext_tags *t,
+				  struct yaffs_packed_tags2_tags_only *pt);
+#endif
diff --git a/fs/yaffs2/yaffs_summary.c b/fs/yaffs2/yaffs_summary.c
new file mode 100755
index 0000000..3c9e723
--- /dev/null
+++ b/fs/yaffs2/yaffs_summary.c
@@ -0,0 +1,312 @@
+/*
+ * YAFFS: Yet Another Flash File System. A NAND-flash specific file system.
+ *
+ * Copyright (C) 2002-2011 Aleph One Ltd.
+ *   for Toby Churchill Ltd and Brightstar Engineering
+ *
+ * Created by Charles Manning <charles@aleph1.co.uk>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+/* Summaries write the useful part of the tags for the chunks in a block into an
+ * an array which is written to the last n chunks of the block.
+ * Reading the summaries gives all the tags for the block in one read. Much
+ * faster.
+ *
+ * Chunks holding summaries are marked with tags making it look like
+ * they are part of a fake file.
+ *
+ * The summary could also be used during gc.
+ *
+ */
+
+#include "yaffs_summary.h"
+#include "yaffs_packedtags2.h"
+#include "yaffs_nand.h"
+#include "yaffs_getblockinfo.h"
+#include "yaffs_bitmap.h"
+
+/*
+ * The summary is built up in an array of summary tags.
+ * This gets written to the last one or two (maybe more) chunks in a block.
+ * A summary header is written as the first part of each chunk of summary data.
+ * The summary header must match or the summary is rejected.
+ */
+
+/* Summary tags don't need the sequence number because that is redundant. */
+struct yaffs_summary_tags {
+	unsigned obj_id;
+	unsigned chunk_id;
+	unsigned n_bytes;
+};
+
+/* Summary header */
+struct yaffs_summary_header {
+	unsigned version;	/* Must match current version */
+	unsigned block;		/* Must be this block */
+	unsigned seq;		/* Must be this sequence number */
+	unsigned sum;		/* Just add up all the bytes in the tags */
+};
+
+
+static void yaffs_summary_clear(struct yaffs_dev *dev)
+{
+	if (!dev->sum_tags)
+		return;
+	memset(dev->sum_tags, 0, dev->chunks_per_summary *
+		sizeof(struct yaffs_summary_tags));
+}
+
+
+void yaffs_summary_deinit(struct yaffs_dev *dev)
+{
+	kfree(dev->sum_tags);
+	dev->sum_tags = NULL;
+	kfree(dev->gc_sum_tags);
+	dev->gc_sum_tags = NULL;
+	dev->chunks_per_summary = 0;
+}
+
+int yaffs_summary_init(struct yaffs_dev *dev)
+{
+	int sum_bytes;
+	int chunks_used; /* Number of chunks used by summary */
+	int sum_tags_bytes;
+
+	sum_bytes = dev->param.chunks_per_block *
+			sizeof(struct yaffs_summary_tags);
+
+	chunks_used = (sum_bytes + dev->data_bytes_per_chunk - 1)/
+			(dev->data_bytes_per_chunk -
+				sizeof(struct yaffs_summary_header));
+
+	dev->chunks_per_summary = dev->param.chunks_per_block - chunks_used;
+	sum_tags_bytes = sizeof(struct yaffs_summary_tags) *
+				dev->chunks_per_summary;
+	dev->sum_tags = kmalloc(sum_tags_bytes, GFP_NOFS);
+	dev->gc_sum_tags = kmalloc(sum_tags_bytes, GFP_NOFS);
+	if (!dev->sum_tags || !dev->gc_sum_tags) {
+		yaffs_summary_deinit(dev);
+		return YAFFS_FAIL;
+	}
+
+	yaffs_summary_clear(dev);
+
+	return YAFFS_OK;
+}
+
+static unsigned yaffs_summary_sum(struct yaffs_dev *dev)
+{
+	u8 *sum_buffer = (u8 *)dev->sum_tags;
+	int i;
+	unsigned sum = 0;
+
+	i = sizeof(struct yaffs_summary_tags) *
+				dev->chunks_per_summary;
+	while (i > 0) {
+		sum += *sum_buffer;
+		sum_buffer++;
+		i--;
+	}
+
+	return sum;
+}
+
+static int yaffs_summary_write(struct yaffs_dev *dev, int blk)
+{
+	struct yaffs_ext_tags tags;
+	u8 *buffer;
+	u8 *sum_buffer = (u8 *)dev->sum_tags;
+	int n_bytes;
+	int chunk_in_nand;
+	int chunk_in_block;
+	int result;
+	int this_tx;
+	struct yaffs_summary_header hdr;
+	int sum_bytes_per_chunk = dev->data_bytes_per_chunk - sizeof(hdr);
+	struct yaffs_block_info *bi = yaffs_get_block_info(dev, blk);
+
+	buffer = yaffs_get_temp_buffer(dev);
+	n_bytes = sizeof(struct yaffs_summary_tags) *
+				dev->chunks_per_summary;
+	memset(&tags, 0, sizeof(struct yaffs_ext_tags));
+	tags.obj_id = YAFFS_OBJECTID_SUMMARY;
+	tags.chunk_id = 1;
+	chunk_in_block = dev->chunks_per_summary;
+	chunk_in_nand = dev->alloc_block * dev->param.chunks_per_block +
+						dev->chunks_per_summary;
+	hdr.version = YAFFS_SUMMARY_VERSION;
+	hdr.block = blk;
+	hdr.seq = bi->seq_number;
+	hdr.sum = yaffs_summary_sum(dev);
+
+	do {
+		this_tx = n_bytes;
+		if (this_tx > sum_bytes_per_chunk)
+			this_tx = sum_bytes_per_chunk;
+		memcpy(buffer, &hdr, sizeof(hdr));
+		memcpy(buffer + sizeof(hdr), sum_buffer, this_tx);
+		tags.n_bytes = this_tx + sizeof(hdr);
+		result = yaffs_wr_chunk_tags_nand(dev, chunk_in_nand,
+						buffer, &tags);
+
+		if (result != YAFFS_OK)
+			break;
+		yaffs_set_chunk_bit(dev, blk, chunk_in_block);
+		bi->pages_in_use++;
+		dev->n_free_chunks--;
+
+		n_bytes -= this_tx;
+		sum_buffer += this_tx;
+		chunk_in_nand++;
+		chunk_in_block++;
+		tags.chunk_id++;
+	} while (result == YAFFS_OK && n_bytes > 0);
+	yaffs_release_temp_buffer(dev, buffer);
+
+
+	if (result == YAFFS_OK)
+		bi->has_summary = 1;
+
+
+	return result;
+}
+
+int yaffs_summary_read(struct yaffs_dev *dev,
+			struct yaffs_summary_tags *st,
+			int blk)
+{
+	struct yaffs_ext_tags tags;
+	u8 *buffer;
+	u8 *sum_buffer = (u8 *)st;
+	int n_bytes;
+	int chunk_id;
+	int chunk_in_nand;
+	int chunk_in_block;
+	int result;
+	int this_tx;
+	struct yaffs_summary_header hdr;
+	struct yaffs_block_info *bi = yaffs_get_block_info(dev, blk);
+	int sum_bytes_per_chunk = dev->data_bytes_per_chunk - sizeof(hdr);
+	int sum_tags_bytes;
+
+	sum_tags_bytes = sizeof(struct yaffs_summary_tags) *
+				dev->chunks_per_summary;
+	buffer = yaffs_get_temp_buffer(dev);
+	n_bytes = sizeof(struct yaffs_summary_tags) * dev->chunks_per_summary;
+	chunk_in_block = dev->chunks_per_summary;
+	chunk_in_nand = blk * dev->param.chunks_per_block +
+							dev->chunks_per_summary;
+	chunk_id = 1;
+	do {
+		this_tx = n_bytes;
+		if (this_tx > sum_bytes_per_chunk)
+			this_tx = sum_bytes_per_chunk;
+		result = yaffs_rd_chunk_tags_nand(dev, chunk_in_nand,
+						buffer, &tags);
+
+		if (tags.chunk_id != chunk_id ||
+			tags.obj_id != YAFFS_OBJECTID_SUMMARY ||
+			tags.chunk_used == 0 ||
+			tags.ecc_result > YAFFS_ECC_RESULT_FIXED ||
+			tags.n_bytes != (this_tx + sizeof(hdr)))
+				result = YAFFS_FAIL;
+		if (result != YAFFS_OK)
+			break;
+
+		if (st == dev->sum_tags) {
+			/* If we're scanning then update the block info */
+			yaffs_set_chunk_bit(dev, blk, chunk_in_block);
+			bi->pages_in_use++;
+		}
+		memcpy(&hdr, buffer, sizeof(hdr));
+		memcpy(sum_buffer, buffer + sizeof(hdr), this_tx);
+		n_bytes -= this_tx;
+		sum_buffer += this_tx;
+		chunk_in_nand++;
+		chunk_in_block++;
+		chunk_id++;
+	} while (result == YAFFS_OK && n_bytes > 0);
+	yaffs_release_temp_buffer(dev, buffer);
+
+	if (result == YAFFS_OK) {
+		/* Verify header */
+		if (hdr.version != YAFFS_SUMMARY_VERSION ||
+		    hdr.seq != bi->seq_number ||
+		    hdr.sum != yaffs_summary_sum(dev))
+			result = YAFFS_FAIL;
+	}
+
+	if (st == dev->sum_tags && result == YAFFS_OK)
+		bi->has_summary = 1;
+
+	return result;
+}
+
+int yaffs_summary_add(struct yaffs_dev *dev,
+			struct yaffs_ext_tags *tags,
+			int chunk_in_nand)
+{
+	struct yaffs_packed_tags2_tags_only tags_only;
+	struct yaffs_summary_tags *sum_tags;
+	int block_in_nand = chunk_in_nand / dev->param.chunks_per_block;
+	int chunk_in_block = chunk_in_nand % dev->param.chunks_per_block;
+
+	if (!dev->sum_tags)
+		return YAFFS_OK;
+
+	if (chunk_in_block >= 0 && chunk_in_block < dev->chunks_per_summary) {
+		yaffs_pack_tags2_tags_only(&tags_only, tags);
+		sum_tags = &dev->sum_tags[chunk_in_block];
+		sum_tags->chunk_id = tags_only.chunk_id;
+		sum_tags->n_bytes = tags_only.n_bytes;
+		sum_tags->obj_id = tags_only.obj_id;
+
+		if (chunk_in_block == dev->chunks_per_summary - 1) {
+			/* Time to write out the summary */
+			yaffs_summary_write(dev, block_in_nand);
+			yaffs_summary_clear(dev);
+			yaffs_skip_rest_of_block(dev);
+		}
+	}
+	return YAFFS_OK;
+}
+
+int yaffs_summary_fetch(struct yaffs_dev *dev,
+			struct yaffs_ext_tags *tags,
+			int chunk_in_block)
+{
+	struct yaffs_packed_tags2_tags_only tags_only;
+	struct yaffs_summary_tags *sum_tags;
+	if (chunk_in_block >= 0 && chunk_in_block < dev->chunks_per_summary) {
+		sum_tags = &dev->sum_tags[chunk_in_block];
+		tags_only.chunk_id = sum_tags->chunk_id;
+		tags_only.n_bytes = sum_tags->n_bytes;
+		tags_only.obj_id = sum_tags->obj_id;
+		yaffs_unpack_tags2_tags_only(tags, &tags_only);
+		return YAFFS_OK;
+	}
+	return YAFFS_FAIL;
+}
+
+void yaffs_summary_gc(struct yaffs_dev *dev, int blk)
+{
+	struct yaffs_block_info *bi = yaffs_get_block_info(dev, blk);
+	int i;
+
+	if (!bi->has_summary)
+		return;
+
+	for (i = dev->chunks_per_summary;
+	     i < dev->param.chunks_per_block;
+	     i++) {
+		if (yaffs_check_chunk_bit(dev, blk, i)) {
+			yaffs_clear_chunk_bit(dev, blk, i);
+			bi->pages_in_use--;
+			dev->n_free_chunks++;
+		}
+	}
+}
diff --git a/fs/yaffs2/yaffs_summary.h b/fs/yaffs2/yaffs_summary.h
new file mode 100755
index 0000000..be141d0
--- /dev/null
+++ b/fs/yaffs2/yaffs_summary.h
@@ -0,0 +1,37 @@
+/*
+ * YAFFS: Yet another Flash File System . A NAND-flash specific file system.
+ *
+ * Copyright (C) 2002-2011 Aleph One Ltd.
+ *   for Toby Churchill Ltd and Brightstar Engineering
+ *
+ * Created by Charles Manning <charles@aleph1.co.uk>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 2.1 as
+ * published by the Free Software Foundation.
+ *
+ * Note: Only YAFFS headers are LGPL, YAFFS C code is covered by GPL.
+ */
+
+#ifndef __YAFFS_SUMMARY_H__
+#define __YAFFS_SUMMARY_H__
+
+#include "yaffs_packedtags2.h"
+
+
+int yaffs_summary_init(struct yaffs_dev *dev);
+void yaffs_summary_deinit(struct yaffs_dev *dev);
+
+int yaffs_summary_add(struct yaffs_dev *dev,
+			struct yaffs_ext_tags *tags,
+			int chunk_in_block);
+int yaffs_summary_fetch(struct yaffs_dev *dev,
+			struct yaffs_ext_tags *tags,
+			int chunk_in_block);
+int yaffs_summary_read(struct yaffs_dev *dev,
+			struct yaffs_summary_tags *st,
+			int blk);
+void yaffs_summary_gc(struct yaffs_dev *dev, int blk);
+
+
+#endif
diff --git a/fs/yaffs2/yaffs_tagscompat.c b/fs/yaffs2/yaffs_tagscompat.c
new file mode 100755
index 0000000..092430b
--- /dev/null
+++ b/fs/yaffs2/yaffs_tagscompat.c
@@ -0,0 +1,381 @@
+/*
+ * YAFFS: Yet Another Flash File System. A NAND-flash specific file system.
+ *
+ * Copyright (C) 2002-2011 Aleph One Ltd.
+ *   for Toby Churchill Ltd and Brightstar Engineering
+ *
+ * Created by Charles Manning <charles@aleph1.co.uk>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include "yaffs_guts.h"
+#include "yaffs_tagscompat.h"
+#include "yaffs_ecc.h"
+#include "yaffs_getblockinfo.h"
+#include "yaffs_trace.h"
+
+static void yaffs_handle_rd_data_error(struct yaffs_dev *dev, int nand_chunk);
+
+
+/********** Tags ECC calculations  *********/
+
+
+void yaffs_calc_tags_ecc(struct yaffs_tags *tags)
+{
+	/* Calculate an ecc */
+	unsigned char *b = ((union yaffs_tags_union *)tags)->as_bytes;
+	unsigned i, j;
+	unsigned ecc = 0;
+	unsigned bit = 0;
+
+	tags->ecc = 0;
+
+	for (i = 0; i < 8; i++) {
+		for (j = 1; j & 0xff; j <<= 1) {
+			bit++;
+			if (b[i] & j)
+				ecc ^= bit;
+		}
+	}
+	tags->ecc = ecc;
+}
+
+int yaffs_check_tags_ecc(struct yaffs_tags *tags)
+{
+	unsigned ecc = tags->ecc;
+
+	yaffs_calc_tags_ecc(tags);
+
+	ecc ^= tags->ecc;
+
+	if (ecc && ecc <= 64) {
+		/* TODO: Handle the failure better. Retire? */
+		unsigned char *b = ((union yaffs_tags_union *)tags)->as_bytes;
+
+		ecc--;
+
+		b[ecc / 8] ^= (1 << (ecc & 7));
+
+		/* Now recvalc the ecc */
+		yaffs_calc_tags_ecc(tags);
+
+		return 1;	/* recovered error */
+	} else if (ecc) {
+		/* Wierd ecc failure value */
+		/* TODO Need to do somethiong here */
+		return -1;	/* unrecovered error */
+	}
+	return 0;
+}
+
+/********** Tags **********/
+
+static void yaffs_load_tags_to_spare(struct yaffs_spare *spare_ptr,
+				     struct yaffs_tags *tags_ptr)
+{
+	union yaffs_tags_union *tu = (union yaffs_tags_union *)tags_ptr;
+
+	yaffs_calc_tags_ecc(tags_ptr);
+
+	spare_ptr->tb0 = tu->as_bytes[0];
+	spare_ptr->tb1 = tu->as_bytes[1];
+	spare_ptr->tb2 = tu->as_bytes[2];
+	spare_ptr->tb3 = tu->as_bytes[3];
+	spare_ptr->tb4 = tu->as_bytes[4];
+	spare_ptr->tb5 = tu->as_bytes[5];
+	spare_ptr->tb6 = tu->as_bytes[6];
+	spare_ptr->tb7 = tu->as_bytes[7];
+}
+
+static void yaffs_get_tags_from_spare(struct yaffs_dev *dev,
+				      struct yaffs_spare *spare_ptr,
+				      struct yaffs_tags *tags_ptr)
+{
+	union yaffs_tags_union *tu = (union yaffs_tags_union *)tags_ptr;
+	int result;
+
+	tu->as_bytes[0] = spare_ptr->tb0;
+	tu->as_bytes[1] = spare_ptr->tb1;
+	tu->as_bytes[2] = spare_ptr->tb2;
+	tu->as_bytes[3] = spare_ptr->tb3;
+	tu->as_bytes[4] = spare_ptr->tb4;
+	tu->as_bytes[5] = spare_ptr->tb5;
+	tu->as_bytes[6] = spare_ptr->tb6;
+	tu->as_bytes[7] = spare_ptr->tb7;
+
+	result = yaffs_check_tags_ecc(tags_ptr);
+	if (result > 0)
+		dev->n_tags_ecc_fixed++;
+	else if (result < 0)
+		dev->n_tags_ecc_unfixed++;
+}
+
+static void yaffs_spare_init(struct yaffs_spare *spare)
+{
+	memset(spare, 0xff, sizeof(struct yaffs_spare));
+}
+
+static int yaffs_wr_nand(struct yaffs_dev *dev,
+			 int nand_chunk, const u8 *data,
+			 struct yaffs_spare *spare)
+{
+	int data_size = dev->data_bytes_per_chunk;
+
+	return dev->drv.drv_write_chunk_fn(dev, nand_chunk,
+				data, data_size,
+				(u8 *) spare, sizeof(*spare));
+}
+
+static int yaffs_rd_chunk_nand(struct yaffs_dev *dev,
+			       int nand_chunk,
+			       u8 *data,
+			       struct yaffs_spare *spare,
+			       enum yaffs_ecc_result *ecc_result,
+			       int correct_errors)
+{
+	int ret_val;
+	struct yaffs_spare local_spare;
+	int data_size;
+	int spare_size;
+	int ecc_result1, ecc_result2;
+	u8 calc_ecc[3];
+
+	if (!spare) {
+		/* If we don't have a real spare, then we use a local one. */
+		/* Need this for the calculation of the ecc */
+		spare = &local_spare;
+	}
+	data_size = dev->data_bytes_per_chunk;
+	spare_size = sizeof(struct yaffs_spare);
+
+	if (dev->param.use_nand_ecc)
+		return dev->drv.drv_read_chunk_fn(dev, nand_chunk,
+						data, data_size,
+						(u8 *) spare, spare_size,
+						ecc_result);
+
+
+	/* Handle the ECC at this level. */
+
+	ret_val = dev->drv.drv_read_chunk_fn(dev, nand_chunk,
+						 data, data_size,
+						 (u8 *)spare, spare_size,
+						NULL);
+	if (!data || !correct_errors)
+		return ret_val;
+
+	/* Do ECC correction if needed. */
+	yaffs_ecc_calc(data, calc_ecc);
+	ecc_result1 = yaffs_ecc_correct(data, spare->ecc1, calc_ecc);
+	yaffs_ecc_calc(&data[256], calc_ecc);
+	ecc_result2 = yaffs_ecc_correct(&data[256], spare->ecc2, calc_ecc);
+
+	if (ecc_result1 > 0) {
+		yaffs_trace(YAFFS_TRACE_ERROR,
+			"**>>yaffs ecc error fix performed on chunk %d:0",
+			nand_chunk);
+		dev->n_ecc_fixed++;
+	} else if (ecc_result1 < 0) {
+		yaffs_trace(YAFFS_TRACE_ERROR,
+			"**>>yaffs ecc error unfixed on chunk %d:0",
+			nand_chunk);
+		dev->n_ecc_unfixed++;
+	}
+
+	if (ecc_result2 > 0) {
+		yaffs_trace(YAFFS_TRACE_ERROR,
+			"**>>yaffs ecc error fix performed on chunk %d:1",
+			nand_chunk);
+		dev->n_ecc_fixed++;
+	} else if (ecc_result2 < 0) {
+		yaffs_trace(YAFFS_TRACE_ERROR,
+			"**>>yaffs ecc error unfixed on chunk %d:1",
+			nand_chunk);
+		dev->n_ecc_unfixed++;
+	}
+
+	if (ecc_result1 || ecc_result2) {
+		/* We had a data problem on this page */
+		yaffs_handle_rd_data_error(dev, nand_chunk);
+	}
+
+	if (ecc_result1 < 0 || ecc_result2 < 0)
+		*ecc_result = YAFFS_ECC_RESULT_UNFIXED;
+	else if (ecc_result1 > 0 || ecc_result2 > 0)
+		*ecc_result = YAFFS_ECC_RESULT_FIXED;
+	else
+		*ecc_result = YAFFS_ECC_RESULT_NO_ERROR;
+
+	return ret_val;
+}
+
+/*
+ * Functions for robustisizing
+ */
+
+static void yaffs_handle_rd_data_error(struct yaffs_dev *dev, int nand_chunk)
+{
+	int flash_block = nand_chunk / dev->param.chunks_per_block;
+
+	/* Mark the block for retirement */
+	yaffs_get_block_info(dev, flash_block + dev->block_offset)->
+		needs_retiring = 1;
+	yaffs_trace(YAFFS_TRACE_ERROR | YAFFS_TRACE_BAD_BLOCKS,
+		"**>>Block %d marked for retirement",
+		flash_block);
+
+	/* TODO:
+	 * Just do a garbage collection on the affected block
+	 * then retire the block
+	 * NB recursion
+	 */
+}
+
+static int yaffs_tags_compat_wr(struct yaffs_dev *dev,
+			 int nand_chunk,
+			 const u8 *data, const struct yaffs_ext_tags *ext_tags)
+{
+	struct yaffs_spare spare;
+	struct yaffs_tags tags;
+
+	yaffs_spare_init(&spare);
+
+	if (ext_tags->is_deleted)
+		spare.page_status = 0;
+	else {
+		tags.obj_id = ext_tags->obj_id;
+		tags.chunk_id = ext_tags->chunk_id;
+
+		tags.n_bytes_lsb = ext_tags->n_bytes & (1024 - 1);
+
+		if (dev->data_bytes_per_chunk >= 1024)
+			tags.n_bytes_msb = (ext_tags->n_bytes >> 10) & 3;
+		else
+			tags.n_bytes_msb = 3;
+
+		tags.serial_number = ext_tags->serial_number;
+
+		if (!dev->param.use_nand_ecc && data) {
+			yaffs_ecc_calc(data, spare.ecc1);
+			yaffs_ecc_calc(&data[256], spare.ecc2);
+		}
+
+		yaffs_load_tags_to_spare(&spare, &tags);
+	}
+	return yaffs_wr_nand(dev, nand_chunk, data, &spare);
+}
+
+static int yaffs_tags_compat_rd(struct yaffs_dev *dev,
+			 int nand_chunk,
+			 u8 *data, struct yaffs_ext_tags *ext_tags)
+{
+	struct yaffs_spare spare;
+	struct yaffs_tags tags;
+	enum yaffs_ecc_result ecc_result = YAFFS_ECC_RESULT_UNKNOWN;
+	static struct yaffs_spare spare_ff;
+	static int init;
+	int deleted;
+
+	if (!init) {
+		memset(&spare_ff, 0xff, sizeof(spare_ff));
+		init = 1;
+	}
+
+	if (!yaffs_rd_chunk_nand(dev, nand_chunk,
+					data, &spare, &ecc_result, 1))
+		return YAFFS_FAIL;
+
+	/* ext_tags may be NULL */
+	if (!ext_tags)
+		return YAFFS_OK;
+
+	deleted = (hweight8(spare.page_status) < 7) ? 1 : 0;
+
+	ext_tags->is_deleted = deleted;
+	ext_tags->ecc_result = ecc_result;
+	ext_tags->block_bad = 0;	/* We're reading it */
+	/* therefore it is not a bad block */
+	ext_tags->chunk_used =
+		memcmp(&spare_ff, &spare, sizeof(spare_ff)) ? 1 : 0;
+
+	if (ext_tags->chunk_used) {
+		yaffs_get_tags_from_spare(dev, &spare, &tags);
+		ext_tags->obj_id = tags.obj_id;
+		ext_tags->chunk_id = tags.chunk_id;
+		ext_tags->n_bytes = tags.n_bytes_lsb;
+
+		if (dev->data_bytes_per_chunk >= 1024)
+			ext_tags->n_bytes |=
+				(((unsigned)tags.n_bytes_msb) << 10);
+
+		ext_tags->serial_number = tags.serial_number;
+	}
+
+	return YAFFS_OK;
+}
+
+static int yaffs_tags_compat_mark_bad(struct yaffs_dev *dev, int flash_block)
+{
+	struct yaffs_spare spare;
+
+	memset(&spare, 0xff, sizeof(struct yaffs_spare));
+
+	spare.block_status = 'Y';
+
+	yaffs_wr_nand(dev, flash_block * dev->param.chunks_per_block, NULL,
+		      &spare);
+	yaffs_wr_nand(dev, flash_block * dev->param.chunks_per_block + 1,
+		      NULL, &spare);
+
+	return YAFFS_OK;
+}
+
+static int yaffs_tags_compat_query_block(struct yaffs_dev *dev,
+				  int block_no,
+				  enum yaffs_block_state *state,
+				  u32 *seq_number)
+{
+	struct yaffs_spare spare0, spare1;
+	static struct yaffs_spare spare_ff;
+	static int init;
+	enum yaffs_ecc_result dummy;
+
+	if (!init) {
+		memset(&spare_ff, 0xff, sizeof(spare_ff));
+		init = 1;
+	}
+
+	*seq_number = 0;
+
+	/* Look for bad block markers in the first two chunks */
+	yaffs_rd_chunk_nand(dev, block_no * dev->param.chunks_per_block,
+			    NULL, &spare0, &dummy, 0);
+	yaffs_rd_chunk_nand(dev, block_no * dev->param.chunks_per_block + 1,
+			    NULL, &spare1, &dummy, 0);
+
+	if (hweight8(spare0.block_status & spare1.block_status) < 7)
+		*state = YAFFS_BLOCK_STATE_DEAD;
+	else if (memcmp(&spare_ff, &spare0, sizeof(spare_ff)) == 0)
+		*state = YAFFS_BLOCK_STATE_EMPTY;
+	else
+		*state = YAFFS_BLOCK_STATE_NEEDS_SCAN;
+
+	return YAFFS_OK;
+}
+
+void yaffs_tags_compat_install(struct yaffs_dev *dev)
+{
+	if(dev->param.is_yaffs2)
+		return;
+	if(!dev->tagger.write_chunk_tags_fn)
+		dev->tagger.write_chunk_tags_fn = yaffs_tags_compat_wr;
+	if(!dev->tagger.read_chunk_tags_fn)
+		dev->tagger.read_chunk_tags_fn = yaffs_tags_compat_rd;
+	if(!dev->tagger.query_block_fn)
+		dev->tagger.query_block_fn = yaffs_tags_compat_query_block;
+	if(!dev->tagger.mark_bad_fn)
+		dev->tagger.mark_bad_fn = yaffs_tags_compat_mark_bad;
+}
diff --git a/fs/yaffs2/yaffs_tagscompat.h b/fs/yaffs2/yaffs_tagscompat.h
new file mode 100755
index 0000000..92d298a
--- /dev/null
+++ b/fs/yaffs2/yaffs_tagscompat.h
@@ -0,0 +1,44 @@
+/*
+ * YAFFS: Yet another Flash File System . A NAND-flash specific file system.
+ *
+ * Copyright (C) 2002-2011 Aleph One Ltd.
+ *   for Toby Churchill Ltd and Brightstar Engineering
+ *
+ * Created by Charles Manning <charles@aleph1.co.uk>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 2.1 as
+ * published by the Free Software Foundation.
+ *
+ * Note: Only YAFFS headers are LGPL, YAFFS C code is covered by GPL.
+ */
+
+#ifndef __YAFFS_TAGSCOMPAT_H__
+#define __YAFFS_TAGSCOMPAT_H__
+
+
+#include "yaffs_guts.h"
+
+#if 0
+
+
+int yaffs_tags_compat_wr(struct yaffs_dev *dev,
+			 int nand_chunk,
+			 const u8 *data, const struct yaffs_ext_tags *tags);
+int yaffs_tags_compat_rd(struct yaffs_dev *dev,
+			 int nand_chunk,
+			 u8 *data, struct yaffs_ext_tags *tags);
+int yaffs_tags_compat_mark_bad(struct yaffs_dev *dev, int block_no);
+int yaffs_tags_compat_query_block(struct yaffs_dev *dev,
+				  int block_no,
+				  enum yaffs_block_state *state,
+				  u32 *seq_number);
+
+#endif
+
+
+void yaffs_tags_compat_install(struct yaffs_dev *dev);
+void yaffs_calc_tags_ecc(struct yaffs_tags *tags);
+int yaffs_check_tags_ecc(struct yaffs_tags *tags);
+
+#endif
diff --git a/fs/yaffs2/yaffs_tagsmarshall.c b/fs/yaffs2/yaffs_tagsmarshall.c
new file mode 100755
index 0000000..44a83b1
--- /dev/null
+++ b/fs/yaffs2/yaffs_tagsmarshall.c
@@ -0,0 +1,199 @@
+/*
+ * YAFFS: Yet Another Flash File System. A NAND-flash specific file system.
+ *
+ * Copyright (C) 2002-2011 Aleph One Ltd.
+ *   for Toby Churchill Ltd and Brightstar Engineering
+ *
+ * Created by Charles Manning <charles@aleph1.co.uk>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include "yaffs_guts.h"
+#include "yaffs_trace.h"
+#include "yaffs_packedtags2.h"
+
+static int yaffs_tags_marshall_write(struct yaffs_dev *dev,
+				    int nand_chunk, const u8 *data,
+				    const struct yaffs_ext_tags *tags)
+{
+	struct yaffs_packed_tags2 pt;
+	int retval;
+
+	int packed_tags_size =
+	    dev->param.no_tags_ecc ? sizeof(pt.t) : sizeof(pt);
+	void *packed_tags_ptr =
+	    dev->param.no_tags_ecc ? (void *)&pt.t : (void *)&pt;
+
+	yaffs_trace(YAFFS_TRACE_MTD,
+		"yaffs_tags_marshall_write chunk %d data %p tags %p",
+		nand_chunk, data, tags);
+
+	/* For yaffs2 writing there must be both data and tags.
+	 * If we're using inband tags, then the tags are stuffed into
+	 * the end of the data buffer.
+	 */
+	if (!data || !tags)
+		BUG();
+	else if (dev->param.inband_tags) {
+		struct yaffs_packed_tags2_tags_only *pt2tp;
+		pt2tp =
+		    (struct yaffs_packed_tags2_tags_only *)(data +
+							dev->
+							data_bytes_per_chunk);
+		yaffs_pack_tags2_tags_only(pt2tp, tags);
+	} else {
+		yaffs_pack_tags2(&pt, tags, !dev->param.no_tags_ecc);
+	}
+
+	retval = dev->drv.drv_write_chunk_fn(dev, nand_chunk,
+			data, dev->param.total_bytes_per_chunk,
+			(dev->param.inband_tags) ? NULL : packed_tags_ptr,
+			(dev->param.inband_tags) ? 0 : packed_tags_size);
+
+	return retval;
+}
+
+static int yaffs_tags_marshall_read(struct yaffs_dev *dev,
+				   int nand_chunk, u8 *data,
+				   struct yaffs_ext_tags *tags)
+{
+	int retval = 0;
+	int local_data = 0;
+	u8 spare_buffer[100];
+	enum yaffs_ecc_result ecc_result;
+
+	struct yaffs_packed_tags2 pt;
+
+	int packed_tags_size =
+	    dev->param.no_tags_ecc ? sizeof(pt.t) : sizeof(pt);
+	void *packed_tags_ptr =
+	    dev->param.no_tags_ecc ? (void *)&pt.t : (void *)&pt;
+
+	yaffs_trace(YAFFS_TRACE_MTD,
+		"yaffs_tags_marshall_read chunk %d data %p tags %p",
+		nand_chunk, data, tags);
+
+	if (dev->param.inband_tags) {
+		if (!data) {
+			local_data = 1;
+			data = yaffs_get_temp_buffer(dev);
+		}
+	}
+
+	if (dev->param.inband_tags || (data && !tags))
+		retval = dev->drv.drv_read_chunk_fn(dev, nand_chunk,
+					data, dev->param.total_bytes_per_chunk,
+					NULL, 0,
+					&ecc_result);
+	else if (tags)
+		retval = dev->drv.drv_read_chunk_fn(dev, nand_chunk,
+					data, dev->param.total_bytes_per_chunk,
+					spare_buffer, packed_tags_size,
+					&ecc_result);
+	else
+		BUG();
+
+
+	if (dev->param.inband_tags) {
+		if (tags) {
+			struct yaffs_packed_tags2_tags_only *pt2tp;
+			pt2tp =
+				(struct yaffs_packed_tags2_tags_only *)
+				&data[dev->data_bytes_per_chunk];
+			yaffs_unpack_tags2_tags_only(tags, pt2tp);
+		}
+	} else if (tags) {
+		memcpy(packed_tags_ptr, spare_buffer, packed_tags_size);
+		yaffs_unpack_tags2(tags, &pt, !dev->param.no_tags_ecc);
+	}
+
+	if (local_data)
+		yaffs_release_temp_buffer(dev, data);
+
+	if (tags && ecc_result == YAFFS_ECC_RESULT_UNFIXED) {
+		tags->ecc_result = YAFFS_ECC_RESULT_UNFIXED;
+		dev->n_ecc_unfixed++;
+	}
+
+	if (tags && ecc_result == -YAFFS_ECC_RESULT_FIXED) {
+		if (tags->ecc_result <= YAFFS_ECC_RESULT_NO_ERROR)
+			tags->ecc_result = YAFFS_ECC_RESULT_FIXED;
+		dev->n_ecc_fixed++;
+	}
+
+	if (ecc_result < YAFFS_ECC_RESULT_UNFIXED)
+		return YAFFS_OK;
+	else
+		return YAFFS_FAIL;
+}
+
+static int yaffs_tags_marshall_query_block(struct yaffs_dev *dev, int block_no,
+			       enum yaffs_block_state *state,
+			       u32 *seq_number)
+{
+	int retval;
+
+	yaffs_trace(YAFFS_TRACE_MTD, "yaffs_tags_marshall_query_block %d",
+			block_no);
+
+	retval = dev->drv.drv_check_bad_fn(dev, block_no);
+
+	if (retval== YAFFS_FAIL) {
+		yaffs_trace(YAFFS_TRACE_MTD, "block is bad");
+
+		*state = YAFFS_BLOCK_STATE_DEAD;
+		*seq_number = 0;
+	} else {
+		struct yaffs_ext_tags t;
+
+		yaffs_tags_marshall_read(dev,
+				    block_no * dev->param.chunks_per_block,
+				    NULL, &t);
+
+		if (t.chunk_used) {
+			*seq_number = t.seq_number;
+			*state = YAFFS_BLOCK_STATE_NEEDS_SCAN;
+		} else {
+			*seq_number = 0;
+			*state = YAFFS_BLOCK_STATE_EMPTY;
+		}
+	}
+
+	yaffs_trace(YAFFS_TRACE_MTD,
+		"block query returns  seq %d state %d",
+		*seq_number, *state);
+
+	if (retval == 0)
+		return YAFFS_OK;
+	else
+		return YAFFS_FAIL;
+}
+
+static int yaffs_tags_marshall_mark_bad(struct yaffs_dev *dev, int block_no)
+{
+	return dev->drv.drv_mark_bad_fn(dev, block_no);
+
+}
+
+
+void yaffs_tags_marshall_install(struct yaffs_dev *dev)
+{
+	if (!dev->param.is_yaffs2)
+		return;
+
+	if (!dev->tagger.write_chunk_tags_fn)
+		dev->tagger.write_chunk_tags_fn = yaffs_tags_marshall_write;
+
+	if (!dev->tagger.read_chunk_tags_fn)
+		dev->tagger.read_chunk_tags_fn = yaffs_tags_marshall_read;
+
+	if (!dev->tagger.query_block_fn)
+		dev->tagger.query_block_fn = yaffs_tags_marshall_query_block;
+
+	if (!dev->tagger.mark_bad_fn)
+		dev->tagger.mark_bad_fn = yaffs_tags_marshall_mark_bad;
+
+}
diff --git a/fs/yaffs2/yaffs_tagsmarshall.h b/fs/yaffs2/yaffs_tagsmarshall.h
new file mode 100755
index 0000000..bf3e68a
--- /dev/null
+++ b/fs/yaffs2/yaffs_tagsmarshall.h
@@ -0,0 +1,22 @@
+/*
+ * YAFFS: Yet another Flash File System . A NAND-flash specific file system.
+ *
+ * Copyright (C) 2002-2011 Aleph One Ltd.
+ *   for Toby Churchill Ltd and Brightstar Engineering
+ *
+ * Created by Charles Manning <charles@aleph1.co.uk>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 2.1 as
+ * published by the Free Software Foundation.
+ *
+ * Note: Only YAFFS headers are LGPL, YAFFS C code is covered by GPL.
+ */
+
+#ifndef __YAFFS_TAGSMARSHALL_H__
+#define __YAFFS_TAGSMARSHALL_H__
+
+#include "yaffs_guts.h"
+void yaffs_tags_marshall_install(struct yaffs_dev *dev);
+
+#endif
diff --git a/fs/yaffs2/yaffs_trace.h b/fs/yaffs2/yaffs_trace.h
new file mode 100755
index 0000000..fd26054
--- /dev/null
+++ b/fs/yaffs2/yaffs_trace.h
@@ -0,0 +1,57 @@
+/*
+ * YAFFS: Yet another Flash File System . A NAND-flash specific file system.
+ *
+ * Copyright (C) 2002-2011 Aleph One Ltd.
+ *   for Toby Churchill Ltd and Brightstar Engineering
+ *
+ * Created by Charles Manning <charles@aleph1.co.uk>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 2.1 as
+ * published by the Free Software Foundation.
+ *
+ * Note: Only YAFFS headers are LGPL, YAFFS C code is covered by GPL.
+ */
+
+#ifndef __YTRACE_H__
+#define __YTRACE_H__
+
+extern unsigned int yaffs_trace_mask;
+extern unsigned int yaffs_wr_attempts;
+
+/*
+ * Tracing flags.
+ * The flags masked in YAFFS_TRACE_ALWAYS are always traced.
+ */
+
+#define YAFFS_TRACE_OS			0x00000002
+#define YAFFS_TRACE_ALLOCATE		0x00000004
+#define YAFFS_TRACE_SCAN		0x00000008
+#define YAFFS_TRACE_BAD_BLOCKS		0x00000010
+#define YAFFS_TRACE_ERASE		0x00000020
+#define YAFFS_TRACE_GC			0x00000040
+#define YAFFS_TRACE_WRITE		0x00000080
+#define YAFFS_TRACE_TRACING		0x00000100
+#define YAFFS_TRACE_DELETION		0x00000200
+#define YAFFS_TRACE_BUFFERS		0x00000400
+#define YAFFS_TRACE_NANDACCESS		0x00000800
+#define YAFFS_TRACE_GC_DETAIL		0x00001000
+#define YAFFS_TRACE_SCAN_DEBUG		0x00002000
+#define YAFFS_TRACE_MTD			0x00004000
+#define YAFFS_TRACE_CHECKPOINT		0x00008000
+
+#define YAFFS_TRACE_VERIFY		0x00010000
+#define YAFFS_TRACE_VERIFY_NAND		0x00020000
+#define YAFFS_TRACE_VERIFY_FULL		0x00040000
+#define YAFFS_TRACE_VERIFY_ALL		0x000f0000
+
+#define YAFFS_TRACE_SYNC		0x00100000
+#define YAFFS_TRACE_BACKGROUND		0x00200000
+#define YAFFS_TRACE_LOCK		0x00400000
+#define YAFFS_TRACE_MOUNT		0x00800000
+
+#define YAFFS_TRACE_ERROR		0x40000000
+#define YAFFS_TRACE_BUG			0x80000000
+#define YAFFS_TRACE_ALWAYS		0xf0000000
+
+#endif
diff --git a/fs/yaffs2/yaffs_verify.c b/fs/yaffs2/yaffs_verify.c
new file mode 100755
index 0000000..e8f2f0a
--- /dev/null
+++ b/fs/yaffs2/yaffs_verify.c
@@ -0,0 +1,529 @@
+/*
+ * YAFFS: Yet Another Flash File System. A NAND-flash specific file system.
+ *
+ * Copyright (C) 2002-2011 Aleph One Ltd.
+ *   for Toby Churchill Ltd and Brightstar Engineering
+ *
+ * Created by Charles Manning <charles@aleph1.co.uk>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include "yaffs_verify.h"
+#include "yaffs_trace.h"
+#include "yaffs_bitmap.h"
+#include "yaffs_getblockinfo.h"
+#include "yaffs_nand.h"
+
+int yaffs_skip_verification(struct yaffs_dev *dev)
+{
+	(void) dev;
+	return !(yaffs_trace_mask &
+		 (YAFFS_TRACE_VERIFY | YAFFS_TRACE_VERIFY_FULL));
+}
+
+static int yaffs_skip_full_verification(struct yaffs_dev *dev)
+{
+	(void) dev;
+	return !(yaffs_trace_mask & (YAFFS_TRACE_VERIFY_FULL));
+}
+
+static int yaffs_skip_nand_verification(struct yaffs_dev *dev)
+{
+	(void) dev;
+	return !(yaffs_trace_mask & (YAFFS_TRACE_VERIFY_NAND));
+}
+
+static const char * const block_state_name[] = {
+	"Unknown",
+	"Needs scan",
+	"Scanning",
+	"Empty",
+	"Allocating",
+	"Full",
+	"Dirty",
+	"Checkpoint",
+	"Collecting",
+	"Dead"
+};
+
+void yaffs_verify_blk(struct yaffs_dev *dev, struct yaffs_block_info *bi, int n)
+{
+	int actually_used;
+	int in_use;
+
+	if (yaffs_skip_verification(dev))
+		return;
+
+	/* Report illegal runtime states */
+	if (bi->block_state >= YAFFS_NUMBER_OF_BLOCK_STATES)
+		yaffs_trace(YAFFS_TRACE_VERIFY,
+			"Block %d has undefined state %d",
+			n, bi->block_state);
+
+	switch (bi->block_state) {
+	case YAFFS_BLOCK_STATE_UNKNOWN:
+	case YAFFS_BLOCK_STATE_SCANNING:
+	case YAFFS_BLOCK_STATE_NEEDS_SCAN:
+		yaffs_trace(YAFFS_TRACE_VERIFY,
+			"Block %d has bad run-state %s",
+			n, block_state_name[bi->block_state]);
+	}
+
+	/* Check pages in use and soft deletions are legal */
+
+	actually_used = bi->pages_in_use - bi->soft_del_pages;
+
+	if (bi->pages_in_use < 0 ||
+	    bi->pages_in_use > dev->param.chunks_per_block ||
+	    bi->soft_del_pages < 0 ||
+	    bi->soft_del_pages > dev->param.chunks_per_block ||
+	    actually_used < 0 || actually_used > dev->param.chunks_per_block)
+		yaffs_trace(YAFFS_TRACE_VERIFY,
+			"Block %d has illegal values pages_in_used %d soft_del_pages %d",
+			n, bi->pages_in_use, bi->soft_del_pages);
+
+	/* Check chunk bitmap legal */
+	in_use = yaffs_count_chunk_bits(dev, n);
+	if (in_use != bi->pages_in_use)
+		yaffs_trace(YAFFS_TRACE_VERIFY,
+			"Block %d has inconsistent values pages_in_use %d counted chunk bits %d",
+			n, bi->pages_in_use, in_use);
+}
+
+void yaffs_verify_collected_blk(struct yaffs_dev *dev,
+				struct yaffs_block_info *bi, int n)
+{
+	yaffs_verify_blk(dev, bi, n);
+
+	/* After collection the block should be in the erased state */
+
+	if (bi->block_state != YAFFS_BLOCK_STATE_COLLECTING &&
+	    bi->block_state != YAFFS_BLOCK_STATE_EMPTY) {
+		yaffs_trace(YAFFS_TRACE_ERROR,
+			"Block %d is in state %d after gc, should be erased",
+			n, bi->block_state);
+	}
+}
+
+void yaffs_verify_blocks(struct yaffs_dev *dev)
+{
+	int i;
+	int state_count[YAFFS_NUMBER_OF_BLOCK_STATES];
+	int illegal_states = 0;
+
+	if (yaffs_skip_verification(dev))
+		return;
+
+	memset(state_count, 0, sizeof(state_count));
+
+	for (i = dev->internal_start_block; i <= dev->internal_end_block; i++) {
+		struct yaffs_block_info *bi = yaffs_get_block_info(dev, i);
+		yaffs_verify_blk(dev, bi, i);
+
+		if (bi->block_state < YAFFS_NUMBER_OF_BLOCK_STATES)
+			state_count[bi->block_state]++;
+		else
+			illegal_states++;
+	}
+
+	yaffs_trace(YAFFS_TRACE_VERIFY,	"Block summary");
+
+	yaffs_trace(YAFFS_TRACE_VERIFY,
+		"%d blocks have illegal states",
+		illegal_states);
+	if (state_count[YAFFS_BLOCK_STATE_ALLOCATING] > 1)
+		yaffs_trace(YAFFS_TRACE_VERIFY,
+			"Too many allocating blocks");
+
+	for (i = 0; i < YAFFS_NUMBER_OF_BLOCK_STATES; i++)
+		yaffs_trace(YAFFS_TRACE_VERIFY,
+			"%s %d blocks",
+			block_state_name[i], state_count[i]);
+
+	if (dev->blocks_in_checkpt != state_count[YAFFS_BLOCK_STATE_CHECKPOINT])
+		yaffs_trace(YAFFS_TRACE_VERIFY,
+			"Checkpoint block count wrong dev %d count %d",
+			dev->blocks_in_checkpt,
+			state_count[YAFFS_BLOCK_STATE_CHECKPOINT]);
+
+	if (dev->n_erased_blocks != state_count[YAFFS_BLOCK_STATE_EMPTY])
+		yaffs_trace(YAFFS_TRACE_VERIFY,
+			"Erased block count wrong dev %d count %d",
+			dev->n_erased_blocks,
+			state_count[YAFFS_BLOCK_STATE_EMPTY]);
+
+	if (state_count[YAFFS_BLOCK_STATE_COLLECTING] > 1)
+		yaffs_trace(YAFFS_TRACE_VERIFY,
+			"Too many collecting blocks %d (max is 1)",
+			state_count[YAFFS_BLOCK_STATE_COLLECTING]);
+}
+
+/*
+ * Verify the object header. oh must be valid, but obj and tags may be NULL in
+ * which case those tests will not be performed.
+ */
+void yaffs_verify_oh(struct yaffs_obj *obj, struct yaffs_obj_hdr *oh,
+		     struct yaffs_ext_tags *tags, int parent_check)
+{
+	if (obj && yaffs_skip_verification(obj->my_dev))
+		return;
+
+	if (!(tags && obj && oh)) {
+		yaffs_trace(YAFFS_TRACE_VERIFY,
+			"Verifying object header tags %p obj %p oh %p",
+			tags, obj, oh);
+		return;
+	}
+
+	if (oh->type <= YAFFS_OBJECT_TYPE_UNKNOWN ||
+	    oh->type > YAFFS_OBJECT_TYPE_MAX)
+		yaffs_trace(YAFFS_TRACE_VERIFY,
+			"Obj %d header type is illegal value 0x%x",
+			tags->obj_id, oh->type);
+
+	if (tags->obj_id != obj->obj_id)
+		yaffs_trace(YAFFS_TRACE_VERIFY,
+			"Obj %d header mismatch obj_id %d",
+			tags->obj_id, obj->obj_id);
+
+	/*
+	 * Check that the object's parent ids match if parent_check requested.
+	 *
+	 * Tests do not apply to the root object.
+	 */
+
+	if (parent_check && tags->obj_id > 1 && !obj->parent)
+		yaffs_trace(YAFFS_TRACE_VERIFY,
+			"Obj %d header mismatch parent_id %d obj->parent is NULL",
+			tags->obj_id, oh->parent_obj_id);
+
+	if (parent_check && obj->parent &&
+	    oh->parent_obj_id != obj->parent->obj_id &&
+	    (oh->parent_obj_id != YAFFS_OBJECTID_UNLINKED ||
+	     obj->parent->obj_id != YAFFS_OBJECTID_DELETED))
+		yaffs_trace(YAFFS_TRACE_VERIFY,
+			"Obj %d header mismatch parent_id %d parent_obj_id %d",
+			tags->obj_id, oh->parent_obj_id,
+			obj->parent->obj_id);
+
+	if (tags->obj_id > 1 && oh->name[0] == 0)	/* Null name */
+		yaffs_trace(YAFFS_TRACE_VERIFY,
+			"Obj %d header name is NULL",
+			obj->obj_id);
+
+	if (tags->obj_id > 1 && ((u8) (oh->name[0])) == 0xff)	/* Junk name */
+		yaffs_trace(YAFFS_TRACE_VERIFY,
+			"Obj %d header name is 0xff",
+			obj->obj_id);
+}
+
+void yaffs_verify_file(struct yaffs_obj *obj)
+{
+	u32 x;
+	int required_depth;
+	int actual_depth;
+	int last_chunk;
+	u32 offset_in_chunk;
+	u32 the_chunk;
+
+	u32 i;
+	struct yaffs_dev *dev;
+	struct yaffs_ext_tags tags;
+	struct yaffs_tnode *tn;
+	u32 obj_id;
+
+	if (!obj)
+		return;
+
+	if (yaffs_skip_verification(obj->my_dev))
+		return;
+
+	dev = obj->my_dev;
+	obj_id = obj->obj_id;
+
+
+	/* Check file size is consistent with tnode depth */
+	yaffs_addr_to_chunk(dev, obj->variant.file_variant.file_size,
+				&last_chunk, &offset_in_chunk);
+	last_chunk++;
+	x = last_chunk >> YAFFS_TNODES_LEVEL0_BITS;
+	required_depth = 0;
+	while (x > 0) {
+		x >>= YAFFS_TNODES_INTERNAL_BITS;
+		required_depth++;
+	}
+
+	actual_depth = obj->variant.file_variant.top_level;
+
+	/* Check that the chunks in the tnode tree are all correct.
+	 * We do this by scanning through the tnode tree and
+	 * checking the tags for every chunk match.
+	 */
+
+	if (yaffs_skip_nand_verification(dev))
+		return;
+
+	for (i = 1; i <= last_chunk; i++) {
+		tn = yaffs_find_tnode_0(dev, &obj->variant.file_variant, i);
+
+		if (!tn)
+			continue;
+
+		the_chunk = yaffs_get_group_base(dev, tn, i);
+		if (the_chunk > 0) {
+			yaffs_rd_chunk_tags_nand(dev, the_chunk, NULL,
+						 &tags);
+			if (tags.obj_id != obj_id || tags.chunk_id != i)
+				yaffs_trace(YAFFS_TRACE_VERIFY,
+					"Object %d chunk_id %d NAND mismatch chunk %d tags (%d:%d)",
+					obj_id, i, the_chunk,
+					tags.obj_id, tags.chunk_id);
+		}
+	}
+}
+
+void yaffs_verify_link(struct yaffs_obj *obj)
+{
+	if (obj && yaffs_skip_verification(obj->my_dev))
+		return;
+
+	/* Verify sane equivalent object */
+}
+
+void yaffs_verify_symlink(struct yaffs_obj *obj)
+{
+	if (obj && yaffs_skip_verification(obj->my_dev))
+		return;
+
+	/* Verify symlink string */
+}
+
+void yaffs_verify_special(struct yaffs_obj *obj)
+{
+	if (obj && yaffs_skip_verification(obj->my_dev))
+		return;
+}
+
+void yaffs_verify_obj(struct yaffs_obj *obj)
+{
+	struct yaffs_dev *dev;
+	u32 chunk_min;
+	u32 chunk_max;
+	u32 chunk_id_ok;
+	u32 chunk_in_range;
+	u32 chunk_wrongly_deleted;
+	u32 chunk_valid;
+
+	if (!obj)
+		return;
+
+	if (obj->being_created)
+		return;
+
+	dev = obj->my_dev;
+
+	if (yaffs_skip_verification(dev))
+		return;
+
+	/* Check sane object header chunk */
+
+	chunk_min = dev->internal_start_block * dev->param.chunks_per_block;
+	chunk_max =
+	    (dev->internal_end_block + 1) * dev->param.chunks_per_block - 1;
+
+	chunk_in_range = (((unsigned)(obj->hdr_chunk)) >= chunk_min &&
+			  ((unsigned)(obj->hdr_chunk)) <= chunk_max);
+	chunk_id_ok = chunk_in_range || (obj->hdr_chunk == 0);
+	chunk_valid = chunk_in_range &&
+	    yaffs_check_chunk_bit(dev,
+				  obj->hdr_chunk / dev->param.chunks_per_block,
+				  obj->hdr_chunk % dev->param.chunks_per_block);
+	chunk_wrongly_deleted = chunk_in_range && !chunk_valid;
+
+	if (!obj->fake && (!chunk_id_ok || chunk_wrongly_deleted))
+		yaffs_trace(YAFFS_TRACE_VERIFY,
+			"Obj %d has chunk_id %d %s %s",
+			obj->obj_id, obj->hdr_chunk,
+			chunk_id_ok ? "" : ",out of range",
+			chunk_wrongly_deleted ? ",marked as deleted" : "");
+
+	if (chunk_valid && !yaffs_skip_nand_verification(dev)) {
+		struct yaffs_ext_tags tags;
+		struct yaffs_obj_hdr *oh;
+		u8 *buffer = yaffs_get_temp_buffer(dev);
+
+		oh = (struct yaffs_obj_hdr *)buffer;
+
+		yaffs_rd_chunk_tags_nand(dev, obj->hdr_chunk, buffer, &tags);
+
+		yaffs_verify_oh(obj, oh, &tags, 1);
+
+		yaffs_release_temp_buffer(dev, buffer);
+	}
+
+	/* Verify it has a parent */
+	if (obj && !obj->fake && (!obj->parent || obj->parent->my_dev != dev)) {
+		yaffs_trace(YAFFS_TRACE_VERIFY,
+			"Obj %d has parent pointer %p which does not look like an object",
+			obj->obj_id, obj->parent);
+	}
+
+	/* Verify parent is a directory */
+	if (obj->parent &&
+	    obj->parent->variant_type != YAFFS_OBJECT_TYPE_DIRECTORY) {
+		yaffs_trace(YAFFS_TRACE_VERIFY,
+			"Obj %d's parent is not a directory (type %d)",
+			obj->obj_id, obj->parent->variant_type);
+	}
+
+	switch (obj->variant_type) {
+	case YAFFS_OBJECT_TYPE_FILE:
+		yaffs_verify_file(obj);
+		break;
+	case YAFFS_OBJECT_TYPE_SYMLINK:
+		yaffs_verify_symlink(obj);
+		break;
+	case YAFFS_OBJECT_TYPE_DIRECTORY:
+		yaffs_verify_dir(obj);
+		break;
+	case YAFFS_OBJECT_TYPE_HARDLINK:
+		yaffs_verify_link(obj);
+		break;
+	case YAFFS_OBJECT_TYPE_SPECIAL:
+		yaffs_verify_special(obj);
+		break;
+	case YAFFS_OBJECT_TYPE_UNKNOWN:
+	default:
+		yaffs_trace(YAFFS_TRACE_VERIFY,
+			"Obj %d has illegaltype %d",
+		   obj->obj_id, obj->variant_type);
+		break;
+	}
+}
+
+void yaffs_verify_objects(struct yaffs_dev *dev)
+{
+	struct yaffs_obj *obj;
+	int i;
+	struct list_head *lh;
+
+	if (yaffs_skip_verification(dev))
+		return;
+
+	/* Iterate through the objects in each hash entry */
+
+	for (i = 0; i < YAFFS_NOBJECT_BUCKETS; i++) {
+		list_for_each(lh, &dev->obj_bucket[i].list) {
+			obj = list_entry(lh, struct yaffs_obj, hash_link);
+			yaffs_verify_obj(obj);
+		}
+	}
+}
+
+void yaffs_verify_obj_in_dir(struct yaffs_obj *obj)
+{
+	struct list_head *lh;
+	struct yaffs_obj *list_obj;
+	int count = 0;
+
+	if (!obj) {
+		yaffs_trace(YAFFS_TRACE_ALWAYS, "No object to verify");
+		BUG();
+		return;
+	}
+
+	if (yaffs_skip_verification(obj->my_dev))
+		return;
+
+	if (!obj->parent) {
+		yaffs_trace(YAFFS_TRACE_ALWAYS, "Object does not have parent");
+		BUG();
+		return;
+	}
+
+	if (obj->parent->variant_type != YAFFS_OBJECT_TYPE_DIRECTORY) {
+		yaffs_trace(YAFFS_TRACE_ALWAYS, "Parent is not directory");
+		BUG();
+	}
+
+	/* Iterate through the objects in each hash entry */
+
+	list_for_each(lh, &obj->parent->variant.dir_variant.children) {
+		list_obj = list_entry(lh, struct yaffs_obj, siblings);
+		yaffs_verify_obj(list_obj);
+		if (obj == list_obj)
+			count++;
+	}
+
+	if (count != 1) {
+		yaffs_trace(YAFFS_TRACE_ALWAYS,
+			"Object in directory %d times",
+			count);
+		BUG();
+	}
+}
+
+void yaffs_verify_dir(struct yaffs_obj *directory)
+{
+	struct list_head *lh;
+	struct yaffs_obj *list_obj;
+
+	if (!directory) {
+		BUG();
+		return;
+	}
+
+	if (yaffs_skip_full_verification(directory->my_dev))
+		return;
+
+	if (directory->variant_type != YAFFS_OBJECT_TYPE_DIRECTORY) {
+		yaffs_trace(YAFFS_TRACE_ALWAYS,
+			"Directory has wrong type: %d",
+			directory->variant_type);
+		BUG();
+	}
+
+	/* Iterate through the objects in each hash entry */
+
+	list_for_each(lh, &directory->variant.dir_variant.children) {
+		list_obj = list_entry(lh, struct yaffs_obj, siblings);
+		if (list_obj->parent != directory) {
+			yaffs_trace(YAFFS_TRACE_ALWAYS,
+				"Object in directory list has wrong parent %p",
+				list_obj->parent);
+			BUG();
+		}
+		yaffs_verify_obj_in_dir(list_obj);
+	}
+}
+
+static int yaffs_free_verification_failures;
+
+void yaffs_verify_free_chunks(struct yaffs_dev *dev)
+{
+	int counted;
+	int difference;
+
+	if (yaffs_skip_verification(dev))
+		return;
+
+	counted = yaffs_count_free_chunks(dev);
+
+	difference = dev->n_free_chunks - counted;
+
+	if (difference) {
+		yaffs_trace(YAFFS_TRACE_ALWAYS,
+			"Freechunks verification failure %d %d %d",
+			dev->n_free_chunks, counted, difference);
+		yaffs_free_verification_failures++;
+	}
+}
+
+int yaffs_verify_file_sane(struct yaffs_obj *in)
+{
+	(void) in;
+	return YAFFS_OK;
+}
diff --git a/fs/yaffs2/yaffs_verify.h b/fs/yaffs2/yaffs_verify.h
new file mode 100755
index 0000000..4f4af8d
--- /dev/null
+++ b/fs/yaffs2/yaffs_verify.h
@@ -0,0 +1,43 @@
+/*
+ * YAFFS: Yet another Flash File System . A NAND-flash specific file system.
+ *
+ * Copyright (C) 2002-2011 Aleph One Ltd.
+ *   for Toby Churchill Ltd and Brightstar Engineering
+ *
+ * Created by Charles Manning <charles@aleph1.co.uk>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 2.1 as
+ * published by the Free Software Foundation.
+ *
+ * Note: Only YAFFS headers are LGPL, YAFFS C code is covered by GPL.
+ */
+
+#ifndef __YAFFS_VERIFY_H__
+#define __YAFFS_VERIFY_H__
+
+#include "yaffs_guts.h"
+
+void yaffs_verify_blk(struct yaffs_dev *dev, struct yaffs_block_info *bi,
+		      int n);
+void yaffs_verify_collected_blk(struct yaffs_dev *dev,
+				struct yaffs_block_info *bi, int n);
+void yaffs_verify_blocks(struct yaffs_dev *dev);
+
+void yaffs_verify_oh(struct yaffs_obj *obj, struct yaffs_obj_hdr *oh,
+		     struct yaffs_ext_tags *tags, int parent_check);
+void yaffs_verify_file(struct yaffs_obj *obj);
+void yaffs_verify_link(struct yaffs_obj *obj);
+void yaffs_verify_symlink(struct yaffs_obj *obj);
+void yaffs_verify_special(struct yaffs_obj *obj);
+void yaffs_verify_obj(struct yaffs_obj *obj);
+void yaffs_verify_objects(struct yaffs_dev *dev);
+void yaffs_verify_obj_in_dir(struct yaffs_obj *obj);
+void yaffs_verify_dir(struct yaffs_obj *directory);
+void yaffs_verify_free_chunks(struct yaffs_dev *dev);
+
+int yaffs_verify_file_sane(struct yaffs_obj *obj);
+
+int yaffs_skip_verification(struct yaffs_dev *dev);
+
+#endif
diff --git a/fs/yaffs2/yaffs_vfs_multi.c b/fs/yaffs2/yaffs_vfs_multi.c
new file mode 100755
index 0000000..5cba218
--- /dev/null
+++ b/fs/yaffs2/yaffs_vfs_multi.c
@@ -0,0 +1,3694 @@
+/*
+ * YAFFS: Yet Another Flash File System. A NAND-flash specific file system.
+ *
+ * Copyright (C) 2002-2011 Aleph One Ltd.
+ *   for Toby Churchill Ltd and Brightstar Engineering
+ *
+ * Created by Charles Manning <charles@aleph1.co.uk>
+ * Acknowledgements:
+ * Luc van OostenRyck for numerous patches.
+ * Nick Bane for numerous patches.
+ * Nick Bane for 2.5/2.6 integration.
+ * Andras Toth for mknod rdev issue.
+ * Michael Fischer for finding the problem with inode inconsistency.
+ * Some code bodily lifted from JFFS
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+/*
+ *
+ * This is the file system front-end to YAFFS that hooks it up to
+ * the VFS.
+ *
+ * Special notes:
+ * >> 2.4: sb->u.generic_sbp points to the struct yaffs_dev associated with
+ *         this superblock
+ * >> 2.6: sb->s_fs_info  points to the struct yaffs_dev associated with this
+ *         superblock
+ * >> inode->u.generic_ip points to the associated struct yaffs_obj.
+ */
+
+/*
+ * There are two variants of the VFS glue code. This variant should compile
+ * for any version of Linux.
+ */
+#include <linux/version.h>
+#include <linux/major.h>
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 10))
+#define YAFFS_COMPILE_BACKGROUND
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 23))
+#define YAFFS_COMPILE_FREEZER
+#endif
+#endif
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 28))
+#define YAFFS_COMPILE_EXPORTFS
+#endif
+
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 35))
+#define YAFFS_USE_SETATTR_COPY
+#define YAFFS_USE_TRUNCATE_SETSIZE
+#endif
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 35))
+#define YAFFS_HAS_EVICT_INODE
+#endif
+
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 13))
+#define YAFFS_NEW_FOLLOW_LINK 1
+#else
+#define YAFFS_NEW_FOLLOW_LINK 0
+#endif
+
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(3, 6, 0))
+#define YAFFS_HAS_WRITE_SUPER
+#endif
+
+
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 19))
+#include <linux/config.h>
+#endif
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/init.h>
+#include <linux/fs.h>
+#include <linux/proc_fs.h>
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 39))
+#include <linux/smp_lock.h>
+#endif
+#include <linux/pagemap.h>
+#include <linux/mtd/mtd.h>
+#include <linux/interrupt.h>
+#include <linux/string.h>
+#include <linux/ctype.h>
+
+#if (YAFFS_NEW_FOLLOW_LINK == 1)
+#include <linux/namei.h>
+#endif
+
+#ifdef YAFFS_COMPILE_EXPORTFS
+#include <linux/exportfs.h>
+#endif
+
+#ifdef YAFFS_COMPILE_BACKGROUND
+#include <linux/kthread.h>
+#include <linux/delay.h>
+#endif
+#ifdef YAFFS_COMPILE_FREEZER
+#include <linux/freezer.h>
+#endif
+
+#include <asm/div64.h>
+
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 5, 0))
+
+#include <linux/statfs.h>
+
+#define UnlockPage(p) unlock_page(p)
+#define Page_Uptodate(page)	test_bit(PG_uptodate, &(page)->flags)
+
+/* FIXME: use sb->s_id instead ? */
+#define yaffs_devname(sb, buf)	bdevname(sb->s_bdev, buf)
+
+#else
+
+#include <linux/locks.h>
+#define	BDEVNAME_SIZE		0
+#define	yaffs_devname(sb, buf)	kdevname(sb->s_dev)
+
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2, 5, 0))
+/* added NCB 26/5/2006 for 2.4.25-vrs2-tcl1 kernel */
+#define __user
+#endif
+
+#endif
+
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 26))
+#define YPROC_ROOT  (&proc_root)
+#else
+#define YPROC_ROOT  NULL
+#endif
+
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 26))
+#define Y_INIT_TIMER(a)	init_timer(a)
+#else
+#define Y_INIT_TIMER(a)	init_timer_on_stack(a)
+#endif
+
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 27))
+#define YAFFS_USE_WRITE_BEGIN_END 1
+#else
+#define YAFFS_USE_WRITE_BEGIN_END 0
+#endif
+
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(3, 6, 0))
+#define YAFFS_SUPER_HAS_DIRTY
+#endif
+
+
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(3, 2, 0))
+#define set_nlink(inode, count)  do { (inode)->i_nlink = (count); } while(0)
+#endif
+
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 28))
+static uint32_t YCALCBLOCKS(uint64_t partition_size, uint32_t block_size)
+{
+	uint64_t result = partition_size;
+	do_div(result, block_size);
+	return (uint32_t) result;
+}
+#else
+#define YCALCBLOCKS(s, b) ((s)/(b))
+#endif
+
+#include <linux/uaccess.h>
+#include <linux/mtd/mtd.h>
+
+#include "yportenv.h"
+#include "yaffs_trace.h"
+#include "yaffs_guts.h"
+#include "yaffs_attribs.h"
+
+#include "yaffs_linux.h"
+
+#include "yaffs_mtdif.h"
+#include "yaffs_packedtags2.h"
+#include "yaffs_getblockinfo.h"
+
+unsigned int yaffs_trace_mask =
+		YAFFS_TRACE_BAD_BLOCKS |
+		YAFFS_TRACE_ALWAYS |
+		0;
+
+unsigned int yaffs_wr_attempts = YAFFS_WR_ATTEMPTS;
+unsigned int yaffs_auto_checkpoint = 1;
+unsigned int yaffs_gc_control = 1;
+unsigned int yaffs_bg_enable = 1;
+unsigned int yaffs_auto_select = 1;
+/* Module Parameters */
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 5, 0))
+module_param(yaffs_trace_mask, uint, 0644);
+module_param(yaffs_wr_attempts, uint, 0644);
+module_param(yaffs_auto_checkpoint, uint, 0644);
+module_param(yaffs_gc_control, uint, 0644);
+module_param(yaffs_bg_enable, uint, 0644);
+#else
+MODULE_PARM(yaffs_trace_mask, "i");
+MODULE_PARM(yaffs_wr_attempts, "i");
+MODULE_PARM(yaffs_auto_checkpoint, "i");
+MODULE_PARM(yaffs_gc_control, "i");
+#endif
+
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 25))
+/* use iget and read_inode */
+#define Y_IGET(sb, inum) iget((sb), (inum))
+
+#else
+/* Call local equivalent */
+#define YAFFS_USE_OWN_IGET
+#define Y_IGET(sb, inum) yaffs_iget((sb), (inum))
+
+#endif
+
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 18))
+#define yaffs_inode_to_obj_lv(iptr) ((iptr)->i_private)
+#else
+#define yaffs_inode_to_obj_lv(iptr) ((iptr)->u.generic_ip)
+#endif
+
+#define yaffs_inode_to_obj(iptr) \
+	((struct yaffs_obj *)(yaffs_inode_to_obj_lv(iptr)))
+#define yaffs_dentry_to_obj(dptr) yaffs_inode_to_obj((dptr)->d_inode)
+
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 5, 0))
+#define yaffs_super_to_dev(sb)	((struct yaffs_dev *)sb->s_fs_info)
+#else
+#define yaffs_super_to_dev(sb)	((struct yaffs_dev *)sb->u.generic_sbp)
+#endif
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 5, 0))
+#define Y_CLEAR_INODE(i) clear_inode(i)
+#else
+#define Y_CLEAR_INODE(i) end_writeback(i)
+#endif
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 12, 0))
+#define YAFFS_USE_DIR_ITERATE
+#endif
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3,12,0))
+#define YAFFS_NEW_PROCFS
+#include <linux/seq_file.h>
+#endif
+
+
+#define update_dir_time(dir) do {\
+			(dir)->i_ctime = (dir)->i_mtime = CURRENT_TIME; \
+		} while (0)
+
+static void yaffs_fill_inode_from_obj(struct inode *inode,
+				      struct yaffs_obj *obj);
+
+
+static void yaffs_gross_lock(struct yaffs_dev *dev)
+{
+	yaffs_trace(YAFFS_TRACE_LOCK, "yaffs locking %p", current);
+	mutex_lock(&(yaffs_dev_to_lc(dev)->gross_lock));
+	yaffs_trace(YAFFS_TRACE_LOCK, "yaffs locked %p", current);
+}
+
+static void yaffs_gross_unlock(struct yaffs_dev *dev)
+{
+	yaffs_trace(YAFFS_TRACE_LOCK, "yaffs unlocking %p", current);
+	mutex_unlock(&(yaffs_dev_to_lc(dev)->gross_lock));
+}
+
+
+static int yaffs_readpage_nolock(struct file *f, struct page *pg)
+{
+	/* Lifted from jffs2 */
+
+	struct yaffs_obj *obj;
+	unsigned char *pg_buf;
+	int ret;
+	loff_t pos = ((loff_t) pg->index) << PAGE_CACHE_SHIFT;
+	struct yaffs_dev *dev;
+
+	yaffs_trace(YAFFS_TRACE_OS,
+		"yaffs_readpage_nolock at %lld, size %08x",
+		(long long)pos,
+		(unsigned)PAGE_CACHE_SIZE);
+
+	obj = yaffs_dentry_to_obj(f->f_dentry);
+
+	dev = obj->my_dev;
+
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 5, 0))
+	BUG_ON(!PageLocked(pg));
+#else
+	if (!PageLocked(pg))
+		PAGE_BUG(pg);
+#endif
+
+	pg_buf = kmap(pg);
+	/* FIXME: Can kmap fail? */
+
+	yaffs_gross_lock(dev);
+
+	ret = yaffs_file_rd(obj, pg_buf, pos, PAGE_CACHE_SIZE);
+
+	yaffs_gross_unlock(dev);
+
+	if (ret >= 0)
+		ret = 0;
+
+	if (ret) {
+		ClearPageUptodate(pg);
+		SetPageError(pg);
+	} else {
+		SetPageUptodate(pg);
+		ClearPageError(pg);
+	}
+
+	flush_dcache_page(pg);
+	kunmap(pg);
+
+	yaffs_trace(YAFFS_TRACE_OS, "yaffs_readpage_nolock done");
+	return ret;
+}
+
+static int yaffs_readpage_unlock(struct file *f, struct page *pg)
+{
+	int ret = yaffs_readpage_nolock(f, pg);
+	UnlockPage(pg);
+	return ret;
+}
+
+static int yaffs_readpage(struct file *f, struct page *pg)
+{
+	int ret;
+
+	yaffs_trace(YAFFS_TRACE_OS, "yaffs_readpage");
+	ret = yaffs_readpage_unlock(f, pg);
+	yaffs_trace(YAFFS_TRACE_OS, "yaffs_readpage done");
+	return ret;
+}
+
+
+static void yaffs_set_super_dirty_val(struct yaffs_dev *dev, int val)
+{
+	struct yaffs_linux_context *lc = yaffs_dev_to_lc(dev);
+
+	if (lc)
+		lc->dirty = val;
+
+# ifdef YAFFS_SUPER_HAS_DIRTY
+	{
+		struct super_block *sb = lc->super;
+
+		if (sb)
+			sb->s_dirt = val;
+	}
+#endif
+
+}
+
+static void yaffs_set_super_dirty(struct yaffs_dev *dev)
+{
+	yaffs_set_super_dirty_val(dev, 1);
+}
+
+static void yaffs_clear_super_dirty(struct yaffs_dev *dev)
+{
+	yaffs_set_super_dirty_val(dev, 0);
+}
+
+static int yaffs_check_super_dirty(struct yaffs_dev *dev)
+{
+	struct yaffs_linux_context *lc = yaffs_dev_to_lc(dev);
+
+	if (lc && lc->dirty)
+		return 1;
+
+# ifdef YAFFS_SUPER_HAS_DIRTY
+	{
+		struct super_block *sb = lc->super;
+
+		if (sb && sb->s_dirt)
+			return 1;
+	}
+#endif
+	return 0;
+
+}
+
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 5, 0))
+static int yaffs_writepage(struct page *page, struct writeback_control *wbc)
+#else
+static int yaffs_writepage(struct page *page)
+#endif
+{
+	struct yaffs_dev *dev;
+	struct address_space *mapping = page->mapping;
+	struct inode *inode;
+	unsigned long end_index;
+	char *buffer;
+	struct yaffs_obj *obj;
+	int n_written = 0;
+	unsigned n_bytes;
+	loff_t i_size;
+
+	if (!mapping)
+		BUG();
+	inode = mapping->host;
+	if (!inode)
+		BUG();
+	i_size = i_size_read(inode);
+
+	end_index = i_size >> PAGE_CACHE_SHIFT;
+
+	if (page->index < end_index)
+		n_bytes = PAGE_CACHE_SIZE;
+	else {
+		n_bytes = i_size & (PAGE_CACHE_SIZE - 1);
+
+		if (page->index > end_index || !n_bytes) {
+			yaffs_trace(YAFFS_TRACE_OS,
+				"yaffs_writepage at %lld, inode size = %lld!!",
+				((loff_t)page->index) << PAGE_CACHE_SHIFT,
+				inode->i_size);
+			yaffs_trace(YAFFS_TRACE_OS,
+				"                -> don't care!!");
+
+			zero_user_segment(page, 0, PAGE_CACHE_SIZE);
+			set_page_writeback(page);
+			unlock_page(page);
+			end_page_writeback(page);
+			return 0;
+		}
+	}
+
+	if (n_bytes != PAGE_CACHE_SIZE)
+		zero_user_segment(page, n_bytes, PAGE_CACHE_SIZE);
+
+	get_page(page);
+
+	buffer = kmap(page);
+
+	obj = yaffs_inode_to_obj(inode);
+	dev = obj->my_dev;
+	yaffs_gross_lock(dev);
+
+	yaffs_trace(YAFFS_TRACE_OS,
+		"yaffs_writepage at %lld, size %08x",
+		((loff_t)page->index) << PAGE_CACHE_SHIFT, n_bytes);
+	yaffs_trace(YAFFS_TRACE_OS,
+		"writepag0: obj = %lld, ino = %lld",
+		obj->variant.file_variant.file_size, inode->i_size);
+
+	n_written = yaffs_wr_file(obj, buffer,
+				  ((loff_t)page->index) << PAGE_CACHE_SHIFT, n_bytes, 0);
+
+	yaffs_set_super_dirty(dev);
+
+	yaffs_trace(YAFFS_TRACE_OS,
+		"writepag1: obj = %lld, ino = %lld",
+		obj->variant.file_variant.file_size, inode->i_size);
+
+	yaffs_gross_unlock(dev);
+
+	kunmap(page);
+	set_page_writeback(page);
+	unlock_page(page);
+	end_page_writeback(page);
+	put_page(page);
+
+	return (n_written == n_bytes) ? 0 : -ENOSPC;
+}
+
+/* Space holding and freeing is done to ensure we have space available for write_begin/end */
+/* For now we just assume few parallel writes and check against a small number. */
+/* Todo: need to do this with a counter to handle parallel reads better */
+
+static ssize_t yaffs_hold_space(struct file *f)
+{
+	struct yaffs_obj *obj;
+	struct yaffs_dev *dev;
+
+	int n_free_chunks;
+
+	obj = yaffs_dentry_to_obj(f->f_dentry);
+
+	dev = obj->my_dev;
+
+	yaffs_gross_lock(dev);
+
+	n_free_chunks = yaffs_get_n_free_chunks(dev);
+
+	yaffs_gross_unlock(dev);
+
+	return (n_free_chunks > 20) ? 1 : 0;
+}
+
+static void yaffs_release_space(struct file *f)
+{
+	struct yaffs_obj *obj;
+	struct yaffs_dev *dev;
+
+	obj = yaffs_dentry_to_obj(f->f_dentry);
+
+	dev = obj->my_dev;
+
+	yaffs_gross_lock(dev);
+
+	yaffs_gross_unlock(dev);
+}
+
+#if (YAFFS_USE_WRITE_BEGIN_END > 0)
+static int yaffs_write_begin(struct file *filp, struct address_space *mapping,
+			     loff_t pos, unsigned len, unsigned flags,
+			     struct page **pagep, void **fsdata)
+{
+	struct page *pg = NULL;
+	pgoff_t index = pos >> PAGE_CACHE_SHIFT;
+
+	int ret = 0;
+	int space_held = 0;
+
+	/* Get a page */
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 28)
+	pg = grab_cache_page_write_begin(mapping, index, flags);
+#else
+	pg = __grab_cache_page(mapping, index);
+#endif
+
+	*pagep = pg;
+	if (!pg) {
+		ret = -ENOMEM;
+		goto out;
+	}
+	yaffs_trace(YAFFS_TRACE_OS,
+		"start yaffs_write_begin index %d(%x) uptodate %d",
+		(int)index, (int)index, Page_Uptodate(pg) ? 1 : 0);
+
+	/* Get fs space */
+	space_held = yaffs_hold_space(filp);
+
+	if (!space_held) {
+		ret = -ENOSPC;
+		goto out;
+	}
+
+	/* Update page if required */
+
+	if (!Page_Uptodate(pg))
+		ret = yaffs_readpage_nolock(filp, pg);
+
+	if (ret)
+		goto out;
+
+	/* Happy path return */
+	yaffs_trace(YAFFS_TRACE_OS, "end yaffs_write_begin - ok");
+
+	return 0;
+
+out:
+	yaffs_trace(YAFFS_TRACE_OS,
+		"end yaffs_write_begin fail returning %d", ret);
+	if (space_held)
+		yaffs_release_space(filp);
+	if (pg) {
+		unlock_page(pg);
+		page_cache_release(pg);
+	}
+	return ret;
+}
+
+#else
+
+static int yaffs_prepare_write(struct file *f, struct page *pg,
+			       unsigned offset, unsigned to)
+{
+	yaffs_trace(YAFFS_TRACE_OS, "yaffs_prepair_write");
+
+	if (!Page_Uptodate(pg))
+		return yaffs_readpage_nolock(f, pg);
+	return 0;
+}
+#endif
+
+
+static ssize_t yaffs_file_write(struct file *f, const char *buf, size_t n,
+				loff_t * pos)
+{
+	struct yaffs_obj *obj;
+	int n_written;
+	loff_t ipos;
+	struct inode *inode;
+	struct yaffs_dev *dev;
+
+	obj = yaffs_dentry_to_obj(f->f_dentry);
+
+	if (!obj) {
+		yaffs_trace(YAFFS_TRACE_OS,
+			"yaffs_file_write: hey obj is null!");
+                return -EINVAL;
+        }
+
+	dev = obj->my_dev;
+
+	yaffs_gross_lock(dev);
+
+	inode = f->f_dentry->d_inode;
+
+	if (!S_ISBLK(inode->i_mode) && f->f_flags & O_APPEND)
+		ipos = inode->i_size;
+	else
+		ipos = *pos;
+
+	yaffs_trace(YAFFS_TRACE_OS,
+		"yaffs_file_write about to write writing %u(%x) bytes to object %d at %lld",
+		(unsigned)n, (unsigned)n, obj->obj_id, ipos);
+
+	n_written = yaffs_wr_file(obj, buf, ipos, n, 0);
+
+	yaffs_set_super_dirty(dev);
+
+	yaffs_trace(YAFFS_TRACE_OS,
+		"yaffs_file_write: %d(%x) bytes written",
+		(unsigned)n, (unsigned)n);
+
+	if (n_written > 0) {
+		ipos += n_written;
+		*pos = ipos;
+		if (ipos > inode->i_size) {
+			inode->i_size = ipos;
+			inode->i_blocks = (ipos + 511) >> 9;
+
+			yaffs_trace(YAFFS_TRACE_OS,
+				"yaffs_file_write size updated to %lld bytes, %d blocks",
+				ipos, (int)(inode->i_blocks));
+		}
+
+	}
+	yaffs_gross_unlock(dev);
+	return (n_written == 0) && (n > 0) ? -ENOSPC : n_written;
+}
+
+
+#if (YAFFS_USE_WRITE_BEGIN_END > 0)
+static int yaffs_write_end(struct file *filp, struct address_space *mapping,
+			   loff_t pos, unsigned len, unsigned copied,
+			   struct page *pg, void *fsdadata)
+{
+	int ret = 0;
+	void *addr, *kva;
+	uint32_t offset_into_page = pos & (PAGE_CACHE_SIZE - 1);
+
+	kva = kmap(pg);
+	addr = kva + offset_into_page;
+
+	yaffs_trace(YAFFS_TRACE_OS,
+		"yaffs_write_end addr %p pos %lld n_bytes %d",
+		addr, pos, copied);
+
+	ret = yaffs_file_write(filp, addr, copied, &pos);
+
+	if (ret != copied) {
+		yaffs_trace(YAFFS_TRACE_OS,
+			"yaffs_write_end not same size ret %d  copied %d",
+			ret, copied);
+		SetPageError(pg);
+	}
+
+	kunmap(pg);
+
+	yaffs_release_space(filp);
+	unlock_page(pg);
+	page_cache_release(pg);
+	return ret;
+}
+#else
+
+static int yaffs_commit_write(struct file *f, struct page *pg, unsigned offset,
+			      unsigned to)
+{
+	void *addr, *kva;
+
+	loff_t pos = (((loff_t) pg->index) << PAGE_CACHE_SHIFT) + offset;
+	int n_bytes = to - offset;
+	int n_written;
+
+	kva = kmap(pg);
+	addr = kva + offset;
+
+	yaffs_trace(YAFFS_TRACE_OS,
+		"yaffs_commit_write addr %p pos %lld n_bytes %d",
+		addr, pos, n_bytes);
+
+	n_written = yaffs_file_write(f, addr, n_bytes, &pos);
+
+	if (n_written != n_bytes) {
+		yaffs_trace(YAFFS_TRACE_OS,
+			"yaffs_commit_write not same size n_written %d  n_bytes %d",
+			n_written, n_bytes);
+		SetPageError(pg);
+	}
+	kunmap(pg);
+
+	yaffs_trace(YAFFS_TRACE_OS,
+		"yaffs_commit_write returning %d",
+		n_written == n_bytes ? 0 : n_written);
+
+	return n_written == n_bytes ? 0 : n_written;
+}
+#endif
+
+static struct address_space_operations yaffs_file_address_operations = {
+	.readpage = yaffs_readpage,
+	.writepage = yaffs_writepage,
+#if (YAFFS_USE_WRITE_BEGIN_END > 0)
+	.write_begin = yaffs_write_begin,
+	.write_end = yaffs_write_end,
+#else
+	.prepare_write = yaffs_prepare_write,
+	.commit_write = yaffs_commit_write,
+#endif
+};
+
+
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 17))
+static int yaffs_file_flush(struct file *file, fl_owner_t id)
+#else
+static int yaffs_file_flush(struct file *file)
+#endif
+{
+	struct yaffs_obj *obj = yaffs_dentry_to_obj(file->f_dentry);
+
+	struct yaffs_dev *dev = obj->my_dev;
+
+	yaffs_trace(YAFFS_TRACE_OS,
+		"yaffs_file_flush object %d (%s)",
+		obj->obj_id,
+		obj->dirty ? "dirty" : "clean");
+
+	yaffs_gross_lock(dev);
+
+	yaffs_flush_file(obj, 1, 0, 0);
+
+	yaffs_gross_unlock(dev);
+
+	return 0;
+}
+
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 39))
+static int yaffs_sync_object(struct file *file, loff_t start, loff_t end, int datasync)
+#elif (LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 34))
+static int yaffs_sync_object(struct file *file, int datasync)
+#else
+static int yaffs_sync_object(struct file *file, struct dentry *dentry,
+			     int datasync)
+#endif
+{
+	struct yaffs_obj *obj;
+	struct yaffs_dev *dev;
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 34))
+	struct dentry *dentry = file->f_path.dentry;
+#endif
+
+	obj = yaffs_dentry_to_obj(dentry);
+
+	dev = obj->my_dev;
+
+	yaffs_trace(YAFFS_TRACE_OS | YAFFS_TRACE_SYNC,
+		"yaffs_sync_object");
+	yaffs_gross_lock(dev);
+	yaffs_flush_file(obj, 1, datasync, 0);
+	yaffs_gross_unlock(dev);
+	return 0;
+}
+
+
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 22))
+static const struct file_operations yaffs_file_operations = {
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 16, 0)
+	.read = NULL, //new_sync_read,
+	.write = NULL,//new_sync_write,
+	.read_iter = generic_file_read_iter,
+	.write_iter = generic_file_write_iter,
+#else
+	.read = do_sync_read,
+	.write = do_sync_write,
+	.aio_read = generic_file_aio_read,
+	.aio_write = generic_file_aio_write,
+#endif
+	.mmap = generic_file_mmap,
+	.flush = yaffs_file_flush,
+	.fsync = yaffs_sync_object,
+	.splice_read = generic_file_splice_read,
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 16, 0)
+	.splice_write = iter_file_splice_write,
+#else
+	.splice_write = generic_file_splice_write,
+#endif
+	.llseek = generic_file_llseek,
+};
+
+#elif (LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 18))
+
+static const struct file_operations yaffs_file_operations = {
+	.read = do_sync_read,
+	.write = do_sync_write,
+	.aio_read = generic_file_aio_read,
+	.aio_write = generic_file_aio_write,
+	.mmap = generic_file_mmap,
+	.flush = yaffs_file_flush,
+	.fsync = yaffs_sync_object,
+	.sendfile = generic_file_sendfile,
+};
+
+#else
+
+static const struct file_operations yaffs_file_operations = {
+	.read = generic_file_read,
+	.write = generic_file_write,
+	.mmap = generic_file_mmap,
+	.flush = yaffs_file_flush,
+	.fsync = yaffs_sync_object,
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 5, 0))
+	.sendfile = generic_file_sendfile,
+#endif
+};
+#endif
+
+
+
+
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 25))
+static void zero_user_segment(struct page *page, unsigned start, unsigned end)
+{
+	void *kaddr = kmap_atomic(page, KM_USER0);
+	memset(kaddr + start, 0, end - start);
+	kunmap_atomic(kaddr, KM_USER0);
+	flush_dcache_page(page);
+}
+#endif
+
+
+static int yaffs_vfs_setsize(struct inode *inode, loff_t newsize)
+{
+#ifdef YAFFS_USE_TRUNCATE_SETSIZE
+	truncate_setsize(inode, newsize);
+	return 0;
+#else
+	truncate_inode_pages(&inode->i_data, newsize);
+	return 0;
+#endif
+
+}
+
+
+static int yaffs_vfs_setattr(struct inode *inode, struct iattr *attr)
+{
+#ifdef YAFFS_USE_SETATTR_COPY
+	setattr_copy(inode, attr);
+	return 0;
+#else
+	return inode_setattr(inode, attr);
+#endif
+
+}
+
+static int yaffs_setattr(struct dentry *dentry, struct iattr *attr)
+{
+	struct inode *inode = dentry->d_inode;
+	int error = 0;
+	struct yaffs_dev *dev;
+
+	yaffs_trace(YAFFS_TRACE_OS,
+		"yaffs_setattr of object %d",
+		yaffs_inode_to_obj(inode)->obj_id);
+#if 0
+	/* Fail if a requested resize >= 2GB */
+	if (attr->ia_valid & ATTR_SIZE && (attr->ia_size >> 31))
+		error = -EINVAL;
+#endif
+
+	if (error == 0)
+		error = inode_change_ok(inode, attr);
+	if (error == 0) {
+		int result;
+		if (!error) {
+			error = yaffs_vfs_setattr(inode, attr);
+			yaffs_trace(YAFFS_TRACE_OS, "inode_setattr called");
+			if (attr->ia_valid & ATTR_SIZE) {
+				yaffs_vfs_setsize(inode, attr->ia_size);
+				inode->i_blocks = (inode->i_size + 511) >> 9;
+			}
+		}
+		dev = yaffs_inode_to_obj(inode)->my_dev;
+		if (attr->ia_valid & ATTR_SIZE) {
+			yaffs_trace(YAFFS_TRACE_OS,
+				"resize to %d(%x)",
+				(int)(attr->ia_size),
+				(int)(attr->ia_size));
+		}
+		yaffs_gross_lock(dev);
+		result = yaffs_set_attribs(yaffs_inode_to_obj(inode), attr);
+		if (result == YAFFS_OK) {
+			error = 0;
+		} else {
+			error = -EPERM;
+		}
+		yaffs_gross_unlock(dev);
+
+	}
+
+	yaffs_trace(YAFFS_TRACE_OS, "yaffs_setattr done returning %d", error);
+
+	return error;
+}
+
+static int yaffs_setxattr(struct dentry *dentry, const char *name,
+		   const void *value, size_t size, int flags)
+{
+	struct inode *inode = dentry->d_inode;
+	int error = 0;
+	struct yaffs_dev *dev;
+	struct yaffs_obj *obj = yaffs_inode_to_obj(inode);
+
+	yaffs_trace(YAFFS_TRACE_OS, "yaffs_setxattr of object %d", obj->obj_id);
+
+	if (error == 0) {
+		int result;
+		dev = obj->my_dev;
+		yaffs_gross_lock(dev);
+		result = yaffs_set_xattrib(obj, name, value, size, flags);
+		if (result == YAFFS_OK)
+			error = 0;
+		else if (result < 0)
+			error = result;
+		yaffs_gross_unlock(dev);
+
+	}
+	yaffs_trace(YAFFS_TRACE_OS, "yaffs_setxattr done returning %d", error);
+
+	return error;
+}
+
+static ssize_t yaffs_getxattr(struct dentry * dentry, const char *name,
+			void *buff, size_t size)
+{
+	struct inode *inode = dentry->d_inode;
+	int error = 0;
+	struct yaffs_dev *dev;
+	struct yaffs_obj *obj = yaffs_inode_to_obj(inode);
+
+	yaffs_trace(YAFFS_TRACE_OS,
+		"yaffs_getxattr \"%s\" from object %d",
+		name, obj->obj_id);
+
+	if (error == 0) {
+		dev = obj->my_dev;
+		yaffs_gross_lock(dev);
+		error = yaffs_get_xattrib(obj, name, buff, size);
+		yaffs_gross_unlock(dev);
+
+	}
+	yaffs_trace(YAFFS_TRACE_OS, "yaffs_getxattr done returning %d", error);
+
+	return error;
+}
+
+static int yaffs_removexattr(struct dentry *dentry, const char *name)
+{
+	struct inode *inode = dentry->d_inode;
+	int error = 0;
+	struct yaffs_dev *dev;
+	struct yaffs_obj *obj = yaffs_inode_to_obj(inode);
+
+	yaffs_trace(YAFFS_TRACE_OS,
+		"yaffs_removexattr of object %d", obj->obj_id);
+
+	if (error == 0) {
+		int result;
+		dev = obj->my_dev;
+		yaffs_gross_lock(dev);
+		result = yaffs_remove_xattrib(obj, name);
+		if (result == YAFFS_OK)
+			error = 0;
+		else if (result < 0)
+			error = result;
+		yaffs_gross_unlock(dev);
+
+	}
+	yaffs_trace(YAFFS_TRACE_OS,
+		"yaffs_removexattr done returning %d", error);
+
+	return error;
+}
+
+static ssize_t yaffs_listxattr(struct dentry * dentry, char *buff, size_t size)
+{
+	struct inode *inode = dentry->d_inode;
+	int error = 0;
+	struct yaffs_dev *dev;
+	struct yaffs_obj *obj = yaffs_inode_to_obj(inode);
+
+	yaffs_trace(YAFFS_TRACE_OS,
+		"yaffs_listxattr of object %d", obj->obj_id);
+
+	if (error == 0) {
+		dev = obj->my_dev;
+		yaffs_gross_lock(dev);
+		error = yaffs_list_xattrib(obj, buff, size);
+		yaffs_gross_unlock(dev);
+
+	}
+	yaffs_trace(YAFFS_TRACE_OS,
+		"yaffs_listxattr done returning %d", error);
+
+	return error;
+}
+
+
+static const struct inode_operations yaffs_file_inode_operations = {
+	.setattr = yaffs_setattr,
+	.setxattr = yaffs_setxattr,
+	.getxattr = yaffs_getxattr,
+	.listxattr = yaffs_listxattr,
+	.removexattr = yaffs_removexattr,
+};
+
+
+static int yaffs_readlink(struct dentry *dentry, char __user * buffer,
+			  int buflen)
+{
+	unsigned char *alias;
+	int ret;
+
+	struct yaffs_dev *dev = yaffs_dentry_to_obj(dentry)->my_dev;
+
+	yaffs_gross_lock(dev);
+
+	alias = yaffs_get_symlink_alias(yaffs_dentry_to_obj(dentry));
+
+	yaffs_gross_unlock(dev);
+
+	if (!alias)
+		return -ENOMEM;
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3, 15, 0)
+	ret = vfs_readlink(dentry, buffer, buflen, alias);
+#else
+	ret = readlink_copy(buffer, buflen, alias);
+#endif
+	kfree(alias);
+	return ret;
+}
+
+#if 1
+#if (YAFFS_NEW_FOLLOW_LINK == 1)
+static const char *yaffs_follow_link(struct dentry *dentry, void **nd)
+{
+	const char *ret;
+#else
+static int yaffs_follow_link(struct dentry *dentry, struct nameidata *nd)
+{
+	int ret
+#endif
+	unsigned char *alias;
+	int ret_int = 0;
+	struct yaffs_dev *dev = yaffs_dentry_to_obj(dentry)->my_dev;
+
+	yaffs_gross_lock(dev);
+
+	alias = yaffs_get_symlink_alias(yaffs_dentry_to_obj(dentry));
+	yaffs_gross_unlock(dev);
+
+	if (!alias) {
+		ret_int = -ENOMEM;
+		goto out;
+	}
+#if (YAFFS_NEW_FOLLOW_LINK == 1)
+//	nd_set_link(nd, alias);
+	ret = (const char *)alias;
+	*nd = alias;
+out:
+	if (ret_int)
+		ret = ERR_PTR(ret_int);
+	return ret;
+#else
+	ret = vfs_follow_link(nd, alias);
+	kfree(alias);
+out:
+	if (ret_int)
+		ret = ret_int;
+	return ret;
+#endif
+}
+
+#endif
+
+
+#ifdef YAFFS_HAS_PUT_INODE
+
+/* For now put inode is just for debugging
+ * Put inode is called when the inode **structure** is put.
+ */
+static void yaffs_put_inode(struct inode *inode)
+{
+	yaffs_trace(YAFFS_TRACE_OS,
+		"yaffs_put_inode: ino %d, count %d"),
+		(int)inode->i_ino, atomic_read(&inode->i_count);
+
+}
+#endif
+
+#if (YAFFS_NEW_FOLLOW_LINK == 1)
+//void yaffs_put_link(struct dentry *dentry, struct nameidata *nd, void *alias)
+void yaffs_put_link(struct inode *inode, void *alias)
+{
+	kfree(alias);
+}
+#endif
+
+static const struct inode_operations yaffs_symlink_inode_operations = {
+	.readlink = yaffs_readlink,
+	.follow_link = yaffs_follow_link,
+#if (YAFFS_NEW_FOLLOW_LINK == 1)
+	.put_link = yaffs_put_link,
+#endif
+	.setattr = yaffs_setattr,
+	.setxattr = yaffs_setxattr,
+	.getxattr = yaffs_getxattr,
+	.listxattr = yaffs_listxattr,
+	.removexattr = yaffs_removexattr,
+};
+
+#ifdef YAFFS_USE_OWN_IGET
+
+static struct inode *yaffs_iget(struct super_block *sb, unsigned long ino)
+{
+	struct inode *inode;
+	struct yaffs_obj *obj;
+	struct yaffs_dev *dev = yaffs_super_to_dev(sb);
+
+	yaffs_trace(YAFFS_TRACE_OS, "yaffs_iget for %lu", ino);
+
+	inode = iget_locked(sb, ino);
+	if (!inode)
+		return ERR_PTR(-ENOMEM);
+	if (!(inode->i_state & I_NEW))
+		return inode;
+
+	/* NB This is called as a side effect of other functions, but
+	 * we had to release the lock to prevent deadlocks, so
+	 * need to lock again.
+	 */
+
+	yaffs_gross_lock(dev);
+
+	obj = yaffs_find_by_number(dev, inode->i_ino);
+
+	yaffs_fill_inode_from_obj(inode, obj);
+
+	yaffs_gross_unlock(dev);
+
+	unlock_new_inode(inode);
+	return inode;
+}
+
+#else
+
+static void yaffs_read_inode(struct inode *inode)
+{
+	/* NB This is called as a side effect of other functions, but
+	 * we had to release the lock to prevent deadlocks, so
+	 * need to lock again.
+	 */
+
+	struct yaffs_obj *obj;
+	struct yaffs_dev *dev = yaffs_super_to_dev(inode->i_sb);
+
+	yaffs_trace(YAFFS_TRACE_OS,
+		"yaffs_read_inode for %d", (int)inode->i_ino);
+
+	if (current != yaffs_dev_to_lc(dev)->readdir_process)
+		yaffs_gross_lock(dev);
+
+	obj = yaffs_find_by_number(dev, inode->i_ino);
+
+	yaffs_fill_inode_from_obj(inode, obj);
+
+	if (current != yaffs_dev_to_lc(dev)->readdir_process)
+		yaffs_gross_unlock(dev);
+}
+
+#endif
+
+
+
+struct inode *yaffs_get_inode(struct super_block *sb, int mode, int dev,
+			      struct yaffs_obj *obj)
+{
+	struct inode *inode;
+
+	if (!sb) {
+		yaffs_trace(YAFFS_TRACE_OS,
+			"yaffs_get_inode for NULL super_block!!");
+		return NULL;
+
+	}
+
+	if (!obj) {
+		yaffs_trace(YAFFS_TRACE_OS,
+			"yaffs_get_inode for NULL object!!");
+		return NULL;
+
+	}
+
+	yaffs_trace(YAFFS_TRACE_OS,
+		"yaffs_get_inode for object %d", obj->obj_id);
+
+	inode = Y_IGET(sb, obj->obj_id);
+	if (IS_ERR(inode))
+		return NULL;
+
+	/* NB Side effect: iget calls back to yaffs_read_inode(). */
+	/* iget also increments the inode's i_count */
+	/* NB You can't be holding gross_lock or deadlock will happen! */
+
+	return inode;
+}
+
+
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 29)
+#define YCRED(x) x
+#else
+#define YCRED(x) (x->cred)
+#endif
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,14,0)
+#define YPROC_uid(p) (YCRED(p)->fsuid)
+#define YPROC_gid(p) (YCRED(p)->fsgid)
+#define EXTRACT_gid(x) x
+#define EXTRACT_uid(x) x
+#define MAKE_gid(x) x
+#define MAKE_uid(x) x
+#else
+#define YPROC_uid(p) from_kuid(&init_user_ns, YCRED(p)->fsuid)
+#define YPROC_gid(p) from_kgid(&init_user_ns, YCRED(p)->fsgid)
+#define EXTRACT_gid(x) from_kgid(&init_user_ns, x)
+#define EXTRACT_uid(x) from_kuid(&init_user_ns, x)
+#define MAKE_gid(x) make_kgid(&init_user_ns, x)
+#define MAKE_uid(x) make_kuid(&init_user_ns, x)
+#endif
+
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 4, 0))
+static int yaffs_mknod(struct inode *dir, struct dentry *dentry, umode_t mode,
+		       dev_t rdev)
+#elif (LINUX_VERSION_CODE > KERNEL_VERSION(2, 5, 0))
+static int yaffs_mknod(struct inode *dir, struct dentry *dentry, int mode,
+		       dev_t rdev)
+#else
+static int yaffs_mknod(struct inode *dir, struct dentry *dentry, int mode,
+		       int rdev)
+#endif
+{
+	struct inode *inode;
+
+	struct yaffs_obj *obj = NULL;
+	struct yaffs_dev *dev;
+
+	struct yaffs_obj *parent = yaffs_inode_to_obj(dir);
+
+	int error = -ENOSPC;
+	uid_t uid = YPROC_uid(current);
+	gid_t gid =
+	    (dir->i_mode & S_ISGID) ? EXTRACT_gid(dir->i_gid) : YPROC_gid(current);
+
+	if ((dir->i_mode & S_ISGID) && S_ISDIR(mode))
+		mode |= S_ISGID;
+
+	if (parent) {
+		yaffs_trace(YAFFS_TRACE_OS,
+			"yaffs_mknod: parent object %d type %d",
+			parent->obj_id, parent->variant_type);
+	} else {
+		yaffs_trace(YAFFS_TRACE_OS,
+			"yaffs_mknod: could not get parent object");
+		return -EPERM;
+	}
+
+	yaffs_trace(YAFFS_TRACE_OS,
+		"yaffs_mknod: making oject for %s, mode %x dev %x",
+		dentry->d_name.name, mode, rdev);
+
+	dev = parent->my_dev;
+
+	yaffs_gross_lock(dev);
+
+	switch (mode & S_IFMT) {
+	default:
+		/* Special (socket, fifo, device...) */
+		yaffs_trace(YAFFS_TRACE_OS, "yaffs_mknod: making special");
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 5, 0))
+		obj =
+		    yaffs_create_special(parent, dentry->d_name.name, mode, uid,
+					 gid, old_encode_dev(rdev));
+#else
+		obj =
+		    yaffs_create_special(parent, dentry->d_name.name, mode, uid,
+					 gid, rdev);
+#endif
+		break;
+	case S_IFREG:		/* file          */
+		yaffs_trace(YAFFS_TRACE_OS, "yaffs_mknod: making file");
+		obj = yaffs_create_file(parent, dentry->d_name.name, mode, uid,
+					gid);
+		break;
+	case S_IFDIR:		/* directory */
+		yaffs_trace(YAFFS_TRACE_OS, "yaffs_mknod: making directory");
+		obj = yaffs_create_dir(parent, dentry->d_name.name, mode,
+				       uid, gid);
+		break;
+	case S_IFLNK:		/* symlink */
+		yaffs_trace(YAFFS_TRACE_OS, "yaffs_mknod: making symlink");
+		obj = NULL;	/* Do we ever get here? */
+		break;
+	}
+
+	/* Can not call yaffs_get_inode() with gross lock held */
+	yaffs_gross_unlock(dev);
+
+	if (obj) {
+		inode = yaffs_get_inode(dir->i_sb, mode, rdev, obj);
+		d_instantiate(dentry, inode);
+		update_dir_time(dir);
+		yaffs_trace(YAFFS_TRACE_OS,
+			"yaffs_mknod created object %d count = %d",
+			obj->obj_id, atomic_read(&inode->i_count));
+		error = 0;
+		yaffs_fill_inode_from_obj(dir, parent);
+	} else {
+		yaffs_trace(YAFFS_TRACE_OS, "yaffs_mknod failed making object");
+		error = -ENOMEM;
+	}
+
+	return error;
+}
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 4, 0))
+static int yaffs_mkdir(struct inode *dir, struct dentry *dentry, umode_t mode)
+#else
+static int yaffs_mkdir(struct inode *dir, struct dentry *dentry, int mode)
+#endif
+{
+	int ret_val;
+	yaffs_trace(YAFFS_TRACE_OS, "yaffs_mkdir");
+	ret_val = yaffs_mknod(dir, dentry, mode | S_IFDIR, 0);
+	return ret_val;
+}
+
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 6, 0))
+static int yaffs_create(struct inode *dir, struct dentry *dentry, umode_t mode,
+			bool dummy)
+#elif (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 4, 0))
+static int yaffs_create(struct inode *dir, struct dentry *dentry, umode_t mode,
+			struct nameidata *n)
+#elif (LINUX_VERSION_CODE > KERNEL_VERSION(2, 5, 0))
+static int yaffs_create(struct inode *dir, struct dentry *dentry, int mode,
+			struct nameidata *n)
+#else
+static int yaffs_create(struct inode *dir, struct dentry *dentry, int mode)
+#endif
+{
+	yaffs_trace(YAFFS_TRACE_OS, "yaffs_create");
+	return yaffs_mknod(dir, dentry, mode | S_IFREG, 0);
+}
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 6, 0))
+static struct dentry *yaffs_lookup(struct inode *dir, struct dentry *dentry,
+				   unsigned int dummy)
+#elif (LINUX_VERSION_CODE > KERNEL_VERSION(2, 5, 0))
+static struct dentry *yaffs_lookup(struct inode *dir, struct dentry *dentry,
+				   struct nameidata *n)
+#else
+static struct dentry *yaffs_lookup(struct inode *dir, struct dentry *dentry)
+#endif
+{
+	struct yaffs_obj *obj;
+	struct inode *inode = NULL;	/* NCB 2.5/2.6 needs NULL here */
+
+	struct yaffs_dev *dev = yaffs_inode_to_obj(dir)->my_dev;
+
+	if (current != yaffs_dev_to_lc(dev)->readdir_process)
+		yaffs_gross_lock(dev);
+
+	yaffs_trace(YAFFS_TRACE_OS, "yaffs_lookup for %d:%s",
+		yaffs_inode_to_obj(dir)->obj_id, dentry->d_name.name);
+
+	obj = yaffs_find_by_name(yaffs_inode_to_obj(dir), dentry->d_name.name);
+
+	obj = yaffs_get_equivalent_obj(obj);	/* in case it was a hardlink */
+
+	/* Can't hold gross lock when calling yaffs_get_inode() */
+	if (current != yaffs_dev_to_lc(dev)->readdir_process)
+		yaffs_gross_unlock(dev);
+
+	if (obj) {
+		yaffs_trace(YAFFS_TRACE_OS,
+			"yaffs_lookup found %d", obj->obj_id);
+
+		inode = yaffs_get_inode(dir->i_sb, obj->yst_mode, 0, obj);
+	} else {
+		yaffs_trace(YAFFS_TRACE_OS, "yaffs_lookup not found");
+
+	}
+
+/* added NCB for 2.5/6 compatability - forces add even if inode is
+ * NULL which creates dentry hash */
+	d_add(dentry, inode);
+
+	return NULL;
+}
+
+/*
+ * Create a link...
+ */
+static int yaffs_link(struct dentry *old_dentry, struct inode *dir,
+		      struct dentry *dentry)
+{
+	struct inode *inode = old_dentry->d_inode;
+	struct yaffs_obj *obj = NULL;
+	struct yaffs_obj *link = NULL;
+	struct yaffs_dev *dev;
+
+	yaffs_trace(YAFFS_TRACE_OS, "yaffs_link");
+
+	obj = yaffs_inode_to_obj(inode);
+	dev = obj->my_dev;
+
+	yaffs_gross_lock(dev);
+
+	if (!S_ISDIR(inode->i_mode))	/* Don't link directories */
+		link =
+		    yaffs_link_obj(yaffs_inode_to_obj(dir), dentry->d_name.name,
+				   obj);
+
+	if (link) {
+		set_nlink(old_dentry->d_inode, yaffs_get_obj_link_count(obj));
+		d_instantiate(dentry, old_dentry->d_inode);
+		atomic_inc(&old_dentry->d_inode->i_count);
+		yaffs_trace(YAFFS_TRACE_OS,
+			"yaffs_link link count %d i_count %d",
+			old_dentry->d_inode->i_nlink,
+			atomic_read(&old_dentry->d_inode->i_count));
+	}
+
+	yaffs_gross_unlock(dev);
+
+	if (link) {
+		update_dir_time(dir);
+		return 0;
+	}
+
+	return -EPERM;
+}
+
+static int yaffs_symlink(struct inode *dir, struct dentry *dentry,
+			 const char *symname)
+{
+	struct yaffs_obj *obj;
+	struct yaffs_dev *dev;
+	uid_t uid = YPROC_uid(current);
+	gid_t gid =
+	    (dir->i_mode & S_ISGID) ? EXTRACT_gid(dir->i_gid) : YPROC_gid(current);
+
+	yaffs_trace(YAFFS_TRACE_OS, "yaffs_symlink");
+
+	if (strnlen(dentry->d_name.name, YAFFS_MAX_NAME_LENGTH + 1) >
+				YAFFS_MAX_NAME_LENGTH)
+		return -ENAMETOOLONG;
+
+	if (strnlen(symname, YAFFS_MAX_ALIAS_LENGTH + 1) >
+				YAFFS_MAX_ALIAS_LENGTH)
+		return -ENAMETOOLONG;
+
+	dev = yaffs_inode_to_obj(dir)->my_dev;
+	yaffs_gross_lock(dev);
+	obj = yaffs_create_symlink(yaffs_inode_to_obj(dir), dentry->d_name.name,
+				   S_IFLNK | S_IRWXUGO, uid, gid, symname);
+	yaffs_gross_unlock(dev);
+
+	if (obj) {
+		struct inode *inode;
+
+		inode = yaffs_get_inode(dir->i_sb, obj->yst_mode, 0, obj);
+		d_instantiate(dentry, inode);
+		update_dir_time(dir);
+		yaffs_trace(YAFFS_TRACE_OS, "symlink created OK");
+		return 0;
+	} else {
+		yaffs_trace(YAFFS_TRACE_OS, "symlink not created");
+	}
+
+	return -ENOMEM;
+}
+
+/*
+ * The VFS layer already does all the dentry stuff for rename.
+ *
+ * NB: POSIX says you can rename an object over an old object of the same name
+ */
+static int yaffs_rename(struct inode *old_dir, struct dentry *old_dentry,
+			struct inode *new_dir, struct dentry *new_dentry)
+{
+	struct yaffs_dev *dev;
+	int ret_val = YAFFS_FAIL;
+	struct yaffs_obj *target;
+
+	yaffs_trace(YAFFS_TRACE_OS, "yaffs_rename");
+	dev = yaffs_inode_to_obj(old_dir)->my_dev;
+
+	yaffs_gross_lock(dev);
+
+	/* Check if the target is an existing directory that is not empty. */
+	target = yaffs_find_by_name(yaffs_inode_to_obj(new_dir),
+				    new_dentry->d_name.name);
+
+	if (target && target->variant_type == YAFFS_OBJECT_TYPE_DIRECTORY &&
+	    !list_empty(&target->variant.dir_variant.children)) {
+
+		yaffs_trace(YAFFS_TRACE_OS, "target is non-empty dir");
+
+		ret_val = YAFFS_FAIL;
+	} else {
+		/* Now does unlinking internally using shadowing mechanism */
+		yaffs_trace(YAFFS_TRACE_OS, "calling yaffs_rename_obj");
+
+		ret_val = yaffs_rename_obj(yaffs_inode_to_obj(old_dir),
+					   old_dentry->d_name.name,
+					   yaffs_inode_to_obj(new_dir),
+					   new_dentry->d_name.name);
+	}
+	yaffs_gross_unlock(dev);
+
+	if (ret_val == YAFFS_OK) {
+		if (target)
+			inode_dec_link_count(new_dentry->d_inode);
+
+		update_dir_time(old_dir);
+		if (old_dir != new_dir)
+			update_dir_time(new_dir);
+		return 0;
+	} else {
+		return -ENOTEMPTY;
+	}
+}
+
+
+
+
+static int yaffs_unlink(struct inode *dir, struct dentry *dentry)
+{
+	int ret_val;
+
+	struct yaffs_dev *dev;
+	struct yaffs_obj *obj;
+
+	yaffs_trace(YAFFS_TRACE_OS, "yaffs_unlink %d:%s",
+		(int)(dir->i_ino), dentry->d_name.name);
+	obj = yaffs_inode_to_obj(dir);
+	dev = obj->my_dev;
+
+	yaffs_gross_lock(dev);
+
+	ret_val = yaffs_unlinker(obj, dentry->d_name.name);
+
+	if (ret_val == YAFFS_OK) {
+		inode_dec_link_count(dentry->d_inode);
+		dir->i_version++;
+		yaffs_gross_unlock(dev);
+		update_dir_time(dir);
+		return 0;
+	}
+	yaffs_gross_unlock(dev);
+	return -ENOTEMPTY;
+}
+
+
+
+static const struct inode_operations yaffs_dir_inode_operations = {
+	.create = yaffs_create,
+	.lookup = yaffs_lookup,
+	.link = yaffs_link,
+	.unlink = yaffs_unlink,
+	.symlink = yaffs_symlink,
+	.mkdir = yaffs_mkdir,
+	.rmdir = yaffs_unlink,
+	.mknod = yaffs_mknod,
+	.rename = yaffs_rename,
+	.setattr = yaffs_setattr,
+	.setxattr = yaffs_setxattr,
+	.getxattr = yaffs_getxattr,
+	.listxattr = yaffs_listxattr,
+	.removexattr = yaffs_removexattr,
+};
+
+/*-----------------------------------------------------------------*/
+/* Directory search context allows us to unlock access to yaffs during
+ * filldir without causing problems with the directory being modified.
+ * This is similar to the tried and tested mechanism used in yaffs direct.
+ *
+ * A search context iterates along a doubly linked list of siblings in the
+ * directory. If the iterating object is deleted then this would corrupt
+ * the list iteration, likely causing a crash. The search context avoids
+ * this by using the remove_obj_fn to move the search context to the
+ * next object before the object is deleted.
+ *
+ * Many readdirs (and thus seach conexts) may be alive simulateously so
+ * each struct yaffs_dev has a list of these.
+ *
+ * A seach context lives for the duration of a readdir.
+ *
+ * All these functions must be called while yaffs is locked.
+ */
+
+struct yaffs_search_context {
+	struct yaffs_dev *dev;
+	struct yaffs_obj *dir_obj;
+	struct yaffs_obj *next_return;
+	struct list_head others;
+};
+
+/*
+ * yaffs_new_search() creates a new search context, initialises it and
+ * adds it to the device's search context list.
+ *
+ * Called at start of readdir.
+ */
+static struct yaffs_search_context *yaffs_new_search(struct yaffs_obj *dir)
+{
+	struct yaffs_dev *dev = dir->my_dev;
+	struct yaffs_search_context *sc =
+	    kmalloc(sizeof(struct yaffs_search_context), GFP_NOFS);
+	if (sc) {
+		sc->dir_obj = dir;
+		sc->dev = dev;
+		if (list_empty(&sc->dir_obj->variant.dir_variant.children))
+			sc->next_return = NULL;
+		else
+			sc->next_return =
+			    list_entry(dir->variant.dir_variant.children.next,
+				       struct yaffs_obj, siblings);
+		INIT_LIST_HEAD(&sc->others);
+		list_add(&sc->others, &(yaffs_dev_to_lc(dev)->search_contexts));
+	}
+	return sc;
+}
+
+/*
+ * yaffs_search_end() disposes of a search context and cleans up.
+ */
+static void yaffs_search_end(struct yaffs_search_context *sc)
+{
+	if (sc) {
+		list_del(&sc->others);
+		kfree(sc);
+	}
+}
+
+/*
+ * yaffs_search_advance() moves a search context to the next object.
+ * Called when the search iterates or when an object removal causes
+ * the search context to be moved to the next object.
+ */
+static void yaffs_search_advance(struct yaffs_search_context *sc)
+{
+	if (!sc)
+		return;
+
+	if (sc->next_return == NULL ||
+	    list_empty(&sc->dir_obj->variant.dir_variant.children))
+		sc->next_return = NULL;
+	else {
+		struct list_head *next = sc->next_return->siblings.next;
+
+		if (next == &sc->dir_obj->variant.dir_variant.children)
+			sc->next_return = NULL;	/* end of list */
+		else
+			sc->next_return =
+			    list_entry(next, struct yaffs_obj, siblings);
+	}
+}
+
+/*
+ * yaffs_remove_obj_callback() is called when an object is unlinked.
+ * We check open search contexts and advance any which are currently
+ * on the object being iterated.
+ */
+static void yaffs_remove_obj_callback(struct yaffs_obj *obj)
+{
+
+	struct list_head *i;
+	struct yaffs_search_context *sc;
+	struct list_head *search_contexts =
+	    &(yaffs_dev_to_lc(obj->my_dev)->search_contexts);
+
+	/* Iterate through the directory search contexts.
+	 * If any are currently on the object being removed, then advance
+	 * the search context to the next object to prevent a hanging pointer.
+	 */
+	list_for_each(i, search_contexts) {
+		sc = list_entry(i, struct yaffs_search_context, others);
+		if (sc->next_return == obj)
+			yaffs_search_advance(sc);
+	}
+
+}
+
+
+/*-----------------------------------------------------------------*/
+
+#ifdef YAFFS_USE_DIR_ITERATE
+static int yaffs_iterate(struct file *f, struct dir_context *dc)
+{
+	struct yaffs_obj *obj;
+	struct yaffs_dev *dev;
+	struct yaffs_search_context *sc;
+	unsigned long curoffs;
+	struct yaffs_obj *l;
+	int ret_val = 0;
+
+	char name[YAFFS_MAX_NAME_LENGTH + 1];
+
+	obj = yaffs_dentry_to_obj(f->f_dentry);
+	dev = obj->my_dev;
+
+	yaffs_gross_lock(dev);
+
+	yaffs_dev_to_lc(dev)->readdir_process = current;
+
+	sc = yaffs_new_search(obj);
+	if (!sc) {
+		ret_val = -ENOMEM;
+		goto out;
+	}
+
+	if (!dir_emit_dots(f, dc))
+		return 0;
+
+	curoffs = 1;
+
+	while (sc->next_return) {
+		curoffs++;
+		l = sc->next_return;
+		if (curoffs >= dc->pos) {
+			int this_inode = yaffs_get_obj_inode(l);
+			int this_type = yaffs_get_obj_type(l);
+
+			yaffs_get_obj_name(l, name, YAFFS_MAX_NAME_LENGTH + 1);
+			yaffs_trace(YAFFS_TRACE_OS,
+				"yaffs_readdir: %s inode %d",
+				name, yaffs_get_obj_inode(l));
+
+			yaffs_gross_unlock(dev);
+
+			if (!dir_emit(dc,
+				      name,
+				      strlen(name),
+				      this_inode,
+				      this_type)) {
+				yaffs_gross_lock(dev);
+				goto out;
+			}
+
+			yaffs_gross_lock(dev);
+
+			dc->pos++;
+			f->f_pos++;
+		}
+		yaffs_search_advance(sc);
+	}
+
+out:
+	yaffs_search_end(sc);
+	yaffs_dev_to_lc(dev)->readdir_process = NULL;
+	yaffs_gross_unlock(dev);
+
+	return ret_val;
+}
+
+#else
+
+static int yaffs_readdir(struct file *f, void *dirent, filldir_t filldir)
+{
+	struct yaffs_obj *obj;
+	struct yaffs_dev *dev;
+	struct yaffs_search_context *sc;
+	struct inode *inode = f->f_dentry->d_inode;
+	unsigned long offset, curoffs;
+	struct yaffs_obj *l;
+	int ret_val = 0;
+
+	char name[YAFFS_MAX_NAME_LENGTH + 1];
+
+	obj = yaffs_dentry_to_obj(f->f_dentry);
+	dev = obj->my_dev;
+
+	yaffs_gross_lock(dev);
+
+	yaffs_dev_to_lc(dev)->readdir_process = current;
+
+	offset = f->f_pos;
+
+	sc = yaffs_new_search(obj);
+	if (!sc) {
+		ret_val = -ENOMEM;
+		goto out;
+	}
+
+	yaffs_trace(YAFFS_TRACE_OS,
+		"yaffs_readdir: starting at %d", (int)offset);
+
+	if (offset == 0) {
+		yaffs_trace(YAFFS_TRACE_OS,
+			"yaffs_readdir: entry . ino %d",
+			(int)inode->i_ino);
+		yaffs_gross_unlock(dev);
+		if (filldir(dirent, ".", 1, offset, inode->i_ino, DT_DIR) < 0) {
+			yaffs_gross_lock(dev);
+			goto out;
+		}
+		yaffs_gross_lock(dev);
+		offset++;
+		f->f_pos++;
+	}
+	if (offset == 1) {
+		yaffs_trace(YAFFS_TRACE_OS,
+			"yaffs_readdir: entry .. ino %d",
+			(int)f->f_dentry->d_parent->d_inode->i_ino);
+		yaffs_gross_unlock(dev);
+		if (filldir(dirent, "..", 2, offset,
+			    f->f_dentry->d_parent->d_inode->i_ino,
+			    DT_DIR) < 0) {
+			yaffs_gross_lock(dev);
+			goto out;
+		}
+		yaffs_gross_lock(dev);
+		offset++;
+		f->f_pos++;
+	}
+
+	curoffs = 1;
+
+	/* If the directory has changed since the open or last call to
+	   readdir, rewind to after the 2 canned entries. */
+	if (f->f_version != inode->i_version) {
+		offset = 2;
+		f->f_pos = offset;
+		f->f_version = inode->i_version;
+	}
+
+	while (sc->next_return) {
+		curoffs++;
+		l = sc->next_return;
+		if (curoffs >= offset) {
+			int this_inode = yaffs_get_obj_inode(l);
+			int this_type = yaffs_get_obj_type(l);
+
+			yaffs_get_obj_name(l, name, YAFFS_MAX_NAME_LENGTH + 1);
+			yaffs_trace(YAFFS_TRACE_OS,
+				"yaffs_readdir: %s inode %d",
+				name, yaffs_get_obj_inode(l));
+
+			yaffs_gross_unlock(dev);
+
+			if (filldir(dirent,
+				    name,
+				    strlen(name),
+				    offset, this_inode, this_type) < 0) {
+				yaffs_gross_lock(dev);
+				goto out;
+			}
+
+			yaffs_gross_lock(dev);
+
+			offset++;
+			f->f_pos++;
+		}
+		yaffs_search_advance(sc);
+	}
+
+out:
+	yaffs_search_end(sc);
+	yaffs_dev_to_lc(dev)->readdir_process = NULL;
+	yaffs_gross_unlock(dev);
+
+	return ret_val;
+}
+
+#endif
+
+static const struct file_operations yaffs_dir_operations = {
+	.read = generic_read_dir,
+#ifdef YAFFS_USE_DIR_ITERATE
+	.iterate = yaffs_iterate,
+#else
+	.readdir = yaffs_readdir,
+#endif
+	.fsync = yaffs_sync_object,
+	.llseek = generic_file_llseek,
+};
+
+static void yaffs_fill_inode_from_obj(struct inode *inode,
+				      struct yaffs_obj *obj)
+{
+	if (inode && obj) {
+
+		/* Check mode against the variant type and attempt to repair if broken. */
+		u32 mode = obj->yst_mode;
+		switch (obj->variant_type) {
+		case YAFFS_OBJECT_TYPE_FILE:
+			if (!S_ISREG(mode)) {
+				obj->yst_mode &= ~S_IFMT;
+				obj->yst_mode |= S_IFREG;
+			}
+
+			break;
+		case YAFFS_OBJECT_TYPE_SYMLINK:
+			if (!S_ISLNK(mode)) {
+				obj->yst_mode &= ~S_IFMT;
+				obj->yst_mode |= S_IFLNK;
+			}
+
+			break;
+		case YAFFS_OBJECT_TYPE_DIRECTORY:
+			if (!S_ISDIR(mode)) {
+				obj->yst_mode &= ~S_IFMT;
+				obj->yst_mode |= S_IFDIR;
+			}
+
+			break;
+		case YAFFS_OBJECT_TYPE_UNKNOWN:
+		case YAFFS_OBJECT_TYPE_HARDLINK:
+		case YAFFS_OBJECT_TYPE_SPECIAL:
+		default:
+			/* TODO? */
+			break;
+		}
+
+		inode->i_flags |= S_NOATIME;
+
+		inode->i_ino = obj->obj_id;
+		inode->i_mode = obj->yst_mode;
+		inode->i_uid = MAKE_uid(obj->yst_uid);
+		inode->i_gid = MAKE_gid(obj->yst_gid);
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 19))
+		inode->i_blksize = inode->i_sb->s_blocksize;
+#endif
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 5, 0))
+
+		inode->i_rdev = old_decode_dev(obj->yst_rdev);
+		inode->i_atime.tv_sec = (time_t) (obj->yst_atime);
+		inode->i_atime.tv_nsec = 0;
+		inode->i_mtime.tv_sec = (time_t) obj->yst_mtime;
+		inode->i_mtime.tv_nsec = 0;
+		inode->i_ctime.tv_sec = (time_t) obj->yst_ctime;
+		inode->i_ctime.tv_nsec = 0;
+#else
+		inode->i_rdev = obj->yst_rdev;
+		inode->i_atime = obj->yst_atime;
+		inode->i_mtime = obj->yst_mtime;
+		inode->i_ctime = obj->yst_ctime;
+#endif
+		inode->i_size = yaffs_get_obj_length(obj);
+		inode->i_blocks = (inode->i_size + 511) >> 9;
+
+		set_nlink(inode, yaffs_get_obj_link_count(obj));
+
+		yaffs_trace(YAFFS_TRACE_OS,
+			"yaffs_fill_inode mode %x uid %d gid %d size %lld count %d",
+			inode->i_mode, obj->yst_uid, obj->yst_gid,
+			inode->i_size, atomic_read(&inode->i_count));
+
+		switch (obj->yst_mode & S_IFMT) {
+		default:	/* fifo, device or socket */
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 5, 0))
+			init_special_inode(inode, obj->yst_mode,
+					   old_decode_dev(obj->yst_rdev));
+#else
+			init_special_inode(inode, obj->yst_mode,
+					   (dev_t) (obj->yst_rdev));
+#endif
+			break;
+		case S_IFREG:	/* file */
+			inode->i_op = &yaffs_file_inode_operations;
+			inode->i_fop = &yaffs_file_operations;
+			inode->i_mapping->a_ops =
+			    &yaffs_file_address_operations;
+			break;
+		case S_IFDIR:	/* directory */
+			inode->i_op = &yaffs_dir_inode_operations;
+			inode->i_fop = &yaffs_dir_operations;
+			break;
+		case S_IFLNK:	/* symlink */
+			inode->i_op = &yaffs_symlink_inode_operations;
+			break;
+		}
+
+		yaffs_inode_to_obj_lv(inode) = obj;
+
+		obj->my_inode = inode;
+
+	} else {
+		yaffs_trace(YAFFS_TRACE_OS,
+			"yaffs_fill_inode invalid parameters");
+	}
+
+}
+
+
+
+/*
+ * yaffs background thread functions .
+ * yaffs_bg_thread_fn() the thread function
+ * yaffs_bg_start() launches the background thread.
+ * yaffs_bg_stop() cleans up the background thread.
+ *
+ * NB:
+ * The thread should only run after the yaffs is initialised
+ * The thread should be stopped before yaffs is unmounted.
+ * The thread should not do any writing while the fs is in read only.
+ */
+
+static unsigned yaffs_bg_gc_urgency(struct yaffs_dev *dev)
+{
+	unsigned erased_chunks =
+	    dev->n_erased_blocks * dev->param.chunks_per_block;
+	struct yaffs_linux_context *context = yaffs_dev_to_lc(dev);
+	unsigned scattered = 0;	/* Free chunks not in an erased block */
+
+	if (erased_chunks < dev->n_free_chunks)
+		scattered = (dev->n_free_chunks - erased_chunks);
+
+	if (!context->bg_running)
+		return 0;
+	else if (scattered < (dev->param.chunks_per_block * 2))
+		return 0;
+	else if (erased_chunks > dev->n_free_chunks / 2)
+		return 0;
+	else if (erased_chunks > dev->n_free_chunks / 4)
+		return 1;
+	else
+		return 2;
+}
+
+#ifdef YAFFS_COMPILE_BACKGROUND
+
+void yaffs_background_waker(unsigned long data)
+{
+	wake_up_process((struct task_struct *)data);
+}
+
+static int yaffs_bg_thread_fn(void *data)
+{
+	struct yaffs_dev *dev = (struct yaffs_dev *)data;
+	struct yaffs_linux_context *context = yaffs_dev_to_lc(dev);
+	unsigned long now = jiffies;
+	unsigned long next_dir_update = now;
+	unsigned long next_gc = now;
+	unsigned long expires;
+	unsigned int urgency;
+
+	int gc_result;
+	struct timer_list timer;
+
+	yaffs_trace(YAFFS_TRACE_BACKGROUND,
+		"yaffs_background starting for dev %p", (void *)dev);
+
+#ifdef YAFFS_COMPILE_FREEZER
+	set_freezable();
+#endif
+	while (context->bg_running) {
+		yaffs_trace(YAFFS_TRACE_BACKGROUND, "yaffs_background");
+
+		if (kthread_should_stop())
+			break;
+
+#ifdef YAFFS_COMPILE_FREEZER
+		if (try_to_freeze())
+			continue;
+#endif
+		yaffs_gross_lock(dev);
+
+		now = jiffies;
+
+		if (time_after(now, next_dir_update) && yaffs_bg_enable) {
+			yaffs_update_dirty_dirs(dev);
+			next_dir_update = now + HZ;
+		}
+
+		if (time_after(now, next_gc) && yaffs_bg_enable) {
+			if (!dev->is_checkpointed) {
+				urgency = yaffs_bg_gc_urgency(dev);
+				gc_result = yaffs_bg_gc(dev, urgency);
+				if (urgency > 1)
+					next_gc = now + HZ / 20 + 1;
+				else if (urgency > 0)
+					next_gc = now + HZ / 10 + 1;
+				else
+					next_gc = now + HZ * 2;
+			} else	{
+			        /*
+				 * gc not running so set to next_dir_update
+				 * to cut down on wake ups
+				 */
+				next_gc = next_dir_update;
+                        }
+		}
+		yaffs_gross_unlock(dev);
+#if 1
+		expires = next_dir_update;
+		if (time_before(next_gc, expires))
+			expires = next_gc;
+		if (time_before(expires, now))
+			expires = now + HZ;
+
+		Y_INIT_TIMER(&timer);
+		timer.expires = expires + 1;
+		timer.data = (unsigned long)current;
+		timer.function = yaffs_background_waker;
+
+		set_current_state(TASK_INTERRUPTIBLE);
+		add_timer(&timer);
+		schedule();
+		del_timer_sync(&timer);
+#else
+		msleep(10);
+#endif
+	}
+
+	return 0;
+}
+
+static int yaffs_bg_start(struct yaffs_dev *dev)
+{
+	int retval = 0;
+	struct yaffs_linux_context *context = yaffs_dev_to_lc(dev);
+
+	if (dev->read_only)
+		return -1;
+
+	context->bg_running = 1;
+
+	context->bg_thread = kthread_run(yaffs_bg_thread_fn,
+					 (void *)dev, "yaffs-bg-%d",
+					 context->mount_id);
+
+	if (IS_ERR(context->bg_thread)) {
+		retval = PTR_ERR(context->bg_thread);
+		context->bg_thread = NULL;
+		context->bg_running = 0;
+	}
+	return retval;
+}
+
+static void yaffs_bg_stop(struct yaffs_dev *dev)
+{
+	struct yaffs_linux_context *ctxt = yaffs_dev_to_lc(dev);
+
+	ctxt->bg_running = 0;
+
+	if (ctxt->bg_thread) {
+		kthread_stop(ctxt->bg_thread);
+		ctxt->bg_thread = NULL;
+	}
+}
+#else
+static int yaffs_bg_thread_fn(void *data)
+{
+	return 0;
+}
+
+static int yaffs_bg_start(struct yaffs_dev *dev)
+{
+	return 0;
+}
+
+static void yaffs_bg_stop(struct yaffs_dev *dev)
+{
+}
+#endif
+
+
+static void yaffs_flush_inodes(struct super_block *sb)
+{
+	struct inode *iptr;
+	struct yaffs_obj *obj;
+
+	list_for_each_entry(iptr, &sb->s_inodes, i_sb_list) {
+		obj = yaffs_inode_to_obj(iptr);
+		if (obj) {
+			yaffs_trace(YAFFS_TRACE_OS,
+				"flushing obj %d",
+				obj->obj_id);
+			yaffs_flush_file(obj, 1, 0, 0);
+		}
+	}
+}
+
+static void yaffs_flush_super(struct super_block *sb, int do_checkpoint)
+{
+	struct yaffs_dev *dev = yaffs_super_to_dev(sb);
+	if (!dev)
+		return;
+
+	yaffs_flush_inodes(sb);
+	yaffs_update_dirty_dirs(dev);
+	yaffs_flush_whole_cache(dev, 1);
+	if (do_checkpoint)
+		yaffs_checkpoint_save(dev);
+}
+
+static LIST_HEAD(yaffs_context_list);
+struct mutex yaffs_context_lock;
+
+static void yaffs_put_super(struct super_block *sb)
+{
+	struct yaffs_dev *dev = yaffs_super_to_dev(sb);
+	struct mtd_info *mtd = yaffs_dev_to_mtd(dev);
+
+	yaffs_trace(YAFFS_TRACE_OS | YAFFS_TRACE_ALWAYS,
+			"yaffs_put_super");
+
+	yaffs_trace(YAFFS_TRACE_OS | YAFFS_TRACE_BACKGROUND,
+		"Shutting down yaffs background thread");
+	yaffs_bg_stop(dev);
+	yaffs_trace(YAFFS_TRACE_OS | YAFFS_TRACE_BACKGROUND,
+		"yaffs background thread shut down");
+
+	yaffs_gross_lock(dev);
+
+	yaffs_flush_super(sb, 1);
+
+	yaffs_deinitialise(dev);
+
+	yaffs_gross_unlock(dev);
+
+	mutex_lock(&yaffs_context_lock);
+	list_del_init(&(yaffs_dev_to_lc(dev)->context_list));
+	mutex_unlock(&yaffs_context_lock);
+
+	if (yaffs_dev_to_lc(dev)->spare_buffer) {
+		kfree(yaffs_dev_to_lc(dev)->spare_buffer);
+		yaffs_dev_to_lc(dev)->spare_buffer = NULL;
+	}
+
+	kfree(dev);
+
+	yaffs_put_mtd_device(mtd);
+
+	yaffs_trace(YAFFS_TRACE_OS | YAFFS_TRACE_ALWAYS,
+			"yaffs_put_super done");
+}
+
+
+static unsigned yaffs_gc_control_callback(struct yaffs_dev *dev)
+{
+	return yaffs_gc_control;
+}
+
+
+#ifdef YAFFS_COMPILE_EXPORTFS
+
+static struct inode *yaffs2_nfs_get_inode(struct super_block *sb, uint64_t ino,
+					  uint32_t generation)
+{
+	return Y_IGET(sb, ino);
+}
+
+static struct dentry *yaffs2_fh_to_dentry(struct super_block *sb,
+					  struct fid *fid, int fh_len,
+					  int fh_type)
+{
+	return generic_fh_to_dentry(sb, fid, fh_len, fh_type,
+				    yaffs2_nfs_get_inode);
+}
+
+static struct dentry *yaffs2_fh_to_parent(struct super_block *sb,
+					  struct fid *fid, int fh_len,
+					  int fh_type)
+{
+	return generic_fh_to_parent(sb, fid, fh_len, fh_type,
+				    yaffs2_nfs_get_inode);
+}
+
+struct dentry *yaffs2_get_parent(struct dentry *dentry)
+{
+
+	struct super_block *sb = dentry->d_inode->i_sb;
+	struct dentry *parent = ERR_PTR(-ENOENT);
+	struct inode *inode;
+	unsigned long parent_ino;
+	struct yaffs_obj *d_obj;
+	struct yaffs_obj *parent_obj;
+
+	d_obj = yaffs_inode_to_obj(dentry->d_inode);
+
+	if (d_obj) {
+		parent_obj = d_obj->parent;
+		if (parent_obj) {
+			parent_ino = yaffs_get_obj_inode(parent_obj);
+			inode = Y_IGET(sb, parent_ino);
+
+			if (IS_ERR(inode)) {
+				parent = ERR_CAST(inode);
+			} else {
+				parent = d_obtain_alias(inode);
+				if (!IS_ERR(parent)) {
+					parent = ERR_PTR(-ENOMEM);
+					iput(inode);
+				}
+			}
+		}
+	}
+
+	return parent;
+}
+
+/* Just declare a zero structure as a NULL value implies
+ * using the default functions of exportfs.
+ */
+
+static struct export_operations yaffs_export_ops = {
+	.fh_to_dentry = yaffs2_fh_to_dentry,
+	.fh_to_parent = yaffs2_fh_to_parent,
+	.get_parent = yaffs2_get_parent,
+};
+
+#endif
+
+static void yaffs_unstitch_obj(struct inode *inode, struct yaffs_obj *obj)
+{
+	/* Clear the association between the inode and
+	 * the struct yaffs_obj.
+	 */
+	obj->my_inode = NULL;
+	yaffs_inode_to_obj_lv(inode) = NULL;
+
+	/* If the object freeing was deferred, then the real
+	 * free happens now.
+	 * This should fix the inode inconsistency problem.
+	 */
+	yaffs_handle_defered_free(obj);
+}
+
+#ifdef YAFFS_HAS_EVICT_INODE
+/* yaffs_evict_inode combines into one operation what was previously done in
+ * yaffs_clear_inode() and yaffs_delete_inode()
+ *
+ */
+static void yaffs_evict_inode(struct inode *inode)
+{
+	struct yaffs_obj *obj;
+	struct yaffs_dev *dev;
+	int deleteme = 0;
+
+	obj = yaffs_inode_to_obj(inode);
+
+	yaffs_trace(YAFFS_TRACE_OS,
+		"yaffs_evict_inode: ino %d, count %d %s",
+		(int)inode->i_ino, atomic_read(&inode->i_count),
+		obj ? "object exists" : "null object");
+
+	if (!inode->i_nlink && !is_bad_inode(inode))
+		deleteme = 1;
+	truncate_inode_pages(&inode->i_data, 0);
+	Y_CLEAR_INODE(inode);
+
+	if (deleteme && obj) {
+		dev = obj->my_dev;
+		yaffs_gross_lock(dev);
+		yaffs_del_obj(obj);
+		yaffs_gross_unlock(dev);
+	}
+	if (obj) {
+		dev = obj->my_dev;
+		yaffs_gross_lock(dev);
+		yaffs_unstitch_obj(inode, obj);
+		yaffs_gross_unlock(dev);
+	}
+}
+#else
+
+/* clear is called to tell the fs to release any per-inode data it holds.
+ * The object might still exist on disk and is just being thrown out of the cache
+ * or else the object has actually been deleted and we're being called via
+ * the chain
+ *   yaffs_delete_inode() -> clear_inode()->yaffs_clear_inode()
+ */
+
+static void yaffs_clear_inode(struct inode *inode)
+{
+	struct yaffs_obj *obj;
+	struct yaffs_dev *dev;
+
+	obj = yaffs_inode_to_obj(inode);
+
+	yaffs_trace(YAFFS_TRACE_OS,
+		"yaffs_clear_inode: ino %d, count %d %s",
+		(int)inode->i_ino, atomic_read(&inode->i_count),
+		obj ? "object exists" : "null object");
+
+	if (obj) {
+		dev = obj->my_dev;
+		yaffs_gross_lock(dev);
+		yaffs_unstitch_obj(inode, obj);
+		yaffs_gross_unlock(dev);
+	}
+
+}
+
+/* delete is called when the link count is zero and the inode
+ * is put (ie. nobody wants to know about it anymore, time to
+ * delete the file).
+ * NB Must call clear_inode()
+ */
+static void yaffs_delete_inode(struct inode *inode)
+{
+	struct yaffs_obj *obj = yaffs_inode_to_obj(inode);
+	struct yaffs_dev *dev;
+
+	yaffs_trace(YAFFS_TRACE_OS,
+		"yaffs_delete_inode: ino %d, count %d %s",
+		(int)inode->i_ino, atomic_read(&inode->i_count),
+		obj ? "object exists" : "null object");
+
+	if (obj) {
+		dev = obj->my_dev;
+		yaffs_gross_lock(dev);
+		yaffs_del_obj(obj);
+		yaffs_gross_unlock(dev);
+	}
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 13))
+	truncate_inode_pages(&inode->i_data, 0);
+#endif
+	clear_inode(inode);
+}
+#endif
+
+
+
+
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 17))
+static int yaffs_statfs(struct dentry *dentry, struct kstatfs *buf)
+{
+	struct yaffs_dev *dev = yaffs_dentry_to_obj(dentry)->my_dev;
+	struct super_block *sb = dentry->d_sb;
+#elif (LINUX_VERSION_CODE > KERNEL_VERSION(2, 5, 0))
+static int yaffs_statfs(struct super_block *sb, struct kstatfs *buf)
+{
+	struct yaffs_dev *dev = yaffs_super_to_dev(sb);
+#else
+static int yaffs_statfs(struct super_block *sb, struct statfs *buf)
+{
+	struct yaffs_dev *dev = yaffs_super_to_dev(sb);
+#endif
+
+	yaffs_trace(YAFFS_TRACE_OS, "yaffs_statfs");
+
+	yaffs_gross_lock(dev);
+
+	buf->f_type = YAFFS_MAGIC;
+	buf->f_bsize = sb->s_blocksize;
+	buf->f_namelen = 255;
+
+	if (dev->data_bytes_per_chunk & (dev->data_bytes_per_chunk - 1)) {
+		/* Do this if chunk size is not a power of 2 */
+
+		uint64_t bytes_in_dev;
+		uint64_t bytes_free;
+
+		bytes_in_dev =
+		    ((uint64_t)
+		     ((dev->param.end_block - dev->param.start_block +
+		       1))) * ((uint64_t) (dev->param.chunks_per_block *
+					   dev->data_bytes_per_chunk));
+
+		do_div(bytes_in_dev, sb->s_blocksize);	/* bytes_in_dev becomes the number of blocks */
+		buf->f_blocks = bytes_in_dev;
+
+		bytes_free = ((uint64_t) (yaffs_get_n_free_chunks(dev))) *
+		    ((uint64_t) (dev->data_bytes_per_chunk));
+
+		do_div(bytes_free, sb->s_blocksize);
+
+		buf->f_bfree = bytes_free;
+
+	} else if (sb->s_blocksize > dev->data_bytes_per_chunk) {
+
+		buf->f_blocks =
+		    (dev->param.end_block - dev->param.start_block + 1) *
+		    dev->param.chunks_per_block /
+		    (sb->s_blocksize / dev->data_bytes_per_chunk);
+		buf->f_bfree =
+		    yaffs_get_n_free_chunks(dev) /
+		    (sb->s_blocksize / dev->data_bytes_per_chunk);
+	} else {
+		buf->f_blocks =
+		    (dev->param.end_block - dev->param.start_block + 1) *
+		    dev->param.chunks_per_block *
+		    (dev->data_bytes_per_chunk / sb->s_blocksize);
+
+		buf->f_bfree =
+		    yaffs_get_n_free_chunks(dev) *
+		    (dev->data_bytes_per_chunk / sb->s_blocksize);
+	}
+
+	buf->f_files = 0;
+	buf->f_ffree = 0;
+	buf->f_bavail = buf->f_bfree;
+
+	yaffs_gross_unlock(dev);
+	return 0;
+}
+
+
+
+static int yaffs_do_sync_fs(struct super_block *sb, int request_checkpoint)
+{
+
+	struct yaffs_dev *dev = yaffs_super_to_dev(sb);
+	unsigned int oneshot_checkpoint = (yaffs_auto_checkpoint & 4);
+	unsigned gc_urgent = yaffs_bg_gc_urgency(dev);
+	int do_checkpoint;
+	int dirty = yaffs_check_super_dirty(dev);
+
+	yaffs_trace(YAFFS_TRACE_OS | YAFFS_TRACE_SYNC | YAFFS_TRACE_BACKGROUND,
+		"yaffs_do_sync_fs: gc-urgency %d %s %s%s",
+		gc_urgent,
+		dirty ? "dirty" : "clean",
+		request_checkpoint ? "checkpoint requested" : "no checkpoint",
+		oneshot_checkpoint ? " one-shot" : "");
+
+	yaffs_gross_lock(dev);
+	do_checkpoint = ((request_checkpoint && !gc_urgent) ||
+			 oneshot_checkpoint) && !dev->is_checkpointed;
+
+	if (dirty || do_checkpoint) {
+		yaffs_flush_super(sb, !dev->is_checkpointed && do_checkpoint);
+		yaffs_clear_super_dirty(dev);
+		if (oneshot_checkpoint)
+			yaffs_auto_checkpoint &= ~4;
+	}
+	yaffs_gross_unlock(dev);
+
+	return 0;
+}
+
+
+#ifdef YAFFS_HAS_WRITE_SUPER
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 17))
+static void yaffs_write_super(struct super_block *sb)
+#else
+static int yaffs_write_super(struct super_block *sb)
+#endif
+{
+	unsigned request_checkpoint = (yaffs_auto_checkpoint >= 2);
+
+	yaffs_trace(YAFFS_TRACE_OS | YAFFS_TRACE_SYNC | YAFFS_TRACE_BACKGROUND,
+		"yaffs_write_super %s",
+		request_checkpoint ? " checkpt" : "");
+
+	yaffs_do_sync_fs(sb, request_checkpoint);
+
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 18))
+	return 0;
+#endif
+}
+#endif
+
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 17))
+static int yaffs_sync_fs(struct super_block *sb, int wait)
+#else
+static int yaffs_sync_fs(struct super_block *sb)
+#endif
+{
+	unsigned request_checkpoint = (yaffs_auto_checkpoint >= 1);
+
+	yaffs_trace(YAFFS_TRACE_OS | YAFFS_TRACE_SYNC,
+		"yaffs_sync_fs%s", request_checkpoint ? " checkpt" : "");
+
+	yaffs_do_sync_fs(sb, request_checkpoint);
+
+	return 0;
+}
+
+/* the function only is used to change dev->read_only when this file system
+ * is remounted.
+ */
+static int yaffs_remount_fs(struct super_block *sb, int *flags, char *data)
+{
+	int read_only = 0;
+	struct mtd_info *mtd;
+	struct yaffs_dev *dev = 0;
+
+	/* Get the device */
+	mtd = get_mtd_device(NULL, MINOR(sb->s_dev));
+	if (!mtd) {
+		yaffs_trace(YAFFS_TRACE_ALWAYS,
+			"MTD device #%u doesn't appear to exist",
+			MINOR(sb->s_dev));
+		return 1;
+	}
+
+	/* Check it's NAND */
+	if (mtd->type != MTD_NANDFLASH) {
+		yaffs_trace(YAFFS_TRACE_ALWAYS,
+			"MTD device is not NAND it's type %d",
+			mtd->type);
+		return 1;
+	}
+
+	read_only = ((*flags & MS_RDONLY) != 0);
+	if (!read_only && !(mtd->flags & MTD_WRITEABLE)) {
+		read_only = 1;
+		printk(KERN_INFO
+			"yaffs: mtd is read only, setting superblock read only");
+		*flags |= MS_RDONLY;
+	}
+
+	dev = sb->s_fs_info;
+	dev->read_only = read_only;
+
+	return 0;
+}
+
+static const struct super_operations yaffs_super_ops = {
+	.statfs = yaffs_statfs,
+
+#ifndef YAFFS_USE_OWN_IGET
+	.read_inode = yaffs_read_inode,
+#endif
+#ifdef YAFFS_HAS_PUT_INODE
+	.put_inode = yaffs_put_inode,
+#endif
+	.put_super = yaffs_put_super,
+#ifdef YAFFS_HAS_EVICT_INODE
+	.evict_inode = yaffs_evict_inode,
+#else
+	.delete_inode = yaffs_delete_inode,
+	.clear_inode = yaffs_clear_inode,
+#endif
+	.sync_fs = yaffs_sync_fs,
+#ifdef YAFFS_HAS_WRITE_SUPER
+	.write_super = yaffs_write_super,
+#endif
+	.remount_fs = yaffs_remount_fs,
+};
+
+struct yaffs_options {
+	int inband_tags;
+	int skip_checkpoint_read;
+	int skip_checkpoint_write;
+	int no_cache;
+	int tags_ecc_on;
+	int tags_ecc_overridden;
+	int lazy_loading_enabled;
+	int lazy_loading_overridden;
+	int empty_lost_and_found;
+	int empty_lost_and_found_overridden;
+	int disable_summary;
+};
+
+#define MAX_OPT_LEN 30
+static int yaffs_parse_options(struct yaffs_options *options,
+			       const char *options_str)
+{
+	char cur_opt[MAX_OPT_LEN + 1];
+	int p;
+	int error = 0;
+
+	/* Parse through the options which is a comma seperated list */
+
+	while (options_str && *options_str && !error) {
+		memset(cur_opt, 0, MAX_OPT_LEN + 1);
+		p = 0;
+
+		while (*options_str == ',')
+			options_str++;
+
+		while (*options_str && *options_str != ',') {
+			if (p < MAX_OPT_LEN) {
+				cur_opt[p] = *options_str;
+				p++;
+			}
+			options_str++;
+		}
+
+		if (!strcmp(cur_opt, "inband-tags")) {
+			options->inband_tags = 1;
+		} else if (!strcmp(cur_opt, "tags-ecc-off")) {
+			options->tags_ecc_on = 0;
+			options->tags_ecc_overridden = 1;
+		} else if (!strcmp(cur_opt, "tags-ecc-on")) {
+			options->tags_ecc_on = 1;
+			options->tags_ecc_overridden = 1;
+		} else if (!strcmp(cur_opt, "lazy-loading-off")) {
+			options->lazy_loading_enabled = 0;
+			options->lazy_loading_overridden = 1;
+		} else if (!strcmp(cur_opt, "lazy-loading-on")) {
+			options->lazy_loading_enabled = 1;
+			options->lazy_loading_overridden = 1;
+		} else if (!strcmp(cur_opt, "disable-summary")) {
+			options->disable_summary = 1;
+		} else if (!strcmp(cur_opt, "empty-lost-and-found-off")) {
+			options->empty_lost_and_found = 0;
+			options->empty_lost_and_found_overridden = 1;
+		} else if (!strcmp(cur_opt, "empty-lost-and-found-on")) {
+			options->empty_lost_and_found = 1;
+			options->empty_lost_and_found_overridden = 1;
+		} else if (!strcmp(cur_opt, "no-cache")) {
+			options->no_cache = 1;
+		} else if (!strcmp(cur_opt, "no-checkpoint-read")) {
+			options->skip_checkpoint_read = 1;
+		} else if (!strcmp(cur_opt, "no-checkpoint-write")) {
+			options->skip_checkpoint_write = 1;
+		} else if (!strcmp(cur_opt, "no-checkpoint")) {
+			options->skip_checkpoint_read = 1;
+			options->skip_checkpoint_write = 1;
+		} else {
+			printk(KERN_INFO "yaffs: Bad mount option \"%s\"\n",
+			       cur_opt);
+			error = 1;
+		}
+	}
+
+	return error;
+}
+
+
+static struct dentry *yaffs_make_root(struct inode *inode)
+{
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(3, 4, 0))
+	struct dentry *root = d_alloc_root(inode);
+
+	if (!root)
+		iput(inode);
+
+        return root;
+#else
+        return d_make_root(inode);
+#endif
+}
+
+
+
+
+static struct super_block *yaffs_internal_read_super(int yaffs_version,
+						     struct super_block *sb,
+						     void *data, int silent)
+{
+	int n_blocks;
+	struct inode *inode = NULL;
+	struct dentry *root;
+	struct yaffs_dev *dev = 0;
+	char devname_buf[BDEVNAME_SIZE + 1];
+	struct mtd_info *mtd;
+	int err;
+	char *data_str = (char *)data;
+	struct yaffs_linux_context *context = NULL;
+	struct yaffs_param *param;
+
+	int read_only = 0;
+	int inband_tags = 0;
+
+	struct yaffs_options options;
+
+	unsigned mount_id;
+	int found;
+	struct yaffs_linux_context *context_iterator;
+	struct list_head *l;
+
+	if (!sb) {
+		printk(KERN_INFO "yaffs: sb is NULL\n");
+		return NULL;
+        }
+
+	sb->s_magic = YAFFS_MAGIC;
+	sb->s_op = &yaffs_super_ops;
+	sb->s_flags |= MS_NOATIME;
+
+	read_only = ((sb->s_flags & MS_RDONLY) != 0);
+
+#ifdef YAFFS_COMPILE_EXPORTFS
+	sb->s_export_op = &yaffs_export_ops;
+#endif
+
+	if (!sb->s_dev)
+		printk(KERN_INFO "yaffs: sb->s_dev is NULL\n");
+	else if (!yaffs_devname(sb, devname_buf))
+		printk(KERN_INFO "yaffs: devname is NULL\n");
+	else
+		printk(KERN_INFO "yaffs: dev is %d name is \"%s\" %s\n",
+		       sb->s_dev,
+		       yaffs_devname(sb, devname_buf), read_only ? "ro" : "rw");
+
+	if (!data_str)
+		data_str = "";
+
+	printk(KERN_INFO "yaffs: passed flags \"%s\"\n", data_str);
+
+	memset(&options, 0, sizeof(options));
+
+	if (yaffs_parse_options(&options, data_str)) {
+		/* Option parsing failed */
+		return NULL;
+	}
+
+	sb->s_blocksize = PAGE_CACHE_SIZE;
+	sb->s_blocksize_bits = PAGE_CACHE_SHIFT;
+
+	yaffs_trace(YAFFS_TRACE_OS,
+		"yaffs_read_super: Using yaffs%d", yaffs_version);
+	yaffs_trace(YAFFS_TRACE_OS,
+		"yaffs_read_super: block size %d", (int)(sb->s_blocksize));
+
+	yaffs_trace(YAFFS_TRACE_ALWAYS,
+		"yaffs: Attempting MTD mount of %u.%u,\"%s\"",
+		MAJOR(sb->s_dev), MINOR(sb->s_dev),
+		yaffs_devname(sb, devname_buf));
+
+	/*
+	*	Get the device
+	* 	fix yaffs2 file system bug by linhongdian20190920:
+	*	we found that something other block device (such as /dev/mmcblock0, /dev/mmcblock0p1) can mount yafffs2 file system,
+	*	which will cause demage to flash data.
+	*	To aviod it, we check if major device number is MTD_BLOCK_MAJOR
+	*/
+	if(MAJOR(sb->s_dev) == MTD_BLOCK_MAJOR)
+		mtd = get_mtd_device(NULL, MINOR(sb->s_dev));
+	else
+		return NULL;
+
+	if (IS_ERR(mtd)) {
+		yaffs_trace(YAFFS_TRACE_ALWAYS,
+			"yaffs: MTD device %u either not valid or unavailable",
+			MINOR(sb->s_dev));
+		return NULL;
+	}
+
+	if (yaffs_auto_select && yaffs_version == 1 && WRITE_SIZE(mtd) >= 2048) {
+		yaffs_trace(YAFFS_TRACE_ALWAYS, "auto selecting yaffs2");
+		yaffs_version = 2;
+	}
+
+	/* Added NCB 26/5/2006 for completeness */
+	if (yaffs_version == 2 && !options.inband_tags
+	    && WRITE_SIZE(mtd) == 512) {
+		yaffs_trace(YAFFS_TRACE_ALWAYS, "auto selecting yaffs1");
+		yaffs_version = 1;
+	}
+
+	if (mtd->oobavail < sizeof(struct yaffs_packed_tags2) ||
+	    options.inband_tags)
+		inband_tags = 1;
+
+	if(yaffs_verify_mtd(mtd, yaffs_version, inband_tags) < 0)
+		return NULL;
+
+	/* OK, so if we got here, we have an MTD that's NAND and looks
+	 * like it has the right capabilities
+	 * Set the struct yaffs_dev up for mtd
+	 */
+
+	if (!read_only && !(mtd->flags & MTD_WRITEABLE)) {
+		read_only = 1;
+		printk(KERN_INFO
+		       "yaffs: mtd is read only, setting superblock read only\n"
+		);
+		sb->s_flags |= MS_RDONLY;
+	}
+
+	dev = kmalloc(sizeof(struct yaffs_dev), GFP_KERNEL);
+	context = kmalloc(sizeof(struct yaffs_linux_context), GFP_KERNEL);
+
+	if (!dev || !context) {
+		kfree(dev);
+		kfree(context);
+		dev = NULL;
+		context = NULL;
+
+		/* Deep shit could not allocate device structure */
+		yaffs_trace(YAFFS_TRACE_ALWAYS,
+			"yaffs_read_super: Failed trying to allocate struct yaffs_dev."
+		);
+		return NULL;
+	}
+	memset(dev, 0, sizeof(struct yaffs_dev));
+	param = &(dev->param);
+
+	memset(context, 0, sizeof(struct yaffs_linux_context));
+	dev->os_context = context;
+	INIT_LIST_HEAD(&(context->context_list));
+	context->dev = dev;
+	context->super = sb;
+
+	dev->read_only = read_only;
+
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 5, 0))
+	sb->s_fs_info = dev;
+#else
+	sb->u.generic_sbp = dev;
+#endif
+
+
+	dev->driver_context = mtd;
+	param->name = mtd->name;
+
+	/* Set up the memory size parameters.... */
+
+
+	param->n_reserved_blocks = 5;
+	param->n_caches = (options.no_cache) ? 0 : 10;
+	param->inband_tags = inband_tags;
+
+	param->enable_xattr = 1;
+	if (options.lazy_loading_overridden)
+		param->disable_lazy_load = !options.lazy_loading_enabled;
+
+	param->defered_dir_update = 1;
+
+	if (options.tags_ecc_overridden)
+		param->no_tags_ecc = !options.tags_ecc_on;
+
+	param->empty_lost_n_found = 1;
+	param->refresh_period = 500;
+	param->disable_summary = options.disable_summary;
+
+
+#ifdef CONFIG_YAFFS_DISABLE_BAD_BLOCK_MARKING
+	param->disable_bad_block_marking  = 1;
+#endif
+	if (options.empty_lost_and_found_overridden)
+		param->empty_lost_n_found = options.empty_lost_and_found;
+
+	/* ... and the functions. */
+	if (yaffs_version == 2) {
+		param->is_yaffs2 = 1;
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 17))
+		param->total_bytes_per_chunk = mtd->writesize;
+		param->chunks_per_block = mtd->erasesize / mtd->writesize;
+#else
+		param->total_bytes_per_chunk = mtd->oobblock;
+		param->chunks_per_block = mtd->erasesize / mtd->oobblock;
+#endif
+		n_blocks = YCALCBLOCKS(mtd->size, mtd->erasesize);
+
+		param->start_block = 0;
+		param->end_block = n_blocks - 1;
+	} else {
+		param->is_yaffs2 = 0;
+		n_blocks = YCALCBLOCKS(mtd->size,
+			     YAFFS_CHUNKS_PER_BLOCK * YAFFS_BYTES_PER_CHUNK);
+
+		param->chunks_per_block = YAFFS_CHUNKS_PER_BLOCK;
+		param->total_bytes_per_chunk = YAFFS_BYTES_PER_CHUNK;
+	}
+
+	param->start_block = 0;
+	param->end_block = n_blocks - 1;
+
+	yaffs_mtd_drv_install(dev);
+
+	param->sb_dirty_fn = yaffs_set_super_dirty;
+	param->gc_control_fn = yaffs_gc_control_callback;
+
+	yaffs_dev_to_lc(dev)->super = sb;
+
+//do for warring
+#if 0 //CONFIG_YAFFS_DOES_ECC
+	param->use_nand_ecc = 1;
+#else
+	param->use_nand_ecc = 0;
+#endif	
+	param->skip_checkpt_rd = options.skip_checkpoint_read;
+	param->skip_checkpt_wr = options.skip_checkpoint_write;
+
+	mutex_lock(&yaffs_context_lock);
+	/* Get a mount id */
+	found = 0;
+	for (mount_id = 0; !found; mount_id++) {
+		found = 1;
+		list_for_each(l, &yaffs_context_list) {
+			context_iterator =
+			    list_entry(l, struct yaffs_linux_context,
+				       context_list);
+			if (context_iterator->mount_id == mount_id)
+				found = 0;
+		}
+	}
+	context->mount_id = mount_id;
+
+	list_add_tail(&(yaffs_dev_to_lc(dev)->context_list),
+		      &yaffs_context_list);
+	mutex_unlock(&yaffs_context_lock);
+
+	/* Directory search handling... */
+	INIT_LIST_HEAD(&(yaffs_dev_to_lc(dev)->search_contexts));
+	param->remove_obj_fn = yaffs_remove_obj_callback;
+
+	mutex_init(&(yaffs_dev_to_lc(dev)->gross_lock));
+
+	yaffs_gross_lock(dev);
+
+	err = yaffs_guts_initialise(dev);
+
+	yaffs_trace(YAFFS_TRACE_OS,
+		"yaffs_read_super: guts initialised %s",
+		(err == YAFFS_OK) ? "OK" : "FAILED");
+
+	if (err == YAFFS_OK)
+		yaffs_bg_start(dev);
+
+	if (!context->bg_thread)
+		param->defered_dir_update = 0;
+
+	sb->s_maxbytes = yaffs_max_file_size(dev);
+
+	/* Release lock before yaffs_get_inode() */
+	yaffs_gross_unlock(dev);
+
+	/* Create root inode */
+	if (err == YAFFS_OK)
+		inode = yaffs_get_inode(sb, S_IFDIR | 0755, 0, yaffs_root(dev));
+
+	if (!inode)
+		return NULL;
+
+	inode->i_op = &yaffs_dir_inode_operations;
+	inode->i_fop = &yaffs_dir_operations;
+
+	yaffs_trace(YAFFS_TRACE_OS, "yaffs_read_super: got root inode");
+
+	root = yaffs_make_root(inode);
+
+	if (!root)
+		return NULL;
+
+	sb->s_root = root;
+	if(!dev->is_checkpointed)
+		yaffs_set_super_dirty(dev);
+
+	yaffs_trace(YAFFS_TRACE_ALWAYS,
+		"yaffs_read_super: is_checkpointed %d",
+		dev->is_checkpointed);
+
+	yaffs_trace(YAFFS_TRACE_OS, "yaffs_read_super: done");
+	return sb;
+}
+
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 5, 0))
+static int yaffs_internal_read_super_mtd(struct super_block *sb, void *data,
+					 int silent)
+{
+	return yaffs_internal_read_super(1, sb, data, silent) ? 0 : -EINVAL;
+}
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 39))
+static struct dentry *yaffs_mount(struct file_system_type *fs_type, int flags,
+        const char *dev_name, void *data)
+{
+    return mount_bdev(fs_type, flags, dev_name, data, yaffs_internal_read_super_mtd);
+}
+#elif (LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 17))
+static int yaffs_read_super(struct file_system_type *fs,
+			    int flags, const char *dev_name,
+			    void *data, struct vfsmount *mnt)
+{
+
+	return get_sb_bdev(fs, flags, dev_name, data,
+			   yaffs_internal_read_super_mtd, mnt);
+}
+#else
+static struct super_block *yaffs_read_super(struct file_system_type *fs,
+					    int flags, const char *dev_name,
+					    void *data)
+{
+
+	return get_sb_bdev(fs, flags, dev_name, data,
+			   yaffs_internal_read_super_mtd);
+}
+#endif
+
+static struct file_system_type yaffs_fs_type = {
+	.owner = THIS_MODULE,
+	.name = "yaffs",
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 39))
+        .mount = yaffs_mount,
+#else
+        .get_sb = yaffs_read_super,
+#endif
+     	.kill_sb = kill_block_super,
+	.fs_flags = FS_REQUIRES_DEV,
+};
+#else
+static struct super_block *yaffs_read_super(struct super_block *sb, void *data,
+					    int silent)
+{
+	return yaffs_internal_read_super(1, sb, data, silent);
+}
+
+static DECLARE_FSTYPE(yaffs_fs_type, "yaffs", yaffs_read_super,
+		      FS_REQUIRES_DEV);
+#endif
+
+
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 5, 0))
+static int yaffs2_internal_read_super_mtd(struct super_block *sb, void *data,
+					  int silent)
+{
+	return yaffs_internal_read_super(2, sb, data, silent) ? 0 : -EINVAL;
+}
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 39))
+static struct dentry *yaffs2_mount(struct file_system_type *fs_type, int flags,
+        const char *dev_name, void *data)
+{
+        return mount_bdev(fs_type, flags, dev_name, data, yaffs2_internal_read_super_mtd);
+}
+#elif (LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 17))
+static int yaffs2_read_super(struct file_system_type *fs,
+			     int flags, const char *dev_name, void *data,
+			     struct vfsmount *mnt)
+{
+	return get_sb_bdev(fs, flags, dev_name, data,
+			   yaffs2_internal_read_super_mtd, mnt);
+}
+#else
+static struct super_block *yaffs2_read_super(struct file_system_type *fs,
+					     int flags, const char *dev_name,
+					     void *data)
+{
+
+	return get_sb_bdev(fs, flags, dev_name, data,
+			   yaffs2_internal_read_super_mtd);
+}
+#endif
+
+static struct file_system_type yaffs2_fs_type = {
+	.owner = THIS_MODULE,
+	.name = "yaffs2",
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 39))
+        .mount = yaffs2_mount,
+#else
+        .get_sb = yaffs2_read_super,
+#endif
+     	.kill_sb = kill_block_super,
+	.fs_flags = FS_REQUIRES_DEV,
+};
+#else
+static struct super_block *yaffs2_read_super(struct super_block *sb,
+					     void *data, int silent)
+{
+	return yaffs_internal_read_super(2, sb, data, silent);
+}
+
+static DECLARE_FSTYPE(yaffs2_fs_type, "yaffs2", yaffs2_read_super,
+		      FS_REQUIRES_DEV);
+#endif
+
+
+static struct proc_dir_entry *my_proc_entry;
+
+static char *yaffs_dump_dev_part0(char *buf, struct yaffs_dev *dev)
+{
+	struct yaffs_param *param = &dev->param;
+	int bs[10];
+
+	yaffs_count_blocks_by_state(dev,bs);
+
+	buf += sprintf(buf, "start_block.......... %d\n", param->start_block);
+	buf += sprintf(buf, "end_block............ %d\n", param->end_block);
+	buf += sprintf(buf, "total_bytes_per_chunk %d\n",
+				param->total_bytes_per_chunk);
+	buf += sprintf(buf, "use_nand_ecc......... %d\n", param->use_nand_ecc);
+	buf += sprintf(buf, "no_tags_ecc.......... %d\n", param->no_tags_ecc);
+	buf += sprintf(buf, "is_yaffs2............ %d\n", param->is_yaffs2);
+	buf += sprintf(buf, "inband_tags.......... %d\n", param->inband_tags);
+	buf += sprintf(buf, "empty_lost_n_found... %d\n",
+				param->empty_lost_n_found);
+	buf += sprintf(buf, "disable_lazy_load.... %d\n",
+				param->disable_lazy_load);
+	buf += sprintf(buf, "disable_bad_block_mrk %d\n",
+				param->disable_bad_block_marking);
+	buf += sprintf(buf, "refresh_period....... %d\n",
+				param->refresh_period);
+	buf += sprintf(buf, "n_caches............. %d\n", param->n_caches);
+	buf += sprintf(buf, "n_reserved_blocks.... %d\n",
+				param->n_reserved_blocks);
+	buf += sprintf(buf, "always_check_erased.. %d\n",
+				param->always_check_erased);
+	buf += sprintf(buf, "\n");
+	buf += sprintf(buf, "block count by state\n");
+	buf += sprintf(buf, "0:%d 1:%d 2:%d 3:%d 4:%d\n",
+				bs[0], bs[1], bs[2], bs[3], bs[4]);
+	buf += sprintf(buf, "5:%d 6:%d 7:%d 8:%d 9:%d\n",
+				bs[5], bs[6], bs[7], bs[8], bs[9]);
+
+	return buf;
+}
+
+static char *yaffs_dump_dev_part1(char *buf, struct yaffs_dev *dev)
+{
+	buf += sprintf(buf, "max file size....... %lld\n",
+				(long long) yaffs_max_file_size(dev));
+	buf += sprintf(buf, "data_bytes_per_chunk. %d\n",
+				dev->data_bytes_per_chunk);
+	buf += sprintf(buf, "chunk_grp_bits....... %d\n", dev->chunk_grp_bits);
+	buf += sprintf(buf, "chunk_grp_size....... %d\n", dev->chunk_grp_size);
+	buf += sprintf(buf, "n_erased_blocks...... %d\n", dev->n_erased_blocks);
+	buf += sprintf(buf, "blocks_in_checkpt.... %d\n",
+				dev->blocks_in_checkpt);
+	buf += sprintf(buf, "\n");
+	buf += sprintf(buf, "n_tnodes............. %d\n", dev->n_tnodes);
+	buf += sprintf(buf, "n_obj................ %d\n", dev->n_obj);
+	buf += sprintf(buf, "n_free_chunks........ %d\n", dev->n_free_chunks);
+	buf += sprintf(buf, "\n");
+	buf += sprintf(buf, "n_page_writes........ %u\n", dev->n_page_writes);
+	buf += sprintf(buf, "n_page_reads......... %u\n", dev->n_page_reads);
+	buf += sprintf(buf, "n_erasures........... %u\n", dev->n_erasures);
+	buf += sprintf(buf, "n_gc_copies.......... %u\n", dev->n_gc_copies);
+	buf += sprintf(buf, "all_gcs.............. %u\n", dev->all_gcs);
+	buf += sprintf(buf, "passive_gc_count..... %u\n",
+				dev->passive_gc_count);
+	buf += sprintf(buf, "oldest_dirty_gc_count %u\n",
+				dev->oldest_dirty_gc_count);
+	buf += sprintf(buf, "n_gc_blocks.......... %u\n", dev->n_gc_blocks);
+	buf += sprintf(buf, "bg_gcs............... %u\n", dev->bg_gcs);
+	buf += sprintf(buf, "n_retried_writes..... %u\n",
+				dev->n_retried_writes);
+	buf += sprintf(buf, "n_retired_blocks..... %u\n",
+				dev->n_retired_blocks);
+	buf += sprintf(buf, "n_ecc_fixed.......... %u\n", dev->n_ecc_fixed);
+	buf += sprintf(buf, "n_ecc_unfixed........ %u\n", dev->n_ecc_unfixed);
+	buf += sprintf(buf, "n_tags_ecc_fixed..... %u\n",
+				dev->n_tags_ecc_fixed);
+	buf += sprintf(buf, "n_tags_ecc_unfixed... %u\n",
+				dev->n_tags_ecc_unfixed);
+	buf += sprintf(buf, "cache_hits........... %u\n", dev->cache_hits);
+	buf += sprintf(buf, "n_deleted_files...... %u\n", dev->n_deleted_files);
+	buf += sprintf(buf, "n_unlinked_files..... %u\n",
+				dev->n_unlinked_files);
+	buf += sprintf(buf, "refresh_count........ %u\n", dev->refresh_count);
+	buf += sprintf(buf, "n_bg_deletions....... %u\n", dev->n_bg_deletions);
+	buf += sprintf(buf, "tags_used............ %u\n", dev->tags_used);
+	buf += sprintf(buf, "summary_used......... %u\n", dev->summary_used);
+
+	return buf;
+}
+
+static int yaffs_proc_read(char *page,
+			   char **start,
+			   off_t offset, int count, int *eof, void *data)
+{
+	struct list_head *item;
+	char *buf = page;
+	int step = offset;
+	int n = 0;
+
+	/* Get proc_file_read() to step 'offset' by one on each sucessive call.
+	 * We use 'offset' (*ppos) to indicate where we are in dev_list.
+	 * This also assumes the user has posted a read buffer large
+	 * enough to hold the complete output; but that's life in /proc.
+	 */
+
+	*(int *)start = 1;
+
+	/* Print header first */
+	if (step == 0)
+		buf +=
+		    sprintf(buf, "Multi-version YAFFS\n");
+	else if (step == 1)
+		buf += sprintf(buf, "\n");
+	else {
+		step -= 2;
+
+		mutex_lock(&yaffs_context_lock);
+
+		/* Locate and print the Nth entry.  Order N-squared but N is small. */
+		list_for_each(item, &yaffs_context_list) {
+			struct yaffs_linux_context *dc =
+			    list_entry(item, struct yaffs_linux_context,
+				       context_list);
+			struct yaffs_dev *dev = dc->dev;
+
+			if (n < (step & ~1)) {
+				n += 2;
+				continue;
+			}
+			if ((step & 1) == 0) {
+				buf +=
+				    sprintf(buf, "\nDevice %d \"%s\"\n", n,
+					    dev->param.name);
+				buf = yaffs_dump_dev_part0(buf, dev);
+			} else {
+				buf = yaffs_dump_dev_part1(buf, dev);
+                        }
+
+			break;
+		}
+		mutex_unlock(&yaffs_context_lock);
+	}
+
+	return buf - page < count ? buf - page : count;
+}
+
+/**
+ * Set the verbosity of the warnings and error messages.
+ *
+ * Note that the names can only be a..z or _ with the current code.
+ */
+
+static struct {
+	char *mask_name;
+	unsigned mask_bitfield;
+} mask_flags[] = {
+	{"allocate", YAFFS_TRACE_ALLOCATE},
+	{"always", YAFFS_TRACE_ALWAYS},
+	{"background", YAFFS_TRACE_BACKGROUND},
+	{"bad_blocks", YAFFS_TRACE_BAD_BLOCKS},
+	{"buffers", YAFFS_TRACE_BUFFERS},
+	{"bug", YAFFS_TRACE_BUG},
+	{"checkpt", YAFFS_TRACE_CHECKPOINT},
+	{"deletion", YAFFS_TRACE_DELETION},
+	{"erase", YAFFS_TRACE_ERASE},
+	{"error", YAFFS_TRACE_ERROR},
+	{"gc_detail", YAFFS_TRACE_GC_DETAIL},
+	{"gc", YAFFS_TRACE_GC},
+	{"lock", YAFFS_TRACE_LOCK},
+	{"mtd", YAFFS_TRACE_MTD},
+	{"nandaccess", YAFFS_TRACE_NANDACCESS},
+	{"os", YAFFS_TRACE_OS},
+	{"scan_debug", YAFFS_TRACE_SCAN_DEBUG},
+	{"scan", YAFFS_TRACE_SCAN},
+	{"mount", YAFFS_TRACE_MOUNT},
+	{"tracing", YAFFS_TRACE_TRACING},
+	{"sync", YAFFS_TRACE_SYNC},
+	{"write", YAFFS_TRACE_WRITE},
+	{"verify", YAFFS_TRACE_VERIFY},
+	{"verify_nand", YAFFS_TRACE_VERIFY_NAND},
+	{"verify_full", YAFFS_TRACE_VERIFY_FULL},
+	{"verify_all", YAFFS_TRACE_VERIFY_ALL},
+	{"all", 0xffffffff},
+	{"none", 0},
+	{NULL, 0},
+};
+
+#define MAX_MASK_NAME_LENGTH 40
+static int yaffs_proc_write_trace_options(struct file *file, const char *buf,
+					  unsigned long count)
+{
+	unsigned rg = 0, mask_bitfield;
+	char *end;
+	char *mask_name;
+	const char *x;
+	char substring[MAX_MASK_NAME_LENGTH + 1];
+	int i;
+	int done = 0;
+	int add, len = 0;
+	int pos = 0;
+
+	rg = yaffs_trace_mask;
+
+	while (!done && (pos < count)) {
+		done = 1;
+		while ((pos < count) && isspace(buf[pos]))
+			pos++;
+
+		switch (buf[pos]) {
+		case '+':
+		case '-':
+		case '=':
+			add = buf[pos];
+			pos++;
+			break;
+
+		default:
+			add = ' ';
+			break;
+		}
+		mask_name = NULL;
+
+		mask_bitfield = simple_strtoul(buf + pos, &end, 0);
+
+		if (end > buf + pos) {
+			mask_name = "numeral";
+			len = end - (buf + pos);
+			pos += len;
+			done = 0;
+		} else {
+			for (x = buf + pos, i = 0;
+			     (*x == '_' || (*x >= 'a' && *x <= 'z')) &&
+			     i < MAX_MASK_NAME_LENGTH; x++, i++, pos++)
+				substring[i] = *x;
+			substring[i] = '\0';
+
+			for (i = 0; mask_flags[i].mask_name != NULL; i++) {
+				if (strcmp(substring, mask_flags[i].mask_name)
+				    == 0) {
+					mask_name = mask_flags[i].mask_name;
+					mask_bitfield =
+					    mask_flags[i].mask_bitfield;
+					done = 0;
+					break;
+				}
+			}
+		}
+
+		if (mask_name != NULL) {
+			done = 0;
+			switch (add) {
+			case '-':
+				rg &= ~mask_bitfield;
+				break;
+			case '+':
+				rg |= mask_bitfield;
+				break;
+			case '=':
+				rg = mask_bitfield;
+				break;
+			default:
+				rg |= mask_bitfield;
+				break;
+			}
+		}
+	}
+
+	yaffs_trace_mask = rg | YAFFS_TRACE_ALWAYS;
+
+	printk(KERN_DEBUG "new trace = 0x%08X\n", yaffs_trace_mask);
+
+	if (rg & YAFFS_TRACE_ALWAYS) {
+		for (i = 0; mask_flags[i].mask_name != NULL; i++) {
+			char flag;
+			flag = ((rg & mask_flags[i].mask_bitfield) ==
+				mask_flags[i].mask_bitfield) ? '+' : '-';
+			printk(KERN_DEBUG "%c%s\n", flag,
+			       mask_flags[i].mask_name);
+		}
+	}
+
+	return count;
+}
+
+/* Debug strings are of the form:
+ * .bnnn         print info on block n
+ * .cobjn,chunkn print nand chunk id for objn:chunkn
+ */
+
+static int yaffs_proc_debug_write(struct file *file, const char *buf,
+					  unsigned long count)
+{
+
+	char str[100];
+	char *p0;
+	char *p1;
+	long p1_val;
+	long p0_val;
+	char cmd;
+	struct list_head *item;
+
+	memset(str, 0, sizeof(str));
+	memcpy(str, buf, min((size_t)count, sizeof(str) -1));
+
+	cmd = str[1];
+
+	p0 = str + 2;
+
+	p1 = p0;
+
+	while (*p1 && *p1 != ',') {
+		p1++;
+	}
+	*p1 = '\0';
+	p1++;
+
+	p0_val = simple_strtol(p0, NULL, 0);
+	p1_val = simple_strtol(p1, NULL, 0);
+
+
+	mutex_lock(&yaffs_context_lock);
+
+	/* Locate and print the Nth entry.  Order N-squared but N is small. */
+	list_for_each(item, &yaffs_context_list) {
+		struct yaffs_linux_context *dc =
+		    list_entry(item, struct yaffs_linux_context,
+			       context_list);
+		struct yaffs_dev *dev = dc->dev;
+
+		if (cmd == 'b') {
+			struct yaffs_block_info *bi;
+
+			bi = yaffs_get_block_info(dev,p0_val);
+
+			if(bi) {
+				printk("Block %d: state %d, retire %d, use %d, seq %d\n",
+					(int)p0_val, bi->block_state,
+					bi->needs_retiring, bi->pages_in_use,
+					bi->seq_number);
+			}
+		} else if (cmd == 'c') {
+			struct yaffs_obj *obj;
+			int nand_chunk;
+
+			obj = yaffs_find_by_number(dev, p0_val);
+			if (!obj)
+				printk("No obj %d\n", (int)p0_val);
+			else {
+				if(p1_val == 0)
+					nand_chunk = obj->hdr_chunk;
+				else
+					nand_chunk =
+						yaffs_find_chunk_in_file(obj,
+							p1_val, NULL);
+				printk("Nand chunk for %d:%d is %d\n",
+					(int)p0_val, (int)p1_val, nand_chunk);
+			}
+		}
+	}
+
+	mutex_unlock(&yaffs_context_lock);
+
+	return count;
+}
+
+
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(3, 14, 0))
+static int yaffs_proc_write(struct file *file, const char *buf,
+			    unsigned long count, void *ppos)
+#else
+static ssize_t yaffs_proc_write(struct file *file, const char __user *buf,
+			    size_t count, loff_t *ppos)
+#endif
+{
+	if (buf[0] == '.')
+		return yaffs_proc_debug_write(file, buf, count);
+	return yaffs_proc_write_trace_options(file, buf, count);
+}
+
+/* Stuff to handle installation of file systems */
+struct file_system_to_install {
+	struct file_system_type *fst;
+	int installed;
+};
+
+static struct file_system_to_install fs_to_install[] = {
+	{&yaffs_fs_type, 0},
+	{&yaffs2_fs_type, 0},
+	{NULL, 0}
+};
+
+
+#ifdef YAFFS_NEW_PROCFS
+static int yaffs_proc_show(struct seq_file *m, void *v)
+{
+	/* FIXME: Unify in a better way? */
+	char buffer[512];
+	char *start;
+	int len;
+
+	len = yaffs_proc_read(buffer, &start, 0, sizeof(buffer), NULL, NULL);
+	seq_puts(m, buffer);
+	return 0;
+}
+
+static int yaffs_proc_open(struct inode *inode, struct file *file)
+{
+	return single_open(file, yaffs_proc_show, NULL);
+}
+
+static struct file_operations procfs_ops = {
+	.owner = THIS_MODULE,
+	.open  = yaffs_proc_open,
+	.read  = seq_read,
+	.write = yaffs_proc_write,
+};
+
+static int yaffs_procfs_init(void)
+{
+	/* Install the proc_fs entries */
+	my_proc_entry = proc_create("yaffs",
+				    S_IRUGO | S_IFREG,
+				    YPROC_ROOT,
+				    &procfs_ops);
+
+	if (my_proc_entry) {
+		return 0;
+	} else {
+		return -ENOMEM;
+	}
+}
+
+#else
+
+
+static int yaffs_procfs_init(void)
+{
+	/* Install the proc_fs entries */
+	my_proc_entry = create_proc_entry("yaffs",
+					  S_IRUGO | S_IFREG, YPROC_ROOT);
+
+	if (my_proc_entry) {
+		my_proc_entry->write_proc = yaffs_proc_write;
+		my_proc_entry->read_proc = yaffs_proc_read;
+		my_proc_entry->data = NULL;
+		return 0;
+	} else {
+		return -ENOMEM;
+	}
+}
+
+#endif
+
+
+static int __init init_yaffs_fs(void)
+{
+	int error = 0;
+	struct file_system_to_install *fsinst;
+
+	yaffs_trace(YAFFS_TRACE_ALWAYS,
+		"yaffs Installing.");
+
+	mutex_init(&yaffs_context_lock);
+
+	error = yaffs_procfs_init();
+	if (error)
+		return error;
+
+	/* Now add the file system entries */
+
+	fsinst = fs_to_install;
+
+	while (fsinst->fst && !error) {
+		error = register_filesystem(fsinst->fst);
+		if (!error)
+			fsinst->installed = 1;
+		fsinst++;
+	}
+
+	/* Any errors? uninstall  */
+	if (error) {
+		fsinst = fs_to_install;
+
+		while (fsinst->fst) {
+			if (fsinst->installed) {
+				unregister_filesystem(fsinst->fst);
+				fsinst->installed = 0;
+			}
+			fsinst++;
+		}
+	}
+
+	return error;
+}
+
+static void __exit exit_yaffs_fs(void)
+{
+
+	struct file_system_to_install *fsinst;
+
+	yaffs_trace(YAFFS_TRACE_ALWAYS,
+		"yaffs removing.");
+
+	remove_proc_entry("yaffs", YPROC_ROOT);
+
+	fsinst = fs_to_install;
+
+	while (fsinst->fst) {
+		if (fsinst->installed) {
+			unregister_filesystem(fsinst->fst);
+			fsinst->installed = 0;
+		}
+		fsinst++;
+	}
+}
+
+module_init(init_yaffs_fs)
+    module_exit(exit_yaffs_fs)
+
+    MODULE_DESCRIPTION("YAFFS2 - a NAND specific flash file system");
+MODULE_AUTHOR("Charles Manning, Aleph One Ltd., 2002-2011");
+MODULE_LICENSE("GPL");
diff --git a/fs/yaffs2/yaffs_vfs_single.c b/fs/yaffs2/yaffs_vfs_single.c
new file mode 100755
index 0000000..0f44eee
--- /dev/null
+++ b/fs/yaffs2/yaffs_vfs_single.c
@@ -0,0 +1,2606 @@
+/*
+ * YAFFS: Yet Another Flash File System. A NAND-flash specific file system.
+ *
+ * Copyright (C) 2002-2011 Aleph One Ltd.
+ *   for Toby Churchill Ltd and Brightstar Engineering
+ *
+ * Created by Charles Manning <charles@aleph1.co.uk>
+ * Acknowledgements:
+ * Luc van OostenRyck for numerous patches.
+ * Nick Bane for numerous patches.
+ * Nick Bane for 2.5/2.6 integration.
+ * Andras Toth for mknod rdev issue.
+ * Michael Fischer for finding the problem with inode inconsistency.
+ * Some code bodily lifted from JFFS
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+/*
+ *
+ * This is the file system front-end to YAFFS that hooks it up to
+ * the VFS.
+ *
+ * Special notes:
+ * >> 2.4: sb->u.generic_sbp points to the struct yaffs_dev associated with
+ *         this superblock
+ * >> 2.6: sb->s_fs_info  points to the struct yaffs_dev associated with this
+ *         superblock
+ * >> inode->u.generic_ip points to the associated struct yaffs_obj.
+ */
+
+/*
+ * NB There are two variants of Linux VFS glue code. This variant supports
+ * a single version and should not include any multi-version code.
+ */
+#include <linux/version.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/init.h>
+#include <linux/fs.h>
+#include <linux/proc_fs.h>
+#include <linux/pagemap.h>
+#include <linux/mtd/mtd.h>
+#include <linux/interrupt.h>
+#include <linux/string.h>
+#include <linux/ctype.h>
+#include <linux/namei.h>
+#include <linux/exportfs.h>
+#include <linux/kthread.h>
+#include <linux/delay.h>
+#include <linux/freezer.h>
+#include <asm/div64.h>
+#include <linux/statfs.h>
+#include <linux/uaccess.h>
+#include <linux/mtd/mtd.h>
+
+#include "yportenv.h"
+#include "yaffs_trace.h"
+#include "yaffs_guts.h"
+#include "yaffs_attribs.h"
+#include "yaffs_linux.h"
+#include "yaffs_mtdif.h"
+//#include "yaffs_mtdif1.h"
+//#include "yaffs_mtdif2.h"
+
+unsigned int yaffs_trace_mask = YAFFS_TRACE_BAD_BLOCKS | YAFFS_TRACE_ALWAYS;
+unsigned int yaffs_wr_attempts = YAFFS_WR_ATTEMPTS;
+unsigned int yaffs_auto_checkpoint = 1;
+unsigned int yaffs_gc_control = 1;
+unsigned int yaffs_bg_enable = 1;
+unsigned int yaffs_auto_select = 1;
+
+/* Module Parameters */
+module_param(yaffs_trace_mask, uint, 0644);
+module_param(yaffs_wr_attempts, uint, 0644);
+module_param(yaffs_auto_checkpoint, uint, 0644);
+module_param(yaffs_gc_control, uint, 0644);
+module_param(yaffs_bg_enable, uint, 0644);
+module_param(yaffs_auto_select, uint, 0644);
+
+#define yaffs_devname(sb, buf)	bdevname(sb->s_bdev, buf)
+
+static uint32_t YCALCBLOCKS(uint64_t partition_size, uint32_t block_size)
+{
+	uint64_t result = partition_size;
+
+	do_div(result, block_size);
+	return (uint32_t) result;
+}
+
+#define yaffs_inode_to_obj_lv(iptr) ((iptr)->i_private)
+#define yaffs_inode_to_obj(iptr)\
+	((struct yaffs_obj *)(yaffs_inode_to_obj_lv(iptr)))
+#define yaffs_dentry_to_obj(dptr) yaffs_inode_to_obj((dptr)->d_inode)
+#define yaffs_super_to_dev(sb)	((struct yaffs_dev *)sb->s_fs_info)
+
+#define update_dir_time(dir) do {\
+			(dir)->i_ctime = (dir)->i_mtime = CURRENT_TIME; \
+		} while (0)
+
+
+static unsigned yaffs_gc_control_callback(struct yaffs_dev *dev)
+{
+	return yaffs_gc_control;
+}
+
+static void yaffs_gross_lock(struct yaffs_dev *dev)
+{
+	yaffs_trace(YAFFS_TRACE_LOCK, "yaffs locking %p", current);
+	mutex_lock(&(yaffs_dev_to_lc(dev)->gross_lock));
+	yaffs_trace(YAFFS_TRACE_LOCK, "yaffs locked %p", current);
+}
+
+static void yaffs_gross_unlock(struct yaffs_dev *dev)
+{
+	yaffs_trace(YAFFS_TRACE_LOCK, "yaffs unlocking %p", current);
+	mutex_unlock(&(yaffs_dev_to_lc(dev)->gross_lock));
+}
+
+static void yaffs_fill_inode_from_obj(struct inode *inode,
+				      struct yaffs_obj *obj);
+
+static struct inode *yaffs_iget(struct super_block *sb, unsigned long ino)
+{
+	struct inode *inode;
+	struct yaffs_obj *obj;
+	struct yaffs_dev *dev = yaffs_super_to_dev(sb);
+
+	yaffs_trace(YAFFS_TRACE_OS, "yaffs_iget for %lu", ino);
+
+	inode = iget_locked(sb, ino);
+	if (!inode)
+		return ERR_PTR(-ENOMEM);
+	if (!(inode->i_state & I_NEW))
+		return inode;
+
+	/* NB This is called as a side effect of other functions, but
+	 * we had to release the lock to prevent deadlocks, so
+	 * need to lock again.
+	 */
+
+	yaffs_gross_lock(dev);
+
+	obj = yaffs_find_by_number(dev, inode->i_ino);
+	yaffs_fill_inode_from_obj(inode, obj);
+
+	yaffs_gross_unlock(dev);
+
+	unlock_new_inode(inode);
+	return inode;
+}
+
+struct inode *yaffs_get_inode(struct super_block *sb, int mode, int dev,
+			      struct yaffs_obj *obj)
+{
+	struct inode *inode;
+
+	if (!sb) {
+		yaffs_trace(YAFFS_TRACE_OS,
+			"yaffs_get_inode for NULL super_block!!");
+		return NULL;
+
+	}
+
+	if (!obj) {
+		yaffs_trace(YAFFS_TRACE_OS,
+			"yaffs_get_inode for NULL object!!");
+		return NULL;
+
+	}
+
+	yaffs_trace(YAFFS_TRACE_OS,
+		"yaffs_get_inode for object %d",
+		obj->obj_id);
+
+	inode = yaffs_iget(sb, obj->obj_id);
+	if (IS_ERR(inode))
+		return NULL;
+
+	/* NB Side effect: iget calls back to yaffs_read_inode(). */
+	/* iget also increments the inode's i_count */
+	/* NB You can't be holding gross_lock or deadlock will happen! */
+
+	return inode;
+}
+
+static int yaffs_mknod(struct inode *dir, struct dentry *dentry, int mode,
+		       dev_t rdev)
+{
+	struct inode *inode;
+	struct yaffs_obj *obj = NULL;
+	struct yaffs_dev *dev;
+	struct yaffs_obj *parent = yaffs_inode_to_obj(dir);
+	int error;
+	uid_t uid = current->cred->fsuid;
+	gid_t gid =
+	    (dir->i_mode & S_ISGID) ? dir->i_gid : current->cred->fsgid;
+
+	if ((dir->i_mode & S_ISGID) && S_ISDIR(mode))
+		mode |= S_ISGID;
+
+	if (!parent) {
+		yaffs_trace(YAFFS_TRACE_OS,
+			"yaffs_mknod: could not get parent object");
+		return -EPERM;
+	}
+
+	yaffs_trace(YAFFS_TRACE_OS,
+			"yaffs_mknod: parent object %d type %d",
+			parent->obj_id, parent->variant_type);
+
+	yaffs_trace(YAFFS_TRACE_OS,
+		"yaffs_mknod: making oject for %s, mode %x dev %x",
+		dentry->d_name.name, mode, rdev);
+
+	dev = parent->my_dev;
+
+	yaffs_gross_lock(dev);
+
+	if (yaffs_get_n_free_chunks(dev) < 1) {
+		error = -ENOSPC;
+		goto err_out;
+	}
+
+	switch (mode & S_IFMT) {
+	default:
+		/* Special (socket, fifo, device...) */
+		yaffs_trace(YAFFS_TRACE_OS, "yaffs_mknod: making special");
+		obj =
+		    yaffs_create_special(parent, dentry->d_name.name, mode, uid,
+					 gid, old_encode_dev(rdev));
+		break;
+	case S_IFREG:		/* file          */
+		yaffs_trace(YAFFS_TRACE_OS, "yaffs_mknod: making file");
+		obj = yaffs_create_file(parent, dentry->d_name.name, mode, uid,
+					gid);
+		break;
+	case S_IFDIR:		/* directory */
+		yaffs_trace(YAFFS_TRACE_OS, "yaffs_mknod: making directory");
+		obj = yaffs_create_dir(parent, dentry->d_name.name, mode,
+				       uid, gid);
+		break;
+	case S_IFLNK:		/* symlink */
+		yaffs_trace(YAFFS_TRACE_OS, "yaffs_mknod: making symlink");
+		obj = NULL;	/* Do we ever get here? */
+		break;
+	}
+
+	if (!obj) {
+		error = -ENOMEM;
+		goto err_out;
+	}
+
+	/* Can not call yaffs_get_inode() with gross lock held */
+	yaffs_gross_unlock(dev);
+
+
+	inode = yaffs_get_inode(dir->i_sb, mode, rdev, obj);
+	d_instantiate(dentry, inode);
+	update_dir_time(dir);
+	yaffs_trace(YAFFS_TRACE_OS,
+		"yaffs_mknod created object %d count = %d",
+		obj->obj_id, atomic_read(&inode->i_count));
+	yaffs_fill_inode_from_obj(dir, parent);
+	return 0;
+
+err_out:
+	yaffs_gross_unlock(dev);
+	yaffs_trace(YAFFS_TRACE_OS, "yaffs_mknod error %d", error);
+	return error;
+
+}
+
+static int yaffs_mkdir(struct inode *dir, struct dentry *dentry, int mode)
+{
+	return yaffs_mknod(dir, dentry, mode | S_IFDIR, 0);
+}
+
+static int yaffs_create(struct inode *dir, struct dentry *dentry, int mode,
+			struct nameidata *n)
+{
+	return yaffs_mknod(dir, dentry, mode | S_IFREG, 0);
+}
+
+static int yaffs_link(struct dentry *old_dentry, struct inode *dir,
+		      struct dentry *dentry)
+{
+	struct inode *inode = old_dentry->d_inode;
+	struct yaffs_obj *obj = NULL;
+	struct yaffs_obj *link = NULL;
+	struct yaffs_dev *dev;
+
+	yaffs_trace(YAFFS_TRACE_OS, "yaffs_link");
+
+	obj = yaffs_inode_to_obj(inode);
+	dev = obj->my_dev;
+
+	yaffs_gross_lock(dev);
+
+	if (!S_ISDIR(inode->i_mode))	/* Don't link directories */
+		link =
+		    yaffs_link_obj(yaffs_inode_to_obj(dir), dentry->d_name.name,
+				   obj);
+
+	if (link) {
+		set_nlink(old_dentry->d_inode, yaffs_get_obj_link_count(obj));
+		d_instantiate(dentry, old_dentry->d_inode);
+		atomic_inc(&old_dentry->d_inode->i_count);
+		yaffs_trace(YAFFS_TRACE_OS,
+			"yaffs_link link count %d i_count %d",
+			old_dentry->d_inode->i_nlink,
+			atomic_read(&old_dentry->d_inode->i_count));
+	}
+
+	yaffs_gross_unlock(dev);
+
+	if (link) {
+		update_dir_time(dir);
+		return 0;
+	}
+
+	return -EPERM;
+}
+
+static int yaffs_symlink(struct inode *dir, struct dentry *dentry,
+			 const char *symname)
+{
+	struct yaffs_obj *obj;
+	struct yaffs_dev *dev;
+	struct inode *inode;
+	uid_t uid = current->cred->fsuid;
+	gid_t gid =
+	    (dir->i_mode & S_ISGID) ? dir->i_gid : current->cred->fsgid;
+
+	yaffs_trace(YAFFS_TRACE_OS, "yaffs_symlink");
+
+	if (strnlen(dentry->d_name.name, YAFFS_MAX_NAME_LENGTH + 1) >
+				YAFFS_MAX_NAME_LENGTH)
+		return -ENAMETOOLONG;
+
+	if (strnlen(symname, YAFFS_MAX_ALIAS_LENGTH + 1) >
+				YAFFS_MAX_ALIAS_LENGTH)
+		return -ENAMETOOLONG;
+
+	dev = yaffs_inode_to_obj(dir)->my_dev;
+	yaffs_gross_lock(dev);
+	obj = yaffs_create_symlink(yaffs_inode_to_obj(dir), dentry->d_name.name,
+				   S_IFLNK | S_IRWXUGO, uid, gid, symname);
+	yaffs_gross_unlock(dev);
+
+	if (!obj) {
+		yaffs_trace(YAFFS_TRACE_OS, "symlink not created");
+		return -ENOMEM;
+	}
+
+	inode = yaffs_get_inode(dir->i_sb, obj->yst_mode, 0, obj);
+	d_instantiate(dentry, inode);
+	update_dir_time(dir);
+	yaffs_trace(YAFFS_TRACE_OS, "symlink created OK");
+
+	return 0;
+}
+
+static struct dentry *yaffs_lookup(struct inode *dir, struct dentry *dentry,
+				   struct nameidata *n)
+{
+	struct yaffs_obj *obj;
+	struct inode *inode = NULL;
+	struct yaffs_dev *dev = yaffs_inode_to_obj(dir)->my_dev;
+
+	if (current != yaffs_dev_to_lc(dev)->readdir_process)
+		yaffs_gross_lock(dev);
+
+	yaffs_trace(YAFFS_TRACE_OS,
+		"yaffs_lookup for %d:%s",
+		yaffs_inode_to_obj(dir)->obj_id, dentry->d_name.name);
+
+	obj = yaffs_find_by_name(yaffs_inode_to_obj(dir), dentry->d_name.name);
+
+	obj = yaffs_get_equivalent_obj(obj);	/* in case it was a hardlink */
+
+	/* Can't hold gross lock when calling yaffs_get_inode() */
+	if (current != yaffs_dev_to_lc(dev)->readdir_process)
+		yaffs_gross_unlock(dev);
+
+	if (obj) {
+		yaffs_trace(YAFFS_TRACE_OS,
+			"yaffs_lookup found %d", obj->obj_id);
+
+		inode = yaffs_get_inode(dir->i_sb, obj->yst_mode, 0, obj);
+
+		if (inode) {
+			yaffs_trace(YAFFS_TRACE_OS, "yaffs_loookup dentry");
+			d_add(dentry, inode);
+			/* return dentry; */
+			return NULL;
+		}
+
+	} else {
+		yaffs_trace(YAFFS_TRACE_OS, "yaffs_lookup not found");
+
+	}
+
+	d_add(dentry, inode);
+
+	return NULL;
+}
+
+static int yaffs_unlink(struct inode *dir, struct dentry *dentry)
+{
+	int ret_val;
+	struct yaffs_dev *dev;
+	struct yaffs_obj *obj;
+
+	yaffs_trace(YAFFS_TRACE_OS,
+		"yaffs_unlink %d:%s",
+		(int)(dir->i_ino), dentry->d_name.name);
+	obj = yaffs_inode_to_obj(dir);
+	dev = obj->my_dev;
+
+	yaffs_gross_lock(dev);
+
+	ret_val = yaffs_unlinker(obj, dentry->d_name.name);
+
+	if (ret_val == YAFFS_OK) {
+		inode_dec_link_count(dentry->d_inode);
+		dir->i_version++;
+		yaffs_gross_unlock(dev);
+		update_dir_time(dir);
+		return 0;
+	}
+	yaffs_gross_unlock(dev);
+	return -ENOTEMPTY;
+}
+
+static int yaffs_sync_object(struct file *file,
+				loff_t start, loff_t end, int datasync)
+{
+
+	struct yaffs_obj *obj;
+	struct yaffs_dev *dev;
+	struct dentry *dentry = file->f_path.dentry;
+
+	obj = yaffs_dentry_to_obj(dentry);
+
+	dev = obj->my_dev;
+
+	yaffs_trace(YAFFS_TRACE_OS | YAFFS_TRACE_SYNC, "yaffs_sync_object");
+	yaffs_gross_lock(dev);
+	yaffs_flush_file(obj, 1, datasync, 0);
+	yaffs_gross_unlock(dev);
+	return 0;
+}
+/*
+ * The VFS layer already does all the dentry stuff for rename.
+ *
+ * NB: POSIX says you can rename an object over an old object of the same name
+ */
+static int yaffs_rename(struct inode *old_dir, struct dentry *old_dentry,
+			struct inode *new_dir, struct dentry *new_dentry)
+{
+	struct yaffs_dev *dev;
+	int ret_val = YAFFS_FAIL;
+	struct yaffs_obj *target;
+
+	yaffs_trace(YAFFS_TRACE_OS, "yaffs_rename");
+	dev = yaffs_inode_to_obj(old_dir)->my_dev;
+
+	yaffs_gross_lock(dev);
+
+	/* Check if the target is an existing directory that is not empty. */
+	target = yaffs_find_by_name(yaffs_inode_to_obj(new_dir),
+				    new_dentry->d_name.name);
+
+	if (target && target->variant_type == YAFFS_OBJECT_TYPE_DIRECTORY &&
+	    !list_empty(&target->variant.dir_variant.children)) {
+
+		yaffs_trace(YAFFS_TRACE_OS, "target is non-empty dir");
+
+		ret_val = YAFFS_FAIL;
+	} else {
+		/* Now does unlinking internally using shadowing mechanism */
+		yaffs_trace(YAFFS_TRACE_OS, "calling yaffs_rename_obj");
+
+		ret_val = yaffs_rename_obj(yaffs_inode_to_obj(old_dir),
+					   old_dentry->d_name.name,
+					   yaffs_inode_to_obj(new_dir),
+					   new_dentry->d_name.name);
+	}
+	yaffs_gross_unlock(dev);
+
+	if (ret_val == YAFFS_OK) {
+		if (target)
+			inode_dec_link_count(new_dentry->d_inode);
+
+		update_dir_time(old_dir);
+		if (old_dir != new_dir)
+			update_dir_time(new_dir);
+		return 0;
+	} else {
+		return -ENOTEMPTY;
+	}
+}
+
+static int yaffs_setattr(struct dentry *dentry, struct iattr *attr)
+{
+	struct inode *inode = dentry->d_inode;
+	int error = 0;
+	struct yaffs_dev *dev;
+	int result;
+
+	yaffs_trace(YAFFS_TRACE_OS,
+		"yaffs_setattr of object %d",
+		yaffs_inode_to_obj(inode)->obj_id);
+
+	/* Fail if a requested resize >= 2GB */
+	if (attr->ia_valid & ATTR_SIZE && (attr->ia_size >> 31))
+		error = -EINVAL;
+
+	if (!error)
+		error = inode_change_ok(inode, attr);
+
+	if (!error) {
+		setattr_copy(inode, attr);
+		yaffs_trace(YAFFS_TRACE_OS, "inode_setattr called");
+		if (attr->ia_valid & ATTR_SIZE) {
+			truncate_setsize(inode, attr->ia_size);
+			inode->i_blocks = (inode->i_size + 511) >> 9;
+		}
+		dev = yaffs_inode_to_obj(inode)->my_dev;
+		if (attr->ia_valid & ATTR_SIZE) {
+			yaffs_trace(YAFFS_TRACE_OS, "resize to %d(%x)",
+					   (int)(attr->ia_size),
+					   (int)(attr->ia_size));
+		}
+
+		yaffs_gross_lock(dev);
+		result = yaffs_set_attribs(yaffs_inode_to_obj(inode), attr);
+		if (result != YAFFS_OK)
+			error = -EPERM;
+		yaffs_gross_unlock(dev);
+	}
+
+	yaffs_trace(YAFFS_TRACE_OS, "yaffs_setattr done returning %d", error);
+
+	return error;
+}
+
+static int yaffs_setxattr(struct dentry *dentry, const char *name,
+		   const void *value, size_t size, int flags)
+{
+	struct inode *inode = dentry->d_inode;
+	int error;
+	struct yaffs_dev *dev;
+	struct yaffs_obj *obj = yaffs_inode_to_obj(inode);
+
+	yaffs_trace(YAFFS_TRACE_OS, "yaffs_setxattr of object %d", obj->obj_id);
+
+	dev = obj->my_dev;
+	yaffs_gross_lock(dev);
+	error = yaffs_set_xattrib(obj, name, value, size, flags);
+	yaffs_gross_unlock(dev);
+
+	yaffs_trace(YAFFS_TRACE_OS, "yaffs_setxattr done returning %d", error);
+
+	return error;
+}
+
+static ssize_t yaffs_getxattr(struct dentry *dentry, const char *name,
+				void *buff, size_t size)
+{
+	struct inode *inode = dentry->d_inode;
+	int error;
+	struct yaffs_dev *dev;
+	struct yaffs_obj *obj = yaffs_inode_to_obj(inode);
+
+	yaffs_trace(YAFFS_TRACE_OS,
+		"yaffs_getxattr \"%s\" from object %d",
+		name, obj->obj_id);
+
+	dev = obj->my_dev;
+	yaffs_gross_lock(dev);
+	error = yaffs_get_xattrib(obj, name, buff, size);
+	yaffs_gross_unlock(dev);
+
+	yaffs_trace(YAFFS_TRACE_OS, "yaffs_getxattr done returning %d", error);
+
+	return error;
+}
+
+static int yaffs_removexattr(struct dentry *dentry, const char *name)
+{
+	struct inode *inode = dentry->d_inode;
+	int error;
+	struct yaffs_dev *dev;
+	struct yaffs_obj *obj = yaffs_inode_to_obj(inode);
+
+	yaffs_trace(YAFFS_TRACE_OS,
+		"yaffs_removexattr of object %d", obj->obj_id);
+
+	dev = obj->my_dev;
+	yaffs_gross_lock(dev);
+	error = yaffs_remove_xattrib(obj, name);
+	yaffs_gross_unlock(dev);
+
+	yaffs_trace(YAFFS_TRACE_OS,
+		"yaffs_removexattr done returning %d", error);
+
+	return error;
+}
+
+static ssize_t yaffs_listxattr(struct dentry *dentry, char *buff, size_t size)
+{
+	struct inode *inode = dentry->d_inode;
+	int error;
+	struct yaffs_dev *dev;
+	struct yaffs_obj *obj = yaffs_inode_to_obj(inode);
+
+	yaffs_trace(YAFFS_TRACE_OS,
+		"yaffs_listxattr of object %d", obj->obj_id);
+
+	dev = obj->my_dev;
+	yaffs_gross_lock(dev);
+	error = yaffs_list_xattrib(obj, buff, size);
+	yaffs_gross_unlock(dev);
+
+	yaffs_trace(YAFFS_TRACE_OS,
+		"yaffs_listxattr done returning %d", error);
+
+	return error;
+}
+
+static const struct inode_operations yaffs_dir_inode_operations = {
+	.create = yaffs_create,
+	.lookup = yaffs_lookup,
+	.link = yaffs_link,
+	.unlink = yaffs_unlink,
+	.symlink = yaffs_symlink,
+	.mkdir = yaffs_mkdir,
+	.rmdir = yaffs_unlink,
+	.mknod = yaffs_mknod,
+	.rename = yaffs_rename,
+	.setattr = yaffs_setattr,
+	.setxattr = yaffs_setxattr,
+	.getxattr = yaffs_getxattr,
+	.listxattr = yaffs_listxattr,
+	.removexattr = yaffs_removexattr,
+};
+/*-----------------------------------------------------------------*/
+/* Directory search context allows us to unlock access to yaffs during
+ * filldir without causing problems with the directory being modified.
+ * This is similar to the tried and tested mechanism used in yaffs direct.
+ *
+ * A search context iterates along a doubly linked list of siblings in the
+ * directory. If the iterating object is deleted then this would corrupt
+ * the list iteration, likely causing a crash. The search context avoids
+ * this by using the remove_obj_fn to move the search context to the
+ * next object before the object is deleted.
+ *
+ * Many readdirs (and thus seach conexts) may be alive simulateously so
+ * each struct yaffs_dev has a list of these.
+ *
+ * A seach context lives for the duration of a readdir.
+ *
+ * All these functions must be called while yaffs is locked.
+ */
+
+struct yaffs_search_context {
+	struct yaffs_dev *dev;
+	struct yaffs_obj *dir_obj;
+	struct yaffs_obj *next_return;
+	struct list_head others;
+};
+
+/*
+ * yaffs_new_search() creates a new search context, initialises it and
+ * adds it to the device's search context list.
+ *
+ * Called at start of readdir.
+ */
+static struct yaffs_search_context *yaffs_new_search(struct yaffs_obj *dir)
+{
+	struct yaffs_dev *dev = dir->my_dev;
+	struct yaffs_search_context *sc =
+	    kmalloc(sizeof(struct yaffs_search_context), GFP_NOFS);
+
+	if (!sc)
+		return NULL;
+
+	sc->dir_obj = dir;
+	sc->dev = dev;
+	if (list_empty(&sc->dir_obj->variant.dir_variant.children))
+		sc->next_return = NULL;
+	else
+		sc->next_return =
+		    list_entry(dir->variant.dir_variant.children.next,
+			       struct yaffs_obj, siblings);
+	INIT_LIST_HEAD(&sc->others);
+	list_add(&sc->others, &(yaffs_dev_to_lc(dev)->search_contexts));
+
+	return sc;
+}
+
+/*
+ * yaffs_search_end() disposes of a search context and cleans up.
+ */
+static void yaffs_search_end(struct yaffs_search_context *sc)
+{
+	if (sc) {
+		list_del(&sc->others);
+		kfree(sc);
+	}
+}
+
+/*
+ * yaffs_search_advance() moves a search context to the next object.
+ * Called when the search iterates or when an object removal causes
+ * the search context to be moved to the next object.
+ */
+static void yaffs_search_advance(struct yaffs_search_context *sc)
+{
+	if (!sc)
+		return;
+
+	if (sc->next_return == NULL ||
+	    list_empty(&sc->dir_obj->variant.dir_variant.children))
+		sc->next_return = NULL;
+	else {
+		struct list_head *next = sc->next_return->siblings.next;
+
+		if (next == &sc->dir_obj->variant.dir_variant.children)
+			sc->next_return = NULL;	/* end of list */
+		else
+			sc->next_return =
+			    list_entry(next, struct yaffs_obj, siblings);
+	}
+}
+
+/*
+ * yaffs_remove_obj_callback() is called when an object is unlinked.
+ * We check open search contexts and advance any which are currently
+ * on the object being iterated.
+ */
+static void yaffs_remove_obj_callback(struct yaffs_obj *obj)
+{
+
+	struct list_head *i;
+	struct yaffs_search_context *sc;
+	struct list_head *search_contexts =
+	    &(yaffs_dev_to_lc(obj->my_dev)->search_contexts);
+
+	/* Iterate through the directory search contexts.
+	 * If any are currently on the object being removed, then advance
+	 * the search context to the next object to prevent a hanging pointer.
+	 */
+	list_for_each(i, search_contexts) {
+		sc = list_entry(i, struct yaffs_search_context, others);
+		if (sc->next_return == obj)
+			yaffs_search_advance(sc);
+	}
+
+}
+
+static int yaffs_readdir(struct file *f, void *dirent, filldir_t filldir)
+{
+	struct yaffs_obj *obj;
+	struct yaffs_dev *dev;
+	struct yaffs_search_context *sc;
+	struct inode *inode = f->f_dentry->d_inode;
+	unsigned long offset, curoffs;
+	struct yaffs_obj *l;
+	int ret_val = 0;
+	char name[YAFFS_MAX_NAME_LENGTH + 1];
+
+	obj = yaffs_dentry_to_obj(f->f_dentry);
+	dev = obj->my_dev;
+
+	yaffs_gross_lock(dev);
+
+	yaffs_dev_to_lc(dev)->readdir_process = current;
+
+	offset = f->f_pos;
+
+	sc = yaffs_new_search(obj);
+	if (!sc) {
+		ret_val = -ENOMEM;
+		goto out;
+	}
+
+	yaffs_trace(YAFFS_TRACE_OS,
+		"yaffs_readdir: starting at %d", (int)offset);
+
+	if (offset == 0) {
+		yaffs_trace(YAFFS_TRACE_OS,
+			"yaffs_readdir: entry . ino %d",
+			(int)inode->i_ino);
+		yaffs_gross_unlock(dev);
+		if (filldir(dirent, ".", 1, offset, inode->i_ino, DT_DIR) < 0) {
+			yaffs_gross_lock(dev);
+			goto out;
+		}
+		yaffs_gross_lock(dev);
+		offset++;
+		f->f_pos++;
+	}
+	if (offset == 1) {
+		yaffs_trace(YAFFS_TRACE_OS,
+			"yaffs_readdir: entry .. ino %d",
+			(int)f->f_dentry->d_parent->d_inode->i_ino);
+		yaffs_gross_unlock(dev);
+		if (filldir(dirent, "..", 2, offset,
+			    f->f_dentry->d_parent->d_inode->i_ino,
+			    DT_DIR) < 0) {
+			yaffs_gross_lock(dev);
+			goto out;
+		}
+		yaffs_gross_lock(dev);
+		offset++;
+		f->f_pos++;
+	}
+
+	curoffs = 1;
+
+	/* If the directory has changed since the open or last call to
+	   readdir, rewind to after the 2 canned entries. */
+	if (f->f_version != inode->i_version) {
+		offset = 2;
+		f->f_pos = offset;
+		f->f_version = inode->i_version;
+	}
+
+	while (sc->next_return) {
+		curoffs++;
+		l = sc->next_return;
+		if (curoffs >= offset) {
+			int this_inode = yaffs_get_obj_inode(l);
+			int this_type = yaffs_get_obj_type(l);
+
+			yaffs_get_obj_name(l, name, YAFFS_MAX_NAME_LENGTH + 1);
+			yaffs_trace(YAFFS_TRACE_OS,
+				"yaffs_readdir: %s inode %d",
+				name, yaffs_get_obj_inode(l));
+
+			yaffs_gross_unlock(dev);
+
+			if (filldir(dirent,
+				    name,
+				    strlen(name),
+				    offset, this_inode, this_type) < 0) {
+				yaffs_gross_lock(dev);
+				goto out;
+			}
+
+			yaffs_gross_lock(dev);
+
+			offset++;
+			f->f_pos++;
+		}
+		yaffs_search_advance(sc);
+	}
+
+out:
+	yaffs_search_end(sc);
+	yaffs_dev_to_lc(dev)->readdir_process = NULL;
+	yaffs_gross_unlock(dev);
+
+	return ret_val;
+}
+
+static const struct file_operations yaffs_dir_operations = {
+	.read = generic_read_dir,
+	.readdir = yaffs_readdir,
+	.fsync = yaffs_sync_object,
+	.llseek = generic_file_llseek,
+};
+
+
+
+static int yaffs_file_flush(struct file *file, fl_owner_t id)
+{
+	struct yaffs_obj *obj = yaffs_dentry_to_obj(file->f_dentry);
+	struct yaffs_dev *dev = obj->my_dev;
+
+	yaffs_trace(YAFFS_TRACE_OS,
+		"yaffs_file_flush object %d (%s)",
+		obj->obj_id, obj->dirty ? "dirty" : "clean");
+
+	yaffs_gross_lock(dev);
+
+	yaffs_flush_file(obj, 1, 0, 0);
+
+	yaffs_gross_unlock(dev);
+
+	return 0;
+}
+
+static const struct file_operations yaffs_file_operations = {
+	.read = do_sync_read,
+	.write = do_sync_write,
+	.aio_read = generic_file_aio_read,
+	.aio_write = generic_file_aio_write,
+	.mmap = generic_file_mmap,
+	.flush = yaffs_file_flush,
+	.fsync = yaffs_sync_object,
+	.splice_read = generic_file_splice_read,
+	.splice_write = generic_file_splice_write,
+	.llseek = generic_file_llseek,
+};
+
+
+/* ExportFS support */
+static struct inode *yaffs2_nfs_get_inode(struct super_block *sb, uint64_t ino,
+					  uint32_t generation)
+{
+	return yaffs_iget(sb, ino);
+}
+
+static struct dentry *yaffs2_fh_to_dentry(struct super_block *sb,
+					  struct fid *fid, int fh_len,
+					  int fh_type)
+{
+	return generic_fh_to_dentry(sb, fid, fh_len, fh_type,
+				    yaffs2_nfs_get_inode);
+}
+
+static struct dentry *yaffs2_fh_to_parent(struct super_block *sb,
+					  struct fid *fid, int fh_len,
+					  int fh_type)
+{
+	return generic_fh_to_parent(sb, fid, fh_len, fh_type,
+				    yaffs2_nfs_get_inode);
+}
+
+struct dentry *yaffs2_get_parent(struct dentry *dentry)
+{
+
+	struct super_block *sb = dentry->d_inode->i_sb;
+	struct dentry *parent = ERR_PTR(-ENOENT);
+	struct inode *inode;
+	unsigned long parent_ino;
+	struct yaffs_obj *d_obj;
+	struct yaffs_obj *parent_obj;
+
+	d_obj = yaffs_inode_to_obj(dentry->d_inode);
+
+	if (d_obj) {
+		parent_obj = d_obj->parent;
+		if (parent_obj) {
+			parent_ino = yaffs_get_obj_inode(parent_obj);
+			inode = yaffs_iget(sb, parent_ino);
+
+			if (IS_ERR(inode)) {
+				parent = ERR_CAST(inode);
+			} else {
+				parent = d_obtain_alias(inode);
+				if (!IS_ERR(parent)) {
+					parent = ERR_PTR(-ENOMEM);
+					iput(inode);
+				}
+			}
+		}
+	}
+	return parent;
+}
+
+/* Just declare a zero structure as a NULL value implies
+ * using the default functions of exportfs.
+ */
+
+static struct export_operations yaffs_export_ops = {
+	.fh_to_dentry = yaffs2_fh_to_dentry,
+	.fh_to_parent = yaffs2_fh_to_parent,
+	.get_parent = yaffs2_get_parent,
+};
+
+
+/*-----------------------------------------------------------------*/
+
+static int yaffs_readlink(struct dentry *dentry, char __user * buffer,
+			  int buflen)
+{
+	unsigned char *alias;
+	int ret;
+	struct yaffs_dev *dev = yaffs_dentry_to_obj(dentry)->my_dev;
+
+	yaffs_gross_lock(dev);
+
+	alias = yaffs_get_symlink_alias(yaffs_dentry_to_obj(dentry));
+
+	yaffs_gross_unlock(dev);
+
+	if (!alias)
+		return -ENOMEM;
+
+	ret = vfs_readlink(dentry, buffer, buflen, alias);
+	kfree(alias);
+	return ret;
+}
+
+static void *yaffs_follow_link(struct dentry *dentry, struct nameidata *nd)
+{
+	unsigned char *alias;
+	void *ret;
+	struct yaffs_dev *dev = yaffs_dentry_to_obj(dentry)->my_dev;
+
+	yaffs_gross_lock(dev);
+
+	alias = yaffs_get_symlink_alias(yaffs_dentry_to_obj(dentry));
+	yaffs_gross_unlock(dev);
+
+	if (!alias) {
+		ret = ERR_PTR(-ENOMEM);
+		goto out;
+	}
+
+	nd_set_link(nd, alias);
+	ret = (void *)alias;
+out:
+	return ret;
+}
+
+void yaffs_put_link(struct dentry *dentry, struct nameidata *nd, void *alias)
+{
+	kfree(alias);
+}
+
+
+static void yaffs_unstitch_obj(struct inode *inode, struct yaffs_obj *obj)
+{
+	/* Clear the association between the inode and
+	 * the struct yaffs_obj.
+	 */
+	obj->my_inode = NULL;
+	yaffs_inode_to_obj_lv(inode) = NULL;
+
+	/* If the object freeing was deferred, then the real
+	 * free happens now.
+	 * This should fix the inode inconsistency problem.
+	 */
+	yaffs_handle_defered_free(obj);
+}
+
+/* yaffs_evict_inode combines into one operation what was previously done in
+ * yaffs_clear_inode() and yaffs_delete_inode()
+ *
+ */
+static void yaffs_evict_inode(struct inode *inode)
+{
+	struct yaffs_obj *obj;
+	struct yaffs_dev *dev;
+	int deleteme = 0;
+
+	obj = yaffs_inode_to_obj(inode);
+
+	yaffs_trace(YAFFS_TRACE_OS,
+		"yaffs_evict_inode: ino %d, count %d %s",
+		(int)inode->i_ino,
+		atomic_read(&inode->i_count),
+		obj ? "object exists" : "null object");
+
+	if (!inode->i_nlink && !is_bad_inode(inode))
+		deleteme = 1;
+	truncate_inode_pages(&inode->i_data, 0);
+	end_writeback(inode);
+
+	if (deleteme && obj) {
+		dev = obj->my_dev;
+		yaffs_gross_lock(dev);
+		yaffs_del_obj(obj);
+		yaffs_gross_unlock(dev);
+	}
+	if (obj) {
+		dev = obj->my_dev;
+		yaffs_gross_lock(dev);
+		yaffs_unstitch_obj(inode, obj);
+		yaffs_gross_unlock(dev);
+	}
+
+}
+
+static void yaffs_touch_super(struct yaffs_dev *dev)
+{
+	struct super_block *sb = yaffs_dev_to_lc(dev)->super;
+
+	yaffs_trace(YAFFS_TRACE_OS, "yaffs_touch_super() sb = %p", sb);
+	if (sb)
+		sb->s_dirt = 1;
+}
+
+static int yaffs_readpage_nolock(struct file *f, struct page *pg)
+{
+	/* Lifted from jffs2 */
+
+	struct yaffs_obj *obj;
+	unsigned char *pg_buf;
+	int ret;
+	struct yaffs_dev *dev;
+	loff_t pos = ((loff_t) pg->index) << PAGE_CACHE_SHIFT;
+
+	yaffs_trace(YAFFS_TRACE_OS,
+		"yaffs_readpage_nolock at %lld, size %08x",
+		(long long)pos,
+		(unsigned)PAGE_CACHE_SIZE);
+
+
+	obj = yaffs_dentry_to_obj(f->f_dentry);
+
+	dev = obj->my_dev;
+
+	BUG_ON(!PageLocked(pg));
+
+	pg_buf = kmap(pg);
+	/* FIXME: Can kmap fail? */
+
+	yaffs_gross_lock(dev);
+
+	ret = yaffs_file_rd(obj, pg_buf, pos, PAGE_CACHE_SIZE);
+
+	yaffs_gross_unlock(dev);
+
+	if (ret >= 0)
+		ret = 0;
+
+	if (ret) {
+		ClearPageUptodate(pg);
+		SetPageError(pg);
+	} else {
+		SetPageUptodate(pg);
+		ClearPageError(pg);
+	}
+
+	flush_dcache_page(pg);
+	kunmap(pg);
+
+	yaffs_trace(YAFFS_TRACE_OS, "yaffs_readpage_nolock done");
+	return ret;
+}
+
+static int yaffs_readpage_unlock(struct file *f, struct page *pg)
+{
+	int ret = yaffs_readpage_nolock(f, pg);
+
+	unlock_page(pg);
+	return ret;
+}
+
+static int yaffs_readpage(struct file *f, struct page *pg)
+{
+	int ret;
+
+	yaffs_trace(YAFFS_TRACE_OS, "yaffs_readpage");
+	ret = yaffs_readpage_unlock(f, pg);
+	yaffs_trace(YAFFS_TRACE_OS, "yaffs_readpage done");
+	return ret;
+}
+
+/* writepage inspired by/stolen from smbfs */
+
+static int yaffs_writepage(struct page *page, struct writeback_control *wbc)
+{
+	struct yaffs_dev *dev;
+	struct address_space *mapping = page->mapping;
+	struct inode *inode;
+	unsigned long end_index;
+	char *buffer;
+	struct yaffs_obj *obj;
+	int n_written = 0;
+	unsigned n_bytes;
+	loff_t i_size;
+
+	if (!mapping)
+		BUG();
+	inode = mapping->host;
+	if (!inode)
+		BUG();
+	i_size = i_size_read(inode);
+
+	end_index = i_size >> PAGE_CACHE_SHIFT;
+
+	if (page->index < end_index)
+		n_bytes = PAGE_CACHE_SIZE;
+	else {
+		n_bytes = i_size & (PAGE_CACHE_SIZE - 1);
+
+		if (page->index > end_index || !n_bytes) {
+			yaffs_trace(YAFFS_TRACE_OS,
+				"yaffs_writepage at %08x, inode size = %08x!!!",
+				(unsigned)(page->index << PAGE_CACHE_SHIFT),
+				(unsigned)inode->i_size);
+			yaffs_trace(YAFFS_TRACE_OS,
+			  "                -> don't care!!");
+
+			zero_user_segment(page, 0, PAGE_CACHE_SIZE);
+			set_page_writeback(page);
+			unlock_page(page);
+			end_page_writeback(page);
+			return 0;
+		}
+	}
+
+	if (n_bytes != PAGE_CACHE_SIZE)
+		zero_user_segment(page, n_bytes, PAGE_CACHE_SIZE);
+
+	get_page(page);
+
+	buffer = kmap(page);
+
+	obj = yaffs_inode_to_obj(inode);
+	dev = obj->my_dev;
+	yaffs_gross_lock(dev);
+
+	yaffs_trace(YAFFS_TRACE_OS,
+		"yaffs_writepage at %08x, size %08x",
+		(unsigned)(page->index << PAGE_CACHE_SHIFT), n_bytes);
+	yaffs_trace(YAFFS_TRACE_OS,
+		"writepag0: obj = %05x, ino = %05x",
+		(int)obj->variant.file_variant.file_size, (int)inode->i_size);
+
+	n_written = yaffs_wr_file(obj, buffer,
+				  ((loff_t)page->index) << PAGE_CACHE_SHIFT,
+				  n_bytes, 0);
+
+	yaffs_touch_super(dev);
+
+	yaffs_trace(YAFFS_TRACE_OS,
+		"writepag1: obj = %05x, ino = %05x",
+		(int)obj->variant.file_variant.file_size, (int)inode->i_size);
+
+	yaffs_gross_unlock(dev);
+
+	kunmap(page);
+	set_page_writeback(page);
+	unlock_page(page);
+	end_page_writeback(page);
+	put_page(page);
+
+	return (n_written == n_bytes) ? 0 : -ENOSPC;
+}
+
+/* Space holding and freeing is done to ensure we have space available for
+ * write_begin/end.
+ * For now we just assume few parallel writes and check against a small
+ * number.
+ * Todo: need to do this with a counter to handle parallel reads better
+ */
+
+static ssize_t yaffs_hold_space(struct file *f)
+{
+	struct yaffs_obj *obj;
+	struct yaffs_dev *dev;
+	int n_free_chunks;
+
+	obj = yaffs_dentry_to_obj(f->f_dentry);
+
+	dev = obj->my_dev;
+
+	yaffs_gross_lock(dev);
+
+	n_free_chunks = yaffs_get_n_free_chunks(dev);
+
+	yaffs_gross_unlock(dev);
+
+	return (n_free_chunks > 20) ? 1 : 0;
+}
+
+static void yaffs_release_space(struct file *f)
+{
+	struct yaffs_obj *obj;
+	struct yaffs_dev *dev;
+
+	obj = yaffs_dentry_to_obj(f->f_dentry);
+
+	dev = obj->my_dev;
+
+	yaffs_gross_lock(dev);
+
+	yaffs_gross_unlock(dev);
+}
+
+static int yaffs_write_begin(struct file *filp, struct address_space *mapping,
+			     loff_t pos, unsigned len, unsigned flags,
+			     struct page **pagep, void **fsdata)
+{
+	struct page *pg = NULL;
+	pgoff_t index = pos >> PAGE_CACHE_SHIFT;
+	int ret = 0;
+	int space_held = 0;
+
+	/* Get a page */
+	pg = grab_cache_page_write_begin(mapping, index, flags);
+
+	*pagep = pg;
+	if (!pg) {
+		ret = -ENOMEM;
+		goto out;
+	}
+	yaffs_trace(YAFFS_TRACE_OS,
+		"start yaffs_write_begin index %d(%x) uptodate %d",
+		(int)index, (int)index, PageUptodate(pg) ? 1 : 0);
+
+	/* Get fs space */
+	space_held = yaffs_hold_space(filp);
+
+	if (!space_held) {
+		ret = -ENOSPC;
+		goto out;
+	}
+
+	/* Update page if required */
+
+	if (!PageUptodate(pg))
+		ret = yaffs_readpage_nolock(filp, pg);
+
+	if (ret)
+		goto out;
+
+	/* Happy path return */
+	yaffs_trace(YAFFS_TRACE_OS, "end yaffs_write_begin - ok");
+
+	return 0;
+
+out:
+	yaffs_trace(YAFFS_TRACE_OS,
+		"end yaffs_write_begin fail returning %d", ret);
+	if (space_held)
+		yaffs_release_space(filp);
+	if (pg) {
+		unlock_page(pg);
+		page_cache_release(pg);
+	}
+	return ret;
+}
+
+static ssize_t yaffs_file_write(struct file *f, const char *buf, size_t n,
+				loff_t *pos)
+{
+	struct yaffs_obj *obj;
+	int n_written, ipos;
+	struct inode *inode;
+	struct yaffs_dev *dev;
+
+	obj = yaffs_dentry_to_obj(f->f_dentry);
+
+	if (!obj) {
+		/* This should not happen */
+		yaffs_trace(YAFFS_TRACE_OS,
+			"yaffs_file_write: hey obj is null!");
+		return -EINVAL;
+	}
+
+	dev = obj->my_dev;
+
+	yaffs_gross_lock(dev);
+
+	inode = f->f_dentry->d_inode;
+
+	if (!S_ISBLK(inode->i_mode) && f->f_flags & O_APPEND)
+		ipos = inode->i_size;
+	else
+		ipos = *pos;
+
+	yaffs_trace(YAFFS_TRACE_OS,
+		"yaffs_file_write about to write writing %u(%x) bytes to object %d at %d(%x)",
+		(unsigned)n, (unsigned)n, obj->obj_id, ipos, ipos);
+
+	n_written = yaffs_wr_file(obj, buf, ipos, n, 0);
+
+	yaffs_touch_super(dev);
+
+	yaffs_trace(YAFFS_TRACE_OS,
+		"yaffs_file_write: %d(%x) bytes written",
+		(unsigned)n, (unsigned)n);
+
+	if (n_written > 0) {
+		ipos += n_written;
+		*pos = ipos;
+		if (ipos > inode->i_size) {
+			inode->i_size = ipos;
+			inode->i_blocks = (ipos + 511) >> 9;
+
+			yaffs_trace(YAFFS_TRACE_OS,
+				"yaffs_file_write size updated to %d bytes, %d blocks",
+				ipos, (int)(inode->i_blocks));
+		}
+	}
+	yaffs_gross_unlock(dev);
+	return (n_written == 0) && (n > 0) ? -ENOSPC : n_written;
+}
+
+static int yaffs_write_end(struct file *filp, struct address_space *mapping,
+			   loff_t pos, unsigned len, unsigned copied,
+			   struct page *pg, void *fsdadata)
+{
+	int ret = 0;
+	void *addr, *kva;
+	uint32_t offset_into_page = pos & (PAGE_CACHE_SIZE - 1);
+
+	kva = kmap(pg);
+	addr = kva + offset_into_page;
+
+	yaffs_trace(YAFFS_TRACE_OS,
+		"yaffs_write_end addr %p pos %x n_bytes %d",
+		addr, (unsigned)pos, copied);
+
+	ret = yaffs_file_write(filp, addr, copied, &pos);
+
+	if (ret != copied) {
+		yaffs_trace(YAFFS_TRACE_OS,
+			"yaffs_write_end not same size ret %d  copied %d",
+			ret, copied);
+		SetPageError(pg);
+	}
+
+	kunmap(pg);
+
+	yaffs_release_space(filp);
+	unlock_page(pg);
+	page_cache_release(pg);
+	return ret;
+}
+
+static int yaffs_statfs(struct dentry *dentry, struct kstatfs *buf)
+{
+	struct yaffs_dev *dev = yaffs_dentry_to_obj(dentry)->my_dev;
+	struct super_block *sb = dentry->d_sb;
+
+	yaffs_trace(YAFFS_TRACE_OS, "yaffs_statfs");
+
+	yaffs_gross_lock(dev);
+
+	buf->f_type = YAFFS_MAGIC;
+	buf->f_bsize = sb->s_blocksize;
+	buf->f_namelen = 255;
+
+	if (dev->data_bytes_per_chunk & (dev->data_bytes_per_chunk - 1)) {
+		/* Do this if chunk size is not a power of 2 */
+
+		uint64_t bytes_in_dev;
+		uint64_t bytes_free;
+
+		bytes_in_dev =
+		    ((uint64_t)
+		     ((dev->param.end_block - dev->param.start_block + 1))) *
+		     ((uint64_t) (dev->param.chunks_per_block *
+					   dev->data_bytes_per_chunk));
+
+		do_div(bytes_in_dev, sb->s_blocksize);
+			/* bytes_in_dev becomes the number of blocks */
+		buf->f_blocks = bytes_in_dev;
+
+		bytes_free = ((uint64_t) (yaffs_get_n_free_chunks(dev))) *
+		    ((uint64_t) (dev->data_bytes_per_chunk));
+
+		do_div(bytes_free, sb->s_blocksize);
+
+		buf->f_bfree = bytes_free;
+
+	} else if (sb->s_blocksize > dev->data_bytes_per_chunk) {
+
+		buf->f_blocks =
+		    (dev->param.end_block - dev->param.start_block + 1) *
+		    dev->param.chunks_per_block /
+		    (sb->s_blocksize / dev->data_bytes_per_chunk);
+		buf->f_bfree =
+		    yaffs_get_n_free_chunks(dev) /
+		    (sb->s_blocksize / dev->data_bytes_per_chunk);
+	} else {
+		buf->f_blocks =
+		    (dev->param.end_block - dev->param.start_block + 1) *
+		    dev->param.chunks_per_block *
+		    (dev->data_bytes_per_chunk / sb->s_blocksize);
+
+		buf->f_bfree =
+		    yaffs_get_n_free_chunks(dev) *
+		    (dev->data_bytes_per_chunk / sb->s_blocksize);
+	}
+
+	buf->f_files = 0;
+	buf->f_ffree = 0;
+	buf->f_bavail = buf->f_bfree;
+
+	yaffs_gross_unlock(dev);
+	return 0;
+}
+
+static void yaffs_flush_inodes(struct super_block *sb)
+{
+	struct inode *iptr;
+	struct yaffs_obj *obj;
+
+	list_for_each_entry(iptr, &sb->s_inodes, i_sb_list) {
+		obj = yaffs_inode_to_obj(iptr);
+		if (obj) {
+			yaffs_trace(YAFFS_TRACE_OS,
+				"flushing obj %d", obj->obj_id);
+			yaffs_flush_file(obj, 1, 0, 0);
+		}
+	}
+}
+
+static void yaffs_flush_super(struct super_block *sb, int do_checkpoint)
+{
+	struct yaffs_dev *dev = yaffs_super_to_dev(sb);
+
+	if (!dev)
+		return;
+
+	yaffs_flush_inodes(sb);
+	yaffs_update_dirty_dirs(dev);
+	yaffs_flush_whole_cache(dev, 1);
+	if (do_checkpoint)
+		yaffs_checkpoint_save(dev);
+}
+
+static unsigned yaffs_bg_gc_urgency(struct yaffs_dev *dev)
+{
+	unsigned erased_chunks =
+	    dev->n_erased_blocks * dev->param.chunks_per_block;
+	struct yaffs_linux_context *context = yaffs_dev_to_lc(dev);
+	unsigned scattered = 0;	/* Free chunks not in an erased block */
+
+	if (erased_chunks < dev->n_free_chunks)
+		scattered = (dev->n_free_chunks - erased_chunks);
+
+	if (!context->bg_running)
+		return 0;
+	else if (scattered < (dev->param.chunks_per_block * 2))
+		return 0;
+	else if (erased_chunks > dev->n_free_chunks / 2)
+		return 0;
+	else if (erased_chunks > dev->n_free_chunks / 4)
+		return 1;
+	else
+		return 2;
+}
+
+static int yaffs_do_sync_fs(struct super_block *sb, int request_checkpoint)
+{
+
+	struct yaffs_dev *dev = yaffs_super_to_dev(sb);
+	unsigned int oneshot_checkpoint = (yaffs_auto_checkpoint & 4);
+	unsigned gc_urgent = yaffs_bg_gc_urgency(dev);
+	int do_checkpoint;
+
+	yaffs_trace(YAFFS_TRACE_OS | YAFFS_TRACE_SYNC | YAFFS_TRACE_BACKGROUND,
+		"yaffs_do_sync_fs: gc-urgency %d %s %s%s",
+		gc_urgent,
+		sb->s_dirt ? "dirty" : "clean",
+		request_checkpoint ? "checkpoint requested" : "no checkpoint",
+		oneshot_checkpoint ? " one-shot" : "");
+
+	yaffs_gross_lock(dev);
+	do_checkpoint = ((request_checkpoint && !gc_urgent) ||
+			 oneshot_checkpoint) && !dev->is_checkpointed;
+
+	if (sb->s_dirt || do_checkpoint) {
+		yaffs_flush_super(sb, !dev->is_checkpointed && do_checkpoint);
+		sb->s_dirt = 0;
+		if (oneshot_checkpoint)
+			yaffs_auto_checkpoint &= ~4;
+	}
+	yaffs_gross_unlock(dev);
+
+	return 0;
+}
+
+/*
+ * yaffs background thread functions .
+ * yaffs_bg_thread_fn() the thread function
+ * yaffs_bg_start() launches the background thread.
+ * yaffs_bg_stop() cleans up the background thread.
+ *
+ * NB:
+ * The thread should only run after the yaffs is initialised
+ * The thread should be stopped before yaffs is unmounted.
+ * The thread should not do any writing while the fs is in read only.
+ */
+
+void yaffs_background_waker(unsigned long data)
+{
+	wake_up_process((struct task_struct *)data);
+}
+
+static int yaffs_bg_thread_fn(void *data)
+{
+	struct yaffs_dev *dev = (struct yaffs_dev *)data;
+	struct yaffs_linux_context *context = yaffs_dev_to_lc(dev);
+	unsigned long now = jiffies;
+	unsigned long next_dir_update = now;
+	unsigned long next_gc = now;
+	unsigned long expires;
+	unsigned int urgency;
+	int gc_result;
+	struct timer_list timer;
+
+	yaffs_trace(YAFFS_TRACE_BACKGROUND,
+		"yaffs_background starting for dev %p", (void *)dev);
+
+	set_freezable();
+	while (context->bg_running) {
+		yaffs_trace(YAFFS_TRACE_BACKGROUND, "yaffs_background");
+
+		if (kthread_should_stop())
+			break;
+
+		if (try_to_freeze())
+			continue;
+
+		yaffs_gross_lock(dev);
+
+		now = jiffies;
+
+		if (time_after(now, next_dir_update) && yaffs_bg_enable) {
+			yaffs_update_dirty_dirs(dev);
+			next_dir_update = now + HZ;
+		}
+
+		if (time_after(now, next_gc) && yaffs_bg_enable) {
+			if (!dev->is_checkpointed) {
+				urgency = yaffs_bg_gc_urgency(dev);
+				gc_result = yaffs_bg_gc(dev, urgency);
+				if (urgency > 1)
+					next_gc = now + HZ / 20 + 1;
+				else if (urgency > 0)
+					next_gc = now + HZ / 10 + 1;
+				else
+					next_gc = now + HZ * 2;
+			} else	{
+				/*
+				 * gc not running so set to next_dir_update
+				 * to cut down on wake ups
+				 */
+				next_gc = next_dir_update;
+			}
+		}
+		yaffs_gross_unlock(dev);
+		expires = next_dir_update;
+		if (time_before(next_gc, expires))
+			expires = next_gc;
+		if (time_before(expires, now))
+			expires = now + HZ;
+
+		init_timer_on_stack(&timer);
+		timer.expires = expires + 1;
+		timer.data = (unsigned long)current;
+		timer.function = yaffs_background_waker;
+
+		set_current_state(TASK_INTERRUPTIBLE);
+		add_timer(&timer);
+		schedule();
+		del_timer_sync(&timer);
+	}
+
+	return 0;
+}
+
+static int yaffs_bg_start(struct yaffs_dev *dev)
+{
+	int retval = 0;
+	struct yaffs_linux_context *context = yaffs_dev_to_lc(dev);
+
+	if (dev->read_only)
+		return -1;
+
+	context->bg_running = 1;
+
+	context->bg_thread = kthread_run(yaffs_bg_thread_fn,
+					 (void *)dev, "yaffs-bg-%d",
+					 context->mount_id);
+
+	if (IS_ERR(context->bg_thread)) {
+		retval = PTR_ERR(context->bg_thread);
+		context->bg_thread = NULL;
+		context->bg_running = 0;
+	}
+	return retval;
+}
+
+static void yaffs_bg_stop(struct yaffs_dev *dev)
+{
+	struct yaffs_linux_context *ctxt = yaffs_dev_to_lc(dev);
+
+	ctxt->bg_running = 0;
+
+	if (ctxt->bg_thread) {
+		kthread_stop(ctxt->bg_thread);
+		ctxt->bg_thread = NULL;
+	}
+}
+
+static void yaffs_write_super(struct super_block *sb)
+{
+	unsigned request_checkpoint = (yaffs_auto_checkpoint >= 2);
+
+	yaffs_trace(YAFFS_TRACE_OS | YAFFS_TRACE_SYNC | YAFFS_TRACE_BACKGROUND,
+		"yaffs_write_super%s",
+		request_checkpoint ? " checkpt" : "");
+
+	yaffs_do_sync_fs(sb, request_checkpoint);
+
+}
+
+static int yaffs_sync_fs(struct super_block *sb, int wait)
+{
+	unsigned request_checkpoint = (yaffs_auto_checkpoint >= 1);
+
+	yaffs_trace(YAFFS_TRACE_OS | YAFFS_TRACE_SYNC,
+		"yaffs_sync_fs%s", request_checkpoint ? " checkpt" : "");
+
+	yaffs_do_sync_fs(sb, request_checkpoint);
+
+	return 0;
+}
+
+static LIST_HEAD(yaffs_context_list);
+struct mutex yaffs_context_lock;
+
+struct yaffs_options {
+	int inband_tags;
+	int skip_checkpoint_read;
+	int skip_checkpoint_write;
+	int no_cache;
+	int tags_ecc_on;
+	int tags_ecc_overridden;
+	int lazy_loading_enabled;
+	int lazy_loading_overridden;
+	int empty_lost_and_found;
+	int empty_lost_and_found_overridden;
+};
+
+#define MAX_OPT_LEN 30
+static int yaffs_parse_options(struct yaffs_options *options,
+				const char *options_str)
+{
+	char cur_opt[MAX_OPT_LEN + 1];
+	int p;
+	int error = 0;
+
+	/* Parse through the options which is a comma seperated list */
+
+	while (options_str && *options_str && !error) {
+		memset(cur_opt, 0, MAX_OPT_LEN + 1);
+		p = 0;
+
+		while (*options_str == ',')
+			options_str++;
+
+		while (*options_str && *options_str != ',') {
+			if (p < MAX_OPT_LEN) {
+				cur_opt[p] = *options_str;
+				p++;
+			}
+			options_str++;
+		}
+
+		if (!strcmp(cur_opt, "inband-tags")) {
+			options->inband_tags = 1;
+		} else if (!strcmp(cur_opt, "tags-ecc-off")) {
+			options->tags_ecc_on = 0;
+			options->tags_ecc_overridden = 1;
+		} else if (!strcmp(cur_opt, "tags-ecc-on")) {
+			options->tags_ecc_on = 1;
+			options->tags_ecc_overridden = 1;
+		} else if (!strcmp(cur_opt, "lazy-loading-off")) {
+			options->lazy_loading_enabled = 0;
+			options->lazy_loading_overridden = 1;
+		} else if (!strcmp(cur_opt, "lazy-loading-on")) {
+			options->lazy_loading_enabled = 1;
+			options->lazy_loading_overridden = 1;
+		} else if (!strcmp(cur_opt, "empty-lost-and-found-off")) {
+			options->empty_lost_and_found = 0;
+			options->empty_lost_and_found_overridden = 1;
+		} else if (!strcmp(cur_opt, "empty-lost-and-found-on")) {
+			options->empty_lost_and_found = 1;
+			options->empty_lost_and_found_overridden = 1;
+		} else if (!strcmp(cur_opt, "no-cache")) {
+			options->no_cache = 1;
+		} else if (!strcmp(cur_opt, "no-checkpoint-read")) {
+			options->skip_checkpoint_read = 1;
+		} else if (!strcmp(cur_opt, "no-checkpoint-write")) {
+			options->skip_checkpoint_write = 1;
+		} else if (!strcmp(cur_opt, "no-checkpoint")) {
+			options->skip_checkpoint_read = 1;
+			options->skip_checkpoint_write = 1;
+		} else {
+			printk(KERN_INFO "yaffs: Bad mount option \"%s\"\n",
+			       cur_opt);
+			error = 1;
+		}
+	}
+	return error;
+}
+
+static const struct address_space_operations yaffs_file_address_operations = {
+	.readpage = yaffs_readpage,
+	.writepage = yaffs_writepage,
+	.write_begin = yaffs_write_begin,
+	.write_end = yaffs_write_end,
+};
+
+
+
+static const struct inode_operations yaffs_file_inode_operations = {
+	.setattr = yaffs_setattr,
+	.setxattr = yaffs_setxattr,
+	.getxattr = yaffs_getxattr,
+	.listxattr = yaffs_listxattr,
+	.removexattr = yaffs_removexattr,
+};
+
+static const struct inode_operations yaffs_symlink_inode_operations = {
+	.readlink = yaffs_readlink,
+	.follow_link = yaffs_follow_link,
+	.put_link = yaffs_put_link,
+	.setattr = yaffs_setattr,
+	.setxattr = yaffs_setxattr,
+	.getxattr = yaffs_getxattr,
+	.listxattr = yaffs_listxattr,
+	.removexattr = yaffs_removexattr,
+};
+
+static void yaffs_fill_inode_from_obj(struct inode *inode,
+				      struct yaffs_obj *obj)
+{
+	u32 mode;
+
+	if (!inode || !obj)  {
+		yaffs_trace(YAFFS_TRACE_OS,
+			"yaffs_fill_inode invalid parameters");
+		return;
+	}
+
+	/* Check mode against the variant type
+	 * and attempt to repair if broken. */
+	mode = obj->yst_mode;
+
+	switch (obj->variant_type) {
+	case YAFFS_OBJECT_TYPE_FILE:
+		if (!S_ISREG(mode)) {
+			obj->yst_mode &= ~S_IFMT;
+			obj->yst_mode |= S_IFREG;
+		}
+		break;
+	case YAFFS_OBJECT_TYPE_SYMLINK:
+		if (!S_ISLNK(mode)) {
+			obj->yst_mode &= ~S_IFMT;
+			obj->yst_mode |= S_IFLNK;
+		}
+		break;
+	case YAFFS_OBJECT_TYPE_DIRECTORY:
+		if (!S_ISDIR(mode)) {
+			obj->yst_mode &= ~S_IFMT;
+			obj->yst_mode |= S_IFDIR;
+		}
+		break;
+	case YAFFS_OBJECT_TYPE_UNKNOWN:
+	case YAFFS_OBJECT_TYPE_HARDLINK:
+	case YAFFS_OBJECT_TYPE_SPECIAL:
+	default:
+		/* TODO? */
+		break;
+	}
+
+	inode->i_flags |= S_NOATIME;
+	inode->i_ino = obj->obj_id;
+	inode->i_mode = obj->yst_mode;
+	inode->i_uid = obj->yst_uid;
+	inode->i_gid = obj->yst_gid;
+
+	inode->i_rdev = old_decode_dev(obj->yst_rdev);
+
+	inode->i_atime.tv_sec = (time_t) (obj->yst_atime);
+	inode->i_atime.tv_nsec = 0;
+	inode->i_mtime.tv_sec = (time_t) obj->yst_mtime;
+	inode->i_mtime.tv_nsec = 0;
+	inode->i_ctime.tv_sec = (time_t) obj->yst_ctime;
+	inode->i_ctime.tv_nsec = 0;
+	inode->i_size = yaffs_get_obj_length(obj);
+	inode->i_blocks = (inode->i_size + 511) >> 9;
+	set_nlink(inode, yaffs_get_obj_link_count(obj));
+	yaffs_trace(YAFFS_TRACE_OS,
+		"yaffs_fill_inode mode %x uid %d gid %d size %d count %d",
+		inode->i_mode, inode->i_uid, inode->i_gid,
+		(int)inode->i_size, atomic_read(&inode->i_count));
+
+	switch (obj->yst_mode & S_IFMT) {
+	default:	/* fifo, device or socket */
+		init_special_inode(inode, obj->yst_mode,
+				   old_decode_dev(obj->yst_rdev));
+		break;
+	case S_IFREG:	/* file */
+		inode->i_op = &yaffs_file_inode_operations;
+		inode->i_fop = &yaffs_file_operations;
+		inode->i_mapping->a_ops = &yaffs_file_address_operations;
+		break;
+	case S_IFDIR:	/* directory */
+		inode->i_op = &yaffs_dir_inode_operations;
+		inode->i_fop = &yaffs_dir_operations;
+		break;
+	case S_IFLNK:	/* symlink */
+		inode->i_op = &yaffs_symlink_inode_operations;
+		break;
+	}
+
+	yaffs_inode_to_obj_lv(inode) = obj;
+	obj->my_inode = inode;
+}
+
+static void yaffs_put_super(struct super_block *sb)
+{
+	struct yaffs_dev *dev = yaffs_super_to_dev(sb);
+	struct mtd_info *mtd = yaffs_dev_to_mtd(dev);
+
+	yaffs_trace(YAFFS_TRACE_OS, "yaffs_put_super");
+
+	yaffs_trace(YAFFS_TRACE_OS | YAFFS_TRACE_BACKGROUND,
+		"Shutting down yaffs background thread");
+	yaffs_bg_stop(dev);
+	yaffs_trace(YAFFS_TRACE_OS | YAFFS_TRACE_BACKGROUND,
+		"yaffs background thread shut down");
+
+	yaffs_gross_lock(dev);
+
+	yaffs_flush_super(sb, 1);
+
+	if (yaffs_dev_to_lc(dev)->put_super_fn)
+		yaffs_dev_to_lc(dev)->put_super_fn(sb);
+
+	yaffs_deinitialise(dev);
+
+	yaffs_gross_unlock(dev);
+	mutex_lock(&yaffs_context_lock);
+	list_del_init(&(yaffs_dev_to_lc(dev)->context_list));
+	mutex_unlock(&yaffs_context_lock);
+
+	if (yaffs_dev_to_lc(dev)->spare_buffer) {
+		kfree(yaffs_dev_to_lc(dev)->spare_buffer);
+		yaffs_dev_to_lc(dev)->spare_buffer = NULL;
+	}
+
+	kfree(dev);
+
+	if (mtd && mtd->sync)
+		mtd->sync(mtd);
+
+	if (mtd)
+		put_mtd_device(mtd);
+}
+
+/* the function only is used to change dev->read_only when this file system
+ * is remounted.
+ */
+static int yaffs_remount_fs(struct super_block *sb, int *flags, char *data)
+{
+	int read_only = 0;
+	struct mtd_info *mtd;
+	struct yaffs_dev *dev = 0;
+
+	/* Get the device */
+	mtd = get_mtd_device(NULL, MINOR(sb->s_dev));
+	if (!mtd) {
+		yaffs_trace(YAFFS_TRACE_ALWAYS,
+			"MTD device #%u doesn't appear to exist",
+			MINOR(sb->s_dev));
+		return 1;
+	}
+
+	/* Check it's NAND */
+	if (mtd->type != MTD_NANDFLASH) {
+		yaffs_trace(YAFFS_TRACE_ALWAYS,
+			"MTD device is not NAND it's type %d",
+			mtd->type);
+		return 1;
+	}
+
+	read_only = ((*flags & MS_RDONLY) != 0);
+	if (!read_only && !(mtd->flags & MTD_WRITEABLE)) {
+		read_only = 1;
+		printk(KERN_INFO
+			"yaffs: mtd is read only, setting superblock read only");
+		*flags |= MS_RDONLY;
+	}
+
+	dev = sb->s_fs_info;
+	dev->read_only = read_only;
+
+	return 0;
+}
+
+
+static const struct super_operations yaffs_super_ops = {
+	.statfs = yaffs_statfs,
+	.put_super = yaffs_put_super,
+	.evict_inode = yaffs_evict_inode,
+	.sync_fs = yaffs_sync_fs,
+	.write_super = yaffs_write_super,
+	.remount_fs = yaffs_remount_fs,
+};
+
+static struct super_block *yaffs_internal_read_super(int yaffs_version,
+						     struct super_block *sb,
+						     void *data, int silent)
+{
+	int n_blocks;
+	struct inode *inode = NULL;
+	struct dentry *root;
+	struct yaffs_dev *dev = 0;
+	char devname_buf[BDEVNAME_SIZE + 1];
+	struct mtd_info *mtd;
+	int err;
+	char *data_str = (char *)data;
+	struct yaffs_linux_context *context = NULL;
+	struct yaffs_param *param;
+	int read_only = 0;
+	struct yaffs_options options;
+	unsigned mount_id;
+	int found;
+	struct yaffs_linux_context *context_iterator;
+	struct list_head *l;
+
+	if (!sb) {
+		printk(KERN_INFO "yaffs: sb is NULL\n");
+		return NULL;
+	}
+
+	sb->s_magic = YAFFS_MAGIC;
+	sb->s_op = &yaffs_super_ops;
+	sb->s_flags |= MS_NOATIME;
+
+	read_only = ((sb->s_flags & MS_RDONLY) != 0);
+
+	sb->s_export_op = &yaffs_export_ops;
+
+	if (!sb->s_dev)
+		printk(KERN_INFO "yaffs: sb->s_dev is NULL\n");
+	else if (!yaffs_devname(sb, devname_buf))
+		printk(KERN_INFO "yaffs: devname is NULL\n");
+	else
+		printk(KERN_INFO "yaffs: dev is %d name is \"%s\" %s\n",
+		       sb->s_dev,
+		       yaffs_devname(sb, devname_buf), read_only ? "ro" : "rw");
+
+	if (!data_str)
+		data_str = "";
+
+	printk(KERN_INFO "yaffs: passed flags \"%s\"\n", data_str);
+
+	memset(&options, 0, sizeof(options));
+
+	if (yaffs_parse_options(&options, data_str))
+		/* Option parsing failed */
+		return NULL;
+
+	sb->s_blocksize = PAGE_CACHE_SIZE;
+	sb->s_blocksize_bits = PAGE_CACHE_SHIFT;
+
+	yaffs_trace(YAFFS_TRACE_OS,
+		"yaffs_read_super: Using yaffs%d", yaffs_version);
+	yaffs_trace(YAFFS_TRACE_OS,
+		"yaffs_read_super: block size %d", (int)(sb->s_blocksize));
+
+	yaffs_trace(YAFFS_TRACE_ALWAYS,
+		"Attempting MTD mount of %u.%u,\"%s\"",
+		MAJOR(sb->s_dev), MINOR(sb->s_dev),
+		yaffs_devname(sb, devname_buf));
+
+	/* Check it's an mtd device..... */
+	if (MAJOR(sb->s_dev) != MTD_BLOCK_MAJOR)
+		return NULL;	/* This isn't an mtd device */
+
+	/* Get the device */
+	mtd = get_mtd_device(NULL, MINOR(sb->s_dev));
+	if (IS_ERR(mtd)) {
+		yaffs_trace(YAFFS_TRACE_ALWAYS,
+			"MTD device #%u doesn't appear to exist",
+			MINOR(sb->s_dev));
+		return NULL;
+	}
+	/* Check it's NAND */
+	if (mtd->type != MTD_NANDFLASH) {
+		yaffs_trace(YAFFS_TRACE_ALWAYS,
+			"MTD device is not NAND it's type %d",
+			mtd->type);
+		return NULL;
+	}
+
+	yaffs_trace(YAFFS_TRACE_OS, " erase %p", mtd->erase);
+	yaffs_trace(YAFFS_TRACE_OS, " read %p", mtd->read);
+	yaffs_trace(YAFFS_TRACE_OS, " write %p", mtd->write);
+	yaffs_trace(YAFFS_TRACE_OS, " readoob %p", mtd->read_oob);
+	yaffs_trace(YAFFS_TRACE_OS, " writeoob %p", mtd->write_oob);
+	yaffs_trace(YAFFS_TRACE_OS, " block_isbad %p", mtd->block_isbad);
+	yaffs_trace(YAFFS_TRACE_OS, " block_markbad %p", mtd->block_markbad);
+	yaffs_trace(YAFFS_TRACE_OS, " writesize %d", mtd->writesize);
+	yaffs_trace(YAFFS_TRACE_OS, " oobsize %d", mtd->oobsize);
+	yaffs_trace(YAFFS_TRACE_OS, " erasesize %d", mtd->erasesize);
+	yaffs_trace(YAFFS_TRACE_OS, " size %lld", mtd->size);
+
+	if (yaffs_auto_select && yaffs_version == 1 && mtd->writesize >= 2048) {
+		yaffs_trace(YAFFS_TRACE_ALWAYS, "auto selecting yaffs2");
+		yaffs_version = 2;
+	}
+
+	if (yaffs_auto_select && yaffs_version == 2 && !options.inband_tags &&
+		mtd->writesize == 512) {
+		yaffs_trace(YAFFS_TRACE_ALWAYS, "auto selecting yaffs1");
+		yaffs_version = 1;
+	}
+
+	if (yaffs_version == 2) {
+		/* Check for version 2 style functions */
+		if (!mtd->erase ||
+		    !mtd->block_isbad ||
+		    !mtd->block_markbad ||
+		    !mtd->read ||
+		    !mtd->write || !mtd->read_oob || !mtd->write_oob) {
+			yaffs_trace(YAFFS_TRACE_ALWAYS,
+				"MTD device does not support required functions");
+			return NULL;
+		}
+
+		if ((mtd->writesize < YAFFS_MIN_YAFFS2_CHUNK_SIZE ||
+		     mtd->oobsize < YAFFS_MIN_YAFFS2_SPARE_SIZE) &&
+		    !options.inband_tags) {
+			yaffs_trace(YAFFS_TRACE_ALWAYS,
+				"MTD device does not have the right page sizes");
+			return NULL;
+		}
+	} else {
+		/* Check for V1 style functions */
+		if (!mtd->erase ||
+		    !mtd->read ||
+		    !mtd->write || !mtd->read_oob || !mtd->write_oob) {
+			yaffs_trace(YAFFS_TRACE_ALWAYS,
+				"MTD device does not support required functions");
+			return NULL;
+		}
+
+		if (mtd->writesize < YAFFS_BYTES_PER_CHUNK ||
+		    mtd->oobsize != YAFFS_BYTES_PER_SPARE) {
+			yaffs_trace(YAFFS_TRACE_ALWAYS,
+				"MTD device does not support have the right page sizes");
+			return NULL;
+		}
+	}
+
+	/* OK, so if we got here, we have an MTD that's NAND and looks
+	 * like it has the right capabilities
+	 * Set the struct yaffs_dev up for mtd
+	 */
+
+	if (!read_only && !(mtd->flags & MTD_WRITEABLE)) {
+		read_only = 1;
+		printk(KERN_INFO
+		       "yaffs: mtd is read only, setting superblock read only");
+		sb->s_flags |= MS_RDONLY;
+	}
+
+	dev = kmalloc(sizeof(struct yaffs_dev), GFP_KERNEL);
+	context = kmalloc(sizeof(struct yaffs_linux_context), GFP_KERNEL);
+
+	if (!dev || !context) {
+		kfree(dev);
+		kfree(context);
+		dev = NULL;
+		context = NULL;
+
+		/* Deep shit could not allocate device structure */
+		yaffs_trace(YAFFS_TRACE_ALWAYS,
+			"yaffs_read_super failed trying to allocate yaffs_dev");
+		return NULL;
+	}
+	memset(dev, 0, sizeof(struct yaffs_dev));
+	param = &(dev->param);
+
+	memset(context, 0, sizeof(struct yaffs_linux_context));
+	dev->os_context = context;
+	INIT_LIST_HEAD(&(context->context_list));
+	context->dev = dev;
+	context->super = sb;
+
+	dev->read_only = read_only;
+
+	sb->s_fs_info = dev;
+
+	dev->driver_context = mtd;
+	param->name = mtd->name;
+
+	/* Set up the memory size parameters.... */
+
+	n_blocks =
+	    YCALCBLOCKS(mtd->size,
+			(YAFFS_CHUNKS_PER_BLOCK * YAFFS_BYTES_PER_CHUNK));
+
+	param->start_block = 0;
+	param->end_block = n_blocks - 1;
+	param->chunks_per_block = YAFFS_CHUNKS_PER_BLOCK;
+	param->total_bytes_per_chunk = YAFFS_BYTES_PER_CHUNK;
+	param->n_reserved_blocks = 5;
+	param->n_caches = (options.no_cache) ? 0 : 10;
+	param->inband_tags = options.inband_tags;
+
+	param->disable_lazy_load = 1;
+	param->enable_xattr = 1;
+	if (options.lazy_loading_overridden)
+		param->disable_lazy_load = !options.lazy_loading_enabled;
+
+	param->defered_dir_update = 1;
+
+	if (options.tags_ecc_overridden)
+		param->no_tags_ecc = !options.tags_ecc_on;
+
+	param->empty_lost_n_found = 1;
+
+	param->refresh_period = 500;
+
+	if (options.empty_lost_and_found_overridden)
+		param->empty_lost_n_found = options.empty_lost_and_found;
+
+	/* ... and the functions. */
+	if (yaffs_version == 2) {
+		param->write_chunk_tags_fn = nandmtd2_write_chunk_tags;
+		param->read_chunk_tags_fn = nandmtd2_read_chunk_tags;
+		param->bad_block_fn = nandmtd2_mark_block_bad;
+		param->query_block_fn = nandmtd2_query_block;
+		yaffs_dev_to_lc(dev)->spare_buffer =
+				kmalloc(mtd->oobsize, GFP_NOFS);
+		param->is_yaffs2 = 1;
+		param->total_bytes_per_chunk = mtd->writesize;
+		param->chunks_per_block = mtd->erasesize / mtd->writesize;
+		n_blocks = YCALCBLOCKS(mtd->size, mtd->erasesize);
+
+		param->start_block = 0;
+		param->end_block = n_blocks - 1;
+	} else {
+		/* use the MTD interface in yaffs_mtdif1.c */
+		param->write_chunk_tags_fn = nandmtd1_write_chunk_tags;
+		param->read_chunk_tags_fn = nandmtd1_read_chunk_tags;
+		param->bad_block_fn = nandmtd1_mark_block_bad;
+		param->query_block_fn = nandmtd1_query_block;
+		param->is_yaffs2 = 0;
+	}
+	/* ... and common functions */
+	param->erase_fn = nandmtd_erase_block;
+	param->initialise_flash_fn = nandmtd_initialise;
+
+	yaffs_dev_to_lc(dev)->put_super_fn = yaffs_mtd_put_super;
+
+	param->sb_dirty_fn = yaffs_touch_super;
+	param->gc_control_fn = yaffs_gc_control_callback;
+
+	yaffs_dev_to_lc(dev)->super = sb;
+
+	param->use_nand_ecc = 1;
+
+	param->skip_checkpt_rd = options.skip_checkpoint_read;
+	param->skip_checkpt_wr = options.skip_checkpoint_write;
+
+	mutex_lock(&yaffs_context_lock);
+	/* Get a mount id */
+	for (mount_id = 0, found = 0; !found; mount_id++) {
+		found = 1;
+		list_for_each(l, &yaffs_context_list) {
+			context_iterator =
+				list_entry(l, struct yaffs_linux_context,
+					context_list);
+			if (context_iterator->mount_id == mount_id)
+				found = 0;
+		}
+	}
+	context->mount_id = mount_id;
+
+	list_add_tail(&(yaffs_dev_to_lc(dev)->context_list),
+		      &yaffs_context_list);
+	mutex_unlock(&yaffs_context_lock);
+
+	/* Directory search handling... */
+	INIT_LIST_HEAD(&(yaffs_dev_to_lc(dev)->search_contexts));
+	param->remove_obj_fn = yaffs_remove_obj_callback;
+
+	mutex_init(&(yaffs_dev_to_lc(dev)->gross_lock));
+
+	yaffs_gross_lock(dev);
+
+	err = yaffs_guts_initialise(dev);
+
+	yaffs_trace(YAFFS_TRACE_OS,
+		"yaffs_read_super: guts initialised %s",
+		(err == YAFFS_OK) ? "OK" : "FAILED");
+
+	if (err == YAFFS_OK)
+		yaffs_bg_start(dev);
+
+	if (!context->bg_thread)
+		param->defered_dir_update = 0;
+
+	sb->s_maxbytes = yaffs_max_file_size(dev);
+
+	/* Release lock before yaffs_get_inode() */
+	yaffs_gross_unlock(dev);
+
+	/* Create root inode */
+	if (err == YAFFS_OK)
+		inode = yaffs_get_inode(sb, S_IFDIR | 0755, 0, yaffs_root(dev));
+
+	if (!inode)
+		return NULL;
+
+	inode->i_op = &yaffs_dir_inode_operations;
+	inode->i_fop = &yaffs_dir_operations;
+
+	yaffs_trace(YAFFS_TRACE_OS, "yaffs_read_super: got root inode");
+
+	root = d_alloc_root(inode);
+
+	yaffs_trace(YAFFS_TRACE_OS, "yaffs_read_super: d_alloc_root done");
+
+	if (!root) {
+		iput(inode);
+		return NULL;
+	}
+	sb->s_root = root;
+	sb->s_dirt = !dev->is_checkpointed;
+	yaffs_trace(YAFFS_TRACE_ALWAYS,
+		"yaffs_read_super: is_checkpointed %d",
+		dev->is_checkpointed);
+
+	yaffs_trace(YAFFS_TRACE_OS, "yaffs_read_super: done");
+	return sb;
+}
+
+static int yaffs_internal_read_super_mtd(struct super_block *sb, void *data,
+					 int silent)
+{
+	return yaffs_internal_read_super(1, sb, data, silent) ? 0 : -EINVAL;
+}
+
+static struct dentry *yaffs_mount(struct file_system_type *fs,
+			    int flags, const char *dev_name,
+			    void *data)
+{
+	return mount_bdev(fs, flags, dev_name, data,
+			   yaffs_internal_read_super_mtd);
+}
+
+static struct file_system_type yaffs_fs_type = {
+	.owner = THIS_MODULE,
+	.name = "yaffs",
+	.mount = yaffs_mount,
+	.kill_sb = kill_block_super,
+	.fs_flags = FS_REQUIRES_DEV,
+};
+
+static int yaffs2_internal_read_super_mtd(struct super_block *sb, void *data,
+					  int silent)
+{
+	return yaffs_internal_read_super(2, sb, data, silent) ? 0 : -EINVAL;
+}
+
+static struct dentry *yaffs2_mount(struct file_system_type *fs,
+			     int flags, const char *dev_name, void *data)
+{
+	return mount_bdev(fs, flags, dev_name, data,
+			   yaffs2_internal_read_super_mtd);
+}
+
+static struct file_system_type yaffs2_fs_type = {
+	.owner = THIS_MODULE,
+	.name = "yaffs2",
+	.mount = yaffs2_mount,
+	.kill_sb = kill_block_super,
+	.fs_flags = FS_REQUIRES_DEV,
+};
+
+
+static struct proc_dir_entry *my_proc_entry;
+
+static char *yaffs_dump_dev_part0(char *buf, struct yaffs_dev *dev)
+{
+	struct yaffs_param *param = &dev->param;
+
+	buf += sprintf(buf, "start_block........... %d\n", param->start_block);
+	buf += sprintf(buf, "end_block............. %d\n", param->end_block);
+	buf += sprintf(buf, "total_bytes_per_chunk. %d\n",
+			param->total_bytes_per_chunk);
+	buf += sprintf(buf, "use_nand_ecc.......... %d\n",
+			param->use_nand_ecc);
+	buf += sprintf(buf, "no_tags_ecc........... %d\n", param->no_tags_ecc);
+	buf += sprintf(buf, "is_yaffs2............. %d\n", param->is_yaffs2);
+	buf += sprintf(buf, "inband_tags........... %d\n", param->inband_tags);
+	buf += sprintf(buf, "empty_lost_n_found.... %d\n",
+			param->empty_lost_n_found);
+	buf += sprintf(buf, "disable_lazy_load..... %d\n",
+			param->disable_lazy_load);
+	buf += sprintf(buf, "refresh_period........ %d\n",
+			param->refresh_period);
+	buf += sprintf(buf, "n_caches.............. %d\n", param->n_caches);
+	buf += sprintf(buf, "n_reserved_blocks..... %d\n",
+			param->n_reserved_blocks);
+	buf += sprintf(buf, "always_check_erased... %d\n",
+			param->always_check_erased);
+
+	return buf;
+}
+
+static char *yaffs_dump_dev_part1(char *buf, struct yaffs_dev *dev)
+{
+	buf += sprintf(buf, "max file size......... %lld\n",
+			(long long) yaffs_max_file_size(dev));
+	buf += sprintf(buf, "data_bytes_per_chunk.. %d\n",
+			dev->data_bytes_per_chunk);
+	buf += sprintf(buf, "chunk_grp_bits........ %d\n", dev->chunk_grp_bits);
+	buf += sprintf(buf, "chunk_grp_size........ %d\n", dev->chunk_grp_size);
+	buf +=
+	    sprintf(buf, "n_erased_blocks....... %d\n", dev->n_erased_blocks);
+	buf +=
+	    sprintf(buf, "blocks_in_checkpt..... %d\n", dev->blocks_in_checkpt);
+	buf += sprintf(buf, "\n");
+	buf += sprintf(buf, "n_tnodes.............. %d\n", dev->n_tnodes);
+	buf += sprintf(buf, "n_obj................. %d\n", dev->n_obj);
+	buf += sprintf(buf, "n_free_chunks......... %d\n", dev->n_free_chunks);
+	buf += sprintf(buf, "\n");
+	buf += sprintf(buf, "n_page_writes......... %u\n", dev->n_page_writes);
+	buf += sprintf(buf, "n_page_reads.......... %u\n", dev->n_page_reads);
+	buf += sprintf(buf, "n_erasures............ %u\n", dev->n_erasures);
+	buf += sprintf(buf, "n_gc_copies........... %u\n", dev->n_gc_copies);
+	buf += sprintf(buf, "all_gcs............... %u\n", dev->all_gcs);
+	buf +=
+	    sprintf(buf, "passive_gc_count...... %u\n", dev->passive_gc_count);
+	buf +=
+	    sprintf(buf, "oldest_dirty_gc_count. %u\n",
+		    dev->oldest_dirty_gc_count);
+	buf += sprintf(buf, "n_gc_blocks........... %u\n", dev->n_gc_blocks);
+	buf += sprintf(buf, "bg_gcs................ %u\n", dev->bg_gcs);
+	buf +=
+	    sprintf(buf, "n_retried_writes...... %u\n", dev->n_retried_writes);
+	buf +=
+	    sprintf(buf, "n_retired_blocks...... %u\n", dev->n_retired_blocks);
+	buf += sprintf(buf, "n_ecc_fixed........... %u\n", dev->n_ecc_fixed);
+	buf += sprintf(buf, "n_ecc_unfixed......... %u\n", dev->n_ecc_unfixed);
+	buf +=
+	    sprintf(buf, "n_tags_ecc_fixed...... %u\n", dev->n_tags_ecc_fixed);
+	buf +=
+	    sprintf(buf, "n_tags_ecc_unfixed.... %u\n",
+		    dev->n_tags_ecc_unfixed);
+	buf += sprintf(buf, "cache_hits............ %u\n", dev->cache_hits);
+	buf +=
+	    sprintf(buf, "n_deleted_files....... %u\n", dev->n_deleted_files);
+	buf +=
+	    sprintf(buf, "n_unlinked_files...... %u\n", dev->n_unlinked_files);
+	buf += sprintf(buf, "refresh_count......... %u\n", dev->refresh_count);
+	buf += sprintf(buf, "n_bg_deletions........ %u\n", dev->n_bg_deletions);
+
+	return buf;
+}
+
+static int yaffs_proc_read(char *page,
+			   char **start,
+			   off_t offset, int count, int *eof, void *data)
+{
+	struct list_head *item;
+	char *buf = page;
+	int step = offset;
+	int n = 0;
+
+	/* Get proc_file_read() to step 'offset' by one on each sucessive call.
+	 * We use 'offset' (*ppos) to indicate where we are in dev_list.
+	 * This also assumes the user has posted a read buffer large
+	 * enough to hold the complete output; but that's life in /proc.
+	 */
+
+	*(int *)start = 1;
+
+	/* Print header first */
+	if (step == 0)
+		buf += sprintf(buf, "YAFFS built:" __DATE__ " " __TIME__ "\n");
+	else if (step == 1)
+		buf += sprintf(buf, "\n");
+	else {
+		step -= 2;
+
+		mutex_lock(&yaffs_context_lock);
+
+		/* Locate and print the Nth entry.
+		 * Order N-squared but N is small. */
+		list_for_each(item, &yaffs_context_list) {
+			struct yaffs_linux_context *dc =
+			    list_entry(item, struct yaffs_linux_context,
+				       context_list);
+			struct yaffs_dev *dev = dc->dev;
+
+			if (n < (step & ~1)) {
+				n += 2;
+				continue;
+			}
+			if ((step & 1) == 0) {
+				buf +=
+				    sprintf(buf, "\nDevice %d \"%s\"\n", n,
+					    dev->param.name);
+				buf = yaffs_dump_dev_part0(buf, dev);
+			} else {
+				buf = yaffs_dump_dev_part1(buf, dev);
+			}
+
+			break;
+		}
+		mutex_unlock(&yaffs_context_lock);
+	}
+
+	return buf - page < count ? buf - page : count;
+}
+
+
+
+/* Stuff to handle installation of file systems */
+struct file_system_to_install {
+	struct file_system_type *fst;
+	int installed;
+};
+
+static struct file_system_to_install fs_to_install[] = {
+	{&yaffs_fs_type, 0},
+	{&yaffs2_fs_type, 0},
+	{NULL, 0}
+};
+
+static int __init init_yaffs_fs(void)
+{
+	int error = 0;
+	struct file_system_to_install *fsinst;
+
+	yaffs_trace(YAFFS_TRACE_ALWAYS,
+		"yaffs built " __DATE__ " " __TIME__ " Installing.");
+
+	mutex_init(&yaffs_context_lock);
+
+	/* Install the proc_fs entries */
+	my_proc_entry = create_proc_entry("yaffs",
+					  S_IRUGO | S_IFREG, NULL);
+
+	if (my_proc_entry) {
+		my_proc_entry->write_proc = NULL;
+		my_proc_entry->read_proc = yaffs_proc_read;
+		my_proc_entry->data = NULL;
+	} else {
+		return -ENOMEM;
+	}
+
+
+	/* Now add the file system entries */
+
+	fsinst = fs_to_install;
+
+	while (fsinst->fst && !error) {
+		error = register_filesystem(fsinst->fst);
+		if (!error)
+			fsinst->installed = 1;
+		fsinst++;
+	}
+
+	/* Any errors? uninstall  */
+	if (error) {
+		fsinst = fs_to_install;
+
+		while (fsinst->fst) {
+			if (fsinst->installed) {
+				unregister_filesystem(fsinst->fst);
+				fsinst->installed = 0;
+			}
+			fsinst++;
+		}
+	}
+
+	return error;
+}
+
+static void __exit exit_yaffs_fs(void)
+{
+
+	struct file_system_to_install *fsinst;
+
+	yaffs_trace(YAFFS_TRACE_ALWAYS,
+		"yaffs built " __DATE__ " " __TIME__ " removing.");
+
+	remove_proc_entry("yaffs", NULL);
+
+	fsinst = fs_to_install;
+
+	while (fsinst->fst) {
+		if (fsinst->installed) {
+			unregister_filesystem(fsinst->fst);
+			fsinst->installed = 0;
+		}
+		fsinst++;
+	}
+}
+
+module_init(init_yaffs_fs)
+module_exit(exit_yaffs_fs)
+
+MODULE_DESCRIPTION("YAFFS2 - a NAND specific flash file system");
+MODULE_AUTHOR("Charles Manning, Aleph One Ltd., 2002-2011");
+MODULE_LICENSE("GPL");
diff --git a/fs/yaffs2/yaffs_yaffs1.c b/fs/yaffs2/yaffs_yaffs1.c
new file mode 100755
index 0000000..4f2e768
--- /dev/null
+++ b/fs/yaffs2/yaffs_yaffs1.c
@@ -0,0 +1,422 @@
+/*
+ * YAFFS: Yet Another Flash File System. A NAND-flash specific file system.
+ *
+ * Copyright (C) 2002-2011 Aleph One Ltd.
+ *   for Toby Churchill Ltd and Brightstar Engineering
+ *
+ * Created by Charles Manning <charles@aleph1.co.uk>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include "yaffs_yaffs1.h"
+#include "yportenv.h"
+#include "yaffs_trace.h"
+#include "yaffs_bitmap.h"
+#include "yaffs_getblockinfo.h"
+#include "yaffs_nand.h"
+#include "yaffs_attribs.h"
+
+int yaffs1_scan(struct yaffs_dev *dev)
+{
+	struct yaffs_ext_tags tags;
+	int blk;
+	int result;
+	int chunk;
+	int c;
+	int deleted;
+	enum yaffs_block_state state;
+	LIST_HEAD(hard_list);
+	struct yaffs_block_info *bi;
+	u32 seq_number;
+	struct yaffs_obj_hdr *oh;
+	struct yaffs_obj *in;
+	struct yaffs_obj *parent;
+	int alloc_failed = 0;
+	struct yaffs_shadow_fixer *shadow_fixers = NULL;
+	u8 *chunk_data;
+
+	yaffs_trace(YAFFS_TRACE_SCAN,
+		"yaffs1_scan starts  intstartblk %d intendblk %d...",
+		dev->internal_start_block, dev->internal_end_block);
+
+	chunk_data = yaffs_get_temp_buffer(dev);
+
+	dev->seq_number = YAFFS_LOWEST_SEQUENCE_NUMBER;
+
+	/* Scan all the blocks to determine their state */
+	bi = dev->block_info;
+	for (blk = dev->internal_start_block; blk <= dev->internal_end_block;
+	     blk++) {
+		yaffs_clear_chunk_bits(dev, blk);
+		bi->pages_in_use = 0;
+		bi->soft_del_pages = 0;
+
+		yaffs_query_init_block_state(dev, blk, &state, &seq_number);
+
+		bi->block_state = state;
+		bi->seq_number = seq_number;
+
+		if (bi->seq_number == YAFFS_SEQUENCE_BAD_BLOCK)
+			bi->block_state = state = YAFFS_BLOCK_STATE_DEAD;
+
+		yaffs_trace(YAFFS_TRACE_SCAN_DEBUG,
+			"Block scanning block %d state %d seq %d",
+			blk, state, seq_number);
+
+		if (state == YAFFS_BLOCK_STATE_DEAD) {
+			yaffs_trace(YAFFS_TRACE_BAD_BLOCKS,
+				"block %d is bad", blk);
+		} else if (state == YAFFS_BLOCK_STATE_EMPTY) {
+			yaffs_trace(YAFFS_TRACE_SCAN_DEBUG, "Block empty ");
+			dev->n_erased_blocks++;
+			dev->n_free_chunks += dev->param.chunks_per_block;
+		}
+		bi++;
+	}
+
+	/* For each block.... */
+	for (blk = dev->internal_start_block;
+	     !alloc_failed && blk <= dev->internal_end_block; blk++) {
+
+		cond_resched();
+
+		bi = yaffs_get_block_info(dev, blk);
+		state = bi->block_state;
+
+		deleted = 0;
+
+		/* For each chunk in each block that needs scanning.... */
+		for (c = 0;
+			!alloc_failed && c < dev->param.chunks_per_block &&
+			state == YAFFS_BLOCK_STATE_NEEDS_SCAN; c++) {
+			/* Read the tags and decide what to do */
+			chunk = blk * dev->param.chunks_per_block + c;
+
+			result = yaffs_rd_chunk_tags_nand(dev, chunk, NULL,
+							  &tags);
+
+			/* Let's have a good look at this chunk... */
+
+			if (tags.ecc_result == YAFFS_ECC_RESULT_UNFIXED ||
+			    tags.is_deleted) {
+				/* YAFFS1 only...
+				 * A deleted chunk
+				 */
+				deleted++;
+				dev->n_free_chunks++;
+			} else if (!tags.chunk_used) {
+				/* An unassigned chunk in the block
+				 * This means that either the block is empty or
+				 * this is the one being allocated from
+				 */
+
+				if (c == 0) {
+					/* We're looking at the first chunk in
+					 *the block so the block is unused */
+					state = YAFFS_BLOCK_STATE_EMPTY;
+					dev->n_erased_blocks++;
+				} else {
+					/* this is the block being allocated */
+					yaffs_trace(YAFFS_TRACE_SCAN,
+						" Allocating from %d %d",
+						blk, c);
+					state = YAFFS_BLOCK_STATE_ALLOCATING;
+					dev->alloc_block = blk;
+					dev->alloc_page = c;
+					dev->alloc_block_finder = blk;
+
+				}
+
+				dev->n_free_chunks +=
+				    (dev->param.chunks_per_block - c);
+			} else if (tags.chunk_id > 0) {
+				/* chunk_id > 0 so it is a data chunk... */
+				unsigned int endpos;
+
+				yaffs_set_chunk_bit(dev, blk, c);
+				bi->pages_in_use++;
+
+				in = yaffs_find_or_create_by_number(dev,
+							tags.obj_id,
+							YAFFS_OBJECT_TYPE_FILE);
+				/* PutChunkIntoFile checks for a clash
+				 * (two data chunks with the same chunk_id).
+				 */
+
+				if (!in)
+					alloc_failed = 1;
+
+				if (in) {
+					if (!yaffs_put_chunk_in_file
+					    (in, tags.chunk_id, chunk, 1))
+						alloc_failed = 1;
+				}
+
+				endpos =
+				    (tags.chunk_id - 1) *
+				    dev->data_bytes_per_chunk +
+				    tags.n_bytes;
+				if (in &&
+				    in->variant_type ==
+				     YAFFS_OBJECT_TYPE_FILE &&
+				    in->variant.file_variant.stored_size <
+				      endpos) {
+					in->variant.file_variant.stored_size =
+					    endpos;
+					if (!dev->param.use_header_file_size) {
+						in->variant.
+						    file_variant.file_size =
+						    in->variant.
+						    file_variant.stored_size;
+					}
+
+				}
+			} else {
+				/* chunk_id == 0, so it is an ObjectHeader.
+				 * Make the object
+				 */
+				yaffs_set_chunk_bit(dev, blk, c);
+				bi->pages_in_use++;
+
+				result = yaffs_rd_chunk_tags_nand(dev, chunk,
+								  chunk_data,
+								  NULL);
+
+				oh = (struct yaffs_obj_hdr *)chunk_data;
+
+				in = yaffs_find_by_number(dev, tags.obj_id);
+				if (in && in->variant_type != oh->type) {
+					/* This should not happen, but somehow
+					 * Wev'e ended up with an obj_id that
+					 * has been reused but not yet deleted,
+					 * and worse still it has changed type.
+					 * Delete the old object.
+					 */
+
+					yaffs_del_obj(in);
+					in = NULL;
+				}
+
+				in = yaffs_find_or_create_by_number(dev,
+								tags.obj_id,
+								oh->type);
+
+				if (!in)
+					alloc_failed = 1;
+
+				if (in && oh->shadows_obj > 0) {
+
+					struct yaffs_shadow_fixer *fixer;
+					fixer =
+						kmalloc(sizeof
+						(struct yaffs_shadow_fixer),
+						GFP_NOFS);
+					if (fixer) {
+						fixer->next = shadow_fixers;
+						shadow_fixers = fixer;
+						fixer->obj_id = tags.obj_id;
+						fixer->shadowed_id =
+						    oh->shadows_obj;
+						yaffs_trace(YAFFS_TRACE_SCAN,
+							" Shadow fixer: %d shadows %d",
+							fixer->obj_id,
+							fixer->shadowed_id);
+
+					}
+
+				}
+
+				if (in && in->valid) {
+					/* We have already filled this one.
+					 * We have a duplicate and need to
+					 * resolve it. */
+
+					unsigned existing_serial = in->serial;
+					unsigned new_serial =
+					    tags.serial_number;
+
+					if (((existing_serial + 1) & 3) ==
+					    new_serial) {
+						/* Use new one - destroy the
+						 * exisiting one */
+						yaffs_chunk_del(dev,
+								in->hdr_chunk,
+								1, __LINE__);
+						in->valid = 0;
+					} else {
+						/* Use existing - destroy
+						 * this one. */
+						yaffs_chunk_del(dev, chunk, 1,
+								__LINE__);
+					}
+				}
+
+				if (in && !in->valid &&
+				    (tags.obj_id == YAFFS_OBJECTID_ROOT ||
+				     tags.obj_id ==
+				     YAFFS_OBJECTID_LOSTNFOUND)) {
+					/* We only load some info, don't fiddle
+					 * with directory structure */
+					in->valid = 1;
+					in->variant_type = oh->type;
+
+					in->yst_mode = oh->yst_mode;
+					yaffs_load_attribs(in, oh);
+					in->hdr_chunk = chunk;
+					in->serial = tags.serial_number;
+
+				} else if (in && !in->valid) {
+					/* we need to load this info */
+
+					in->valid = 1;
+					in->variant_type = oh->type;
+
+					in->yst_mode = oh->yst_mode;
+					yaffs_load_attribs(in, oh);
+					in->hdr_chunk = chunk;
+					in->serial = tags.serial_number;
+
+					yaffs_set_obj_name_from_oh(in, oh);
+					in->dirty = 0;
+
+					/* directory stuff...
+					 * hook up to parent
+					 */
+
+					parent =
+					    yaffs_find_or_create_by_number
+					    (dev, oh->parent_obj_id,
+					     YAFFS_OBJECT_TYPE_DIRECTORY);
+					if (!parent)
+						alloc_failed = 1;
+					if (parent && parent->variant_type ==
+					    YAFFS_OBJECT_TYPE_UNKNOWN) {
+						/* Set up as a directory */
+						parent->variant_type =
+						    YAFFS_OBJECT_TYPE_DIRECTORY;
+						INIT_LIST_HEAD(&parent->
+							variant.dir_variant.
+							children);
+					} else if (!parent ||
+						parent->variant_type !=
+						YAFFS_OBJECT_TYPE_DIRECTORY) {
+						/* Hoosterman, a problem....
+						 * We're trying to use a
+						 * non-directory as a directory
+						 */
+
+						yaffs_trace(YAFFS_TRACE_ERROR,
+							"yaffs tragedy: attempting to use non-directory as a directory in scan. Put in lost+found."
+							);
+						parent = dev->lost_n_found;
+					}
+
+					yaffs_add_obj_to_dir(parent, in);
+
+					switch (in->variant_type) {
+					case YAFFS_OBJECT_TYPE_UNKNOWN:
+						/* Todo got a problem */
+						break;
+					case YAFFS_OBJECT_TYPE_FILE:
+						if (dev->param.
+						    use_header_file_size)
+							in->variant.
+							file_variant.file_size
+							= yaffs_oh_to_size(oh);
+						break;
+					case YAFFS_OBJECT_TYPE_HARDLINK:
+						in->variant.
+						    hardlink_variant.equiv_id =
+						    oh->equiv_id;
+						list_add(&in->hard_links,
+								&hard_list);
+						break;
+					case YAFFS_OBJECT_TYPE_DIRECTORY:
+						/* Do nothing */
+						break;
+					case YAFFS_OBJECT_TYPE_SPECIAL:
+						/* Do nothing */
+						break;
+					case YAFFS_OBJECT_TYPE_SYMLINK:
+						in->variant.symlink_variant.
+						    alias =
+						    yaffs_clone_str(oh->alias);
+						if (!in->variant.
+						    symlink_variant.alias)
+							alloc_failed = 1;
+						break;
+					}
+				}
+			}
+		}
+
+		if (state == YAFFS_BLOCK_STATE_NEEDS_SCAN) {
+			/* If we got this far while scanning,
+			 * then the block is fully allocated. */
+			state = YAFFS_BLOCK_STATE_FULL;
+		}
+
+		if (state == YAFFS_BLOCK_STATE_ALLOCATING) {
+			/* If the block was partially allocated then
+			 * treat it as fully allocated. */
+			state = YAFFS_BLOCK_STATE_FULL;
+			dev->alloc_block = -1;
+		}
+
+		bi->block_state = state;
+
+		/* Now let's see if it was dirty */
+		if (bi->pages_in_use == 0 &&
+		    !bi->has_shrink_hdr &&
+		    bi->block_state == YAFFS_BLOCK_STATE_FULL)
+			yaffs_block_became_dirty(dev, blk);
+	}
+
+	/* Ok, we've done all the scanning.
+	 * Fix up the hard link chains.
+	 * We should now have scanned all the objects, now it's time to add
+	 * these hardlinks.
+	 */
+
+	yaffs_link_fixup(dev, &hard_list);
+
+	/*
+	 * Fix up any shadowed objects.
+	 * There should not be more than one of these.
+	 */
+	{
+		struct yaffs_shadow_fixer *fixer;
+		struct yaffs_obj *obj;
+
+		while (shadow_fixers) {
+			fixer = shadow_fixers;
+			shadow_fixers = fixer->next;
+			/* Complete the rename transaction by deleting the
+			 * shadowed object then setting the object header
+			 to unshadowed.
+			 */
+			obj = yaffs_find_by_number(dev, fixer->shadowed_id);
+			if (obj)
+				yaffs_del_obj(obj);
+
+			obj = yaffs_find_by_number(dev, fixer->obj_id);
+
+			if (obj)
+				yaffs_update_oh(obj, NULL, 1, 0, 0, NULL);
+
+			kfree(fixer);
+		}
+	}
+
+	yaffs_release_temp_buffer(dev, chunk_data);
+
+	if (alloc_failed)
+		return YAFFS_FAIL;
+
+	yaffs_trace(YAFFS_TRACE_SCAN, "yaffs1_scan ends");
+
+	return YAFFS_OK;
+}
diff --git a/fs/yaffs2/yaffs_yaffs1.h b/fs/yaffs2/yaffs_yaffs1.h
new file mode 100755
index 0000000..97e2fdd
--- /dev/null
+++ b/fs/yaffs2/yaffs_yaffs1.h
@@ -0,0 +1,22 @@
+/*
+ * YAFFS: Yet another Flash File System . A NAND-flash specific file system.
+ *
+ * Copyright (C) 2002-2011 Aleph One Ltd.
+ *   for Toby Churchill Ltd and Brightstar Engineering
+ *
+ * Created by Charles Manning <charles@aleph1.co.uk>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 2.1 as
+ * published by the Free Software Foundation.
+ *
+ * Note: Only YAFFS headers are LGPL, YAFFS C code is covered by GPL.
+ */
+
+#ifndef __YAFFS_YAFFS1_H__
+#define __YAFFS_YAFFS1_H__
+
+#include "yaffs_guts.h"
+int yaffs1_scan(struct yaffs_dev *dev);
+
+#endif
diff --git a/fs/yaffs2/yaffs_yaffs2.c b/fs/yaffs2/yaffs_yaffs2.c
new file mode 100755
index 0000000..f2f98a4
--- /dev/null
+++ b/fs/yaffs2/yaffs_yaffs2.c
@@ -0,0 +1,1533 @@
+/*
+ * YAFFS: Yet Another Flash File System. A NAND-flash specific file system.
+ *
+ * Copyright (C) 2002-2011 Aleph One Ltd.
+ *   for Toby Churchill Ltd and Brightstar Engineering
+ *
+ * Created by Charles Manning <charles@aleph1.co.uk>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include "yaffs_guts.h"
+#include "yaffs_trace.h"
+#include "yaffs_yaffs2.h"
+#include "yaffs_checkptrw.h"
+#include "yaffs_bitmap.h"
+#include "yaffs_nand.h"
+#include "yaffs_getblockinfo.h"
+#include "yaffs_verify.h"
+#include "yaffs_attribs.h"
+#include "yaffs_summary.h"
+
+/*
+ * Checkpoints are really no benefit on very small partitions.
+ *
+ * To save space on small partitions don't bother with checkpoints unless
+ * the partition is at least this big.
+ */
+#define YAFFS_CHECKPOINT_MIN_BLOCKS 60
+#define YAFFS_SMALL_HOLE_THRESHOLD 4
+
+/*
+ * Oldest Dirty Sequence Number handling.
+ */
+
+/* yaffs_calc_oldest_dirty_seq()
+ * yaffs2_find_oldest_dirty_seq()
+ * Calculate the oldest dirty sequence number if we don't know it.
+ */
+void yaffs_calc_oldest_dirty_seq(struct yaffs_dev *dev)
+{
+	int i;
+	unsigned seq;
+	unsigned block_no = 0;
+	struct yaffs_block_info *b;
+
+	if (!dev->param.is_yaffs2)
+		return;
+
+	/* Find the oldest dirty sequence number. */
+	seq = dev->seq_number + 1;
+	b = dev->block_info;
+	for (i = dev->internal_start_block; i <= dev->internal_end_block; i++) {
+		if (b->block_state == YAFFS_BLOCK_STATE_FULL &&
+		    (b->pages_in_use - b->soft_del_pages) <
+		    dev->param.chunks_per_block &&
+		    b->seq_number < seq) {
+			seq = b->seq_number;
+			block_no = i;
+		}
+		b++;
+	}
+
+	if (block_no) {
+		dev->oldest_dirty_seq = seq;
+		dev->oldest_dirty_block = block_no;
+	}
+}
+
+void yaffs2_find_oldest_dirty_seq(struct yaffs_dev *dev)
+{
+	if (!dev->param.is_yaffs2)
+		return;
+
+	if (!dev->oldest_dirty_seq)
+		yaffs_calc_oldest_dirty_seq(dev);
+}
+
+/*
+ * yaffs_clear_oldest_dirty_seq()
+ * Called when a block is erased or marked bad. (ie. when its seq_number
+ * becomes invalid). If the value matches the oldest then we clear
+ * dev->oldest_dirty_seq to force its recomputation.
+ */
+void yaffs2_clear_oldest_dirty_seq(struct yaffs_dev *dev,
+				   struct yaffs_block_info *bi)
+{
+
+	if (!dev->param.is_yaffs2)
+		return;
+
+	if (!bi || bi->seq_number == dev->oldest_dirty_seq) {
+		dev->oldest_dirty_seq = 0;
+		dev->oldest_dirty_block = 0;
+	}
+}
+
+/*
+ * yaffs2_update_oldest_dirty_seq()
+ * Update the oldest dirty sequence number whenever we dirty a block.
+ * Only do this if the oldest_dirty_seq is actually being tracked.
+ */
+void yaffs2_update_oldest_dirty_seq(struct yaffs_dev *dev, unsigned block_no,
+				    struct yaffs_block_info *bi)
+{
+	if (!dev->param.is_yaffs2)
+		return;
+
+	if (dev->oldest_dirty_seq) {
+		if (dev->oldest_dirty_seq > bi->seq_number) {
+			dev->oldest_dirty_seq = bi->seq_number;
+			dev->oldest_dirty_block = block_no;
+		}
+	}
+}
+
+int yaffs_block_ok_for_gc(struct yaffs_dev *dev, struct yaffs_block_info *bi)
+{
+
+	if (!dev->param.is_yaffs2)
+		return 1;	/* disqualification only applies to yaffs2. */
+
+	if (!bi->has_shrink_hdr)
+		return 1;	/* can gc */
+
+	yaffs2_find_oldest_dirty_seq(dev);
+
+	/* Can't do gc of this block if there are any blocks older than this
+	 * one that have discarded pages.
+	 */
+	return (bi->seq_number <= dev->oldest_dirty_seq);
+}
+
+/*
+ * yaffs2_find_refresh_block()
+ * periodically finds the oldest full block by sequence number for refreshing.
+ * Only for yaffs2.
+ */
+u32 yaffs2_find_refresh_block(struct yaffs_dev *dev)
+{
+	u32 b;
+	u32 oldest = 0;
+	u32 oldest_seq = 0;
+	struct yaffs_block_info *bi;
+
+	if (!dev->param.is_yaffs2)
+		return oldest;
+
+	/*
+	 * If refresh period < 10 then refreshing is disabled.
+	 */
+	if (dev->param.refresh_period < 10)
+		return oldest;
+
+	/*
+	 * Fix broken values.
+	 */
+	if (dev->refresh_skip > dev->param.refresh_period)
+		dev->refresh_skip = dev->param.refresh_period;
+
+	if (dev->refresh_skip > 0)
+		return oldest;
+
+	/*
+	 * Refresh skip is now zero.
+	 * We'll do a refresh this time around....
+	 * Update the refresh skip and find the oldest block.
+	 */
+	dev->refresh_skip = dev->param.refresh_period;
+	dev->refresh_count++;
+	bi = dev->block_info;
+	for (b = dev->internal_start_block; b <= dev->internal_end_block; b++) {
+
+		if (bi->block_state == YAFFS_BLOCK_STATE_FULL) {
+
+			if (oldest < 1 || bi->seq_number < oldest_seq) {
+				oldest = b;
+				oldest_seq = bi->seq_number;
+			}
+		}
+		bi++;
+	}
+
+	if (oldest > 0) {
+		yaffs_trace(YAFFS_TRACE_GC,
+			"GC refresh count %d selected block %d with seq_number %d",
+			dev->refresh_count, oldest, oldest_seq);
+	}
+
+	return oldest;
+}
+
+int yaffs2_checkpt_required(struct yaffs_dev *dev)
+{
+	int nblocks;
+
+	if (!dev->param.is_yaffs2)
+		return 0;
+
+	nblocks = dev->internal_end_block - dev->internal_start_block + 1;
+
+	return !dev->param.skip_checkpt_wr &&
+	    !dev->read_only && (nblocks >= YAFFS_CHECKPOINT_MIN_BLOCKS);
+}
+
+int yaffs_calc_checkpt_blocks_required(struct yaffs_dev *dev)
+{
+	int retval;
+	int n_bytes = 0;
+	int n_blocks;
+	int dev_blocks;
+
+	if (!dev->param.is_yaffs2)
+		return 0;
+
+	if (!dev->checkpoint_blocks_required && yaffs2_checkpt_required(dev)) {
+		/* Not a valid value so recalculate */
+		dev_blocks = dev->param.end_block - dev->param.start_block + 1;
+		n_bytes += sizeof(struct yaffs_checkpt_validity);
+		n_bytes += sizeof(struct yaffs_checkpt_dev);
+		n_bytes += dev_blocks * sizeof(struct yaffs_block_info);
+		n_bytes += dev_blocks * dev->chunk_bit_stride;
+		n_bytes +=
+		    (sizeof(struct yaffs_checkpt_obj) + sizeof(u32)) *
+		    dev->n_obj;
+		n_bytes += (dev->tnode_size + sizeof(u32)) * dev->n_tnodes;
+		n_bytes += sizeof(struct yaffs_checkpt_validity);
+		n_bytes += sizeof(u32);	/* checksum */
+
+		/* Round up and add 2 blocks to allow for some bad blocks,
+		 * so add 3 */
+
+		n_blocks =
+		    (n_bytes /
+		     (dev->data_bytes_per_chunk *
+		      dev->param.chunks_per_block)) + 3;
+
+		dev->checkpoint_blocks_required = n_blocks;
+	}
+
+	retval = dev->checkpoint_blocks_required - dev->blocks_in_checkpt;
+	if (retval < 0)
+		retval = 0;
+	return retval;
+}
+
+/*--------------------- Checkpointing --------------------*/
+
+static int yaffs2_wr_checkpt_validity_marker(struct yaffs_dev *dev, int head)
+{
+	struct yaffs_checkpt_validity cp;
+
+	memset(&cp, 0, sizeof(cp));
+
+	cp.struct_type = sizeof(cp);
+	cp.magic = YAFFS_MAGIC;
+	cp.version = YAFFS_CHECKPOINT_VERSION;
+	cp.head = (head) ? 1 : 0;
+
+	return (yaffs2_checkpt_wr(dev, &cp, sizeof(cp)) == sizeof(cp)) ? 1 : 0;
+}
+
+static int yaffs2_rd_checkpt_validity_marker(struct yaffs_dev *dev, int head)
+{
+	struct yaffs_checkpt_validity cp;
+	int ok;
+
+	ok = (yaffs2_checkpt_rd(dev, &cp, sizeof(cp)) == sizeof(cp));
+
+	if (ok)
+		ok = (cp.struct_type == sizeof(cp)) &&
+		    (cp.magic == YAFFS_MAGIC) &&
+		    (cp.version == YAFFS_CHECKPOINT_VERSION) &&
+		    (cp.head == ((head) ? 1 : 0));
+	return ok ? 1 : 0;
+}
+
+static void yaffs2_dev_to_checkpt_dev(struct yaffs_checkpt_dev *cp,
+				      struct yaffs_dev *dev)
+{
+	cp->n_erased_blocks = dev->n_erased_blocks;
+	cp->alloc_block = dev->alloc_block;
+	cp->alloc_page = dev->alloc_page;
+	cp->n_free_chunks = dev->n_free_chunks;
+
+	cp->n_deleted_files = dev->n_deleted_files;
+	cp->n_unlinked_files = dev->n_unlinked_files;
+	cp->n_bg_deletions = dev->n_bg_deletions;
+	cp->seq_number = dev->seq_number;
+
+}
+
+static void yaffs_checkpt_dev_to_dev(struct yaffs_dev *dev,
+				     struct yaffs_checkpt_dev *cp)
+{
+	dev->n_erased_blocks = cp->n_erased_blocks;
+	dev->alloc_block = cp->alloc_block;
+	dev->alloc_page = cp->alloc_page;
+	dev->n_free_chunks = cp->n_free_chunks;
+
+	dev->n_deleted_files = cp->n_deleted_files;
+	dev->n_unlinked_files = cp->n_unlinked_files;
+	dev->n_bg_deletions = cp->n_bg_deletions;
+	dev->seq_number = cp->seq_number;
+}
+
+static int yaffs2_wr_checkpt_dev(struct yaffs_dev *dev)
+{
+	struct yaffs_checkpt_dev cp;
+	u32 n_bytes;
+	u32 n_blocks = dev->internal_end_block - dev->internal_start_block + 1;
+	int ok;
+
+	/* Write device runtime values */
+	yaffs2_dev_to_checkpt_dev(&cp, dev);
+	cp.struct_type = sizeof(cp);
+
+	ok = (yaffs2_checkpt_wr(dev, &cp, sizeof(cp)) == sizeof(cp));
+	if (!ok)
+		return 0;
+
+	/* Write block info */
+	n_bytes = n_blocks * sizeof(struct yaffs_block_info);
+	ok = (yaffs2_checkpt_wr(dev, dev->block_info, n_bytes) == n_bytes);
+	if (!ok)
+		return 0;
+
+	/* Write chunk bits */
+	n_bytes = n_blocks * dev->chunk_bit_stride;
+	ok = (yaffs2_checkpt_wr(dev, dev->chunk_bits, n_bytes) == n_bytes);
+
+	return ok ? 1 : 0;
+}
+
+static int yaffs2_rd_checkpt_dev(struct yaffs_dev *dev)
+{
+	struct yaffs_checkpt_dev cp;
+	u32 n_bytes;
+	u32 n_blocks =
+	    (dev->internal_end_block - dev->internal_start_block + 1);
+	int ok;
+
+	ok = (yaffs2_checkpt_rd(dev, &cp, sizeof(cp)) == sizeof(cp));
+	if (!ok)
+		return 0;
+
+	if (cp.struct_type != sizeof(cp))
+		return 0;
+
+	yaffs_checkpt_dev_to_dev(dev, &cp);
+
+	n_bytes = n_blocks * sizeof(struct yaffs_block_info);
+
+	ok = (yaffs2_checkpt_rd(dev, dev->block_info, n_bytes) == n_bytes);
+
+	if (!ok)
+		return 0;
+
+	n_bytes = n_blocks * dev->chunk_bit_stride;
+
+	ok = (yaffs2_checkpt_rd(dev, dev->chunk_bits, n_bytes) == n_bytes);
+
+	return ok ? 1 : 0;
+}
+
+static void yaffs2_obj_checkpt_obj(struct yaffs_checkpt_obj *cp,
+				   struct yaffs_obj *obj)
+{
+	cp->obj_id = obj->obj_id;
+	cp->parent_id = (obj->parent) ? obj->parent->obj_id : 0;
+	cp->hdr_chunk = obj->hdr_chunk;
+	cp->variant_type = obj->variant_type;
+	cp->deleted = obj->deleted;
+	cp->soft_del = obj->soft_del;
+	cp->unlinked = obj->unlinked;
+	cp->fake = obj->fake;
+	cp->rename_allowed = obj->rename_allowed;
+	cp->unlink_allowed = obj->unlink_allowed;
+	cp->serial = obj->serial;
+	cp->n_data_chunks = obj->n_data_chunks;
+
+	if (obj->variant_type == YAFFS_OBJECT_TYPE_FILE)
+		cp->size_or_equiv_obj = obj->variant.file_variant.file_size;
+	else if (obj->variant_type == YAFFS_OBJECT_TYPE_HARDLINK)
+		cp->size_or_equiv_obj = obj->variant.hardlink_variant.equiv_id;
+}
+
+static int yaffs2_checkpt_obj_to_obj(struct yaffs_obj *obj,
+				     struct yaffs_checkpt_obj *cp)
+{
+	struct yaffs_obj *parent;
+
+	if (obj->variant_type != cp->variant_type) {
+		yaffs_trace(YAFFS_TRACE_ERROR,
+			"Checkpoint read object %d type %d chunk %d does not match existing object type %d",
+			cp->obj_id, cp->variant_type, cp->hdr_chunk,
+			obj->variant_type);
+		return 0;
+	}
+
+	obj->obj_id = cp->obj_id;
+
+	if (cp->parent_id)
+		parent = yaffs_find_or_create_by_number(obj->my_dev,
+						cp->parent_id,
+						YAFFS_OBJECT_TYPE_DIRECTORY);
+	else
+		parent = NULL;
+
+	if (parent) {
+		if (parent->variant_type != YAFFS_OBJECT_TYPE_DIRECTORY) {
+			yaffs_trace(YAFFS_TRACE_ALWAYS,
+				"Checkpoint read object %d parent %d type %d chunk %d Parent type, %d, not directory",
+				cp->obj_id, cp->parent_id,
+				cp->variant_type, cp->hdr_chunk,
+				parent->variant_type);
+			return 0;
+		}
+		yaffs_add_obj_to_dir(parent, obj);
+	}
+
+	obj->hdr_chunk = cp->hdr_chunk;
+	obj->variant_type = cp->variant_type;
+	obj->deleted = cp->deleted;
+	obj->soft_del = cp->soft_del;
+	obj->unlinked = cp->unlinked;
+	obj->fake = cp->fake;
+	obj->rename_allowed = cp->rename_allowed;
+	obj->unlink_allowed = cp->unlink_allowed;
+	obj->serial = cp->serial;
+	obj->n_data_chunks = cp->n_data_chunks;
+
+	if (obj->variant_type == YAFFS_OBJECT_TYPE_FILE) {
+		obj->variant.file_variant.file_size = cp->size_or_equiv_obj;
+		obj->variant.file_variant.stored_size = cp->size_or_equiv_obj;
+	} else if (obj->variant_type == YAFFS_OBJECT_TYPE_HARDLINK) {
+		obj->variant.hardlink_variant.equiv_id = cp->size_or_equiv_obj;
+	}
+	if (obj->hdr_chunk > 0)
+		obj->lazy_loaded = 1;
+	return 1;
+}
+
+static int yaffs2_checkpt_tnode_worker(struct yaffs_obj *in,
+				       struct yaffs_tnode *tn, u32 level,
+				       int chunk_offset)
+{
+	int i;
+	struct yaffs_dev *dev = in->my_dev;
+	int ok = 1;
+	u32 base_offset;
+
+	if (!tn)
+		return 1;
+
+	if (level > 0) {
+		for (i = 0; i < YAFFS_NTNODES_INTERNAL && ok; i++) {
+			if (!tn->internal[i])
+				continue;
+			ok = yaffs2_checkpt_tnode_worker(in,
+				 tn->internal[i],
+				 level - 1,
+				 (chunk_offset <<
+				  YAFFS_TNODES_INTERNAL_BITS) + i);
+		}
+		return ok;
+	}
+
+	/* Level 0 tnode */
+	base_offset = chunk_offset << YAFFS_TNODES_LEVEL0_BITS;
+	ok = (yaffs2_checkpt_wr(dev, &base_offset, sizeof(base_offset)) ==
+			sizeof(base_offset));
+	if (ok)
+		ok = (yaffs2_checkpt_wr(dev, tn, dev->tnode_size) ==
+			dev->tnode_size);
+
+	return ok;
+}
+
+static int yaffs2_wr_checkpt_tnodes(struct yaffs_obj *obj)
+{
+	u32 end_marker = ~0;
+	int ok = 1;
+
+	if (obj->variant_type != YAFFS_OBJECT_TYPE_FILE)
+		return ok;
+
+	ok = yaffs2_checkpt_tnode_worker(obj,
+					 obj->variant.file_variant.top,
+					 obj->variant.file_variant.
+					 top_level, 0);
+	if (ok)
+		ok = (yaffs2_checkpt_wr(obj->my_dev, &end_marker,
+				sizeof(end_marker)) == sizeof(end_marker));
+
+	return ok ? 1 : 0;
+}
+
+static int yaffs2_rd_checkpt_tnodes(struct yaffs_obj *obj)
+{
+	u32 base_chunk;
+	int ok = 1;
+	struct yaffs_dev *dev = obj->my_dev;
+	struct yaffs_file_var *file_stuct_ptr = &obj->variant.file_variant;
+	struct yaffs_tnode *tn;
+	int nread = 0;
+
+	ok = (yaffs2_checkpt_rd(dev, &base_chunk, sizeof(base_chunk)) ==
+	      sizeof(base_chunk));
+
+	while (ok && (~base_chunk)) {
+		nread++;
+		/* Read level 0 tnode */
+
+		tn = yaffs_get_tnode(dev);
+		if (tn)
+			ok = (yaffs2_checkpt_rd(dev, tn, dev->tnode_size) ==
+				dev->tnode_size);
+		else
+			ok = 0;
+
+		if (tn && ok)
+			ok = yaffs_add_find_tnode_0(dev,
+						    file_stuct_ptr,
+						    base_chunk, tn) ? 1 : 0;
+
+		if (ok)
+			ok = (yaffs2_checkpt_rd
+			      (dev, &base_chunk,
+			       sizeof(base_chunk)) == sizeof(base_chunk));
+	}
+
+	yaffs_trace(YAFFS_TRACE_CHECKPOINT,
+		"Checkpoint read tnodes %d records, last %d. ok %d",
+		nread, base_chunk, ok);
+
+	return ok ? 1 : 0;
+}
+
+static int yaffs2_wr_checkpt_objs(struct yaffs_dev *dev)
+{
+	struct yaffs_obj *obj;
+	struct yaffs_checkpt_obj cp;
+	int i;
+	int ok = 1;
+	struct list_head *lh;
+
+	/* Iterate through the objects in each hash entry,
+	 * dumping them to the checkpointing stream.
+	 */
+
+	for (i = 0; ok && i < YAFFS_NOBJECT_BUCKETS; i++) {
+		list_for_each(lh, &dev->obj_bucket[i].list) {
+			obj = list_entry(lh, struct yaffs_obj, hash_link);
+			if (!obj->defered_free) {
+				yaffs2_obj_checkpt_obj(&cp, obj);
+				cp.struct_type = sizeof(cp);
+
+				yaffs_trace(YAFFS_TRACE_CHECKPOINT,
+					"Checkpoint write object %d parent %d type %d chunk %d obj addr %p",
+					cp.obj_id, cp.parent_id,
+					cp.variant_type, cp.hdr_chunk, obj);
+
+				ok = (yaffs2_checkpt_wr(dev, &cp,
+						sizeof(cp)) == sizeof(cp));
+
+				if (ok &&
+					obj->variant_type ==
+					YAFFS_OBJECT_TYPE_FILE)
+					ok = yaffs2_wr_checkpt_tnodes(obj);
+			}
+		}
+	}
+
+	/* Dump end of list */
+	memset(&cp, 0xff, sizeof(struct yaffs_checkpt_obj));
+	cp.struct_type = sizeof(cp);
+
+	if (ok)
+		ok = (yaffs2_checkpt_wr(dev, &cp, sizeof(cp)) == sizeof(cp));
+
+	return ok ? 1 : 0;
+}
+
+static int yaffs2_rd_checkpt_objs(struct yaffs_dev *dev)
+{
+	struct yaffs_obj *obj;
+	struct yaffs_checkpt_obj cp;
+	int ok = 1;
+	int done = 0;
+	LIST_HEAD(hard_list);
+
+
+	while (ok && !done) {
+		ok = (yaffs2_checkpt_rd(dev, &cp, sizeof(cp)) == sizeof(cp));
+		if (cp.struct_type != sizeof(cp)) {
+			yaffs_trace(YAFFS_TRACE_CHECKPOINT,
+				"struct size %d instead of %d ok %d",
+				cp.struct_type, (int)sizeof(cp), ok);
+			ok = 0;
+		}
+
+		yaffs_trace(YAFFS_TRACE_CHECKPOINT,
+			"Checkpoint read object %d parent %d type %d chunk %d ",
+			cp.obj_id, cp.parent_id, cp.variant_type,
+			cp.hdr_chunk);
+
+		if (ok && cp.obj_id == ~0) {
+			done = 1;
+		} else if (ok) {
+			obj =
+			    yaffs_find_or_create_by_number(dev, cp.obj_id,
+							   cp.variant_type);
+			if (obj) {
+				ok = yaffs2_checkpt_obj_to_obj(obj, &cp);
+				if (!ok)
+					break;
+				if (obj->variant_type ==
+					YAFFS_OBJECT_TYPE_FILE) {
+					ok = yaffs2_rd_checkpt_tnodes(obj);
+				} else if (obj->variant_type ==
+					YAFFS_OBJECT_TYPE_HARDLINK) {
+					list_add(&obj->hard_links, &hard_list);
+				}
+			} else {
+				ok = 0;
+			}
+		}
+	}
+
+	if (ok)
+		yaffs_link_fixup(dev, &hard_list);
+
+	return ok ? 1 : 0;
+}
+
+static int yaffs2_wr_checkpt_sum(struct yaffs_dev *dev)
+{
+	u32 checkpt_sum;
+	int ok;
+
+	yaffs2_get_checkpt_sum(dev, &checkpt_sum);
+
+	ok = (yaffs2_checkpt_wr(dev, &checkpt_sum, sizeof(checkpt_sum)) ==
+		sizeof(checkpt_sum));
+
+	if (!ok)
+		return 0;
+
+	return 1;
+}
+
+static int yaffs2_rd_checkpt_sum(struct yaffs_dev *dev)
+{
+	u32 checkpt_sum0;
+	u32 checkpt_sum1;
+	int ok;
+
+	yaffs2_get_checkpt_sum(dev, &checkpt_sum0);
+
+	ok = (yaffs2_checkpt_rd(dev, &checkpt_sum1, sizeof(checkpt_sum1)) ==
+		sizeof(checkpt_sum1));
+
+	if (!ok)
+		return 0;
+
+	if (checkpt_sum0 != checkpt_sum1)
+		return 0;
+
+	return 1;
+}
+
+static int yaffs2_wr_checkpt_data(struct yaffs_dev *dev)
+{
+	int ok = 1;
+
+	if (!yaffs2_checkpt_required(dev)) {
+		yaffs_trace(YAFFS_TRACE_CHECKPOINT,
+			"skipping checkpoint write");
+		ok = 0;
+	}
+
+	if (ok)
+		ok = yaffs2_checkpt_open(dev, 1);
+
+	if (ok) {
+		yaffs_trace(YAFFS_TRACE_CHECKPOINT,
+			"write checkpoint validity");
+		ok = yaffs2_wr_checkpt_validity_marker(dev, 1);
+	}
+	if (ok) {
+		yaffs_trace(YAFFS_TRACE_CHECKPOINT,
+			"write checkpoint device");
+		ok = yaffs2_wr_checkpt_dev(dev);
+	}
+	if (ok) {
+		yaffs_trace(YAFFS_TRACE_CHECKPOINT,
+			"write checkpoint objects");
+		ok = yaffs2_wr_checkpt_objs(dev);
+	}
+	if (ok) {
+		yaffs_trace(YAFFS_TRACE_CHECKPOINT,
+			"write checkpoint validity");
+		ok = yaffs2_wr_checkpt_validity_marker(dev, 0);
+	}
+
+	if (ok)
+		ok = yaffs2_wr_checkpt_sum(dev);
+
+	if (!yaffs_checkpt_close(dev))
+		ok = 0;
+
+	if (ok)
+		dev->is_checkpointed = 1;
+	else
+		dev->is_checkpointed = 0;
+
+	return dev->is_checkpointed;
+}
+
+static int yaffs2_rd_checkpt_data(struct yaffs_dev *dev)
+{
+	int ok = 1;
+
+	if (!dev->param.is_yaffs2)
+		ok = 0;
+
+	if (ok && dev->param.skip_checkpt_rd) {
+		yaffs_trace(YAFFS_TRACE_CHECKPOINT,
+			"skipping checkpoint read");
+		ok = 0;
+	}
+
+	if (ok)
+		ok = yaffs2_checkpt_open(dev, 0); /* open for read */
+
+	if (ok) {
+		yaffs_trace(YAFFS_TRACE_CHECKPOINT,
+			"read checkpoint validity");
+		ok = yaffs2_rd_checkpt_validity_marker(dev, 1);
+	}
+	if (ok) {
+		yaffs_trace(YAFFS_TRACE_CHECKPOINT,
+			"read checkpoint device");
+		ok = yaffs2_rd_checkpt_dev(dev);
+	}
+	if (ok) {
+		yaffs_trace(YAFFS_TRACE_CHECKPOINT,
+			"read checkpoint objects");
+		ok = yaffs2_rd_checkpt_objs(dev);
+	}
+	if (ok) {
+		yaffs_trace(YAFFS_TRACE_CHECKPOINT,
+			"read checkpoint validity");
+		ok = yaffs2_rd_checkpt_validity_marker(dev, 0);
+	}
+
+	if (ok) {
+		ok = yaffs2_rd_checkpt_sum(dev);
+		yaffs_trace(YAFFS_TRACE_CHECKPOINT,
+			"read checkpoint checksum %d", ok);
+	}
+
+	if (!yaffs_checkpt_close(dev))
+		ok = 0;
+
+	if (ok)
+		dev->is_checkpointed = 1;
+	else
+		dev->is_checkpointed = 0;
+
+	return ok ? 1 : 0;
+}
+
+void yaffs2_checkpt_invalidate(struct yaffs_dev *dev)
+{
+	if (dev->is_checkpointed || dev->blocks_in_checkpt > 0) {
+		dev->is_checkpointed = 0;
+		yaffs2_checkpt_invalidate_stream(dev);
+	}
+	if (dev->param.sb_dirty_fn)
+		dev->param.sb_dirty_fn(dev);
+}
+
+int yaffs_checkpoint_save(struct yaffs_dev *dev)
+{
+	yaffs_trace(YAFFS_TRACE_CHECKPOINT,
+		"save entry: is_checkpointed %d",
+		dev->is_checkpointed);
+
+	yaffs_verify_objects(dev);
+	yaffs_verify_blocks(dev);
+	yaffs_verify_free_chunks(dev);
+
+	if (!dev->is_checkpointed) {
+		yaffs2_checkpt_invalidate(dev);
+		yaffs2_wr_checkpt_data(dev);
+	}
+
+	yaffs_trace(YAFFS_TRACE_CHECKPOINT | YAFFS_TRACE_MOUNT,
+		"save exit: is_checkpointed %d",
+		dev->is_checkpointed);
+
+	return dev->is_checkpointed;
+}
+
+int yaffs2_checkpt_restore(struct yaffs_dev *dev)
+{
+	int retval;
+
+	yaffs_trace(YAFFS_TRACE_CHECKPOINT,
+		"restore entry: is_checkpointed %d",
+		dev->is_checkpointed);
+
+	retval = yaffs2_rd_checkpt_data(dev);
+
+	if (dev->is_checkpointed) {
+		yaffs_verify_objects(dev);
+		yaffs_verify_blocks(dev);
+		yaffs_verify_free_chunks(dev);
+	}
+
+	yaffs_trace(YAFFS_TRACE_CHECKPOINT,
+		"restore exit: is_checkpointed %d",
+		dev->is_checkpointed);
+
+	return retval;
+}
+
+int yaffs2_handle_hole(struct yaffs_obj *obj, loff_t new_size)
+{
+	/* if new_size > old_file_size.
+	 * We're going to be writing a hole.
+	 * If the hole is small then write zeros otherwise write a start
+	 * of hole marker.
+	 */
+	loff_t old_file_size;
+	loff_t increase;
+	int small_hole;
+	int result = YAFFS_OK;
+	struct yaffs_dev *dev = NULL;
+	u8 *local_buffer = NULL;
+	int small_increase_ok = 0;
+
+	if (!obj)
+		return YAFFS_FAIL;
+
+	if (obj->variant_type != YAFFS_OBJECT_TYPE_FILE)
+		return YAFFS_FAIL;
+
+	dev = obj->my_dev;
+
+	/* Bail out if not yaffs2 mode */
+	if (!dev->param.is_yaffs2)
+		return YAFFS_OK;
+
+	old_file_size = obj->variant.file_variant.file_size;
+
+	if (new_size <= old_file_size)
+		return YAFFS_OK;
+
+	increase = new_size - old_file_size;
+
+	if (increase < YAFFS_SMALL_HOLE_THRESHOLD * dev->data_bytes_per_chunk &&
+	    yaffs_check_alloc_available(dev, YAFFS_SMALL_HOLE_THRESHOLD + 1))
+		small_hole = 1;
+	else
+		small_hole = 0;
+
+	if (small_hole)
+		local_buffer = yaffs_get_temp_buffer(dev);
+
+	if (local_buffer) {
+		/* fill hole with zero bytes */
+		loff_t pos = old_file_size;
+		int this_write;
+		int written;
+		memset(local_buffer, 0, dev->data_bytes_per_chunk);
+		small_increase_ok = 1;
+
+		while (increase > 0 && small_increase_ok) {
+			this_write = increase;
+			if (this_write > dev->data_bytes_per_chunk)
+				this_write = dev->data_bytes_per_chunk;
+			written =
+			    yaffs_do_file_wr(obj, local_buffer, pos, this_write,
+					     0);
+			if (written == this_write) {
+				pos += this_write;
+				increase -= this_write;
+			} else {
+				small_increase_ok = 0;
+			}
+		}
+
+		yaffs_release_temp_buffer(dev, local_buffer);
+
+		/* If out of space then reverse any chunks we've added */
+		if (!small_increase_ok)
+			yaffs_resize_file_down(obj, old_file_size);
+	}
+
+	if (!small_increase_ok &&
+	    obj->parent &&
+	    obj->parent->obj_id != YAFFS_OBJECTID_UNLINKED &&
+	    obj->parent->obj_id != YAFFS_OBJECTID_DELETED) {
+		/* Write a hole start header with the old file size */
+		yaffs_update_oh(obj, NULL, 0, 1, 0, NULL);
+	}
+
+	return result;
+}
+
+struct yaffs_block_index {
+	int seq;
+	int block;
+};
+
+static int yaffs2_ybicmp(const void *a, const void *b)
+{
+	int aseq = ((struct yaffs_block_index *)a)->seq;
+	int bseq = ((struct yaffs_block_index *)b)->seq;
+	int ablock = ((struct yaffs_block_index *)a)->block;
+	int bblock = ((struct yaffs_block_index *)b)->block;
+
+	if (aseq == bseq)
+		return ablock - bblock;
+
+	return aseq - bseq;
+}
+
+static inline int yaffs2_scan_chunk(struct yaffs_dev *dev,
+		struct yaffs_block_info *bi,
+		int blk, int chunk_in_block,
+		int *found_chunks,
+		u8 *chunk_data,
+		struct list_head *hard_list,
+		int summary_available)
+{
+	struct yaffs_obj_hdr *oh;
+	struct yaffs_obj *in;
+	struct yaffs_obj *parent;
+	int equiv_id;
+	loff_t file_size;
+	int is_shrink;
+	int is_unlinked;
+	struct yaffs_ext_tags tags;
+	int result;
+	int alloc_failed = 0;
+	int chunk = blk * dev->param.chunks_per_block + chunk_in_block;
+	struct yaffs_file_var *file_var;
+	struct yaffs_hardlink_var *hl_var;
+	struct yaffs_symlink_var *sl_var;
+
+	if (summary_available) {
+		result = yaffs_summary_fetch(dev, &tags, chunk_in_block);
+		tags.seq_number = bi->seq_number;
+	}
+
+	if (!summary_available || tags.obj_id == 0) {
+		result = yaffs_rd_chunk_tags_nand(dev, chunk, NULL, &tags);
+		dev->tags_used++;
+	} else {
+		dev->summary_used++;
+	}
+
+	/* Let's have a good look at this chunk... */
+
+	if (!tags.chunk_used) {
+		/* An unassigned chunk in the block.
+		 * If there are used chunks after this one, then
+		 * it is a chunk that was skipped due to failing
+		 * the erased check. Just skip it so that it can
+		 * be deleted.
+		 * But, more typically, We get here when this is
+		 * an unallocated chunk and his means that
+		 * either the block is empty or this is the one
+		 * being allocated from
+		 */
+
+		if (*found_chunks) {
+			/* This is a chunk that was skipped due
+			 * to failing the erased check */
+		} else if (chunk_in_block == 0) {
+			/* We're looking at the first chunk in
+			 * the block so the block is unused */
+			bi->block_state = YAFFS_BLOCK_STATE_EMPTY;
+			dev->n_erased_blocks++;
+		} else {
+			if (bi->block_state == YAFFS_BLOCK_STATE_NEEDS_SCAN ||
+			    bi->block_state == YAFFS_BLOCK_STATE_ALLOCATING) {
+				if (dev->seq_number == bi->seq_number) {
+					/* Allocating from this block*/
+					yaffs_trace(YAFFS_TRACE_SCAN,
+					    " Allocating from %d %d",
+					    blk, chunk_in_block);
+
+					bi->block_state =
+						YAFFS_BLOCK_STATE_ALLOCATING;
+					dev->alloc_block = blk;
+					dev->alloc_page = chunk_in_block;
+					dev->alloc_block_finder = blk;
+				} else {
+					/* This is a partially written block
+					 * that is not the current
+					 * allocation block.
+					 */
+					yaffs_trace(YAFFS_TRACE_SCAN,
+						"Partially written block %d detected. gc will fix this.",
+						blk);
+				}
+			}
+		}
+
+		dev->n_free_chunks++;
+
+	} else if (tags.ecc_result ==
+		YAFFS_ECC_RESULT_UNFIXED) {
+		yaffs_trace(YAFFS_TRACE_SCAN,
+			" Unfixed ECC in chunk(%d:%d), chunk ignored",
+			blk, chunk_in_block);
+			dev->n_free_chunks++;
+	} else if (tags.obj_id > YAFFS_MAX_OBJECT_ID ||
+		   tags.chunk_id > YAFFS_MAX_CHUNK_ID ||
+		   tags.obj_id == YAFFS_OBJECTID_SUMMARY ||
+		   (tags.chunk_id > 0 &&
+		     tags.n_bytes > dev->data_bytes_per_chunk) ||
+		   tags.seq_number != bi->seq_number) {
+		yaffs_trace(YAFFS_TRACE_SCAN,
+			"Chunk (%d:%d) with bad tags:obj = %d, chunk_id = %d, n_bytes = %d, ignored",
+			blk, chunk_in_block, tags.obj_id,
+			tags.chunk_id, tags.n_bytes);
+		dev->n_free_chunks++;
+	} else if (tags.chunk_id > 0) {
+		/* chunk_id > 0 so it is a data chunk... */
+		loff_t endpos;
+		loff_t chunk_base = (tags.chunk_id - 1) *
+					dev->data_bytes_per_chunk;
+
+		*found_chunks = 1;
+
+		yaffs_set_chunk_bit(dev, blk, chunk_in_block);
+		bi->pages_in_use++;
+
+		in = yaffs_find_or_create_by_number(dev,
+					tags.obj_id,
+					YAFFS_OBJECT_TYPE_FILE);
+		if (!in)
+			/* Out of memory */
+			alloc_failed = 1;
+
+		if (in &&
+		    in->variant_type == YAFFS_OBJECT_TYPE_FILE &&
+		    chunk_base < in->variant.file_variant.shrink_size) {
+			/* This has not been invalidated by
+			 * a resize */
+			if (!yaffs_put_chunk_in_file(in, tags.chunk_id,
+								chunk, -1))
+				alloc_failed = 1;
+
+			/* File size is calculated by looking at
+			 * the data chunks if we have not
+			 * seen an object header yet.
+			 * Stop this practice once we find an
+			 * object header.
+			 */
+			endpos = chunk_base + tags.n_bytes;
+
+			if (!in->valid &&
+			    in->variant.file_variant.stored_size < endpos) {
+				in->variant.file_variant.
+				    stored_size = endpos;
+				in->variant.file_variant.
+				    file_size = endpos;
+			}
+		} else if (in) {
+			/* This chunk has been invalidated by a
+			 * resize, or a past file deletion
+			 * so delete the chunk*/
+			yaffs_chunk_del(dev, chunk, 1, __LINE__);
+		}
+	} else {
+		/* chunk_id == 0, so it is an ObjectHeader.
+		 * Thus, we read in the object header and make
+		 * the object
+		 */
+		*found_chunks = 1;
+
+		yaffs_set_chunk_bit(dev, blk, chunk_in_block);
+		bi->pages_in_use++;
+
+		oh = NULL;
+		in = NULL;
+
+		if (tags.extra_available) {
+			in = yaffs_find_or_create_by_number(dev,
+					tags.obj_id,
+					tags.extra_obj_type);
+			if (!in)
+				alloc_failed = 1;
+		}
+
+		if (!in ||
+		    (!in->valid && dev->param.disable_lazy_load) ||
+		    tags.extra_shadows ||
+		    (!in->valid && (tags.obj_id == YAFFS_OBJECTID_ROOT ||
+				 tags.obj_id == YAFFS_OBJECTID_LOSTNFOUND))) {
+
+			/* If we don't have  valid info then we
+			 * need to read the chunk
+			 * TODO In future we can probably defer
+			 * reading the chunk and living with
+			 * invalid data until needed.
+			 */
+
+			result = yaffs_rd_chunk_tags_nand(dev,
+						  chunk,
+						  chunk_data,
+						  NULL);
+
+			oh = (struct yaffs_obj_hdr *)chunk_data;
+
+			if (dev->param.inband_tags) {
+				/* Fix up the header if they got
+				 * corrupted by inband tags */
+				oh->shadows_obj =
+				    oh->inband_shadowed_obj_id;
+				oh->is_shrink =
+				    oh->inband_is_shrink;
+			}
+
+			if (!in) {
+				in = yaffs_find_or_create_by_number(dev,
+							tags.obj_id, oh->type);
+				if (!in)
+					alloc_failed = 1;
+			}
+		}
+
+		if (!in) {
+			/* TODO Hoosterman we have a problem! */
+			yaffs_trace(YAFFS_TRACE_ERROR,
+				"yaffs tragedy: Could not make object for object  %d at chunk %d during scan",
+				tags.obj_id, chunk);
+			return YAFFS_FAIL;
+		}
+
+		if (in->valid) {
+			/* We have already filled this one.
+			 * We have a duplicate that will be
+			 * discarded, but we first have to suck
+			 * out resize info if it is a file.
+			 */
+			if ((in->variant_type == YAFFS_OBJECT_TYPE_FILE) &&
+				((oh && oh->type == YAFFS_OBJECT_TYPE_FILE) ||
+				 (tags.extra_available &&
+				  tags.extra_obj_type == YAFFS_OBJECT_TYPE_FILE)
+				)) {
+				loff_t this_size = (oh) ?
+					yaffs_oh_to_size(oh) :
+					tags.extra_file_size;
+				u32 parent_obj_id = (oh) ?
+					oh->parent_obj_id :
+					tags.extra_parent_id;
+
+				is_shrink = (oh) ?
+					oh->is_shrink :
+					tags.extra_is_shrink;
+
+				/* If it is deleted (unlinked
+				 * at start also means deleted)
+				 * we treat the file size as
+				 * being zeroed at this point.
+				 */
+				if (parent_obj_id == YAFFS_OBJECTID_DELETED ||
+				    parent_obj_id == YAFFS_OBJECTID_UNLINKED) {
+					this_size = 0;
+					is_shrink = 1;
+				}
+
+				if (is_shrink &&
+				    in->variant.file_variant.shrink_size >
+				    this_size)
+					in->variant.file_variant.shrink_size =
+					this_size;
+
+				if (is_shrink)
+					bi->has_shrink_hdr = 1;
+			}
+			/* Use existing - destroy this one. */
+			yaffs_chunk_del(dev, chunk, 1, __LINE__);
+		}
+
+		if (!in->valid && in->variant_type !=
+		    (oh ? oh->type : tags.extra_obj_type)) {
+			yaffs_trace(YAFFS_TRACE_ERROR,
+				"yaffs tragedy: Bad type, %d != %d, for object %d at chunk %d during scan",
+				oh ? oh->type : tags.extra_obj_type,
+				in->variant_type, tags.obj_id,
+				chunk);
+			in = yaffs_retype_obj(in, oh ? oh->type : tags.extra_obj_type);
+		}
+
+		if (!in->valid &&
+		    (tags.obj_id == YAFFS_OBJECTID_ROOT ||
+		     tags.obj_id == YAFFS_OBJECTID_LOSTNFOUND)) {
+			/* We only load some info, don't fiddle
+			 * with directory structure */
+			in->valid = 1;
+
+			if (oh) {
+				in->yst_mode = oh->yst_mode;
+				yaffs_load_attribs(in, oh);
+				in->lazy_loaded = 0;
+			} else {
+				in->lazy_loaded = 1;
+			}
+			in->hdr_chunk = chunk;
+
+		} else if (!in->valid) {
+			/* we need to load this info */
+			in->valid = 1;
+			in->hdr_chunk = chunk;
+			if (oh) {
+				in->variant_type = oh->type;
+				in->yst_mode = oh->yst_mode;
+				yaffs_load_attribs(in, oh);
+
+				if (oh->shadows_obj > 0)
+					yaffs_handle_shadowed_obj(dev,
+					     oh->shadows_obj, 1);
+
+				yaffs_set_obj_name_from_oh(in, oh);
+				parent = yaffs_find_or_create_by_number(dev,
+						oh->parent_obj_id,
+						YAFFS_OBJECT_TYPE_DIRECTORY);
+				file_size = yaffs_oh_to_size(oh);
+				is_shrink = oh->is_shrink;
+				equiv_id = oh->equiv_id;
+			} else {
+				in->variant_type = tags.extra_obj_type;
+				parent = yaffs_find_or_create_by_number(dev,
+						tags.extra_parent_id,
+						YAFFS_OBJECT_TYPE_DIRECTORY);
+				file_size = tags.extra_file_size;
+				is_shrink = tags.extra_is_shrink;
+				equiv_id = tags.extra_equiv_id;
+				in->lazy_loaded = 1;
+			}
+			in->dirty = 0;
+
+			if (!parent)
+				alloc_failed = 1;
+
+			/* directory stuff...
+			 * hook up to parent
+			 */
+
+			if (parent &&
+			    parent->variant_type == YAFFS_OBJECT_TYPE_UNKNOWN) {
+				/* Set up as a directory */
+				parent->variant_type =
+					YAFFS_OBJECT_TYPE_DIRECTORY;
+				INIT_LIST_HEAD(&parent->
+						variant.dir_variant.children);
+			} else if (!parent ||
+				   parent->variant_type !=
+					YAFFS_OBJECT_TYPE_DIRECTORY) {
+				/* Hoosterman, another problem....
+				 * Trying to use a non-directory as a directory
+				 */
+
+				yaffs_trace(YAFFS_TRACE_ERROR,
+					"yaffs tragedy: attempting to use non-directory as a directory in scan. Put in lost+found."
+					);
+				parent = dev->lost_n_found;
+			}
+			yaffs_add_obj_to_dir(parent, in);
+
+			is_unlinked = (parent == dev->del_dir) ||
+					(parent == dev->unlinked_dir);
+
+			if (is_shrink)
+				/* Mark the block */
+				bi->has_shrink_hdr = 1;
+
+			/* Note re hardlinks.
+			 * Since we might scan a hardlink before its equivalent
+			 * object is scanned we put them all in a list.
+			 * After scanning is complete, we should have all the
+			 * objects, so we run through this list and fix up all
+			 * the chains.
+			 */
+
+			switch (in->variant_type) {
+			case YAFFS_OBJECT_TYPE_UNKNOWN:
+				/* Todo got a problem */
+				break;
+			case YAFFS_OBJECT_TYPE_FILE:
+				file_var = &in->variant.file_variant;
+				if (file_var->stored_size < file_size) {
+					/* This covers the case where the file
+					 * size is greater than the data held.
+					 * This will happen if the file is
+					 * resized to be larger than its
+					 * current data extents.
+					 */
+					file_var->file_size = file_size;
+					file_var->stored_size = file_size;
+				}
+
+				if (file_var->shrink_size > file_size)
+					file_var->shrink_size = file_size;
+
+				break;
+			case YAFFS_OBJECT_TYPE_HARDLINK:
+				hl_var = &in->variant.hardlink_variant;
+				if (!is_unlinked) {
+					hl_var->equiv_id = equiv_id;
+					list_add(&in->hard_links, hard_list);
+				}
+				break;
+			case YAFFS_OBJECT_TYPE_DIRECTORY:
+				/* Do nothing */
+				break;
+			case YAFFS_OBJECT_TYPE_SPECIAL:
+				/* Do nothing */
+				break;
+			case YAFFS_OBJECT_TYPE_SYMLINK:
+				sl_var = &in->variant.symlink_variant;
+				if (oh) {
+					sl_var->alias =
+					    yaffs_clone_str(oh->alias);
+					if (!sl_var->alias)
+						alloc_failed = 1;
+				}
+				break;
+			}
+		}
+	}
+	return alloc_failed ? YAFFS_FAIL : YAFFS_OK;
+}
+
+int yaffs2_scan_backwards(struct yaffs_dev *dev)
+{
+	int blk;
+	int block_iter;
+	int start_iter;
+	int end_iter;
+	int n_to_scan = 0;
+	enum yaffs_block_state state;
+	int c;
+	LIST_HEAD(hard_list);
+	struct yaffs_block_info *bi;
+	u32 seq_number;
+	int n_blocks = dev->internal_end_block - dev->internal_start_block + 1;
+	u8 *chunk_data;
+	int found_chunks;
+	int alloc_failed = 0;
+	struct yaffs_block_index *block_index = NULL;
+	int alt_block_index = 0;
+	int summary_available;
+
+	yaffs_trace(YAFFS_TRACE_SCAN,
+		"yaffs2_scan_backwards starts  intstartblk %d intendblk %d...",
+		dev->internal_start_block, dev->internal_end_block);
+
+	dev->seq_number = YAFFS_LOWEST_SEQUENCE_NUMBER;
+
+	block_index =
+		kmalloc(n_blocks * sizeof(struct yaffs_block_index), GFP_NOFS);
+
+	if (!block_index) {
+		block_index =
+		    vmalloc(n_blocks * sizeof(struct yaffs_block_index));
+		alt_block_index = 1;
+	}
+
+	if (!block_index) {
+		yaffs_trace(YAFFS_TRACE_SCAN,
+			"yaffs2_scan_backwards() could not allocate block index!"
+			);
+		return YAFFS_FAIL;
+	}
+
+	dev->blocks_in_checkpt = 0;
+
+	chunk_data = yaffs_get_temp_buffer(dev);
+
+	/* Scan all the blocks to determine their state */
+	bi = dev->block_info;
+	for (blk = dev->internal_start_block; blk <= dev->internal_end_block;
+	     blk++) {
+		yaffs_clear_chunk_bits(dev, blk);
+		bi->pages_in_use = 0;
+		bi->soft_del_pages = 0;
+
+		yaffs_query_init_block_state(dev, blk, &state, &seq_number);
+
+		bi->block_state = state;
+		bi->seq_number = seq_number;
+
+		if (bi->seq_number == YAFFS_SEQUENCE_CHECKPOINT_DATA)
+			bi->block_state = YAFFS_BLOCK_STATE_CHECKPOINT;
+		if (bi->seq_number == YAFFS_SEQUENCE_BAD_BLOCK)
+			bi->block_state = YAFFS_BLOCK_STATE_DEAD;
+
+		yaffs_trace(YAFFS_TRACE_SCAN_DEBUG,
+			"Block scanning block %d state %d seq %d",
+			blk, bi->block_state, seq_number);
+
+		if (bi->block_state == YAFFS_BLOCK_STATE_CHECKPOINT) {
+			dev->blocks_in_checkpt++;
+
+		} else if (bi->block_state == YAFFS_BLOCK_STATE_DEAD) {
+			yaffs_trace(YAFFS_TRACE_BAD_BLOCKS,
+				"block %d is bad", blk);
+		} else if (bi->block_state == YAFFS_BLOCK_STATE_EMPTY) {
+			yaffs_trace(YAFFS_TRACE_SCAN_DEBUG, "Block empty ");
+			dev->n_erased_blocks++;
+			dev->n_free_chunks += dev->param.chunks_per_block;
+		} else if (bi->block_state ==
+				YAFFS_BLOCK_STATE_NEEDS_SCAN) {
+			/* Determine the highest sequence number */
+			if (seq_number >= YAFFS_LOWEST_SEQUENCE_NUMBER &&
+			    seq_number < YAFFS_HIGHEST_SEQUENCE_NUMBER) {
+				block_index[n_to_scan].seq = seq_number;
+				block_index[n_to_scan].block = blk;
+				n_to_scan++;
+				if (seq_number >= dev->seq_number)
+					dev->seq_number = seq_number;
+			} else {
+				/* TODO: Nasty sequence number! */
+				yaffs_trace(YAFFS_TRACE_SCAN,
+					"Block scanning block %d has bad sequence number %d",
+					blk, seq_number);
+			}
+		}
+		bi++;
+	}
+
+	yaffs_trace(YAFFS_TRACE_ALWAYS, "%d blocks to be sorted...", n_to_scan);
+
+	cond_resched();
+
+	/* Sort the blocks by sequence number */
+	sort(block_index, n_to_scan, sizeof(struct yaffs_block_index),
+		   yaffs2_ybicmp, NULL);
+
+	cond_resched();
+
+	yaffs_trace(YAFFS_TRACE_SCAN, "...done");
+
+	/* Now scan the blocks looking at the data. */
+	start_iter = 0;
+	end_iter = n_to_scan - 1;
+	yaffs_trace(YAFFS_TRACE_SCAN_DEBUG, "%d blocks to scan", n_to_scan);
+
+	/* For each block.... backwards */
+	for (block_iter = end_iter;
+	     !alloc_failed && block_iter >= start_iter;
+	     block_iter--) {
+		/* Cooperative multitasking! This loop can run for so
+		   long that watchdog timers expire. */
+		cond_resched();
+
+		/* get the block to scan in the correct order */
+		blk = block_index[block_iter].block;
+		bi = yaffs_get_block_info(dev, blk);
+
+		summary_available = yaffs_summary_read(dev, dev->sum_tags, blk);
+
+		/* For each chunk in each block that needs scanning.... */
+		found_chunks = 0;
+		if (summary_available)
+			c = dev->chunks_per_summary - 1;
+		else
+			c = dev->param.chunks_per_block - 1;
+
+		for (/* c is already initialised */;
+		     !alloc_failed && c >= 0 &&
+		     (bi->block_state == YAFFS_BLOCK_STATE_NEEDS_SCAN ||
+		      bi->block_state == YAFFS_BLOCK_STATE_ALLOCATING);
+		      c--) {
+			/* Scan backwards...
+			 * Read the tags and decide what to do
+			 */
+			if (yaffs2_scan_chunk(dev, bi, blk, c,
+					&found_chunks, chunk_data,
+					&hard_list, summary_available) ==
+					YAFFS_FAIL)
+				alloc_failed = 1;
+		}
+
+		if (bi->block_state == YAFFS_BLOCK_STATE_NEEDS_SCAN) {
+			/* If we got this far while scanning, then the block
+			 * is fully allocated. */
+			bi->block_state = YAFFS_BLOCK_STATE_FULL;
+		}
+
+		/* Now let's see if it was dirty */
+		if (bi->pages_in_use == 0 &&
+		    !bi->has_shrink_hdr &&
+		    bi->block_state == YAFFS_BLOCK_STATE_FULL) {
+			yaffs_block_became_dirty(dev, blk);
+		}
+	}
+
+	yaffs_skip_rest_of_block(dev);
+
+	if (alt_block_index)
+		vfree(block_index);
+	else
+		kfree(block_index);
+
+	/* Ok, we've done all the scanning.
+	 * Fix up the hard link chains.
+	 * We have scanned all the objects, now it's time to add these
+	 * hardlinks.
+	 */
+	yaffs_link_fixup(dev, &hard_list);
+
+	yaffs_release_temp_buffer(dev, chunk_data);
+
+	if (alloc_failed)
+		return YAFFS_FAIL;
+
+	yaffs_trace(YAFFS_TRACE_SCAN, "yaffs2_scan_backwards ends");
+
+	return YAFFS_OK;
+}
diff --git a/fs/yaffs2/yaffs_yaffs2.h b/fs/yaffs2/yaffs_yaffs2.h
new file mode 100755
index 0000000..2363bfd
--- /dev/null
+++ b/fs/yaffs2/yaffs_yaffs2.h
@@ -0,0 +1,39 @@
+/*
+ * YAFFS: Yet another Flash File System . A NAND-flash specific file system.
+ *
+ * Copyright (C) 2002-2011 Aleph One Ltd.
+ *   for Toby Churchill Ltd and Brightstar Engineering
+ *
+ * Created by Charles Manning <charles@aleph1.co.uk>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 2.1 as
+ * published by the Free Software Foundation.
+ *
+ * Note: Only YAFFS headers are LGPL, YAFFS C code is covered by GPL.
+ */
+
+#ifndef __YAFFS_YAFFS2_H__
+#define __YAFFS_YAFFS2_H__
+
+#include "yaffs_guts.h"
+
+void yaffs_calc_oldest_dirty_seq(struct yaffs_dev *dev);
+void yaffs2_find_oldest_dirty_seq(struct yaffs_dev *dev);
+void yaffs2_clear_oldest_dirty_seq(struct yaffs_dev *dev,
+				   struct yaffs_block_info *bi);
+void yaffs2_update_oldest_dirty_seq(struct yaffs_dev *dev, unsigned block_no,
+				    struct yaffs_block_info *bi);
+int yaffs_block_ok_for_gc(struct yaffs_dev *dev, struct yaffs_block_info *bi);
+u32 yaffs2_find_refresh_block(struct yaffs_dev *dev);
+int yaffs2_checkpt_required(struct yaffs_dev *dev);
+int yaffs_calc_checkpt_blocks_required(struct yaffs_dev *dev);
+
+void yaffs2_checkpt_invalidate(struct yaffs_dev *dev);
+int yaffs2_checkpt_save(struct yaffs_dev *dev);
+int yaffs2_checkpt_restore(struct yaffs_dev *dev);
+
+int yaffs2_handle_hole(struct yaffs_obj *obj, loff_t new_size);
+int yaffs2_scan_backwards(struct yaffs_dev *dev);
+
+#endif
diff --git a/fs/yaffs2/yportenv.h b/fs/yaffs2/yportenv.h
new file mode 100755
index 0000000..d4a9178
--- /dev/null
+++ b/fs/yaffs2/yportenv.h
@@ -0,0 +1,20 @@
+/*
+ * YAFFS: Yet another Flash File System . A NAND-flash specific file system.
+ *
+ * Copyright (C) 2002-2011 Aleph One Ltd.
+ *   for Toby Churchill Ltd and Brightstar Engineering
+ *
+ * Created by Waldemar Rymarkiewicz <waldemar.rymarkiewicz@gmail.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 2.1 as
+ * published by the Free Software Foundation.
+ *
+ * Note: Only YAFFS headers are LGPL, YAFFS C code is covered by GPL.
+ */
+
+#ifdef YAFFS_CURRENT
+	#include "yportenv_single.h"
+#else
+	#include "yportenv_multi.h"
+#endif
diff --git a/fs/yaffs2/yportenv_multi.h b/fs/yaffs2/yportenv_multi.h
new file mode 100755
index 0000000..9fade6d
--- /dev/null
+++ b/fs/yaffs2/yportenv_multi.h
@@ -0,0 +1,91 @@
+/*
+ * YAFFS: Yet another Flash File System . A NAND-flash specific file system.
+ *
+ * Copyright (C) 2002-2011 Aleph One Ltd.
+ *   for Toby Churchill Ltd and Brightstar Engineering
+ *
+ * Created by Charles Manning <charles@aleph1.co.uk>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 2.1 as
+ * published by the Free Software Foundation.
+ *
+ * Note: Only YAFFS headers are LGPL, YAFFS C code is covered by GPL.
+ */
+
+#ifndef __YPORTENV_H__
+#define __YPORTENV_H__
+
+/*
+ * Define the MTD version in terms of Linux Kernel versions
+ * This allows yaffs to be used independantly of the kernel
+ * as well as with it.
+ */
+
+#define MTD_VERSION(a, b, c) (((a) << 16) + ((b) << 8) + (c))
+
+#ifdef YAFFS_OUT_OF_TREE
+#include "moduleconfig.h"
+#endif
+
+#include <linux/version.h>
+#define MTD_VERSION_CODE LINUX_VERSION_CODE
+
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 19))
+#include <linux/config.h>
+#endif
+#include <linux/version.h>
+#include <linux/kernel.h>
+#include <linux/mm.h>
+#include <linux/sched.h>
+#include <linux/string.h>
+#include <linux/slab.h>
+#include <linux/vmalloc.h>
+#include <linux/xattr.h>
+#include <linux/list.h>
+#include <linux/types.h>
+#include <linux/fs.h>
+#include <linux/stat.h>
+#include <linux/sort.h>
+#include <linux/bitops.h>
+
+/*  These type wrappings are used to support Unicode names in WinCE. */
+#define YCHAR char
+#define YUCHAR unsigned char
+#define _Y(x)     x
+
+#define YAFFS_LOSTNFOUND_NAME		"lost+found"
+#define YAFFS_LOSTNFOUND_PREFIX		"obj"
+
+
+#define YAFFS_ROOT_MODE			0755
+#define YAFFS_LOSTNFOUND_MODE		0700
+
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2, 5, 0))
+#define Y_CURRENT_TIME CURRENT_TIME.tv_sec
+#define Y_TIME_CONVERT(x) (x).tv_sec
+#else
+#define Y_CURRENT_TIME CURRENT_TIME
+#define Y_TIME_CONVERT(x) (x)
+#endif
+
+#define compile_time_assertion(assertion) \
+	({ int x = __builtin_choose_expr(assertion, 0, (void)0); (void) x; })
+
+
+#define yaffs_printf(msk, fmt, ...) \
+	printk(KERN_DEBUG "yaffs: " fmt "\n", ##__VA_ARGS__)
+
+#if 0 
+#define yaffs_trace(msk, fmt, ...) do { \
+		printk(KERN_ALERT "yaffs: " fmt "\n", ##__VA_ARGS__); \
+} while (0)
+
+#else
+#define yaffs_trace(msk, fmt, ...) do { \
+	if (yaffs_trace_mask & (msk)) \
+		printk(KERN_DEBUG "yaffs: " fmt "\n", ##__VA_ARGS__); \
+} while (0)
+#endif
+
+#endif
diff --git a/fs/yaffs2/yportenv_single.h b/fs/yaffs2/yportenv_single.h
new file mode 100755
index 0000000..76a7914
--- /dev/null
+++ b/fs/yaffs2/yportenv_single.h
@@ -0,0 +1,65 @@
+/*
+ * YAFFS: Yet another Flash File System . A NAND-flash specific file system.
+ *
+ * Copyright (C) 2002-2011 Aleph One Ltd.
+ *   for Toby Churchill Ltd and Brightstar Engineering
+ *
+ * Created by Charles Manning <charles@aleph1.co.uk>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License version 2.1 as
+ * published by the Free Software Foundation.
+ *
+ * Note: Only YAFFS headers are LGPL, YAFFS C code is covered by GPL.
+ */
+
+#ifndef __YPORTENV_LINUX_H__
+#define __YPORTENV_LINUX_H__
+
+#include <linux/version.h>
+#include <linux/kernel.h>
+#include <linux/mm.h>
+#include <linux/sched.h>
+#include <linux/string.h>
+#include <linux/slab.h>
+#include <linux/vmalloc.h>
+#include <linux/xattr.h>
+#include <linux/list.h>
+#include <linux/types.h>
+#include <linux/fs.h>
+#include <linux/stat.h>
+#include <linux/sort.h>
+#include <linux/bitops.h>
+
+/*  These type wrappings are used to support Unicode names in WinCE. */
+#define YCHAR char
+#define YUCHAR unsigned char
+#define _Y(x)     x
+
+#define YAFFS_LOSTNFOUND_NAME		"lost+found"
+#define YAFFS_LOSTNFOUND_PREFIX		"obj"
+
+
+#define YAFFS_ROOT_MODE			0755
+#define YAFFS_LOSTNFOUND_MODE		0700
+
+#define Y_CURRENT_TIME CURRENT_TIME.tv_sec
+#define Y_TIME_CONVERT(x) (x).tv_sec
+
+#define compile_time_assertion(assertion) \
+	({ int x = __builtin_choose_expr(assertion, 0, (void)0); (void) x; })
+
+#define yaffs_printf(msk, fmt, ...) \
+	printk(KERN_DEBUG "yaffs: " fmt "\n", ##__VA_ARGS__)
+
+#ifdef CONFIG_YAFFS_DEBUG
+#define yaffs_trace(msk, fmt, ...) do { \
+	if (yaffs_trace_mask & (msk)) \
+		printk(KERN_DEBUG "yaffs: " fmt "\n", ##__VA_ARGS__); \
+} while (0)
+#else
+#define yaffs_trace(msk, fmt, ...) do { \
+} while (0)
+#endif
+
+#endif
diff --git a/include/linux/cma.h b/include/linux/cma.h
old mode 100644
new mode 100755
index 29f9e77..112ed33
--- a/include/linux/cma.h
+++ b/include/linux/cma.h
@@ -15,6 +15,14 @@
 
 struct cma;
 
+#ifdef CONFIG_CMA_AGGRESSIVE
+extern atomic_t cma_alloc_counter;
+extern int cma_aggressive_switch;
+extern unsigned long cma_aggressive_free_min;
+extern int cma_aggressive_shrink_switch;
+#endif
+
+
 extern unsigned long totalcma_pages;
 extern phys_addr_t cma_get_base(const struct cma *cma);
 extern unsigned long cma_get_size(const struct cma *cma);
diff --git a/include/linux/fs.h b/include/linux/fs.h
old mode 100644
new mode 100755
index 26c4bf4..f5d7b5b
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -878,6 +878,8 @@ struct file {
 		struct rcu_head 	fu_rcuhead;
 	} f_u;
 	struct path		f_path;
+#define f_dentry	f_path.dentry
+#define f_vfsmnt	f_path.mnt
 	struct inode		*f_inode;	/* cached value */
 	const struct file_operations	*f_op;
 
diff --git a/include/linux/gpio/consumer.h b/include/linux/gpio/consumer.h
old mode 100644
new mode 100755
index fb0fde6..fb8f86d
--- a/include/linux/gpio/consumer.h
+++ b/include/linux/gpio/consumer.h
@@ -120,6 +120,17 @@ void gpiod_set_raw_array_value_cansleep(unsigned int array_size,
 					struct gpio_desc **desc_array,
 					int *value_array);
 
+int gpiod_set_drive(struct gpio_desc *desc, int strength);
+int gpiod_get_drive(struct gpio_desc *desc);
+int gpiod_set_pull_polarity(struct gpio_desc *desc, int pullup);
+int gpiod_get_pull_polarity(struct gpio_desc *desc);
+int gpiod_set_pull_enable(struct gpio_desc *desc, int enable);
+int gpiod_get_pull_enable(struct gpio_desc *desc);
+int gpiod_set_input_enable(struct gpio_desc *desc, int enable);
+int gpiod_get_input_enable(struct gpio_desc *desc);
+int gpiod_set_slew_rate(struct gpio_desc *desc, int fast);
+int gpiod_get_slew_rate(struct gpio_desc *desc);
+
 int gpiod_set_debounce(struct gpio_desc *desc, unsigned debounce);
 
 int gpiod_is_active_low(const struct gpio_desc *desc);
diff --git a/include/linux/gpio/driver.h b/include/linux/gpio/driver.h
old mode 100644
new mode 100755
index d1baebf..3293139
--- a/include/linux/gpio/driver.h
+++ b/include/linux/gpio/driver.h
@@ -108,6 +108,26 @@ struct gpio_chip {
 						unsigned offset);
 	void			(*set)(struct gpio_chip *chip,
 						unsigned offset, int value);
+	int			(*set_drive)(struct gpio_chip *chip,
+						unsigned offset, int strength);
+	int			(*get_drive)(struct gpio_chip *chip,
+						unsigned offset);
+	int			(*set_pull_polarity)(struct gpio_chip *chip,
+						unsigned offset, int pullup);
+	int			(*get_pull_polarity)(struct gpio_chip *chip,
+						unsigned offset);
+	int			(*set_pull_enable)(struct gpio_chip *chip,
+						unsigned offset, int enable);
+	int			(*get_pull_enable)(struct gpio_chip *chip,
+						unsigned offset);
+	int			(*set_input_enable)(struct gpio_chip *chip,
+						unsigned offset, int enable);
+	int			(*get_input_enable)(struct gpio_chip *chip,
+						unsigned offset);
+	int			(*set_slew_rate)(struct gpio_chip *chip,
+						unsigned offset, int fast);
+	int			(*get_slew_rate)(struct gpio_chip *chip,
+						unsigned offset);
 	void			(*set_multiple)(struct gpio_chip *chip,
 						unsigned long *mask,
 						unsigned long *bits);
diff --git a/include/linux/mtd/mtd.h b/include/linux/mtd/mtd.h
old mode 100644
new mode 100755
index f17fa75..454930c
--- a/include/linux/mtd/mtd.h
+++ b/include/linux/mtd/mtd.h
@@ -64,6 +64,23 @@ struct mtd_erase_region_info {
 	unsigned long *lockmap;		/* If keeping bitmap of locks */
 };
 
+/*
+ * oob operation modes
+ *
+ * MTD_OOB_PLACE:	oob data are placed at the given offset
+ * MTD_OOB_AUTO:	oob data are automatically placed at the free areas
+ *			which are defined by the ecclayout
+ * MTD_OOB_RAW:		mode to read raw data+oob in one chunk. The oob data
+ *			is inserted into the data. Thats a raw image of the
+ *			flash contents.
+ */
+typedef enum {
+	MTD_OOB_PLACE,
+	MTD_OOB_AUTO,
+	MTD_OOB_RAW,
+} mtd_oob_mode_t;
+
+
 /**
  * struct mtd_oob_ops - oob operation operands
  * @mode:	operation mode
@@ -235,6 +252,9 @@ struct mtd_info {
 	int (*_get_device) (struct mtd_info *mtd);
 	void (*_put_device) (struct mtd_info *mtd);
 
+    /*Get device chip ID.*/
+	int (*get_device_id) (struct mtd_info *mtd);
+
 	/* Backing device capabilities for this device
 	 * - provides mmap capabilities
 	 */
diff --git a/include/linux/spi/flash.h b/include/linux/spi/flash.h
old mode 100644
new mode 100755
index 3f22932..a2b5043
--- a/include/linux/spi/flash.h
+++ b/include/linux/spi/flash.h
@@ -3,6 +3,13 @@
 
 struct mtd_partition;
 
+
+#define FLASH_BUS_WIDTH_1WIRE 	(1<<0)
+#define FLASH_BUS_WIDTH_2WIRE	(1<<1)
+#define FLASH_BUS_WIDTH_4WIRE	(1<<2)
+
+
+
 /**
  * struct flash_platform_data: board-specific flash data
  * @name: optional flash device name (eg, as used with mtdparts=)
@@ -25,6 +32,7 @@ struct flash_platform_data {
 
 	char		*type;
 
+    u8  bus_width;
 	/* we'll likely add more ... use JEDEC IDs, etc */
 };
 
diff --git a/include/linux/swap.h b/include/linux/swap.h
old mode 100644
new mode 100755
index 0a0b752..84669a3
--- a/include/linux/swap.h
+++ b/include/linux/swap.h
@@ -330,6 +330,11 @@ extern unsigned long mem_cgroup_shrink_node_zone(struct mem_cgroup *mem,
 						struct zone *zone,
 						unsigned long *nr_scanned);
 extern unsigned long shrink_all_memory(unsigned long nr_pages);
+
+#ifdef CONFIG_CMA_AGGRESSIVE
+extern void shrink_all_memory_for_cma(unsigned long nr_to_reclaim);
+#endif
+
 extern int vm_swappiness;
 extern int remove_mapping(struct address_space *mapping, struct page *page);
 extern unsigned long vm_total_pages;
diff --git a/kernel/sysctl.c b/kernel/sysctl.c
old mode 100644
new mode 100755
index 24c7fe8..52a261a
--- a/kernel/sysctl.c
+++ b/kernel/sysctl.c
@@ -95,6 +95,11 @@
 #include <linux/nmi.h>
 #endif
 
+#ifdef CONFIG_CMA_AGGRESSIVE
+#include <linux/cma.h>
+#endif
+
+
 #if defined(CONFIG_SYSCTL)
 
 /* External variables not in a header file. */
@@ -1574,6 +1579,29 @@ static struct ctl_table vm_table[] = {
 		.mode		= 0644,
 		.proc_handler	= proc_doulongvec_minmax,
 	},
+#ifdef CONFIG_CMA_AGGRESSIVE
+			{
+				.procname	= "cma-aggressive-switch",
+				.data		= &cma_aggressive_switch,
+				.maxlen 	= sizeof(int),
+				.mode		= 0600,
+				.proc_handler	= proc_dointvec,
+			},
+			{
+				.procname	= "cma-aggressive-free-min",
+				.data		= &cma_aggressive_free_min,
+				.maxlen 	= sizeof(unsigned long),
+				.mode		= 0600,
+				.proc_handler	= proc_doulongvec_minmax,
+			},
+			{
+				.procname	= "cma-aggressive-shrink-switch",
+				.data		= &cma_aggressive_shrink_switch,
+				.maxlen 	= sizeof(int),
+				.mode		= 0600,
+				.proc_handler	= proc_dointvec,
+			},
+#endif
 	{ }
 };
 
diff --git a/mm/Kconfig b/mm/Kconfig
old mode 100644
new mode 100755
index 5753f69..8a8cf8a
--- a/mm/Kconfig
+++ b/mm/Kconfig
@@ -517,6 +517,49 @@ config CMA_AREAS
 
 	  If unsure, leave the default value "7".
 
+config CMA_AGGRESSIVE
+	bool "CMA aggressive"
+	depends on CMA
+	default n
+	help
+	  Be more aggressive about taking memory from CMA when allocate MOVABLE
+	  page.
+	  Sysctl "vm.cma-aggressive-switch", "vm.cma-aggressive-alloc-max"
+	  and "vm.cma-aggressive-shrink-switch" can control this function.
+	  If unsure, say "n".
+
+config CMA_AGGRESSIVE_PHY_MAX
+	hex "Physical memory size in Bytes that auto turn on the CMA aggressive switch"
+	depends on CMA_AGGRESSIVE
+	default 0x4000000
+	help
+	  If physical memory size (not include CMA memory) in byte less than or
+	  equal to this value, CMA aggressive switch will be opened.
+	  After the Linux boot, sysctl "vm.cma-aggressive-switch" can control
+	  the CMA AGGRESSIVE switch.
+
+config CMA_AGGRESSIVE_FREE_MIN
+	int "The minimum free CMA page number that CMA aggressive work"
+	depends on CMA_AGGRESSIVE
+	default 50
+	help
+	  When system boot, this value will set to sysctl
+	  "vm.cma-aggressive-free-min".
+	  If the number of CMA free pages is small than this sysctl value,
+	  CMA aggressive will not work.
+
+config CMA_AGGRESSIVE_SHRINK
+	bool "CMA aggressive shrink"
+	depends on CMA_AGGRESSIVE
+	default y
+	help
+	  If this value is true, sysctl "vm.cma-aggressive-shrink-switch" will
+	  be set to true when Linux boot.
+	  If sysctl "vm.cma-aggressive-shrink-switch" is true and free normal
+	  memory's size is smaller than the size that it want to allocate,
+	  do memory shrink before driver allocate pages from CMA.
+	  If unsure, say "y".
+
 config MEM_SOFT_DIRTY
 	bool "Track memory changes"
 	depends on CHECKPOINT_RESTORE && HAVE_ARCH_SOFT_DIRTY && PROC_FS
diff --git a/mm/cma.c b/mm/cma.c
old mode 100644
new mode 100755
index 65c7aa4..7e8af73
--- a/mm/cma.c
+++ b/mm/cma.c
@@ -34,6 +34,8 @@
 #include <linux/log2.h>
 #include <linux/cma.h>
 #include <linux/highmem.h>
+#include <linux/swap.h>
+
 #include <linux/io.h>
 #include <trace/events/cma.h>
 
@@ -141,6 +143,29 @@ err:
 	return -EINVAL;
 }
 
+
+#ifdef CONFIG_CMA_AGGRESSIVE
+/* The counter for the dma_alloc_from_contiguous and
+   dma_release_from_contiguous.  */
+atomic_t cma_alloc_counter = ATOMIC_INIT(0);
+
+/* Swich of CMA_AGGRESSIVE.  */
+int cma_aggressive_switch __read_mostly;
+
+/* If the number of CMA free pages is small than this value, CMA_AGGRESSIVE will
+   not work. */
+#ifdef CONFIG_CMA_AGGRESSIVE_FREE_MIN
+unsigned long cma_aggressive_free_min __read_mostly =
+					CONFIG_CMA_AGGRESSIVE_FREE_MIN;
+#else
+unsigned long cma_aggressive_free_min __read_mostly = 500;
+#endif
+
+/* Swich of CMA_AGGRESSIVE shink.  */
+int cma_aggressive_shrink_switch __read_mostly;
+#endif /* CONFIG_CMA_AGGRESSIVE */
+
+
 static int __init cma_init_reserved_areas(void)
 {
 	int i;
@@ -152,6 +177,22 @@ static int __init cma_init_reserved_areas(void)
 			return ret;
 	}
 
+#ifdef CONFIG_CMA_AGGRESSIVE
+		cma_aggressive_switch = 0;
+#ifdef CONFIG_CMA_AGGRESSIVE_PHY_MAX
+		if (memblock_phys_mem_size() <= CONFIG_CMA_AGGRESSIVE_PHY_MAX)
+#else
+		if (memblock_phys_mem_size() <= 0x40000000)
+#endif
+			cma_aggressive_switch = 1;
+
+		cma_aggressive_shrink_switch = 0;
+#ifdef CONFIG_CMA_AGGRESSIVE_SHRINK
+		if (cma_aggressive_switch)
+			cma_aggressive_shrink_switch = 1;
+#endif
+#endif
+
 	return 0;
 }
 core_initcall(cma_init_reserved_areas);
@@ -385,6 +426,13 @@ struct page *cma_alloc(struct cma *cma, size_t count, unsigned int align)
 	struct page *page = NULL;
 	int ret;
 
+#ifdef CONFIG_CMA_AGGRESSIVE
+		int free = global_page_state(NR_FREE_PAGES)
+				- global_page_state(NR_FREE_CMA_PAGES)
+				- totalreserve_pages;
+#endif
+
+
 	if (!cma || !cma->count)
 		return NULL;
 
@@ -399,6 +447,15 @@ struct page *cma_alloc(struct cma *cma, size_t count, unsigned int align)
 	bitmap_maxno = cma_bitmap_maxno(cma);
 	bitmap_count = cma_bitmap_pages_to_bits(cma, count);
 
+#ifdef CONFIG_CMA_AGGRESSIVE
+		atomic_inc(&cma_alloc_counter);
+		if (cma_aggressive_switch && cma_aggressive_shrink_switch
+			&& free < count)
+			shrink_all_memory_for_cma(count - free);
+#endif
+
+
+
 	for (;;) {
 		mutex_lock(&cma->lock);
 		bitmap_no = bitmap_find_next_zero_area_off(cma->bitmap,
@@ -435,6 +492,11 @@ struct page *cma_alloc(struct cma *cma, size_t count, unsigned int align)
 		start = bitmap_no + mask + 1;
 	}
 
+
+#ifdef CONFIG_CMA_AGGRESSIVE
+		atomic_dec(&cma_alloc_counter);
+#endif
+
 	trace_cma_alloc(pfn, page, count, align);
 
 	pr_debug("%s(): returned %p\n", __func__, page);
diff --git a/mm/page_alloc.c b/mm/page_alloc.c
old mode 100644
new mode 100755
index fd75e27..d7e181e
--- a/mm/page_alloc.c
+++ b/mm/page_alloc.c
@@ -68,6 +68,12 @@
 #include <asm/div64.h>
 #include "internal.h"
 
+
+#ifdef CONFIG_CMA_AGGRESSIVE
+#include <linux/cma.h>
+#endif
+
+
 /* prevent >1 _updater_ of zone percpu pageset ->high and ->batch fields */
 static DEFINE_MUTEX(pcp_batch_high_lock);
 #define MIN_PERCPU_PAGELIST_FRACTION	(8)
@@ -211,7 +217,6 @@ int sysctl_lowmem_reserve_ratio[MAX_NR_ZONES-1] = {
 };
 
 EXPORT_SYMBOL(totalram_pages);
-
 static char * const zone_names[MAX_NR_ZONES] = {
 #ifdef CONFIG_ZONE_DMA
 	 "DMA",
@@ -1497,7 +1502,7 @@ struct page *__rmqueue_smallest(struct zone *zone, unsigned int order,
 static int fallbacks[MIGRATE_TYPES][4] = {
 	[MIGRATE_UNMOVABLE]   = { MIGRATE_RECLAIMABLE, MIGRATE_MOVABLE,   MIGRATE_TYPES },
 	[MIGRATE_RECLAIMABLE] = { MIGRATE_UNMOVABLE,   MIGRATE_MOVABLE,   MIGRATE_TYPES },
-	[MIGRATE_MOVABLE]     = { MIGRATE_RECLAIMABLE, MIGRATE_UNMOVABLE, MIGRATE_TYPES },
+	[MIGRATE_MOVABLE]		= { MIGRATE_RECLAIMABLE, MIGRATE_UNMOVABLE, MIGRATE_TYPES },
 #ifdef CONFIG_CMA
 	[MIGRATE_CMA]         = { MIGRATE_TYPES }, /* Never used */
 #endif
@@ -1858,21 +1863,39 @@ __rmqueue_fallback(struct zone *zone, unsigned int order, int start_migratetype)
 static struct page *__rmqueue(struct zone *zone, unsigned int order,
 				int migratetype, gfp_t gfp_flags)
 {
-	struct page *page;
+		struct page *page;
 
-	page = __rmqueue_smallest(zone, order, migratetype);
-	if (unlikely(!page)) {
-		if (migratetype == MIGRATE_MOVABLE)
-			page = __rmqueue_cma_fallback(zone, order);
+#ifdef CONFIG_CMA_AGGRESSIVE
+			if (cma_aggressive_switch
+				&& migratetype == MIGRATE_MOVABLE
+				&& atomic_read(&cma_alloc_counter) == 0
+				&& global_page_state(NR_FREE_CMA_PAGES) > cma_aggressive_free_min
+									+ (1 << order))
+				migratetype = MIGRATE_CMA;
+retry:
+#endif
 
-		if (!page)
-			page = __rmqueue_fallback(zone, order, migratetype);
-	}
+		page = __rmqueue_smallest(zone, order, migratetype);
+		if (unlikely(!page)) {
+#ifdef CONFIG_CMA_AGGRESSIVE
+			if (migratetype == MIGRATE_CMA) {
+				migratetype = MIGRATE_MOVABLE;
+				goto retry;
+			}
+#endif
+			if (migratetype == MIGRATE_MOVABLE)
+				page = __rmqueue_cma_fallback(zone, order);
+
+			if (!page)
+				page = __rmqueue_fallback(zone, order, migratetype);
+		}
+
+		trace_mm_page_alloc_zone_locked(page, order, migratetype);
+		return page;
 
-	trace_mm_page_alloc_zone_locked(page, order, migratetype);
-	return page;
 }
 
+
 /*
  * Obtain a specified number of elements from the buddy allocator, all under
  * a single hold of the lock, for efficiency.  Add them to the supplied list.
@@ -2149,6 +2172,7 @@ void free_hot_cold_page_list(struct list_head *list, bool cold)
 	}
 }
 
+
 /*
  * split_page takes a non-compound higher-order page, and splits it into
  * n (1<<order) sub-pages: page[0..n]
@@ -3146,6 +3170,7 @@ retry:
 	if (page)
 		goto got_pg;
 
+
 	/* Checks for THP-specific high-order allocations */
 	if (is_thp_gfp_mask(gfp_mask)) {
 		/*
@@ -3191,6 +3216,7 @@ retry:
 	if (page)
 		goto got_pg;
 
+
 	/* Do not loop if specifically requested */
 	if (gfp_mask & __GFP_NORETRY)
 		goto noretry;
diff --git a/mm/vmscan.c b/mm/vmscan.c
old mode 100644
new mode 100755
index 7685308..5609f80
--- a/mm/vmscan.c
+++ b/mm/vmscan.c
@@ -422,6 +422,8 @@ static unsigned long shrink_slab(gfp_t gfp_mask, int nid,
 	struct shrinker *shrinker;
 	unsigned long freed = 0;
 
+
+
 	if (memcg && !memcg_kmem_is_active(memcg))
 		return 0;
 
@@ -3541,6 +3543,29 @@ void wakeup_kswapd(struct zone *zone, int order, enum zone_type classzone_idx)
 	wake_up_interruptible(&pgdat->kswapd_wait);
 }
 
+
+#if defined CONFIG_HIBERNATION || defined CONFIG_CMA_AGGRESSIVE
+static unsigned long __shrink_all_memory(struct scan_control *sc)
+{
+	struct reclaim_state reclaim_state;
+	struct zonelist *zonelist = node_zonelist(numa_node_id(), sc->gfp_mask);
+	struct task_struct *p = current;
+	unsigned long nr_reclaimed;
+
+	p->flags |= PF_MEMALLOC;
+	lockdep_set_current_reclaim_state(sc->gfp_mask);
+	reclaim_state.reclaimed_slab = 0;
+	p->reclaim_state = &reclaim_state;
+
+	nr_reclaimed = do_try_to_free_pages(zonelist, sc);
+
+	p->reclaim_state = NULL;
+	lockdep_clear_current_reclaim_state();
+	p->flags &= ~PF_MEMALLOC;
+
+	return nr_reclaimed;
+}
+
 #ifdef CONFIG_HIBERNATION
 /*
  * Try to free `nr_to_reclaim' of memory, system-wide, and return the number of
@@ -3552,7 +3577,7 @@ void wakeup_kswapd(struct zone *zone, int order, enum zone_type classzone_idx)
  */
 unsigned long shrink_all_memory(unsigned long nr_to_reclaim)
 {
-	struct reclaim_state reclaim_state;
+	//struct reclaim_state reclaim_state;
 	struct scan_control sc = {
 		.nr_to_reclaim = nr_to_reclaim,
 		.gfp_mask = GFP_HIGHUSER_MOVABLE,
@@ -3562,25 +3587,49 @@ unsigned long shrink_all_memory(unsigned long nr_to_reclaim)
 		.may_swap = 1,
 		.hibernation_mode = 1,
 	};
-	struct zonelist *zonelist = node_zonelist(numa_node_id(), sc.gfp_mask);
-	struct task_struct *p = current;
-	unsigned long nr_reclaimed;
+	//struct zonelist *zonelist = node_zonelist(numa_node_id(), sc.gfp_mask);
+	//struct task_struct *p = current;
+	//unsigned long nr_reclaimed;
 
-	p->flags |= PF_MEMALLOC;
-	lockdep_set_current_reclaim_state(sc.gfp_mask);
-	reclaim_state.reclaimed_slab = 0;
-	p->reclaim_state = &reclaim_state;
+	//p->flags |= PF_MEMALLOC;
+	//lockdep_set_current_reclaim_state(sc.gfp_mask);
+	//reclaim_state.reclaimed_slab = 0;
+	//p->reclaim_state = &reclaim_state;
 
-	nr_reclaimed = do_try_to_free_pages(zonelist, &sc);
+	//nr_reclaimed = do_try_to_free_pages(zonelist, &sc);
 
-	p->reclaim_state = NULL;
-	lockdep_clear_current_reclaim_state();
-	p->flags &= ~PF_MEMALLOC;
+	//p->reclaim_state = NULL;
+	//lockdep_clear_current_reclaim_state();
+	//p->flags &= ~PF_MEMALLOC;
 
-	return nr_reclaimed;
+	//return nr_reclaimed;
+	return __shrink_all_memory(&sc);
 }
 #endif /* CONFIG_HIBERNATION */
 
+#ifdef CONFIG_CMA_AGGRESSIVE
+/*
+ * Try to free `nr_to_reclaim' of memory, system-wide, for CMA aggressive
+ * shrink function.
+ */
+void shrink_all_memory_for_cma(unsigned long nr_to_reclaim)
+{
+	struct scan_control sc = {
+		.nr_to_reclaim = nr_to_reclaim,
+		.gfp_mask = GFP_USER | __GFP_MOVABLE | __GFP_HIGHMEM,
+		.priority = DEF_PRIORITY,
+		.may_writepage = !laptop_mode,
+		.may_unmap = 1,
+		.may_swap = 1,
+	};
+	__shrink_all_memory(&sc);
+}
+#endif /* CONFIG_CMA_AGGRESSIVE */
+#endif /* CONFIG_HIBERNATION || CONFIG_CMA_AGGRESSIVE */
+
+
+
+
 /* It's optimal to keep kswapds on the same CPUs as their memory, but
    not required for correctness.  So if the last cpu in a node goes
    away, we get changed to run anywhere: as the first one comes back,
diff --git a/scripts/Makefile.lib b/scripts/Makefile.lib
old mode 100644
new mode 100755
index 27c56b5..cf6da90
--- a/scripts/Makefile.lib
+++ b/scripts/Makefile.lib
@@ -349,7 +349,8 @@ UIMAGE_COMPRESSION ?= $(if $(2),$(2),none)
 UIMAGE_OPTS-y ?=
 UIMAGE_TYPE ?= kernel
 UIMAGE_LOADADDR ?= arch_must_set_this
-UIMAGE_ENTRYADDR ?= $(UIMAGE_LOADADDR)
+UIMAGE_HEAD := 0x40
+UIMAGE_ENTRYADDR ?= $(shell /bin/bash -c 'printf "0x%08x" $$[$(UIMAGE_LOADADDR)+$(UIMAGE_HEAD)]')
 UIMAGE_NAME ?= 'Linux-$(KERNELRELEASE)'
 UIMAGE_IN ?= $<
 UIMAGE_OUT ?= $@
diff --git a/scripts/setlocalversion b/scripts/setlocalversion
index 966dd39..dbe6997 100755
--- a/scripts/setlocalversion
+++ b/scripts/setlocalversion
@@ -152,7 +152,7 @@ res="$(collect_files localversion*)"
 if test ! "$srctree" -ef .; then
 	res="$res$(collect_files "$srctree"/localversion*)"
 fi
-
+LOCALVERSION=
 # CONFIG_LOCALVERSION and LOCALVERSION (if set)
 res="${res}${CONFIG_LOCALVERSION}${LOCALVERSION}"
 
